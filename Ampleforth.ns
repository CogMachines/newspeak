Newspeak3
'Samples'
class Ampleforth packageUsing: manifest = (
(* 
Ampleforth is designed to support live literate programming by embedding Newspeak code inside the text of a normal web page. Ampleforth is in its infancy, and currently can be used in conjunction with Madoko to produce such documents.  

Ampleforth is the name of a character in 1984 who worked at the Ministry of Truth. His job was to edit Oldspeak text so it would be goodthinkful. 
*)| 
  BrowsingForHTML = manifest BrowsingForHTML. 
|) (
class Embedder usingPlatform: p browsing: b = (|
	Subject = p hopscotch core Subject.
	Presenter = p hopscotch core Presenter.
	ObjectSubject = b ObjectSubject.
	TextEditorFragment = p hopscotch fragments TextEditorFragment.
	Color = p graphics Color.
	Gradient = p hopscotch Gradient.
	List = p collections OrderedCollection.
	ObjectMirror = p mirrors ObjectMirror.
	ClassDeclarationMirror = p mirrors ClassDeclarationMirror.
	MixinBuilder = p mirrors MixinBuilder.
	EmbeddedHopscotchWindow = p hopscotch core EmbeddedHopscotchWindow.
	
	browsing = b.
	document = p aliens global at: 'document'.
	platformMirror = ObjectMirror reflecting: p.
|) (
class ErrorPresenter onSubject: s = Presenter onSubject: s (
(* Describe the class in this comment. *)) (
'as yet unclassified'
public definition ^ <Fragment> = (
	^label: subject errorMessage
)
) : (
)
class ErrorSubject onModel: s <String> = Subject onModel: s (
(* Describe the class in this comment. *)|
	public errorMessage = s.
|) (
'as yet unclassified'
public createPresenter ^ <ErrorPresenter> = (
	^ErrorPresenter onSubject: self
)
) : (
)
class SnippetPresenter onSubject: s = Presenter onSubject: s (| resultHolder = holder: [nothing]. |) (
'as yet unclassified'
definition = (
	| result |
	^column: {
		TextEditorFragment new
			text: subject snippet;
			changeResponse: [:editor | result content: (evaluate: editor textBeingAccepted asString)].
		result:: holder: [evaluate: subject snippet].
	}
)
evaluate: expression = (
	| s |
	s:: platformMirror
		evaluate: (withoutNbsp: expression)
		ifCompilerError: [:e | ^label: 'compile-time error: ', e printString]
		ifError: [:e | ^label: 'runtime error: ', e printString].
		^resultHolder content: 
		  (link: s reflectee printString
		   action: [enterSubject: (ObjectSubject onModel: s) fromSnippet: subject]).
)
) : (
)
public class SnippetSubject onModel: m = Subject onModel: m () (
'as yet unclassified'
createPresenter = (
	^SnippetPresenter onSubject: self
)
public snippet = (
	^model
)
) : (
)
'as yet unclassified'
evaluateSubject: se <String> ^ <Subject> = (
(* Takes a string representing a unary block and evaluates it with 
    browsing as its argument.  The result should be a Subject, which gets
    returned. In other words, the string should contain an expression of type
   [:BrowsingForHTML | Subject]
*)
	| blk |
	blk:: platformMirror
		evaluate: (withoutNbsp: se)
		ifCompilerError: [:e | ^ErrorSubject onModel: 'compile-time error: ', e printString]
		ifError: [:e | ^ErrorSubject onModel: 'runtime error: ', e printString].
		^blk value: browsing
)
public processClassPresenters = (
	| elements = document getElementsByClassName: 'classPresenter'. |
	
	1 to: (elements at: 'length') do: [:i |
		|
		element = elements at: i - 1.
		errorBlock = [: errorMessage <String> |
			^EmbeddedHopscotchWindow
			 into: element
			 openSubject: (ErrorSubject onModel: errorMessage)
			].
(*		namespaceName <String> = element getAttribute: 'namespaceName'.
		namespace = browsing namespaces at: namespaceName 
		                        ifAbsent:[errorBlock value: 'There is no namespace called ', namespaceName].*)
		className <String> = element getAttribute: 'className'.
		klass <Class>
		cm <ClassDeclarationMirror>
		|
		klass:: browsing namespace at: className.
		klass isBehavior ifFalse:[errorBlock value: className, ' is not a class']. 
		(* isClass should be defined but isn't. *)
		cm:: ClassDeclarationMirror reflecting: klass mixin.
		EmbeddedHopscotchWindow
			into: element
			openSubject: (browsing ClassSubject onModel: cm)
	].
)
public processEvaluators = (
	| elements = document getElementsByClassName: 'evaluator'. |
	
	1 to: (elements at: 'length') do: [:i |
		|
		element = elements at: i - 1.
		expression = element getAttribute: 'expression'.
		|
		EmbeddedHopscotchWindow
			into: element
			openSubject: (SnippetSubject onModel: expression)
	].
)
public processHopscotchSubjects = (
	| elements = document getElementsByClassName: 'hopscotch-subject'. |
	
	1 to: (elements at: 'length') do: [:i |
		|
		element = elements at: i - 1.
		expression = element getAttribute: 'expression'.
		|

		EmbeddedHopscotchWindow
			into: element
			openSubject: (evaluateSubject: expression)
	].
)
public processMinibrowsers = (
	| elements = document getElementsByClassName: 'minibrowser'. |
	1 to: (elements at: 'length')  do: [:i |
		|
		element = elements at: i - 1.
		|
		EmbeddedHopscotchWindow
			into: element
			openSubject: (browsing ObjectSubject onModel: platformMirror)
	].	
)
withoutNbsp: string = (
	|
	nonbreakingSpace = String fromRune: 160.
	space = String fromRune: 32.
	|
	^string replaceAll: nonbreakingSpace with: space.
)
) : (
)
'as yet unclassified'
public main: platform args: args = (
	| embedder elements browsing |
	browsing:: BrowsingForHTML usingPlatform: platform.
	browsing namespace at: #Ampleforth put: self class.
	embedder:: Embedder usingPlatform: platform browsing: browsing.
      embedder processEvaluators; processMinibrowsers; processClassPresenters.
)
) : (
)
