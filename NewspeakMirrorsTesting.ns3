Newspeak3
'NewspeakMirrorsForJavascript'
class NewspeakMirrorsTesting platform: platform testing: mirrors testFramework: utf = (
(*
   Copyright 2012 SAP AG.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)|
	private TestContext = utf TestContext.
	private ClassMirror = mirrors ClassMirror.
	private ObjectMirror = mirrors ObjectMirror.
	private ClosureMirror = mirrors ClosureMirror.	
	private MessageNotUnderstood = platform exceptions MessageNotUnderstood.
|)
(
class NewspeakMirrorTests = TestContext (|
	private TestedClass = TestedClasses new SubClass.

|)
(
class TestedClasses = ()
(
class SubClass factory: x = SuperClass superFactory: x (
(*Test Comment*)|
	subSlot1NotSet
	subSlot2MutableSetTo0 ::= 0.
	subSlot3ImmutableSetTo91 = 91.
	private subSlot4PrivateSetTo1 ::= 1.
	protected subSlot5ProtectedSetTo2 ::= 2.
	public subSlot6PublicSetTo3 ::= 3.
	|unaryMethod)
(
class Nested1 = ()
() : ()
class NestedClass2 = ()
() : ()
class OverriddenClass = ()
() : ()'unclassified'
aTernaryMethod: a with: b and: c = (
			^a + b + c
		)
overriddenMethod = (^ 'sub')
unaryMethod = (^3)) : ('foo'
subClassMethod = (^ 12))
class SuperClass superFactory: x = (|
		superSlot1ImmutableSetTo23 = 23.
		superSlot2MutableSetToNil ::= nil.
		superSlot3NotSet
		|)
(
class OverriddenClass = ()
() : ()
class SuperNested1 = ()
() : ()
class SuperNestedClass2 = ()
() : ()'unclassified'
overriddenMethod = (^ 'super')
superMethod = (^77)) : ('foo'
superClassMethod = (^ 13))) : ()'as yet unclassified'
classDeclarationMirror = (

	^ classMirror mixin declaration
)
classHeaderMirror = (

	^ classDeclarationMirror header
)
classMirror = (

	^ (ClassMirror reflecting: TestedClass)
)
closureMirror ^ <ClosureMirror> = (
| y <Integer>  |
	y:: 91.
	^ClosureMirror reflecting: [:x | x + y].
)
fail = (

	assert: [false]
)
mixinMirror = (

	^ classMirror mixin
)
newInstance = (

	^ TestedClass factory: 42
)
objectMirror = (

	^ ObjectMirror reflecting: newInstance
)
testAccessSuperclassOfObject = (
	
	assert: [(ClassMirror reflecting: Object) allSuperclasses isEmpty].
)
testClassDeclarationHasNoMixin = (

	(*We cannot get to a mixin from a class declaration.*)
	should: [classDeclarationMirror mixin] signal: MessageNotUnderstood
)
testClassDeclarationMirrorAccessSides = (

	classDeclarationMirror instanceSide.
	classDeclarationMirror classSide.
)
testClassDeclarationMirrorHasEnclosingClassDeclaration = (

	| instance declarationMirror |
	instance:: newInstance.
	declarationMirror::
		(ClassMirror reflecting: (instance SuperNested1)) declaration.
	assert: [declarationMirror enclosingClassDeclaration simpleName = 'SuperClass'].

	declarationMirror::
		(ClassMirror reflecting: (instance Nested1)) declaration.
	assert: [declarationMirror enclosingClassDeclaration simpleName = 'SubClass'].
)
testClassMirrorBasicNew = (
	
	| instance |
	instance:: classMirror basicNew reflecteeIfFail: [:error | fail].
	assert: [instance subSlot3ImmutableSetTo91 = nil].
	assert: [instance superSlot1ImmutableSetTo23 = nil].
)
testClassMirrorHasCorrectNumberOfMirrors = (

	assert: [classMirror slots mirrors size = 9].
	(*We cannot test for the correct number of methods, as we don't know how many methods Object will bring along.
	testSubClassMirror: 'assert: [mirror methods mirrors size = 4] description: ''Expecting 4 methods. 3 in subclass. 2 in superclass, one of them overridden'''.*)
	assert: [classMirror nestedClassDeclarations mirrors size = 5]
	description: 'Expecting 5 nested classes. 3 in subclass. 3 in subclass, one of them overridden'.
)
testClassMirrorHasCorrectSuperclass = (
	
	assert: [classMirror superclass simpleName = 'SuperClass'].
)
testClassMirrorHasEnclosingObject = (

	| instance |
	instance:: newInstance.
	assert: [instance = ((ClassMirror reflecting: instance Nested1) enclosingObject reflecteeIfFail: [:e | fail])].
	assert: [instance = ((ClassMirror reflecting: instance SuperNested1) enclosingObject reflecteeIfFail: [:e | fail])]
)
testClassMirrorSuperclassesEndInNil = (
	
	| n superclass |
	n:: 7.
	superclass:: classMirror.
	[n > 0 and: [(superclass = nil) not]] whileTrue: [
		superclass:: superclass superclass.
		n:: n - 1].
	assert: [nil = superclass]
	description: ['Expected superclass to be nil, but it is ', superclass asString].
)
testClosureAST = (
| ast <AST> |
	ast:: closureMirror ast.
	assert:[ast body parameters size = 1].
	assert:[ast body statements size = 1].
)
testClosureFreeVariableAccess = (
	assert:[(closureMirror freeVariableNamed: #y) = 91]
)
testHeaderReadClassComment = (

	(*Not sure how we represent a superclass clause, yet. Is it merely a string?*)
	assert: [classHeaderMirror classComment = 'Test Comment']
)
testHeaderReadInitExprs = (

	(*Init expressions will be an AST*)
	classHeaderMirror initExprs
)
testHeaderReadPrimaryFactory = (

	assert: [classHeaderMirror primaryFactory selector = #factory:]
)
testHeaderReadSuperclassClause = (

	(*Not sure how we represent a superclass clause, yet. Is it merely a string?*)
	assert: [classHeaderMirror superclassClause sel = #superFactory:].
	assert: [classHeaderMirror superclassClause args size = 1].
	assert: [(classHeaderMirror superclassClause args at: 1) msg sel = #x].
)
testHeaderSource = (

	assert: [classHeaderMirror source = 'SubClass factory: x = SuperClass superFactory: x(
"Test Comment"
	|
	subSlot1NotSet
	subSlot2MutableSetTo0 ::= 0.
	subSlot3ImmutableSetTo91 = 91.
	private subSlot4PrivateSetTo1 ::= 1.
	protected subSlot5ProtectedSetTo2 ::= 2.
	public subSlot6PublicSetTo3 ::= 3.
	|
	unaryMethod
)']
)
testMixinAccessDualMixin = (

	(*We should be able to test for mirror equality
	assert: [mirror dualMixin dualMixin = mirror].*)
	assert: [mixinMirror dualMixin dualMixin methods includesMirrorNamed: #unaryMethod].
	assert: [mixinMirror dualMixin methods includesMirrorNamed: #subClassMethod].
)
testMixinMirrorHasCorrectNumberOfMirrors = (

	assert: [mixinMirror slots mirrors size = 6].
	assert: [mixinMirror methods mirrors size = 3].
	assert: [mixinMirror nestedClassDeclarations mirrors size = 3].
)
testMultiFullyQualifiedNameName = (

	{classMirror. mixinMirror. classDeclarationMirror} do: [:mirror |
		assert: [mirror fullyQualifiedName includesSubString: 'SubClass']]
)
testMultiHasInheritedMethods = (
	
	assert: [classMirror methods includesMirrorNamed: #superMethod].
	{mixinMirror. classDeclarationMirror instanceSide} do: [:mirror |
		deny: [mirror methods includesMirrorNamed: #superMethod]].
)
testMultiHasInheritedNestedClasses = (

	| denySource |
	assert: [classMirror nestedClassDeclarations includesMirrorNamed: #SuperNested1].
	assert: [classMirror nestedClassDeclarations includesMirrorNamed: #SuperNestedClass2].
	
	{mixinMirror. classDeclarationMirror instanceSide} do: [:mirror |
		deny: [mirror nestedClassDeclarations includesMirrorNamed: #SuperNested1].
		deny: [mirror nestedClassDeclarations includesMirrorNamed: #SuperNestedClass2]].
)
testMultiHasInheritedSlots = (

	assert: [classMirror slots includesMirrorNamed: #superSlot1ImmutableSetTo23].
	assert: [classMirror slots includesMirrorNamed: #superSlot2MutableSetToNil].
	assert: [classMirror slots includesMirrorNamed: #superSlot3NotSet].

	{mixinMirror. classDeclarationMirror instanceSide} do: [:mirror |
		deny: [mirror slots includesMirrorNamed: #superSlot1ImmutableSetTo23].
		deny: [mirror slots includesMirrorNamed: #superSlot2MutableSetToNil].
		deny: [mirror slots includesMirrorNamed: #superSlot3NotSet]]
)
testMultiHasLocalMethods = (

	{classMirror. mixinMirror. classDeclarationMirror instanceSide} do: [:mirror
|
		assert: [mirror methods includesMirrorNamed: #unaryMethod].
		assert: [mirror methods includesMirrorNamed: #aTernaryMethod:with:and:]]

)
testMultiHasLocalNestedClasses = (

	{classMirror. mixinMirror. classDeclarationMirror instanceSide} do: [:mirror |
		assert: [mirror nestedClassDeclarations includesMirrorNamed: #Nested1].
		assert: [mirror nestedClassDeclarations includesMirrorNamed: #NestedClass2]]

)
testMultiHasLocalSlots = (

	{classMirror. mixinMirror. classDeclarationMirror instanceSide} do: [:mirror |
		assert: [mirror slots includesMirrorNamed: #subSlot1NotSet].
		assert: [mirror slots includesMirrorNamed: #subSlot2MutableSetTo0]]
)
testMultiHasMetadata = (
	
	(*We're not actually storing anything in the meta data yet. So just check
	whether we have a method metadata that returns something dictionary-like*)

	classDeclarationMirror metadata keys.
	classDeclarationMirror slots do: [:each | each metadata keys].
	classDeclarationMirror instanceSide methods do: [:each | each metadata keys].
)
testMultiMetaHasNoSlots = (

	deny: [classDeclarationMirror classSide slots includesMirrorNamed: #subSlot1NotSet].
	deny: [classDeclarationMirror classSide slots includesMirrorNamed: #subSlot2MutableSetTo0]
)
testMultiMethodsHaveExpectedFields = (

(*This test currently fails, as access modifiers are lost by storing TestedClass as an image-class

			private unaryMethod = (^3)
			protected aTernaryMethod: a with: b and: c = (
				^a + b + c
			)
			public overriddenMethod = (^ ''sub'')
*)

	{classMirror. mixinMirror. classDeclarationMirror instanceSide} do: [:mirror |
		| methodMirror |
		methodMirror:: mirror methods findMirrorNamed: #unaryMethod.
		assert: [methodMirror accessLevel = #private].
		assert: [methodMirror simpleName = #unaryMethod].
		methodMirror ast.

		methodMirror:: mirror methods findMirrorNamed: #aTernaryMethod:with:and:.
		assert: [methodMirror accessLevel = #protected].

		methodMirror:: mirror methods findMirrorNamed: #overriddenMethod.
		assert: [methodMirror accessLevel = #public].]

)
testMultiSimpleName = (

	{classMirror. mixinMirror. classDeclarationMirror} do: [:mirror |
		assert: [mirror simpleName = 'SubClass']].
)
testMultiSlotsHaveExpectedFields = (

	{classMirror. mixinMirror. classDeclarationMirror instanceSide} do: [:mirror |
		| slotMirror |
		slotMirror:: mirror slots findMirrorNamed: #subSlot4PrivateSetTo1.
		assert: [slotMirror accessLevel = #private].
		assert: [slotMirror isMutable].
		assert: [slotMirror simpleName = #subSlot4PrivateSetTo1].
		(*Just try to access it. We might not return anything sensible yet*)
		slotMirror initExpression.
		
		slotMirror:: mirror slots findMirrorNamed: #subSlot5ProtectedSetTo2.
		assert: [slotMirror accessLevel = #protected].
		
		slotMirror:: mirror slots findMirrorNamed: #subSlot6PublicSetTo3.
		assert: [slotMirror accessLevel = #public].
		
		slotMirror:: mirror slots findMirrorNamed: #subSlot3ImmutableSetTo91.
		(*The default access modifier is #protected*)
		assert: [slotMirror accessLevel = #protected].
		assert: [slotMirror isMutable not]]
)
testObjectMirrorAccessNonexistentSlots = (
	
	| exceptionWasRaised |
	exceptionWasRaised:: false.
	objectMirror setSlot: #thisSlotDoesNotExist to: 1234 ifFail: [:exception |
		exceptionWasRaised:: true].
	assert: [exceptionWasRaised].

	exceptionWasRaised:: false.
	objectMirror getSlot: #thisSlotDoesNotExist ifFail: [:exception |
		exceptionWasRaised:: true].
	assert: [exceptionWasRaised].
)
testObjectMirrorGetClass = (
	
	assert: [TestedClass = (objectMirror getClassIfFail: [:exception | fail]) reflectee].
)
testObjectMirrorPerform = (
	
	assert: [6 = (objectMirror perform: #aTernaryMethod:with:and: with: {1. 2. 3} ifFail: [:exception | fail]) reflectee].
	assert: [77 = (objectMirror perform: #superMethod with: {} ifFail: [:exception | fail]) reflectee].
)
testObjectMirrorPerformNonexistentMethod = (
	
	| exceptionWasRaised |
	exceptionWasRaised:: false.
	objectMirror
		perform: #thisMethodDoesNotExist
		with: {}
		ifFail: [:exception | exceptionWasRaised:: true].
	assert: [exceptionWasRaised]
)
testObjectMirrorReadSlots = (
	
	assert: [91 = (objectMirror getSlot: #subSlot3ImmutableSetTo91 ifFail: [:exception | fail]) reflectee].
	assert: [23 = (objectMirror getSlot: #superSlot1ImmutableSetTo23 ifFail: [:exception | fail]) reflectee].
)
testObjectMirrorWriteImmutableSlots = (

	(*For now object mirrors shall be able to write immutable slots. Should we change or mind, the tests for the other case are below.*)
	
	| instance mirror |
	mirror:: objectMirror.
	instance:: mirror reflecteeIfFail: [fail].
	mirror setSlot: #subSlot3ImmutableSetTo91 to: 1234 ifFail: [:exception | fail].
	assert: [instance subSlot3ImmutableSetTo91 = 1234].
	mirror setSlot: #superSlot1ImmutableSetTo23 to: 5678 ifFail: [:exception | fail].
	assert: [instance superSlot1ImmutableSetTo23 = 5678].
	(*
	testSubClassObjectMirror: '	 | exceptionWasRaised |
		exceptionWasRaised:: false.
		mirror setSlot: #subSlot3ImmutableSetTo91 to: 1234 ifFail: [:exception | exceptionWasRaised:: true].
		assert: [exceptionWasRaised].
		assert: [(instance subSlot3ImmutableSetTo91 = 1234) not].

		exceptionWasRaised:: false.
		mirror setSlot: #superSlot1ImmutableSetTo23 to: 1234 ifFail: [:exception | exceptionWasRaised:: true].
		assert: [exceptionWasRaised].
		assert: [(instance superSlot1ImmutableSetTo23 = 1234) not].'.*)
)
testObjectMirrorWriteSlots = (
	
	| mirror instance |
	mirror:: objectMirror.
	instance:: mirror reflecteeIfFail: [fail].
	mirror setSlot: #subSlot2MutableSetTo0 to: 1234 ifFail: [:exception | fail].
	assert: [instance subSlot2MutableSetTo0 = 1234].
	mirror setSlot: #superSlot3NotSet to: 5678 ifFail: [:exception | fail].
	assert: [instance superSlot3NotSet = 5678].
)
testPass = (
	
)) : ('as yet unclassified'
TEST_CONTEXT = (
	
))) : ()