Newspeak3
'NS2 Combinatorial Parsing'
class FastBlocklessCombinatorialParsing usingLib: p = Object usingLib: p (
(*
WIP: CombinatorialParsers that can be automatically transformed into an LL(1) predictive parser.

Note the awkward superclass clause to work around the limitations of explicit mixin application.

TODO: override EmptyParser, NegatingParser, SymbolicTokenParser, TokenizingParser.  Make a copy of the NewspeakGrammar that doesn't use custom subclasses of CP and test.

cp := CombinatorialParsing.
bcp := BlocklessCombinatorialParsing.
fbcp := FastBlocklessCombinatorialParsing.
conc := fbcp mixin apply: (bcp mixin apply: cp).
lib := conc usingLib: Platform nsPlatform.
g := FastNewspeak3Grammar parserLib: lib.
g NS3Grammar new fastStart
*))
(
class AlternatingParser = super AlternatingParser (
(* Describe the class in this comment. *)|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		| n p1 p2 |
		n: Nonterminal new.
		map at: self put: n. (* Do thing before recursing *)
		n name: self name.
		
		p1:: Production 
			nonterminal: n
			symbols: {p asNonterminalUsing: map}
			action: [:subresults | subresults first].
		p2:: Production 
			nonterminal: n
			symbols: {q asNonterminalUsing: map}
			action: [:subresults | subresults first].	
		n productions add: p1.
		n productions add: p2.
		
		n
	].
)) : ()
class CharParser from: f to: t = CombinatorialParser (
(* Describe the class in this comment. *)|
	from = f.
	to = t.
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		map at: self put: (CharacterRangeTerminal from: from to: to).
	].
)) : ()
class CharacterRangeTerminal from: f to: t = (
(*  *)|
	from = f.
	to = t.
|)
('as yet unclassified'
= other = (
	^self class mixin = other class mixin
		and: [self from = other from]
		and: [self to = other to]
)
first = (
	^{self}
)
nullable = (
	^false
)
parse: stm = (
	| char = stm next. |
	(char between: from and: to) ifFalse: [parseError].
	^char
)
peekMatches: stm = (
	stm atEnd ifTrue: [^false].
	^stm peek between: from and: to
)
printOn: stm = (
	stm nextPut: from; nextPutAll: '-'; nextPut: to
)) : ()
class CombinatorialParser = VerySuperCombinatorialParser (
(* Describe the class in this comment. *)|
|)
('as yet unclassified'
aWhitespaceChar ^ <CombinatorialParser> = (
	^self charBetween: (Character value: 0) and: Character space
)
char: c = (
	^CharParser from: c to: c
)
charBetween: c1 and: c2 = (
	^CharParser from: c1 to: c2
)
eoi = (
	^EOIParser new
)
symbol: s = (
	^SequentialParser new on: (s collect: [:c | self char: c])
)
tokenFromSymbol: s <Symbol> ^ <CombinatorialParser> = (
	^self tokenFor: (self symbol: s)
)
whitespace ^ <CombinatorialParser> = (
	^ aWhitespaceChar plus
)) : ()
class EOIParser = super EOIParser (
(* Describe the class in this comment. *)|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		map at: self put: EOITerminal new.
	].
)) : ()
class EOITerminal = Terminal (
(* A terminal representing the end of input. *)|
|)
('as yet unclassified'
= other = (
	^self class mixin = other class mixin
)
first = (
	^{self}
)
nullable = (
	^false
)
parse: stm = (
	stm atEnd ifFalse: [parseError].
	^#EOF
)
peekMatches: stm = (
	^stm atEnd
)) : ()
class EmptyParser = super EmptyParser (|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		map at: self put: (EmptyTerminal new).
	].
)) : ()
class EmptyTerminal = Terminal (
(* A terminal denoting the empty string, aka epsilon. *)|
|)
('as yet unclassified'
addToFollow: x = (
	^false
)
first = (
	^{}
)
nullable = (
	^true
)
parse: stm = (
	^nil
)
printOn: stm = (
	stm nextPutAll: 'epsilon'
)) : ()
class ExecutableGrammar = super ExecutableGrammar (
(* Describe the class in this comment. *)|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	#BOGUS.
	^self start asNonterminalUsing: map
)
computeFirstAndFollowOf: nonterminals = (
	| changed |
	[changed: false.
	nonterminals do: [:n | 
		n computeFirst ifTrue: [changed: true].
		n computeFollow ifTrue: [changed: true]].
	changed] whileTrue.

	nonterminals do: [:n | n checkForSelectConflicts].
)
fastStart = (
	|
	map = Dictionary new. 
	startV = self start asNonterminalUsing: map. 
	variables = map values.
	|
	
	computeFirstAndFollowOf: (variables select: [:v | v isNonterminal]).
	(* ^variables *)
	^map at: self start
)) : ()
class ForwardReferenceParser = super ForwardReferenceParser (
(* Describe the class in this comment. *)|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		ultimateParser asNonterminalUsing: map
	].
)) : ()
class NegatingParser = super NegatingParser (|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		error.
	].
)) : ()
class Nonterminal = Symbol (
(* A nonterminal is a symbol that is expanded according to one or more productions in a derivation. *)|

	productions <Set[Production]> = OrderedCollection new.
	
	first <Set[Terminal]> = OrderedCollection new. (* What terminals can appear at the beginning of a sentence derived from this nonterminal? *)
	
	follow <Set[Terminal]> = OrderedCollection new. (* What terminals can legally follow this nonterminal? *)
	
	nullable <Boolean> ::= false. (* Can this nonterminal derive the empty string? *)
	
	name 
	hasConflict
|)
('as yet unclassified'
addToFirst: fi = (

	| changed ::= false. |
	fi do: [:each | 
		(first includes: each) 
			ifFalse: [first add: each. changed: true]].
	^changed
)
addToFollow: fo = (

	| changed ::= false. |
	fo do: [:each | 
		(follow includes: each) 
			ifFalse: [follow add: each. changed: true]].
	^changed
)
checkForSelectConflicts = (

	hasConflict:: false.

	productions do: [:p | p computeSelect].
	
	productions do: [:p1 | productions do: [:p2 |
		p1 == p2 ifFalse: [
			#BOGUS yourself. (* This is not completely correct. It will fail to detect incomplete overlaps, like a-c with b-d. Also we need to check if more than one production is nullable. *)
			(p1 select intersection: p2 select) isEmpty ifFalse: [
				(* error: 'SELECT set conflict: this grammar is not LL(1)' *)
				hasConflict:: true]]]].
)
computeFirst = (
	| changed ::= false. |
	productions do: [:p |
		p computeFirst ifTrue: [
			(addToFirst: p first).
			p nullable ifTrue: [nullable: true].
			changed: true.
		]
	].
	^changed
)
computeFollow = (
	| changed ::= false. |
	productions do: [:p |
		p computeFollow ifTrue: [changed: true].
	].
	^changed
)
isNonterminal = (
	^true
)
parse: stm = (
	^hasConflict ifTrue: [parseBacktracking: stm] ifFalse: [parseLL1: stm]
)
parseBacktracking: stm = (
	(* The select sets of my productions have overlap.  This grammar is not LL(1), but let's try to use backtracking at this point. *)
	| pos = stm position. |
	#BOGUS yourself. (* Should only capture parse errors... *)
	productions do: [:p |
		[^p parse: stm] ifError: [stm position: pos].
	].
	parseError.
)
parseLL1: stm = (
	(* The select sets of my productions are disjoint, thus we can predict which one to use by peeking at the next character in the input. *)
	productions do: [:p |
		(p peekMatches: stm) ifTrue: [^p parse: stm].
	].
	(* Next character was not in any select set: the input is not legal for this grammar. *)
	ParserError new
		message: 'Expected <something in the union of select sets>';
		position: stm position;
		signal.
)
printOn: stm = (
	stm 
		nextPutAll: name asString
)) : ()
class PlusParser = super PlusParser (
(* Describe the class in this comment. *)|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		(* A -> B plus
		=>
		A' -> BA'' (cons/insert)
		A'' -> BA'' (cons/insert)
		A'' -> epsilon (new collection)
		*)
		| n p1 m p2 p3 |
		n: Nonterminal new.
		m: Nonterminal new.
		map at: self put: n. (* Do thing before recursing *)
		map at: m put: m.
		n name: self name.
		m name: self name printString, 'prime'.
		
		p1:: Production 
			nonterminal: n
			symbols: {p asNonterminalUsing: map. m}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
			
		p2:: Production 
			nonterminal: m
			symbols: {p asNonterminalUsing: map. m}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
			
		p3:: Production 
			nonterminal: m
			symbols: {EmptyTerminal new}
			action: [:subresults |
				assert: [subresults first = nil] message: ''.
				OrderedCollection new].	
				
		n productions add: p1.
		m productions add: p2.
		m productions add: p3.
		
		n
	].
)) : ()
class Production nonterminal: n symbols: h action: a = (
(* X -> ABC *)|

	nonterminal <Nonterminal> = n. (* The LHS of this production. *)
	symbols <List[Symbol]> = h. (* The RHS *)
	action <[:List| Object]> = a. (* How to transform the results of the symbols into the overall result of this production *)
	
	first <Set[Terminal]> = OrderedCollection new. (* What terminals can appear at the beginning of sentences derived from the sentital form give by the RHS? *)
	
	select <Set[Terminal]> (* The set of terminals that predict this use of this production.  Either the first set, if this production is not nullable, or the first set unioned with the follow set of the nonterminal if this production is nullable. *)
	
	nullable <Boolean> ::= false. (* Can the sentential form given by the RHS of this production derive the empty string? *)
|)
('as yet unclassified'
addToFirst: fi = (

	| changed ::= false. |
	fi do: [:each | 
		(first includes: each) 
			ifFalse: [first add: each. changed: true]].
	^changed
)
computeFirst = (
	| changed ::= false. |
	
	symbols do: [:symbol |
		(addToFirst: symbol first) 
			ifTrue: [changed: true].
		
		symbol nullable ifFalse: [^changed].
		(* otherwise nullable and we continue to next entry in the RHS *)
	].
	(* all the entries in the RHS were nullable: the LHS is nullable *)
	 
	nullable ifFalse: [
		nullable: true.
		changed: true].
	
	^changed
)
computeFollow = (
	| changed ::= false. |
	
	1 to: symbols size - 1 do: [:i | (* This is wrong if epsilon appears in the middle, where we would need to copy follow across the epsilon.  Auto generated epsilon from star and plus is always on its own, so there will only crop up from explicit use of the #empty combinator. *)
		|
		a = symbols at: i.
		b = symbols at: i + 1.
		|
		
		a isNonterminal ifTrue: [
		
			(a addToFollow: b first) 
				ifTrue: [changed: true].
		
			b nullable ifTrue: [(a addToFollow: b follow)
				ifTrue: [changed: true]]
		].
		(* The follow sets of terminals are uninteresting because terminals are never nullable. *)
	].

	symbols last isNonterminal ifTrue: [
		(symbols last addToFollow: nonterminal follow) ifTrue: [changed: true].
	].
	
	^changed
)
computeSelect = (

	select:: OrderedCollection withAll: first.
	
	nullable ifTrue: [select addAll: nonterminal follow].
)
parse: stm = (
	
	^action value: (symbols collect: [:symbol | symbol parse: stm])
)
peekMatches: stm = (
	(* Is the next character in the input stream in my select set? *)
	select do: [:terminal |
		(terminal peekMatches: stm) ifTrue: [^true]].
	^false
)
printOn: stm = (
	nonterminal printOn: stm.
	stm nextPutAll: ' -> '.
	symbols do: [:symbol | symbol printOn: stm. stm space].
)) : ()
class SequentialParser = super SequentialParser (
(* Describe the class in this comment. *)|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		| n p |
		n: Nonterminal new.
		map at: self put: n. (* Do thing before recursing *)
		n name: self name.
		
		p:: Production 
			nonterminal: n
			symbols: (parsers collect: [:each | each asNonterminalUsing: map])
			action: [:subresults | 
				assert: [subresults size = subparsers size] message: 'Wrong # results'.
				subresults.
				].
		n productions add: p.
		
		n
	].
)) : ()
class StarParser = super StarParser (
(*  *)|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		(* A -> B star
		=>
		A' -> BA' (cons, insert)
		A' -> epsilon (new collection)
		*)
		| n p1 p2 |
		n: Nonterminal new.
		map at: self put: n. (* Do thing before recursing *)
		n name: self name printString.
		
		p1:: Production 
			nonterminal: n
			symbols: {p asNonterminalUsing: map. n}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
		p2:: Production 
			nonterminal: n
			symbols: {EmptyTerminal new}
			action: [:subresults |
				assert: [subresults first = nil] message: ''.
				OrderedCollection new].	
				
		n productions add: p1.
		n productions add: p2.
		
		n
	].
)) : ()
class Symbol = (
(* A terminal or nonterminal. *)|
|)
() : ()
class Terminal = Symbol (
(* A terminal is a symbol that can be direct matched to the input. *)|
|)
() : ()
class TestGrammar = ExecutableGrammar (
(* Describe the class in this comment. *)|
	(* start = exp, eoi.
	exp = e1, (plus, e1) star wrapper: [:lhs :rhss | 
		| z ::= lhs. | rhss do: [:rhs | z: z + (rhs at: 2)]. z].
	e1 = e2, (times, e2) star wrapper: [:lhs :rhss | 
		| z ::= lhs. | rhss do: [:rhs | z: z * (rhs at: 2)]. z].
	e2 = number | parenExp.
	
	parenExp = lparen, exp, rparen wrapper: [:lhs :e :rhs | e].
	
	number = digit wrapper: [:d | d asString asNumber].
	
	plus = char: $+.
	times = char: $*.
	digit = charBetween: $0 and: $9.
	lparen = char: $(.
	rparen = char: $). *)
	
	start = exp, eoi.
	letter = charBetween: $a and: $z.
	digit = charBetween: $0 and: $9.
	colon = char: $:.
	id = letter, (letter | digit) star.
	kw = id, colon.
	white = (char: $ ) star.
	
	identifier = id, white.
	keyword = kw, white.
	
	unarySend = identifier plus.
	keywordSend = unarySend, (keyword, unarySend) star.
	exp = keywordSend.
	
|)
() : ()
class TokenizingParser = super TokenizingParser (|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		| n p |
		n: Nonterminal new.
		map at: self put: n. (* Do thing before recursing *)
		n name: self name.
		
		p:: Production 
			nonterminal: n
			symbols: {parser asNonterminalUsing: map}
			action: [:startPos :subresults :endPos | 
				Token new for: (subresults first (* only *)) start: startPos end: endPos
				].
		n productions add: p.
		
		n
	].
)) : ()
class WrappingParser = super WrappingParser (|

|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		| n p |
		n: Nonterminal new.
		map at: self put: n. (* Do thing before recursing *)
		n name: self name.
		
		p:: Production 
			nonterminal: n
			symbols: {self parser asNonterminalUsing: map}
			action: [:subresults | self wrapperBlock value: subresults first].
		n productions add: p.
		
		n
	].
)) : ()'as yet unclassified'
Dictionary = (
	^super Dictionary
)
OrderedCollection = (
	^super OrderedCollection
)
VerySuperCombinatorialParser = (
	^super CombinatorialParser
)) : ()