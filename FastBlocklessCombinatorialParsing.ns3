Newspeak3
'NS2 Combinatorial Parsing'
class FastBlocklessCombinatorialParsing usingLib: p = Object usingLib: p (
"
WIP: CombinatorialParsers that can be automatically transformed into an LL(1) predictive parser.

cp := CombinatorialParsing..
bcp := BlocklessCombinatorialParsing.
fbcp := FastBlocklessCombinatorialParsing.

conc := fbcp mixin apply: (bcp mixin apply: cp).

lib := conc usingLib: Platform nsPlatform.

lib TestGrammar new fastProductions
"|
	"Slot names with just Super conflict with those of BCP"
	VerySuperExecutableGrammar = super ExecutableGrammar.
	VerySuperSequentialParser = super SequentialParser.
	VerySuperAlternatingParser = super AlternatingParser.
	VerySuperStarParser = super StarParser.
	VerySuperPlusParser = super PlusParser.
	VerySuperCharParser = super CharParser.
	VerySuperForwardReferenceParser = super ForwardReferenceParser.
	VerySuperEOIParser = super EOIParser.
	VerySuperWrappingParser = super WrappingParser.
|)
(
class AlternatingParser = VerySuperAlternatingParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		| n p1 p2 |
		n: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		n name: self name.
		
		p1:: Production 
			nonterminal: n
			handle: {p asNonterminalUsing: map}
			action: [:subresults | subresults first].
		p2:: Production 
			nonterminal: n
			handle: {q asNonterminalUsing: map}
			action: [:subresults | subresults first].	
		n productions add: p1.
		n productions add: p2.
		
		n
	].
)) : ()
class CharParser from: f to: t = CombinatorialParser (
"Describe the class in this comment."|
	from = f.
	to = t.
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		map at: self put: (CharacterRangeTerminal from: from to: to).
	].
)) : ()
class CharacterRangeTerminal from: f to: t = (
""|
	from = f.
	to = t.
|)
('as yet unclassified'
= other = (
	^self class mixin = other class mixin
		and: [self from = other from]
		and: [self to = other to]
)
addToFollow: x = (
	^false
)
first = (
	^{self}
)
nullable = (
	^false
)
parse: stm = (
	| char = stm next. |
	(char between: from and: to) ifFalse: [parseError].
	^char
)
peekMatches: stm = (
	stm atEnd ifTrue: [^false].
	^stm peek between: from and: to
)
printOn: stm = (
	stm nextPut: from; nextPutAll: '-'; nextPut: to
)) : ()
class CombinatorialParser = VerySuperCombinatorialParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
char: c = (
	^CharParser from: c to: c
)
charBetween: c1 and: c2 = (
	^CharParser from: c1 to: c2
)
eoi = (
	^EOIParser new
)) : ()
class EOIParser = VerySuperEOIParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		map at: self put: EOITerminal new.
	].
)) : ()
class EOITerminal = Terminal (
"Describe the class in this comment."|
|)
('as yet unclassified'
= other = (
	^self class mixin = other class mixin
)
first = (
	^{self}
)
nullable = (
	^false
)
parse: stm = (
	stm atEnd ifFalse: [parseError].
	^#EOF
)
peekMatches: stm = (
	^stm atEnd
)) : ()
class EmptyTerminal = Terminal (
"Describe the class in this comment."|
|)
('as yet unclassified'
addToFollow: x = (
	^false
)
first = (
	^{}
)
nullable = (
	^true
)
parse: stm = (
	^nil
)
printOn: stm = (
	stm nextPutAll: 'epsilon'
)) : ()
class ExecutableGrammar = VerySuperExecutableGrammar (
"Describe the class in this comment."|
|)
('as yet unclassified'
computeFirstAndFollowOf: nonterminals = (
	| changed |
	[changed: false.
	nonterminals do: [:n | 
		n computeFirst ifTrue: [changed: true].
		n computeFollow ifTrue: [changed: true]].
	changed] whileTrue.

	nonterminals do: [:n | n checkForSelectConflicts].
)
fastStart = (
	|
	map = Dictionary new. 
	startV = self start asNonterminalUsing: map. 
	variables = map values.
	|
	
	computeFirstAndFollowOf: (variables select: [:v | v isNonterminal]).
	"^variables"
	^map at: self start
)) : ()
class ForwardReferenceParser = VerySuperForwardReferenceParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		ultimateParser asNonterminalUsing: map
	].
)) : ()
class Nonterminal = Variable (
""|
	productions <Set[Production]> = OrderedCollection new.
	first <Set[Terminal]> = OrderedCollection new.
	follow <Set[Terminal]> = OrderedCollection new.
	nullable <Boolean> ::= false.
	
	name
|)
('as yet unclassified'
addToFirst: fi = (

	| changed ::= false. |
	fi do: [:each | 
		(first includes: each) 
			ifFalse: [first add: each. changed: true]].
	^changed
)
addToFollow: fo = (

	| changed ::= false. |
	fo do: [:each | 
		(follow includes: each) 
			ifFalse: [follow add: each. changed: true]].
	^changed
)
checkForSelectConflicts = (
	productions do: [:p | p computeSelect].
	
	productions do: [:p1 | productions do: [:p2 |
		p1 == p2 ifFalse: [
			(p1 select intersection: p2 select) isEmpty ifFalse: [
				error: 'SELECT set conflict: this grammar is not LL(1)']]]].
)
computeFirst = (
	| changed ::= false. |
	productions do: [:p |
		p computeFirst ifTrue: [
			(addToFirst: p first).
			p nullable ifTrue: [nullable: true].
			changed: true.
		]
	].
	^changed
)
computeFollow = (
	| changed ::= false. |
	productions do: [:p |
		p computeFollow ifTrue: [changed: true].
	].
	^changed
)
isNonterminal = (
	^true
)
parse: stm = (
	productions do: [:p |
		(p peekMatches: stm) ifTrue: [^p parse: stm].
	].
	parseError.
)
printOn: stm = (
	stm 
		nextPutAll: name asString
)) : ()
class PlusParser = VerySuperPlusParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		"A -> B plus
		=>
		A' -> BA'' (cons/insert)
		A'' -> BA'' (cons/insert)
		A'' -> epsilon (new collection)
		"
		| n p1 m p2 p3 |
		n: Nonterminal new.
		m: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		map at: m put: m.
		n name: self name.
		m name: self name printString, 'prime'.
		
		p1:: Production 
			nonterminal: n
			handle: {p asNonterminalUsing: map. m}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
			
		p2:: Production 
			nonterminal: m
			handle: {p asNonterminalUsing: map. m}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
			
		p3:: Production 
			nonterminal: m
			handle: {EmptyTerminal new}
			action: [:subresults |
				assert: [subresults first = nil] message: ''.
				OrderedCollection new].	
				
		n productions add: p1.
		m productions add: p2.
		m productions add: p3.
		
		n
	].
)) : ()
class Production nonterminal: n handle: h action: a = (
"X -> ABC"|
	nonterminal <Nonterminal> = n.
	handle <List[Symbol]> = h.
	action <[List,^Object]> = a.
	
	first <Set[Terminal]> = OrderedCollection new.
	"follow <Set[Terminal]> = OrderedCollection new."
	select
	nullable <Boolean> ::= false.
|)
('as yet unclassified'
addToFirst: fi = (

	| changed ::= false. |
	fi do: [:each | 
		(first includes: each) 
			ifFalse: [first add: each. changed: true]].
	^changed
)
computeFirst = (
	| changed ::= false. |
	
	handle do: [:variable |
		(addToFirst: variable first) 
			ifTrue: [changed: true].
		
		variable nullable ifFalse: [^changed].
		"otherwise nullable and we continue to next entry in the RHS"
	].
	"all the entries in the RHS were nullable: the LHS is nullable"
	 
	nullable ifFalse: [
		nullable: true.
		changed: true].
	
	^changed
)
computeFollow = (
	| changed ::= false. |
	
	1 to: handle size - 1 do: [:i | 
		|
		a = handle at: i.
		b = handle at: i + 1.
		|
		
		a isNonterminal ifTrue: [
		
			(a addToFollow: b first) 
				ifTrue: [changed: true].
		
			b nullable ifTrue: [(a addToFollow: b follow)
				ifTrue: [changed: true]]
		]
	].

	handle last isNonterminal ifTrue: [
		(handle last addToFollow: nonterminal follow) ifTrue: [changed: true].
	].
	
	^changed
)
computeSelect = (

	select:: OrderedCollection withAll: first.
	
	nullable ifTrue: [select addAll: nonterminal follow].
)
parse: stm = (
	
	^action value: (handle collect: [:variable | variable parse: stm])
)
peekMatches: stm = (
	select do: [:terminal |
		(terminal peekMatches: stm) ifTrue: [^true]].
	^false
)
printOn: stm = (
	nonterminal printOn: stm.
	stm nextPutAll: ' -> '.
	handle do: [:var | var printOn: stm. stm space].
)) : ()
class SequentialParser = VerySuperSequentialParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		| n p |
		n: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		n name: self name.
		
		p:: Production 
			nonterminal: n
			handle: (parsers collect: [:each | each asNonterminalUsing: map])
			action: [:subresults | 
				assert: [subresults size = subparsers size] message: 'Wrong # results'.
				subresults.
				].
		n productions add: p.
		
		n
	].
)) : ()
class StarParser = VerySuperStarParser (
""|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		"A -> B star
		=>
		A' -> BA' (cons, insert)
		A' -> epsilon (new collection)
		"
		| n p1 p2 |
		n: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		n name: self name printString.
		
		p1:: Production 
			nonterminal: n
			handle: {p asNonterminalUsing: map. n}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
		p2:: Production 
			nonterminal: n
			handle: {EmptyTerminal new}
			action: [:subresults |
				assert: [subresults first = nil] message: ''.
				OrderedCollection new].	
				
		n productions add: p1.
		n productions add: p2.
		
		n
	].
)) : ()
class Terminal = Variable (
"Describe the class in this comment."|
|)
() : ()
class TestGrammar = ExecutableGrammar (
"Describe the class in this comment."|
	start = exp, eoi.
	exp = e1, (plus, e1) star wrapper: [:lhs :rhss | 
		| z ::= lhs. | rhss do: [:rhs | z: z + (rhs at: 2)]. z].
	e1 = e2, (times, e2) star wrapper: [:lhs :rhss | 
		| z ::= lhs. | rhss do: [:rhs | z: z * (rhs at: 2)]. z].
	e2 = number | parenExp.
	
	parenExp = lparen, exp, rparen wrapper: [:lhs :e :rhs | e].
	
	number = digit wrapper: [:d | d asString asNumber].
	
	plus = char: $+.
	times = char: $*.
	digit = charBetween: $0 and: $9.
	lparen = char: $(.
	rparen = char: $).
|)
() : ()
class Variable = (
"A terminal or nonterminal.  I'd prefer to call this a Symbol, but that would be confusing with Smalltalk's interned strings."|
|)
() : ()
class WrappingParser = VerySuperWrappingParser (|

|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		| n p |
		n: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		n name: self name.
		
		p:: Production 
			nonterminal: n
			handle: {self parser asNonterminalUsing: map}
			action: [:subresults | self wrapperBlock value: subresults first].
		n productions add: p.
		
		n
	].
)) : ()'as yet unclassified'
Dictionary = (
	^super Dictionary
)
OrderedCollection = (
	^super OrderedCollection
)
VerySuperCombinatorialParser = (
	^super CombinatorialParser
)) : ()