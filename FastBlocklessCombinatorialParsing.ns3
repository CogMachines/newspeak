Newspeak3
'NS2 Combinatorial Parsing'
class FastBlocklessCombinatorialParsing usingLib: p = Object usingLib: p (
"
WIP: CombinatorialParsers that can be automatically transformed into an LL(1) predictive parser.

cp := CombinatorialParsing..
bcp := BlocklessCombinatorialParsing.
fbcp := FastBlocklessCombinatorialParsing.

conc := fbcp mixin apply: (bcp mixin apply: cp).

lib := conc usingLib: Platform nsPlatform.

lib TestGrammar new fastProductions
"|
	"Slot names with just Super conflict with those of BCP"
	VerySuperExecutableGrammar = super ExecutableGrammar.
	VerySuperSequentialParser = super SequentialParser.
	VerySuperAlternatingParser = super AlternatingParser.
	VerySuperStarParser = super StarParser.
	VerySuperPlusParser = super PlusParser.
	VerySuperCharParser = super CharParser.
	VerySuperForwardReferenceParser = super ForwardReferenceParser.
|)
(
class AlternatingParser = VerySuperAlternatingParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		| n p1 p2 |
		n: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		n name: self name.
		
		p1:: Production 
			nonterminal: n
			handle: {p asNonterminalUsing: map}
			action: [:subresults | subresults first].
		p2:: Production 
			nonterminal: n
			handle: {q asNonterminalUsing: map}
			action: [:subresults | subresults first].	
		n productions add: p1.
		n productions add: p2.
		
		n
	].
)) : ()
class CharParser for: c = CombinatorialParser (
"Describe the class in this comment."|
	char = c.
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		map at: self put: (CharacterRangeTerminal from: char to: char).
	].
)) : ()
class CharacterRangeTerminal from: f to: t = (
""|
	from = f.
	to = t.
|)
('as yet unclassified'
first = (
	^{self}
)
nullable = (
	^false
)) : ()
class CombinatorialParser = VerySuperCombinatorialParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
char: c = (
	^CharParser for: c
)) : ()
class EOITerminal = Terminal (
"Describe the class in this comment."|
|)
() : ()
class EmptyTerminal = Terminal (
"Describe the class in this comment."|
|)
('as yet unclassified'
first = (
	^{}
)
nullable = (
	^true
)) : ()
class ExecutableGrammar = VerySuperExecutableGrammar (
"Describe the class in this comment."|
|)
('as yet unclassified'
computeFirstAndFollowOf: nonterminals = (
	| changed |
	[changed: false.
	nonterminals do: [:n | 
		n computeFirst ifTrue: [changed: true]].
	changed] whileTrue.
)
fastStart = (
	|
	map = Dictionary new. 
	startV = self start asNonterminalUsing: map. 
	variables = map values.
	|
	
	computeFirstAndFollowOf: (variables select: [:v | v isNonterminal]).
	^variables
)) : ()
class ForwardReferenceParser = VerySuperForwardReferenceParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		ultimateParser asNonterminalUsing: map
	].
)) : ()
class Nonterminal = Variable (
""|
	productions <Set[Production]> = OrderedCollection new.
	first <Set[Terminal]> = OrderedCollection new.
	follow <Set[Terminal]> = OrderedCollection new.
	nullable <Boolean> ::= false.
	
	name
|)
('as yet unclassified'
addToFirst: fi = (

	| changed ::= false. |
	fi do: [:each | 
		(first includes: each) 
			ifFalse: [first add: each. changed: true]].
	^changed
)
computeFirst = (
	| changed ::= false. |
	productions do: [:p |
		p computeFirst ifTrue: [
			(addToFirst: p first).
			p nullable ifTrue: [nullable: true].
			changed: true.
		]
	].
)
isNonterminal = (
	^true
)
parse: stm = (
	error.
)
printOn: stm = (
	stm 
		nextPutAll: 'Nonterminal: ';
		nextPutAll: name asString
)) : ()
class PlusParser = VerySuperPlusParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		"A -> B plus
		=>
		A' -> BA'' (cons/insert)
		A'' -> BA'' (cons/insert)
		A'' -> epsilon (new collection)
		"
		| n p1 m p2 p3 |
		n: Nonterminal new.
		m: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		map at: m put: m.
		n name: self name.
		m name: self name printString, 'prime'.
		
		p1:: Production 
			nonterminal: n
			handle: {p asNonterminalUsing: map. m}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
			
		p2:: Production 
			nonterminal: m
			handle: {p asNonterminalUsing: map. m}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
			
		p3:: Production 
			nonterminal: m
			handle: {EmptyTerminal new}
			action: [:subresults |
				assert: [subresults size = 0] message: ''.
				OrderedCollection new].	
				
		n productions add: p1.
		m productions add: p2.
		m productions add: p3.
		
		n
	].
)) : ()
class Production nonterminal: n handle: h action: a = (
"X -> ABC"|
	nonterminal <Nonterminal> = n.
	handle <List[Symbol]> = h.
	action <[List,^Object]> = a.
	
	first <Set[Terminal]> = OrderedCollection new.
	follow <Set[Terminal]> = OrderedCollection new.
	nullable <Boolean> ::= false.
|)
('as yet unclassified'
addToFirst: fi = (

	| changed ::= false. |
	fi do: [:each | 
		(first includes: each) 
			ifFalse: [first add: each. changed: true]].
	^changed
)
computeFirst = (
	| changed ::= false. |
	
	handle do: [:variable |
		(addToFirst: variable first) 
			ifTrue: [changed: true].
		
		variable nullable ifFalse: [^changed].
		"otherwise nullable and we continue to next entry in the RHS"
	].
	"all the entries in the RHS were nullable: the LHS is nullable"
	 
	nullable ifFalse: [
		nullable: true.
		changed: true].
	
	^changed
)
printOn: stm = (
	stm nextPutAll: 'Production: '.
	nonterminal printOn: stm.
	stm nextPutAll: ' -> '.
	handle do: [:var | var printOn: stm. stm space].
)) : ()
class SequentialParser = VerySuperSequentialParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		| n p |
		n: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		n name: self name.
		
		p:: Production 
			nonterminal: n
			handle: (parsers collect: [:each | each asNonterminalUsing: map])
			action: [:subresults | 
				assert: [subresults size = subparsers size] message: 'Wrong # results'.
				subresults.
				].
		n productions add: p.
		
		n
	].
)) : ()
class StarParser = VerySuperStarParser (
""|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		"A -> B star
		=>
		A' -> BA' (cons, insert)
		A' -> epsilon (new collection)
		"
		| n p1 p2 |
		n: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		n name: self name printString.
		
		p1:: Production 
			nonterminal: n
			handle: {p asNonterminalUsing: map. n}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
		p2:: Production 
			nonterminal: n
			handle: {EmptyTerminal new}
			action: [:subresults |
				assert: [subresults size = 0] message: ''.
				OrderedCollection new].	
				
		n productions add: p1.
		n productions add: p2.
		
		n
	].
)) : ()
class Terminal = Variable (
"Describe the class in this comment."|
|)
() : ()
class TestGrammar = ExecutableGrammar (
"Describe the class in this comment."|
	start = Xstar, Yplus.
	Xstar = X star.
	Yplus = Y plus.
	X = a | b.
	Y = c | d.
	a = char: $a.
	b = char: $b.
	c = char: $c.
	d = char: $d.
|)
() : ()
class Variable = (
"A terminal or nonterminal.  I'd prefer to call this a Symbol, but that would be confusing with Smalltalk's interned strings."|
|)
() : ()'as yet unclassified'
Dictionary = (
	^super Dictionary
)
OrderedCollection = (
	^super OrderedCollection
)
VerySuperCombinatorialParser = (
	^super CombinatorialParser
)) : ()