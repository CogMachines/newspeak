Newspeak3
'NS2 Combinatorial Parsing'
class FastBlocklessCombinatorialParsing usingLib: p = Object usingLib: p (
"
WIP: CombinatorialParsers that can be automatically transformed into an LL(1) predictive parser.

cp := CombinatorialParsing..
bcp := BlocklessCombinatorialParsing.
fbcp := FastBlocklessCombinatorialParsing.

conc := fbcp mixin apply: (bcp mixin apply: cp).

lib := conc usingLib: Platform nsPlatform.

lib TestGrammar new fastProductions
"|
	"Slot names with just Super conflict with those of BCP"
	VerySuperExecutableGrammar = super ExecutableGrammar.
	VerySuperSequentialParser = super SequentialParser.
	VerySuperAlternatingParser = super AlternatingParser.
	VerySuperStarParser = super StarParser.
	VerySuperPlusParser = super PlusParser.
	VerySuperCharParser = super CharParser.
	VerySuperForwardReferenceParser = super ForwardReferenceParser.
|)
(
class AlternatingParser = VerySuperAlternatingParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		| n p1 p2 |
		n: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		
		p1:: Production 
			nonterminal: n
			handle: {p asNonterminalUsing: map}
			action: [:subresults | subresults first].
		p2:: Production 
			nonterminal: n
			handle: {q asNonterminalUsing: map}
			action: [:subresults | subresults first].	
		n productions add: p1.
		n productions add: p2.
		
		n
	].
)) : ()
class CharParser for: c = CombinatorialParser (
"Describe the class in this comment."|
	char = c.
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		map at: self put: (CharacterRangeTerminal from: char to: char).
	].
)) : ()
class CharacterRangeTerminal from: f to: t = (
""|
	from = f.
	to = t.
|)
() : ()
class CombinatorialParser = VerySuperCombinatorialParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
char: c = (
	^CharParser for: c
)) : ()
class EOITerminal = Terminal (
"Describe the class in this comment."|
|)
() : ()
class EmptyTerminal = Terminal (
"Describe the class in this comment."|
	slot1
	slot2
|)
() : ()
class ExecutableGrammar = VerySuperExecutableGrammar (
"Describe the class in this comment."|
|)
('as yet unclassified'
computeFirstAndFollowOf: nonterminals = (
	| changed ::= false. |
	
	nonterminals do: [:n |
		someIterativeConstruction.
	].
)
fastStart = (
	|
	map = Dictionary new. 
	startV = self start asNonterminalUsing: map. 
	variables = map values.
	|
	
	computeFirstAndFollowOf: (variables select: [:v | v isNonterminal]).
)) : ()
class ForwardReferenceParser = VerySuperForwardReferenceParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		ultimateParser asNonterminalUsing: map
	].
)) : ()
class Nonterminal = Variable (
""|
	productions <Set[Production]> = OrderedCollection new.
	first <Set[Terminal]>
	follow <Set[Terminal]>
	nullable <Boolean>
|)
() : ()
class PlusParser = VerySuperPlusParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		"A -> B plus
		=>
		A' -> BA'' (cons/insert)
		A'' -> BA'' (cons/insert)
		A'' -> epsilon (new collection)
		"
		| n p1 m p2 p3 |
		n: Nonterminal new.
		m: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		map at: m put: m.
		
		p1:: Production 
			nonterminal: n
			handle: {p asNonterminalUsing: map. m}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
			
		p2:: Production 
			nonterminal: m
			handle: {p asNonterminalUsing: map. m}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
			
		p3:: Production 
			nonterminal: m
			handle: {EmptyTerminal}
			action: [:subresults |
				assert: [subresults size = 0] message: ''.
				OrderedCollection new].	
				
		n productions add: p1.
		m productions add: p2.
		m productions add: p3.
		
		n
	].
)) : ()
class Production nonterminal: n handle: h action: a = (
"X -> ABC"|
	nonterminal <Nonterminal> = n.
	handle <List[Symbol]> = h.
	action <[List,^Object]> = a.
|)
() : ()
class SequentialParser = VerySuperSequentialParser (
"Describe the class in this comment."|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		| n p |
		n: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		
		p:: Production 
			nonterminal: n
			handle: (parsers collect: [:each | each asNonterminalUsing: map])
			action: [:subresults | 
				assert: [subresults size = subparsers size] message: 'Wrong # results'.
				subresults.
				].
		n productions add: p.
		
		n
	].
)) : ()
class StarParser = VerySuperStarParser (
""|
|)
('as yet unclassified'
asNonterminalUsing: map = (
	^map at: self ifAbsent: [
		"A -> B star
		=>
		A' -> BA' (cons, insert)
		A' -> epsilon (new collection)
		"
		| n p1 p2 |
		n: Nonterminal new.
		map at: self put: n. "Do thing before recursing"
		
		p1:: Production 
			nonterminal: n
			handle: {p asNonterminalUsing: map. n}
			action: [:subresults | 
				assert: [subresults size = 2] message: ''.
				(subresults at: 2) addFirst: (subresults at: 1); yourself].
		p2:: Production 
			nonterminal: n
			handle: {EmptyTerminal}
			action: [:subresults |
				assert: [subresults size = 0] message: ''.
				OrderedCollection new].	
				
		n productions add: p1.
		n productions add: p2.
		
		n
	].
)) : ()
class Terminal = Variable (
"Describe the class in this comment."|
|)
() : ()
class TestGrammar = ExecutableGrammar (
"Describe the class in this comment."|
	start = X star, Y plus.
	X = a | b.
	Y = c | d.
	a = char: $a.
	b = char: $b.
	c = char: $c.
	d = char: $d.
|)
() : ()
class Variable = (
"A terminal or nonterminal.  I'd prefer to call this a Symbol, but that would be confusing with Smalltalk's interned strings."|
|)
() : ()'as yet unclassified'
Dictionary = (
	^super Dictionary
)
OrderedCollection = (
	^super OrderedCollection
)
VerySuperCombinatorialParser = (
	^super CombinatorialParser
)) : ()