Newspeak3

'StructuredVCS'



class VCSSmalltalkSourceMirrors usingPlatform: p vcs: vcs = NewspeakObject (
"Describe the class in this comment."
|
	parserLib <BlocklessCombinatorialParsing> = p mirrors parserLib. "cheatish"

	ExectuableGrammar = parserLib ExecutableGrammar.
	CombinatorialParser = parserLib CombinatorialParser.
	PredicateTokenParser = parserLib PredicateTokenParser.
	CommentParser = parserLib CommentParser.

	OrderedCollection = p OrderedCollection.
	WriteStream = p WriteStream.
	Smalltalk = p Smalltalk.
	PackageInfo = p PackageInfo.
	UnversionedSourceManager = p UnversionedSourceManager.

	vcs = vcs.
	StringMirror = Delay computation: [vcs sourceMirrors mirrors StringMirror].
	SourceMirror = Delay computation: [vcs sourceMirrors mirrors SourceMirror].

	AsciiLetterTable = (0 to: 255) collect: [:ea | (Character value: ea) isLetter].
	parser = NewsqueakParser new.
|
)

(



class SmalltalkMethodSourceMirror = (
"Describe the class in this comment."
|
	category
	methodSource

	messagePattern
	selector
|
)

('as yet unclassified'

accessModifier = (	^#public)



children = (	^{})



contentsEquals: other = (	^ self methodSource = other methodSource and: [		self category = other category and: [			self accessModifier = other accessModifier]])



correspondsHash = (	^ selector hash)



correspondsTo: other = (	^ self selector = other selector)



installInto: klass = (	klass		compile: (methodDeclToMethod: methodSource usingMessagePattern: messagePattern)		classified: category		withStamp: 'MemoryHole'		notifying: nil.)



name = (	^selector)



printOn: stm = (	stm nextPutAll: 'Method:'; nextPutAll: selector)



source = (	^ String streamContents: [:stream | streamTo: stream])



streamTo: stream = (	stream nextPutAll: methodSource.)



)



class CollectingCommentParser = CommentParser (
"A special parser used for inputs that need to be rapidly scanned over. It differs from its superclass in that it actually collects the characters it scans, in case they are needed (e.g., for pretty printers). 

Ideally,we should not have to do this, but until we do proper optimization by compiling combinators, this will have to suffice. It provides a marked improvement in performance, By using such parsers for comments, whitespace and strings, the overall performance of the Newqueak parser improved by a factor of 2 or so."
| comment |
)

('as yet unclassified'

parse: input inContext: context ifError: blk = (| c  | comment: OrderedCollection new.	[termBlock value: input] whileFalse: [ 		c:: input nextIfAbsent: [blk value:'Premature end of input' value: input position-1].           comment add: c.	]. ^ comment)



)



class UnarySelectorParser = CombinatorialParser (
"In the absence of a separate lexer, an ambiguity arises, which this parser deals with.
 The problem is that when parsing a unary expression that is an argument to a keyword
 message, one expects a unary selector, which is an identifer.  However, it may be that the next
 token is actually a keyword, part of the surrounding message. If we aren't actually tokenizing,
 the prefix of the keyword will be misinterpreted as an identifier and hence as another unary
 message being sent to the argument.
 
 Using a lexer solves this but introduces a subtlety around the assignment operator :=,. In that case
 if there is no whitespace between a variable name and the assignment, the variable name will
 be tokenized as a keyword rather than as an identifier. The Strongtalk parser, DeltaParser, deals
 with this specially. In the longterm, that is probably the way to go.

   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"
|
	p
|
)

('as yet unclassified'

on: s = (	self p: s.)



parse: input inContext: context ifError: blk = (	| pos |	pos:: input position.	self p keyword		parse: input inContext: context		ifError: [:msg :position | 			input position: pos.			^ self p identifier parse: input inContext: context ifError: blk].	input position: pos.	blk value: 'should not print' value: pos)



)



class NewsqueakParser = SmalltalkGrammar (
"Describe the class in this comment."
|

|
)

(



class AST = (
"Describe the class in this comment."
|
	start
	end
	cStart
	cEnd
|
)

('as yet unclassified'

concreteEnd = (	^ cEnd isNil ifTrue:[self end] ifFalse:[cEnd])



concreteEnd: p = (	self cEnd: p)



concreteStart = (	^ cStart isNil ifTrue:[self start] ifFalse:[cStart])



concreteStart: p = (	self cStart: p)



)



class StringAST = AST (
"Describe the class in this comment."
|
val
|
)

()



class PackageAST = AST (
"Describe the class in this comment."
|
	name
	classes
	extendedClasses
|
)

()



class MessageAST = AST (
"Describe the class in this comment."
|
	sel args
|
)

('as yet unclassified'

send: aSelector with: arguments = (self assert:[aSelector isSymbol] message: ''.self assert:[arguments isCollection] message: ''.self sel: aSelector; args: arguments)



)



class SideAST = AST (
"Describe the class in this comment."
|
	vars categories classComment classPoolVars sharedPoolVars
|
)

('as yet unclassified'

vars: vs cats: cs = (self vars: vs; categories: cs)



)



class VarDeclAST = AST (
"Describe the class in this comment."
|
	name type
|
)

('as yet unclassified'

name: aName type: aType = (  self name: aName; type: aType)



)



class MethodAST = AST (
"Describe the class in this comment."
|
	pattern body visibility
|
)

('as yet unclassified'

pattern: p body: b visibility: v = (self pattern: p; body: b;   visibility: v)



)



class ClassAST = AST (
"Describe the class in this comment."
|
	format name superclassName instanceSide classSide category
|
)

('as yet unclassified'

forClass: n super: s instSide: b classSide: cb = (self name:n; superclassName: s; instanceSide: b; classSide: cb)



)



class CategoryAST = AST (
"Describe the class in this comment."
|
	name methods
|
)

()



class MessagePatternAST = AST (
"Describe the class in this comment."
|
	selector
	parameters
	returnType
	typePattern
|
)

('as yet unclassified'

selector: s parameters: p = (self selector: s; parameters: p)



)'as yet unclassified'

binaryMsgPattern = (^super binaryMsgPattern    wrapper:[:sel :p  |                | params |                 params:: OrderedCollection new add:p; yourself.                 MessagePatternAST new selector: sel token parameters: params ;                                              start: sel start; end: p end                           ].)



category = (^super category          wrapper:[:cn :ms  |                      | end |                       end:: ms isEmpty ifTrue:[cn end] ifFalse:[ms last end].                       CategoryAST new name: cn val asSymbol; methods: ms;                                            start: cn start; end: end                     ].)



charsToString: cs = (^cs inject: '' into:[:s :c | s, c asString].)



classBody = (^super classBody     wrapper:[:lp :cmnt :instVars :classPoolVars :sharedPoolVars :categories :rp  |                | vs |                  vs:: instVars isNil ifTrue:[OrderedCollection new] ifFalse:[instVars].                  SideAST new vars: vs cats: categories ;                                 classComment: cmnt;                                 start: lp start; end: rp end; classPoolVars: classPoolVars; sharedPoolVars: sharedPoolVars                                   ].)



classComment = (^super classComment  wrapper:[:ws :c | (c at:2)  inject:'' into:[:s :ch | s, ch asString]])



classDefinition = (^super classDefinition     wrapper:[:cat :format :className :eq :superClassName :instSide :classSide |                 | klassSide kat |                  klassSide:: classSide isNil ifTrue:[SideAST new vars: OrderedCollection new cats: OrderedCollection new]                                                 ifFalse:[classSide].                  kat:: cat isNil ifTrue:['Newsqueak-tests'] ifFalse:[cat val].                  ClassAST new forClass: className snd asSymbol                                   super:  superClassName snd asSymbol                                   instSide: instSide                                   classSide: klassSide;                                   start: className start;                                   end: (classSide isNil ifTrue:[instSide end] ifFalse:[classSide end]) ;                                   category: kat;						format: format token.                           ].)



classSideDecl = (^super classSideDecl    wrapper:[:cn :side | side])



extendedClass = (	^super extendedClass wrapper: [:extensions :name :eq :lp :instCategories :rp :colon :lp2 :classCategories :rp2 |		ClassAST new			name: name snd asSymbol;			instanceSide: (SideAST new categories: instCategories);			classSide: (SideAST new categories: classCategories)	])



keywordMsgPattern = (^super keywordMsgPattern     wrap:[:kws  |             | sel  params |              params:: OrderedCollection new.              self assert:[kws isEmpty not].              sel:: kws inject: '' into:[:s  :kwp |                                            params add: kwp last.                                           s, kwp first token                                          ].              MessagePatternAST new selector: sel asSymbol parameters: params  ;                                          start: kws first first start;                                          end: params last end               ].)



messagePattern = (^super messagePattern    wrapper:[:pt ":rt :tp"  |			| rt tp |                tp isNil ifTrue:[rt isNil ifFalse:[pt end: rt end]]                         ifFalse:[pt end: tp end].                                                 pt returnType: rt; typePattern: tp                                   ].)



method = (^super method     wrapper:[:msg :cb :ei  |                   MethodAST new pattern: msg                                       body: cb                                      visibility: #public";                                      start: msg start;                                      end: cb end ;                                      concreteEnd: cb concreteEnd   "                                          ].)



methodDecl = (^super methodDecl     wrapper:[:msg :eq :lp :cb :rp  |                                                                          MethodAST new pattern: msg                                       body: cb                                      visibility: #public;                                      start: msg start;                                      end: rp end                                                                ].)



package = (	^super package wrapper: [:langId :pkg :name :eq :lp :classes :extendedClasses :rp :end |		PackageAST new			name: name val asSymbol;			classes: (classes ifNil: [OrderedCollection new]);			extendedClasses: (extendedClasses ifNil: [OrderedCollection new])	])



string = (^super string   wrap:[: t | StringAST new val: t token; start: t start; end: t end].)



unaryMsgPattern = (^super unaryMsgPattern          wrap:[:sel   |                   MessagePatternAST new selector: sel sel parameters: OrderedCollection new;                                               start: sel start; end: sel end                    ].)



unarySelector = (^super unarySelector     wrap:[:u  |              MessageAST new send: u token asSymbol with: OrderedCollection new;                                              start: u start; end: u end             ].)



varDecls = (^super varDecls     wrapper:[:vb1 :vds :vb2  |                   vds isEmpty ifFalse:[vds first concreteStart: vb1 start.                                           vds last concreteEnd: vb2 end.                                           ].                  vds                ].)



variableDecl = (^super variableDecl    wrapper:[:n ":t"  |                | end t |                end:: t isNil ifTrue:[n end] ifFalse:[t end].                VarDeclAST new name: n token asSymbol type: t;                                    start: n start; end: end                ].)



)



class SmalltalkClassSourceMirror = (
"Describe the class in this comment."
|
	category <Symbol>
	name <Symbol>
	superclassName <Symbol>
	instanceVariables <List[Symbol]>
	classInstanceVariables <List[Symbol]>
	classPoolVariables <List[Symbol]>
	sharedPoolVariables <List[Symbol]>

	classComment <String>
	format <Symbol>

	instanceMethods 
	classMethods

	"class pool variables, etc!"
|
)

('as yet unclassified'

children = (	^Array streamContents: [:stm |	stm nextPut: #category -> (StringMirror new string: category).	stm nextPut: #name -> (StringMirror new string: name).	stm nextPut: #superclassName -> (StringMirror new string: superclassName).	stm nextPut: #instVariables -> (StringMirror new string: instanceVariablesString).	stm nextPut: #classInstVariables -> (StringMirror new string: classInstanceVariablesString).	stm nextPutAll: (instanceMethods collect: [:el | #instanceMethods -> el]).	stm nextPutAll: (classMethods collect: [:el | #classMethods -> el]).	])



classInstanceVariablesString = (	^String streamContents: [:stream | classInstanceVariables do: [:var | stream nextPutAll: var; space]].	)



classPoolVariablesString = (	^String streamContents: [:stream | classPoolVariables do: [:var | stream nextPutAll: var; space]].	)



correspondsHash = (	^ name hash)



correspondsTo: other = (	^ name = other name)



installAsToplevelClass = (	installMirrorsAsToplevelClasses: {self})



installClassOnly = (	| superclass klass |	superclass:: Smalltalk at: superclassName. "superclassName = 'nil' ifTrue: [nil]"	format = #class ifTrue: [klass:: superclass		subclass: name		instanceVariableNames: instanceVariablesString		classVariableNames: classPoolVariablesString 		poolDictionaries: sharedPoolVariablesString 		category: category].	format = #weakclass ifTrue: [klass:: superclass		weakSubclass: name		instanceVariableNames: instanceVariablesString		classVariableNames: classPoolVariablesString 		poolDictionaries: sharedPoolVariablesString 		category: category].	format = #variableclass ifTrue: [klass:: superclass		variableSubclass: name		instanceVariableNames: instanceVariablesString		classVariableNames: classPoolVariablesString 		poolDictionaries: sharedPoolVariablesString 		category: category].	format = #variablebyteclass ifTrue: [klass:: superclass		variableByteSubclass: name		instanceVariableNames: instanceVariablesString		classVariableNames: classPoolVariablesString 		poolDictionaries: sharedPoolVariablesString 		category: category].	format = #variablewordclass ifTrue: [klass:: superclass		variableWordSubclass: name		instanceVariableNames: instanceVariablesString		classVariableNames: classPoolVariablesString 		poolDictionaries: sharedPoolVariablesString 		category: category].	assert: [klass notNil] message: 'Unknown class format'.	klass class instanceVariableNames: classInstanceVariablesString.	klass classComment: classComment.	^klass)



installMethods = (	| klass |	klass:: Smalltalk at: name.		instanceMethods do: [:each | each installInto: klass].	classMethods do: [:each | each installInto: klass class].	"remove (nonextension) methods in image that aren't in this mirror"	klass organization categories do: [:cat | 		cat first = $* ifFalse: ["Exclude extension methods"			(klass organization listAtCategoryNamed: cat) do: [:selector |				(in: instanceMethods anySatisfy: [:m | m selector = selector])					ifFalse: [klass removeSelector: selector]]]].	klass class organization categories do: [:cat | 		cat first = $* ifFalse: ["Exclude extension methods"			(klass class organization listAtCategoryNamed: cat) do: [:selector |				(in: classMethods anySatisfy: [:m | m selector = selector])					ifFalse: [klass class removeSelector: selector]]]].)



instanceVariablesString = (	^String streamContents: [:stream | instanceVariables do: [:var | stream nextPutAll: var; space]].	)



isToplevel = (	^true)



languageIdentifier = (	^'Smalltalk')



printOn: stm = (	stm nextPutAll: 'Class:'; nextPutAll: name.)



sharedPoolVariablesString = (	^String streamContents: [:stream | sharedPoolVariables do: [:var | stream nextPutAll: var; space]].	)



sortBlock = (	^[:a :b | a name <= b name])



source = (	^String streamContents: [:stm | self streamTo: stm])



streamMethods: methods to: stream = (	| categories sortedAssociations |	categories:: methods groupBy: [:each | each category] having: [:each | true].	sortedAssociations:: categories associations sortBy: [:a :b |		a key name <= b key name].	sortedAssociations do: [:each |		stream nextPutAll: each key asString printString. "printString to escape the single quotes, which some categories have.  include the surronding single quote to make it a string literal"		(each value sortBy: sortBlock) do: [:method |			stream cr.			method streamTo: stream	]].)



streamTo: stream = (		stream nextPut: $'; nextPutAll: category; nextPut: $'; cr.		stream nextPutAll: format, ' ', name , ' = ', superclassName.		stream nextPutAll: ' ('; cr.		stream nextPut: $".	classComment asString encodeWithoutDoubleQuotesOn: stream.	stream nextPut: $"; cr.		stream nextPutAll: '| "instance variables" '.	stream nextPutAll: instanceVariablesString.	stream nextPutAll: ' |';  cr.	stream nextPutAll: '| "class pool variables" '.	stream nextPutAll: classPoolVariablesString.	stream nextPutAll: ' |';  cr.	stream nextPutAll: '| "shared pool variables" '.	stream nextPutAll: sharedPoolVariablesString.	stream nextPutAll: ' |';  cr.		streamMethods: instanceMethods to: stream.		stream nextPutAll: ') : ('; cr.		stream nextPutAll: '| "class instance variables" '.	stream nextPutAll: classInstanceVariablesString.	stream nextPutAll: ' |';  cr.				streamMethods: classMethods to: stream.		stream nextPut: $); cr.)



) : (

'as yet unclassified'

fromClass: klass <Class> = (	assert: [klass isMeta not] message: 'Should build class mirror from the nonmeta class'.		^self new		category: klass category;		name: klass name;		superclassName: klass superclass name;		instanceVariables: klass instVarNames;		classInstanceVariables: klass class instVarNames;		classPoolVariables: klass classVarNames;		sharedPoolVariables: (klass sharedPools collect: [:ea | ea name]);		classComment: klass organization classComment asString;		instanceMethods: (methodsFromClass: klass);		classMethods: (methodsFromClass: klass class);		format: (formatOf: klass)		)



formatOf: klass <Class> = (	klass isWeak ifTrue: [^#weakclass].	klass isVariable ifFalse: [^#class].	klass isPointers ifTrue: [^#variableclass].	klass isBytes ifTrue: [^#variablebyteclass].	^#variablewordclass)



methodsFrom: sideAst stream: input= (		| meths |	meths: OrderedCollection new.		sideAst categories do: [:catAst | 		catAst methods do: [:methAst |			(meths add: SmalltalkMethodSourceMirror new)				methodSource: (input contents copyFrom: methAst start to: methAst end);				messagePattern: (input contents copyFrom: methAst pattern start to: methAst pattern end);				selector: methAst pattern selector;				category: catAst name		].		].	^meths)



fromClassAst: ast stream: input = (	^self new		category: ast category asSymbol;		name: ast name;		superclassName: ast superclassName;		instanceVariables: (ast instanceSide vars collect: [:ea | ea name]);		classInstanceVariables: (ast classSide vars collect: [:ea | ea name]);		classPoolVariables: ((ast instanceSide classPoolVars ifNil: [{}])collect: [:ea | ea name]);		sharedPoolVariables: ((ast instanceSide sharedPoolVars ifNil: [{}]) collect: [:ea | ea name]);		instanceMethods: (methodsFrom: ast instanceSide stream: input);		classMethods: (methodsFrom: ast classSide stream: input);		classComment: ast instanceSide classComment;		format: ast format)



methodsFromClass: klass <Class | Metaclass> = (		| meths |	meths: OrderedCollection new.		klass organization categories do: [:cat |		cat first = $* ifFalse: ["Exclude extension methods"		(klass organization listAtCategoryNamed: cat) do: [:sel |						| pair |			pair:: methodToMethodDecl: (klass sourceCodeAt: sel ifAbsent:[halt]) asString.						(meths add: SmalltalkMethodSourceMirror new)				methodSource: pair first;				messagePattern: pair last;				selector: sel;				category: cat		].		].	].	^meths)



)



class SmalltalkPackageSourceMirror = (
"Describe the class in this comment."
|
	name <Symbol>
	classes <List[SmalltalkClassSourceMirror]>
	extendedClasses <List[ExtendedClassSourceMirror]>
|
)

('as yet unclassified'

children = (	^Array streamContents: [:stm |		stm nextPut: #name -> (StringMirror new string: name).		stm nextPutAll: (classes collect: [:el | #classes -> el]).		stm nextPutAll: (extendedClasses collect: [:el | #extendedClasses -> el]).	])



filename = (	^name , '.st')



installAsToplevelClass = (	vcs sourceMirrors mirrorLoader installMirrorsAsToplevelClasses: {self})



installClass: klass fromRemainingClasses: remainingClasses = (		remainingClasses remove: klass.	(Smalltalk includesKey: klass superclassName) ifFalse: [		installClass: (remainingClasses detect: [:c | c name = klass superclassName]) 		fromRemainingClasses: remainingClasses.	].	klass installClassOnly.)



installPackage = (silenceBackgroundSavingDuring: [	| pkgInfo remainingClasses |	pkgInfo:: PackageInfo named: name. "Cause package to exist"	"Install the shape part of classes"	remainingClasses:: OrderedCollection withAll: classes.	[remainingClasses isEmpty] whileFalse: 		[installClass: remainingClasses first fromRemainingClasses: remainingClasses].	"Install methods"	classes do: [:each | each installMethods].	#BOGUS yourself.  "Remove classes in image not in source?"	(pkgInfo classes removeAllSuchThat: [:ea | in: classes anySatisfy: [:c | c name = ea name]])		do: [:ea | ('REMOVING ',ea name) out.  ea removeFromSystem].	"Extension methods"	extendedClasses do: [:each | each installExtensions].	"Call initialize.  Probably ought to do this in topoloical order..."	classes do: [:each | (Smalltalk at: each name) initialize].])



isPackageMirror = (	^true)



languageIdentifier = (	^'Smalltalk')



printOn: stm = (	stm nextPutAll: 'Package:'; nextPutAll: name.)



silenceBackgroundSavingDuring: block = (	[UnversionedSourceManager deactivate. ^block value] 		ensure: [UnversionedSourceManager setup].)



source = (	^String streamContents: [:stm | self streamTo: stm])



streamTo: stm = (		stm 		nextPutAll: languageIdentifier; cr;		nextPutAll: 'package '; nextPutAll: name asString printString; nextPutAll: ' = ('; cr; cr.	(classes asArray sortBy: [:a :b | a name <= b name]) 		do: [:cls | cls streamTo: stm. stm cr].	(extendedClasses asArray sortBy: [:a :b | a name <= b name]) 		do: [:cls | cls streamTo: stm. stm cr].	stm		nextPutAll: ')'.)



) : (

'accessing'

fromPackageInfo: pkgInfo <PackageInfo> = (	^self new		name: pkgInfo name;		classes: (pkgInfo classes collect: [:ea | SmalltalkClassSourceMirror fromClass: ea]);		extendedClasses: ((pkgInfo extensionClasses collect: [:ea | ea theNonMetaClass]) asSet collect: [:ea | ExtendedClassSourceMirror forClass: ea inPackage: pkgInfo]))



fromStream: input <ReadStream> = (		^self fromPackageAst: (parser package parse: input) stream: input)



'private'

fromPackageAst: ast stream: input = (	^self new		name: ast name asSymbol;		classes: (ast classes collect: [:ea | SmalltalkClassSourceMirror fromClassAst: ea stream: input]);		extendedClasses: (ast extendedClasses collect: [:ea | ExtendedClassSourceMirror fromClassAst: ea stream: input]))



)



class SmalltalkGrammar = ExectuableGrammar (
"Describe the class in this comment."
|
	array assignmentLHS arrayConstant binaryExpression binaryMsg binaryMsgPattern block blockParameter blockParameters cascadedMessageExpression cascadeMsg category classCategory classComment classDefinition classBody classSideDecl codeBody decimalNum expression furtherStatements keywordExpression keywordMsg keywordMsgPattern languageId literal method methodBody methodDecl messagePattern parenthesizedExpression primary radixNum returnStatement statements statementSequence symbolConstant temporaries tuple unaryExpression unaryMsgPattern unarySelector varDecls variableName variableDecl assignment binarySelector characterConstant colon comma dollar dot equalSign hat identifier keyword langleBracket lbracket lcurly lparen number pound rangleBracket rbracket rcurly rparen semicolon slash string symbol twoQuotes twoDblQuotes vbar assign binSel character Char comment digit digits id kw letter num specialCharacter str sym whitespace beginComment endComment

radix fraction exponent extendedFraction extendedDigits kws commentDelimiter

pragma
classFormat
packageName
package
extendedClass
|
	self setupTokens; lexicalGrammar; syntacticGrammar.

 	(selfMirror getClassIfFail:[]) slots do:[:slot <SlotMirror>| |p|
	p:: (selfMirror getSlot: slot name ifFail:[]) reflecteeIfFail:[].
	(p isKindOfCombinatorialParser) ifTrue:[
		p name: slot name " a good place to name the productions"
	]]
)

('as yet unclassified'

commentBody = ("As an optimization, we process the body of a comment with a dedicated scanning parser. It should be equivalent to: ^(self character | [self aWhitespaceChar] | [self char: $' ] | [self twoDblQuotes]) star, "^CollectingCommentParser new    termBlock:[: input | | c|                c:: input peek.                c isNil                     ifTrue:[false] "let main routine handle end of input"                    ifFalse:[c = $"                               ifFalse:[false]                              ifTrue:[| pos |                                        pos:: input position.                                       input next.                                       input peek = $" ifTrue:[false] ifFalse:[input position: pos. true]                                     ]                             ]               ])



lexicalGrammar = ("All the lexical productions are defined in this method. This makes it rather long, but puts everything in one convenient place."digit::  self charBetween: $0 and: $9."PredicateTokenParser new accept:[:c   | c between: $0 and: $9]                                        errorMsg: 'digit expected'."digits:: self digit plus.extendedDigits:: (self digit | [self letter]) plus.radix:: self digits, [self char: $r]                     wrapper:[:ds  :r  | ds].                   fraction:: self dot, [self digits]                         wrapper:[:period  :ds  | ds].extendedFraction:: self dot, [extendedDigits]                         wrapper:[:period  :ds  | ds].                        exponent:: (self char: $e), [(self char: $- ) opt], [self digits]                             wrapper:[:e :sgn :ds | sgn isNil ifTrue:[ds] ifFalse:["sgn asString," ds]].decimalNum:: (self char: $-)  opt,                    [self digits],                   [fraction opt],                  [exponent opt].radixNum:: radix,               [(self char: $-)  opt],                 [extendedDigits],                [extendedFraction opt],               [exponent opt].                                                                                                                   num::   self radixNum | [self decimalNum]. "must distinguish internal use of productions from use as tokens"                                                                                                         number:: self tokenFor: self num.                                                                                                         letter::  PredicateTokenParser new accept:[:c | isLetter: c]                                          errorMsg: 'letter expected'.               "(PredicateTokenParser new accept:[:c | c between: $A and: $Z]                                          errorMsg: ''               ) |               [PredicateTokenParser new accept:[:c  | c between: $a and: $z]                                               errorMsg: 'letter expected'               ]."                                                             specialCharacter:: (self char: $+ )  | [self char: $/ ] |                                         [self char: $\ ] | [self char: $* ]   |                                       [self char: $~ ] | [self char: $<] | [self char: $>] |                                       [self char: $=] | [self char: $@ ]  |                                       [self char: $% ] | [self char: $| ]  |                                       [self char: $& ] | [self char: $? ]  |                                       [self char: $! ] |  [self char: $, ] | [self char: $`].                                                    character:: self digit | [self letter] | [self specialCharacter] | [self char: $[  ] | [self char: $]  ] |                        [self char: ${ ] | [self char: $} ] | [self char: $(  ] |                        [self char:$) ] | [self char: $^ ] | [self char: $; ] | [self char: $$ ] | [self char: $#  ] |                        [self char: $: ] | [self char: $. ] | [self char: $-] | [self char: $_] | [self char: $`] "the Smalltalk grammar neglects to add - to characters, or to comments. It does add | [self char: $' ], but these are both bugs. We intend to support underscores, which Squeak insists on tirning into assignment arrows. However, we do not support these as assignments. At the moment, we do not accept them in identifiers, but this will change in time.".                          id::  self letter,  [(self letter | [self digit]) star]                  wrapper:[:fst   :snd  | fst asString, (String withAll: snd)].                                            identifier::  self tokenFor: self id.  Char:: (self char: $$),  	(self charBetween: (Character value: 0) and: (Character value: 16r10000)).	"[self character | [self char: $' ] | [self char: $"" ] | [self char:$  ]]."  characterConstant:: self tokenFor: self Char. twoQuotes:: (self char: $' ),  [self char: $' ]                   wrapper:[:q1 : q2 | '''']. str:: (self char: $' ),           [self stringBody],                   "[(self character | [self aWhitespaceChar] | [self char: $" "] | [self twoQuotes]) star],"        [self char: $']              wrapper:[:oq :es :eq | es inject:'' into:[:s : e | s, e asString]].  string:: self tokenFor: self str. kw:: self id, [self char: $:] wrapper:[: i  :c   | i, $: asString].  kws:: self kw plus wrap:[:c | c inject: '' into:[:s :e | s, e]].      keyword:: self tokenFor: self kw.  sym:: self str | [kws] | [self binSel] | [self id].   symbol:: self tokenFor: self sym.  commentDelimiter:: self char: $". beginComment:: commentDelimiter. endComment:: commentDelimiter. twoDblQuotes:: (self char: $" ),  [self char: $" ]                   wrapper:[:q1 : q2 | '"']. comment:: self beginComment,                  [self commentBody],               [self endComment].  binSel::  (self specialCharacter | [self char: $- ]), [self specialCharacter opt], [self specialCharacter opt]                          wrapper:[:c1 :c2 :c3  |			((c1 ifNil: ['']) asString ,			(c2 ifNil: ['']) asString ,			(c3 ifNil: ['']) asString ) asSymbol                                         "     c2 isNil ifTrue:[c1 asString asSymbol]                                                             ifFalse:[(c1 asString, c2 asString) asSymbol ]" "probably delay interning as symbol until later phase"                                           ].                                             binarySelector:: self tokenFor: self binSel. "maybe intern as symbol here"         assign:: (self char: $:), [self char: $=] wrapper:[:c :e | #':=']. assignment:: self tokenFor: (self assign | [self char: $_]). "Temporary hack")



parse: input inContext: context ifError: blk = (	self halt.)



setupTokens = (whitespace::   super whitespace. colon:: self tokenFromChar: $:.comma:: self tokenFromChar: $,.dollar:: self tokenFromChar: $$.dot:: self tokenFromChar: $..equalSign:: self tokenFromChar:$=.hat:: self tokenFromChar: $^.lbracket:: self tokenFromChar: $[.lcurly:: self tokenFromChar: ${.lparen:: self tokenFromChar: $(.langleBracket:: self tokenFromChar: $<.pound:: self tokenFromChar: $#.rangleBracket:: self tokenFromChar: $>.rbracket:: self tokenFromChar: $].rcurly:: self tokenFromChar: $}.rparen:: self tokenFromChar: $).semicolon:: self tokenFromChar: $;.slash:: self tokenFromChar: $/.vbar:: self tokenFromChar: $|.)



stringBody = ("As an optimization, we process the body of a string with a dedicated scanning parser.It should be equivalent to:  ^[(self character | [self aWhitespaceChar] | [self char: $"" ] | [self twoQuotes]) star"^CollectingCommentParser new    termBlock:[: input | | c|                c:: input peek.                c isNil                     ifTrue:[false] "let main routine handle end of input"                    ifFalse:[c = $'                               ifFalse:[false]                              ifTrue:[| pos |                                        pos:: input position.                                       input next.                                       input peek = $' ifTrue:[false] ifFalse:[input position: pos. true]                                     ]                             ]               ]                   )



syntacticGrammar = ("The entire syntactic grammar for Smalltalk,with a syntax for top level classes as well""This is a very large method, but it does allow the entire grammar to be viewed as a unit" symbolConstant::  self pound,  [self symbol].  array:: (self  lparen,                   [(self number | [self symbolConstant] | [self symbol] | [self string] | [self characterConstant] | [self arrayConstant] | [self array]) star],                  [self rparen])		|		(self  lbracket, "Byte array literal"                  [self number star],                  [self rbracket]).                                                            arrayConstant:: self pound, [self array]. tuple::  self lcurly,           [self expression starSeparatedOrTerminatedBy: self dot],           [self rcurly].  literal:: self number | [self symbolConstant] | [self characterConstant] | [self string] |  [self arrayConstant] | [self tuple].                  variableName:: self identifier.                                                                                                                                                               unarySelector:: (UnarySelectorParser new on: self). " the one hack/flaw. See UnarySelector parser for details"                                           parenthesizedExpression:: self lparen, [self expression], [self rparen].                                                                                                           primary::  self variableName |                [self literal] |                [self block] |                [self parenthesizedExpression].  unaryExpression:: self primary, [self unarySelector star]. binaryMsg:: self binarySelector, [self unaryExpression]. binaryExpression::  self unaryExpression, [self binaryMsg star].                                                                 keywordMsg:: (self keyword, [self binaryExpression]) plus.                                                keywordExpression::  self binaryExpression, [self keywordMsg opt].                                                                                                                                                                                                                      cascadeMsg:: self semicolon, [self  keywordMsg | [self binaryMsg] | [self unarySelector]].                                                                                                                         cascadedMessageExpression:: self keywordExpression, [self cascadeMsg star].                                                                                           assignmentLHS:: self variableName, [self assignment].                                                                                                                     expression:: self assignmentLHS star,                 [self cascadedMessageExpression ].                                                returnStatement:: self hat,  [self expression], [self dot opt].                                                                                                                          furtherStatements:: self dot,  [self statements].                                                                           statementSequence:: ((self expression) , [self furtherStatements  opt]) | furtherStatements.                                           statements:: self returnStatement  |                     [self statementSequence] |                  [self empty].                               blockParameter:: self colon, [self variableDecl].                                            blockParameters::  self blockParameter plus, [self vbar].  varDecls:: self vbar, [self variableDecl star], [self vbar].  temporaries:: self varDecls.  codeBody:: self temporaries opt, [pragma star],   [self statements].                                block:: (self lbracket,  [self blockParameters opt], [self codeBody],  [self rbracket]) | (lbracket, blockParameter star, rbracket).                        variableDecl:: self identifier.                      unaryMsgPattern:: self unarySelector.  binaryMsgPattern:: self binarySelector,  [self variableDecl].                                                                keywordMsgPattern:: (self keyword, [self variableDecl]) plus.                                                                                                                            messagePattern::  self unaryMsgPattern |                         [self binaryMsgPattern] |                         [self keywordMsgPattern ].     "Yuck, a pragma can appear before or after | temps | "  pragma:: langleBracket, (unarySelector| (keyword, (literal | variableDecl)) plus) , rangleBracket.  methodBody:: pragma star, self codeBody.      method:: self messagePattern, [self methodBody], [self eoi]. "A method in a browser"                                                                                                                                                  "Top level productions for classes"  methodDecl:: self messagePattern, [self equalSign], [self lparen], [self methodBody], [self rparen].   category:: self string, [self methodDecl star].  classComment:: self whitespace, [self comment]. "A hack, to preserve comments from a complete class declaration"                                              classBody:: self lparen, [self classComment opt], [self varDecls opt], [self varDecls opt], [self varDecls opt], [self category star], [self rparen].  classSideDecl:: self colon, [self classBody ].  languageId:: self identifier.   classCategory:: self string "opt".  classFormat:: (tokenFromSymbol: #class) | (tokenFromSymbol: #weakclass) | (tokenFromSymbol: #variableclass) | (tokenFromSymbol: #variablebyteclass) | (tokenFromSymbol: #variablewordclass).                                                                   classDefinition:: self classCategory, classFormat, [self identifier], [self equalSign], [self identifier], [self classBody],[ self classSideDecl opt]. extendedClass:: (tokenFromSymbol: #extensions), identifier, equalSign, lparen, category star, rparen, colon, lparen, category star, rparen.  packageName::  "tokenFor: ((letter | digit | (char: $-)) plus wrap:[:chars | (String withAll: chars)] )." string.   package:: languageId, (tokenFromSymbol: #package), packageName, equalSign, lparen, classDefinition star, extendedClass star, rparen , eoi.)



)



class ExtendedClassSourceMirror = (
|
	name
	instanceMethods
	classMethods
|
)

('as yet unclassified'

children = (	^Array streamContents: [:stm |	stm nextPut: #name -> (StringMirror new string: name).	stm nextPutAll: (instanceMethods collect: [:el | #instanceMethods -> el]).	stm nextPutAll: (classMethods collect: [:el | #classMethods -> el]).	])



correspondsHash = (	^ name hash)



correspondsTo: other = (	^ name = other name)



installExtensions = (	| klass |		klass:: Smalltalk at: name.		instanceMethods do: [:each | each installInto: klass].	classMethods do: [:each | each installInto: klass class].	#BOGUS yourself.  "remove extensions in image missing in this mirror")



printOn: stm = (	stm nextPutAll: 'ExtendedClass:'; nextPutAll: name)



streamMethods: methods to: stream = (	| categories sortedAssociations |	categories:: methods groupBy: [:each | each category] having: [:each | true].	sortedAssociations:: categories associations sortBy: [:a :b |		a key name <= b key name].	sortedAssociations do: [:each |		stream nextPutAll: each key asString printString. "printString to escape the single quotes, which some categories have.  include the surronding single quote to make it a string literal"		(each value sortBy: [:a :b | a name <= b name]) do: [:method |			stream cr.			method streamTo: stream	]].)



streamTo: stream = (	stream nextPutAll: 'extensions '; nextPutAll: name; nextPutAll: ' = ('; cr.	streamMethods: instanceMethods to: stream.	stream nextPutAll: ') : ('; cr.	streamMethods: classMethods to: stream.	stream nextPutAll: ')'; cr.)



) : (

'as yet unclassified'

forClass: klass inPackage: pkgInfo = (	^self new		name: klass name;		instanceMethods: (extensionMethodsFor: klass in: pkgInfo);		classMethods: (extensionMethodsFor: klass class in: pkgInfo))



fromClassAst: ast stream: input = (	^self new		name: ast name;		instanceMethods: (SmalltalkClassSourceMirror methodsFrom: ast instanceSide stream: input);		classMethods: (SmalltalkClassSourceMirror methodsFrom: ast classSide stream: input))



extensionMethodsFor: klass in: pkgInfo = (	^(pkgInfo extensionMethodsForClass: klass) collect: [:mref |		| pair |		pair:: methodToMethodDecl: (klass sourceCodeAt: mref selector ifAbsent:[halt]) asString.					SmalltalkMethodSourceMirror new			methodSource: pair first;			messagePattern: pair last;			selector: mref selector;			category: mref category	])



)'as yet unclassified'

in: collection <Collection[E]> anySatisfy: predicate <[E, ^Boolean]> ^<Boolean> = (	"Someday Ryan will convince Gilad that the goodthink collections should understand any/all/noneSatisfy:.."	collection do: [:each | (predicate value: each) ifTrue: [^true]].	^false)



isLetter: char = (	"This is 12 times faster than Character>>isLetter and 6 times faster than Unicode class>>isLetter:"	| charCode |	charCode:: char asciiValue.	^charCode < 255		ifTrue: [AsciiLetterTable at: charCode + 1]		ifFalse: [Unicode isLetter: char])



methodDeclToMethod: source usingMessagePattern: p = (		| result |		assert: [source startsWith: p] message: ''.	result:: source copyFrom: 1 to: p size.		result:: result , (source copyFrom: (source indexOf: $()+1 to: (source lastIndexOf: $)) - 1).	^result	)



methodToMethodDecl: rawSource = (| ast output patternEnd end |ast:: parser method parse: rawSource readStream                         ifError:[:msg :pos |                                     Transcript show: msg; show: ' at position ';                                                  show: pos printString; show:' ', selector; cr                                  ]."determine end of pattern"patternEnd:: ast pattern concreteEnd."extract pattern from source and append to output"output:: WriteStream on: String new.ast pattern start to: patternEnd do:[:i | output nextPut: (rawSource at: i)].output nextPutAll: ' = ('."trim trailing crs..."end:: rawSource size.[end > 1 and: [(rawSource at: end) = Character cr]] whileTrue:	[end:: end - 1]."extract body from source and append to output"patternEnd + 1 to: end do:[:i | output nextPut: (rawSource at: i)].output cr; nextPut: $).^{output contents asString . rawSource copyFrom: ast pattern start to: patternEnd})



)