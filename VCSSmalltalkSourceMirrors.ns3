Newspeak3

'StructuredVCS'



class VCSSmalltalkSourceMirrors usingPlatform: p vcs: vcs = NewspeakObject (
"Describe the class in this comment."
|
	parserLib <BlocklessCombinatorialParsing> = p mirrors parserLib. "cheatish"

	ExectuableGrammar = parserLib ExecutableGrammar.
	CombinatorialParser = parserLib CombinatorialParser.
	PredicateTokenParser = parserLib PredicateTokenParser.
	CommentParser = parserLib CommentParser.

	OrderedCollection = p OrderedCollection.
	WriteStream = p WriteStream.

	AsciiLetterTable = (0 to: 255) collect: [:ea | (Character value: ea) isLetter].

	parser = NewsqueakParser new.

	StringMirror = Delay computation: [vcs sourceMirrors mirrors StringMirror].
	SourceMirror = Delay computation: [vcs sourceMirrors mirrors SourceMirror].
|
)

(



class SmalltalkMethodSourceMirror = (
"Describe the class in this comment."
|
	category
	methodSource

	messagePattern
	selector
|
)

('as yet unclassified'

accessModifier = (	^#public)



children = (	^{})



contentsEquals: other = (	^ self methodSource = other methodSource and: [		self category = other category and: [			self accessModifier = other accessModifier]])



correspondsHash = (	^ selector hash)



correspondsTo: other = (	^ self selector = other selector)



name = (	^selector)



source = (	^ String streamContents: [:stream | streamTo: stream])



streamTo: stream = (	stream nextPutAll: methodSource.)



)



class CollectingCommentParser = CommentParser (
"A special parser used for inputs that need to be rapidly scanned over. It differs from its superclass in that it actually collects the characters it scans, in case they are needed (e.g., for pretty printers). 

Ideally,we should not have to do this, but until we do proper optimization by compiling combinators, this will have to suffice. It provides a marked improvement in performance, By using such parsers for comments, whitespace and strings, the overall performance of the Newqueak parser improved by a factor of 2 or so."
| comment |
)

('as yet unclassified'

parse: input inContext: context ifError: blk = (| c  | comment: OrderedCollection new.	[termBlock value: input] whileFalse: [ 		c:: input nextIfAbsent: [blk value:'Premature end of input' value: input position-1].           comment add: c.	]. ^ comment)



)



class UnarySelectorParser = CombinatorialParser (
"In the absence of a separate lexer, an ambiguity arises, which this parser deals with.
 The problem is that when parsing a unary expression that is an argument to a keyword
 message, one expects a unary selector, which is an identifer.  However, it may be that the next
 token is actually a keyword, part of the surrounding message. If we aren't actually tokenizing,
 the prefix of the keyword will be misinterpreted as an identifier and hence as another unary
 message being sent to the argument.
 
 Using a lexer solves this but introduces a subtlety around the assignment operator :=,. In that case
 if there is no whitespace between a variable name and the assignment, the variable name will
 be tokenized as a keyword rather than as an identifier. The Strongtalk parser, DeltaParser, deals
 with this specially. In the longterm, that is probably the way to go.

   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"
|
	p
|
)

('as yet unclassified'

on: s = (	self p: s.)



parse: input inContext: context ifError: blk = (	| pos |	pos:: input position.	self p keyword		parse: input inContext: context		ifError: [:msg :position | 			input position: pos.			^ self p identifier parse: input inContext: context ifError: blk].	input position: pos.	blk value: 'should not print' value: pos)



)



class NewsqueakParser = SmalltalkGrammar (
"Describe the class in this comment."
|

|
)

(



class AST = (
"Describe the class in this comment."
|
	start
	end
	cStart
	cEnd
|
)

('as yet unclassified'

concreteEnd = (	^ cEnd isNil ifTrue:[self end] ifFalse:[cEnd])



concreteEnd: p = (	self cEnd: p)



concreteStart = (	^ cStart isNil ifTrue:[self start] ifFalse:[cStart])



concreteStart: p = (	self cStart: p)



)



class StringAST = AST (
"Describe the class in this comment."
|
val
|
)

()



class PackageAST = AST (
"Describe the class in this comment."
|
	name
	classes
	
|
)

()



class MessageAST = AST (
"Describe the class in this comment."
|
	sel args
|
)

('as yet unclassified'

send: aSelector with: arguments = (self assert:[aSelector isSymbol].self assert:[arguments isCollection].self sel: aSelector; args: arguments)



)



class SideAST = AST (
"Describe the class in this comment."
|
	vars categories classComment
|
)

('as yet unclassified'

vars: vs cats: cs = (self vars: vs; categories: cs)



)



class VarDeclAST = AST (
"Describe the class in this comment."
|
	name type
|
)

('as yet unclassified'

name: aName type: aType = (  self name: aName; type: aType)



)



class MethodAST = AST (
"Describe the class in this comment."
|
	pattern body visibility
|
)

('as yet unclassified'

pattern: p body: b visibility: v = (self pattern: p; body: b;   visibility: v)



)



class ClassAST = AST (
"Describe the class in this comment."
|
	format name superclassName instanceSide classSide category
|
)

('as yet unclassified'

forClass: n super: s instSide: b classSide: cb = (self name:n; superclassName: s; instanceSide: b; classSide: cb)



)



class CategoryAST = AST (
"Describe the class in this comment."
|
	name methods
|
)

()



class MessagePatternAST = AST (
"Describe the class in this comment."
|
	selector
	parameters
	returnType
	typePattern
|
)

('as yet unclassified'

selector: s parameters: p = (self selector: s; parameters: p)



)'as yet unclassified'

binaryMsgPattern = (^super binaryMsgPattern    wrapper:[:sel :p  |                | params |                 params:: OrderedCollection new add:p; yourself.                 MessagePatternAST new selector: sel token parameters: params ;                                              start: sel start; end: p end                           ].)



category = (^super category          wrapper:[:cn :ms  |                      | end |                       end:: ms isEmpty ifTrue:[cn end] ifFalse:[ms last end].                       CategoryAST new name: cn val asSymbol; methods: ms;                                            start: cn start; end: end                     ].)



charsToString: cs = (^cs inject: '' into:[:s :c | s, c asString].)



classBody = (^super classBody     wrapper:[:lp :cmnt :instVars :categories :rp  |                | vs |                  vs:: instVars isNil ifTrue:[OrderedCollection new] ifFalse:[instVars].                  SideAST new vars: vs cats: categories ;                                 classComment: cmnt;                                 start: lp start; end: rp end                                   ].)



classComment = (^super classComment  wrapper:[:ws :c | (c at:2)  inject:'' into:[:s :ch | s, ch asString]])



classDefinition = (^super classDefinition     wrapper:[:cat :format :className :eq :superClassName :instSide :classSide |                 | klassSide kat |                  klassSide:: classSide isNil ifTrue:[SideAST new vars: OrderedCollection new cats: OrderedCollection new]                                                 ifFalse:[classSide].                  kat:: cat isNil ifTrue:['Newsqueak-tests'] ifFalse:[cat val].                  ClassAST new forClass: className snd asSymbol                                   super:  superClassName snd asSymbol                                   instSide: instSide                                   classSide: klassSide;                                   start: className start;                                   end: (classSide isNil ifTrue:[instSide end] ifFalse:[classSide end]) ;                                   category: kat;						format: format token.                           ].)



classSideDecl = (^super classSideDecl    wrapper:[:cn :side | side])



keywordMsgPattern = (^super keywordMsgPattern     wrap:[:kws  |             | sel  params |              params:: OrderedCollection new.              self assert:[kws isEmpty not].              sel:: kws inject: '' into:[:s  :kwp |                                            params add: kwp last.                                           s, kwp first token                                          ].              MessagePatternAST new selector: sel asSymbol parameters: params  ;                                          start: kws first first start;                                          end: params last end               ].)



messagePattern = (^super messagePattern    wrapper:[:pt ":rt :tp"  |			| rt tp |                tp isNil ifTrue:[rt isNil ifFalse:[pt end: rt end]]                         ifFalse:[pt end: tp end].                                                 pt returnType: rt; typePattern: tp                                   ].)



method = (^super method     wrapper:[:msg :cb :ei  |                   MethodAST new pattern: msg                                       body: cb                                      visibility: #public";                                      start: msg start;                                      end: cb end ;                                      concreteEnd: cb concreteEnd   "                                          ].)



methodDecl = (^super methodDecl     wrapper:[:msg :eq :lp :cb :rp  |                                                                          MethodAST new pattern: msg                                       body: cb                                      visibility: #public;                                      start: msg start;                                      end: rp end                                                                ].)



package = (	^super package wrapper: [:langId :pkg :name :eq :lp :classes :rp :end |		PackageAST new			name: name val asSymbol;			classes: (classes ifNil: [OrderedCollection new])	])



string = (^super string   wrap:[: t | StringAST new val: t token; start: t start; end: t end].)



unaryMsgPattern = (^super unaryMsgPattern          wrap:[:sel   |                   MessagePatternAST new selector: sel sel parameters: OrderedCollection new;                                               start: sel start; end: sel end                    ].)



unarySelector = (^super unarySelector     wrap:[:u  |              MessageAST new send: u token asSymbol with: OrderedCollection new;                                              start: u start; end: u end             ].)



varDecls = (^super varDecls     wrapper:[:vb1 :vds :vb2  |                   vds isEmpty ifFalse:[vds first concreteStart: vb1 start.                                           vds last concreteEnd: vb2 end.                                           ].                  vds                ].)



variableDecl = (^super variableDecl    wrapper:[:n ":t"  |                | end t |                end:: t isNil ifTrue:[n end] ifFalse:[t end].                VarDeclAST new name: n token asSymbol type: t;                                    start: n start; end: end                ].)



)



class SmalltalkClassSourceMirror = (
"Describe the class in this comment."
|
	category <Symbol>
	name <Symbol>
	superclassName <Symbol>
	instanceVariables <List[Symbol]>
	classInstanceVariables <List[Symbol]>
	
	classComment <String>
	format <Symbol>

	instanceMethods 
	classMethods

	"class pool variables, etc!"
|
)

('as yet unclassified'

children = (	^Array streamContents: [:stm |	stm nextPut: #category -> (StringMirror new string: category).	stm nextPut: #name -> (StringMirror new string: name).	stm nextPut: #superclassName -> (StringMirror new string: superclassName).	stm nextPut: #instVariables -> (StringMirror new string: instanceVariablesString).	stm nextPut: #classInstVariables -> (StringMirror new string: classInstanceVariablesString).	stm nextPutAll: (instanceMethods collect: [:el | #instanceMethods -> el]).	stm nextPutAll: (classMethods collect: [:el | #classMethods -> el]).	])



classInstanceVariablesString = (	^String streamContents: [:stream | classInstanceVariables do: [:var | stream nextPutAll: var; space]].	)



correspondsHash = (	^ name hash)



correspondsTo: other = (	^ name = other name)



installAsToplevelClass = (	installMirrorsAsToplevelClasses: {self})



installST = (	| klass |	format = #class ifFalse: [self asYetUnimplemented].	klass:: (Smalltalk at: superclassName)		subclass: name		instanceVariableNames: instVarNames		classVariableNames: ''		poolDictionaries: ''		category: category.	klass		compile: methodSource		classified: category		withStamp: Utilities changeStamp		notifying: nil.)



instanceVariablesString = (	^String streamContents: [:stream | instanceVariables do: [:var | stream nextPutAll: var; space]].	)



isToplevel = (	^true)



languageIdentifier = (	^'Smalltalk')



sortBlock = (	^[:a :b | a name <= b name])



source = (	^String streamContents: [:stm | self streamTo: stm])



streamMethods: methods to: stream = (	| categories sortedAssociations |	categories:: methods groupBy: [:each | each category] having: [:each | true].	sortedAssociations:: categories associations sortBy: [:a :b |		a key name <= b key name].	sortedAssociations do: [:each |		stream nextPutAll: each key asString printString. "printString to escape the single quotes, which some categories have.  include the surronding single quote to make it a string literal"		(each value sortBy: sortBlock) do: [:method |			stream cr.			method streamTo: stream	]].)



streamTo: stream = (		stream nextPut: $'; nextPutAll: category; nextPut: $'; cr.		stream nextPutAll: format, ' ', name , ' = ', superclassName.		stream nextPutAll: ' ('; cr.		stream nextPut: $".	classComment asString encodeWithoutDoubleQuotesOn: stream.	stream nextPut: $"; cr.		stream nextPutAll: '| '.	stream nextPutAll: instanceVariablesString.	stream nextPutAll: ' |';  cr.		streamMethods: instanceMethods to: stream.		stream nextPutAll: ') : ('; cr.		stream nextPutAll: '| '.	stream nextPutAll: classInstanceVariablesString.	stream nextPutAll: ' |';  cr.				streamMethods: classMethods to: stream.		stream nextPut: $); cr.)



) : (

'as yet unclassified'

formatOf: klass <Class> = (	klass isWeak ifTrue: [^#weakclass].	klass isVariable ifFalse: [^#class].	klass isPointers ifTrue: [^#variableclass].	klass isBytes ifTrue: [^#variablebyteclass].	^#variablewordclass)



methodsFrom: sideAst stream: input= (		| meths |	meths: OrderedCollection new.		sideAst categories do: [:catAst | 		catAst methods do: [:methAst |			(meths add: SmalltalkMethodSourceMirror new)				methodSource: (input contents copyFrom: methAst start to: methAst end);				messagePattern: (input contents copyFrom: methAst pattern start to: methAst pattern end);				selector: methAst pattern selector;				category: catAst name		].		].	^meths)



fromClass: klass <Class> = (	assert: [klass isMeta not] message: 'Should build class mirror from the nonmeta class'.		^self new		category: klass category;		name: klass name;		superclassName: klass superclass name;		instanceVariables: klass instVarNames;		classInstanceVariables: klass class instVarNames;		classComment: klass organization classComment asString;		instanceMethods: (methodsFromClass: klass);		classMethods: (methodsFromClass: klass class);		format: (formatOf: klass)		)



fromClassAst: ast stream: input = (	^self new		category: ast category asSymbol;		name: ast name;		superclassName: ast superclassName;		instanceVariables: (ast instanceSide vars collect: [:ea | ea name]);		classInstanceVariables: (ast classSide vars collect: [:ea | ea name]);		instanceMethods: (methodsFrom: ast instanceSide stream: input);		classMethods: (methodsFrom: ast classSide stream: input);		classComment: ast instanceSide classComment;		format: ast format)



methodsFromClass: klass <Class | Metaclass> = (		| meths |	meths: OrderedCollection new.		klass organization categories do: [:cat |		(klass organization listAtCategoryNamed: cat) do: [:sel |						| pair |			pair:: methodToMethodDecl: (klass sourceCodeAt: sel ifAbsent:[halt]) asString.						(meths add: SmalltalkMethodSourceMirror new)				methodSource: pair first;				messagePattern: pair last;				selector: sel;				category: cat		].	].	^meths)



)



class SmalltalkPackageSourceMirror = (
"Describe the class in this comment."
|
	name
	classes
	extensionMethods
|
)

('as yet unclassified'

children = (	^Array streamContents: [:stm |		stm nextPut: #name -> (StringMirror new string: name).		stm nextPutAll: (classes collect: [:el | #classes -> el]).	])



filename = (	^name , '.st')



isPackageMirror = (	^true)



languageIdentifier = (	^'Smalltalk')



source = (	^String streamContents: [:stm | self streamTo: stm])



streamTo: stm = (		stm 		nextPutAll: languageIdentifier; cr;		nextPutAll: 'package '; nextPutAll: name asString printString; nextPutAll: ' = ('; cr; cr.	(classes sortBy: [:a :b | a name <= b name]) 		do: [:cls | cls streamTo: stm. stm cr].	stm		nextPutAll: ')'.)



) : (

'private'

fromPackageAst: ast stream: input = (	^self new		name: ast name asSymbol;		classes: (ast classes collect: [:ea | SmalltalkClassSourceMirror fromClassAst: ea stream: input]);		extensionMethods: OrderedCollection new.)



'accessing'

fromPackageInfo: pkgInfo <PackageInfo> = (	^self new		name: pkgInfo name;		classes: (pkgInfo classes collect: [:ea | SmalltalkClassSourceMirror fromClass: ea]);		extensionMethods: OrderedCollection new)



fromStream: input <ReadStream> = (		^self fromPackageAst: (parser package parse: input) stream: input)



)



class SmalltalkGrammar = ExectuableGrammar (
"Describe the class in this comment."
|
	array assignmentLHS arrayConstant binaryExpression binaryMsg binaryMsgPattern block blockParameter blockParameters cascadedMessageExpression cascadeMsg category classCategory classComment classDefinition classBody classSideDecl codeBody decimalNum expression furtherStatements keywordExpression keywordMsg keywordMsgPattern languageId literal method methodBody methodDecl messagePattern parenthesizedExpression primary radixNum returnStatement statements statementSequence symbolConstant temporaries tuple unaryExpression unaryMsgPattern unarySelector varDecls variableName variableDecl assignment binarySelector characterConstant colon comma dollar dot equalSign hat identifier keyword langleBracket lbracket lcurly lparen number pound rangleBracket rbracket rcurly rparen semicolon slash string symbol twoQuotes twoDblQuotes vbar assign binSel character Char comment digit digits id kw letter num specialCharacter str sym whitespace beginComment endComment

radix fraction exponent extendedFraction extendedDigits kws commentDelimiter

pragma
classFormat
packageName
package
|
	self setupTokens; lexicalGrammar; syntacticGrammar.

 	(selfMirror getClassIfFail:[]) slots do:[:slot <SlotMirror>| |p|
	p:: (selfMirror getSlot: slot name ifFail:[]) reflecteeIfFail:[].
	(p isKindOfCombinatorialParser) ifTrue:[
		p name: slot name " a good place to name the productions"
	]]
)

('as yet unclassified'

commentBody = ("As an optimization, we process the body of a comment with a dedicated scanning parser. It should be equivalent to: ^(self character | [self aWhitespaceChar] | [self char: $' ] | [self twoDblQuotes]) star, "^CollectingCommentParser new    termBlock:[: input | | c|                c:: input peek.                c isNil                     ifTrue:[false] "let main routine handle end of input"                    ifFalse:[c = $"                               ifFalse:[false]                              ifTrue:[| pos |                                        pos:: input position.                                       input next.                                       input peek = $" ifTrue:[false] ifFalse:[input position: pos. true]                                     ]                             ]               ])



lexicalGrammar = ("All the lexical productions are defined in this method. This makes it rather long, but puts everything in one convenient place."digit::  self charBetween: $0 and: $9."PredicateTokenParser new accept:[:c   | c between: $0 and: $9]                                        errorMsg: 'digit expected'."digits:: self digit plus.extendedDigits:: (self digit | [self letter]) plus.radix:: self digits, [self char: $r]                     wrapper:[:ds  :r  | ds].                   fraction:: self dot, [self digits]                         wrapper:[:period  :ds  | ds].extendedFraction:: self dot, [extendedDigits]                         wrapper:[:period  :ds  | ds].                        exponent:: (self char: $e), [(self char: $- ) opt], [self digits]                             wrapper:[:e :sgn :ds | sgn isNil ifTrue:[ds] ifFalse:["sgn asString," ds]].decimalNum:: (self char: $-)  opt,                    [self digits],                   [fraction opt],                  [exponent opt].radixNum:: radix,               [(self char: $-)  opt],                 [extendedDigits],                [extendedFraction opt],               [exponent opt].                                                                                                                   num::   self radixNum | [self decimalNum]. "must distinguish internal use of productions from use as tokens"                                                                                                         number:: self tokenFor: self num.                                                                                                         letter::  PredicateTokenParser new accept:[:c | isLetter: c]                                          errorMsg: 'letter expected'.               "(PredicateTokenParser new accept:[:c | c between: $A and: $Z]                                          errorMsg: ''               ) |               [PredicateTokenParser new accept:[:c  | c between: $a and: $z]                                               errorMsg: 'letter expected'               ]."                                                             specialCharacter:: (self char: $+ )  | [self char: $/ ] |                                         [self char: $\ ] | [self char: $* ]   |                                       [self char: $~ ] | [self char: $<] | [self char: $>] |                                       [self char: $=] | [self char: $@ ]  |                                       [self char: $% ] | [self char: $| ]  |                                       [self char: $& ] | [self char: $? ]  |                                       [self char: $! ] |  [self char: $, ] | [self char: $`].                                                    character:: self digit | [self letter] | [self specialCharacter] | [self char: $[  ] | [self char: $]  ] |                        [self char: ${ ] | [self char: $} ] | [self char: $(  ] |                        [self char:$) ] | [self char: $^ ] | [self char: $; ] | [self char: $$ ] | [self char: $#  ] |                        [self char: $: ] | [self char: $. ] | [self char: $-] | [self char: $_] | [self char: $`] "the Smalltalk grammar neglects to add - to characters, or to comments. It does add | [self char: $' ], but these are both bugs. We intend to support underscores, which Squeak insists on tirning into assignment arrows. However, we do not support these as assignments. At the moment, we do not accept them in identifiers, but this will change in time.".                          id::  self letter,  [(self letter | [self digit]) star]                  wrapper:[:fst   :snd  | fst asString, (String withAll: snd)].                                            identifier::  self tokenFor: self id.  Char:: (self char: $$),  	(self charBetween: (Character value: 0) and: (Character value: 16r10000)).	"[self character | [self char: $' ] | [self char: $"" ] | [self char:$  ]]."  characterConstant:: self tokenFor: self Char. twoQuotes:: (self char: $' ),  [self char: $' ]                   wrapper:[:q1 : q2 | '''']. str:: (self char: $' ),           [self stringBody],                   "[(self character | [self aWhitespaceChar] | [self char: $" "] | [self twoQuotes]) star],"        [self char: $']              wrapper:[:oq :es :eq | es inject:'' into:[:s : e | s, e asString]].  string:: self tokenFor: self str. kw:: self id, [self char: $:] wrapper:[: i  :c   | i, $: asString].  kws:: self kw plus wrap:[:c | c inject: '' into:[:s :e | s, e]].      keyword:: self tokenFor: self kw.  sym:: self str | [kws] | [self binSel] | [self id].   symbol:: self tokenFor: self sym.  commentDelimiter:: self char: $". beginComment:: commentDelimiter. endComment:: commentDelimiter. twoDblQuotes:: (self char: $" ),  [self char: $" ]                   wrapper:[:q1 : q2 | '"']. comment:: self beginComment,                  [self commentBody],               [self endComment].  binSel::  (self specialCharacter | [self char: $- ]), [self specialCharacter opt], [self specialCharacter opt]                          wrapper:[:c1 :c2 :c3  |			((c1 ifNil: ['']) asString ,			(c2 ifNil: ['']) asString ,			(c3 ifNil: ['']) asString ) asSymbol                                         "     c2 isNil ifTrue:[c1 asString asSymbol]                                                             ifFalse:[(c1 asString, c2 asString) asSymbol ]" "probably delay interning as symbol until later phase"                                           ].                                             binarySelector:: self tokenFor: self binSel. "maybe intern as symbol here"         assign:: (self char: $:), [self char: $=] wrapper:[:c :e | #':=']. assignment:: self tokenFor: (self assign | [self char: $_]). "Temporary hack")



parse: input inContext: context ifError: blk = (	self halt.)



setupTokens = (whitespace::   super whitespace. colon:: self tokenFromChar: $:.comma:: self tokenFromChar: $,.dollar:: self tokenFromChar: $$.dot:: self tokenFromChar: $..equalSign:: self tokenFromChar:$=.hat:: self tokenFromChar: $^.lbracket:: self tokenFromChar: $[.lcurly:: self tokenFromChar: ${.lparen:: self tokenFromChar: $(.langleBracket:: self tokenFromChar: $<.pound:: self tokenFromChar: $#.rangleBracket:: self tokenFromChar: $>.rbracket:: self tokenFromChar: $].rcurly:: self tokenFromChar: $}.rparen:: self tokenFromChar: $).semicolon:: self tokenFromChar: $;.slash:: self tokenFromChar: $/.vbar:: self tokenFromChar: $|.)



stringBody = ("As an optimization, we process the body of a string with a dedicated scanning parser.It should be equivalent to:  ^[(self character | [self aWhitespaceChar] | [self char: $"" ] | [self twoQuotes]) star"^CollectingCommentParser new    termBlock:[: input | | c|                c:: input peek.                c isNil                     ifTrue:[false] "let main routine handle end of input"                    ifFalse:[c = $'                               ifFalse:[false]                              ifTrue:[| pos |                                        pos:: input position.                                       input next.                                       input peek = $' ifTrue:[false] ifFalse:[input position: pos. true]                                     ]                             ]               ]                   )



syntacticGrammar = ("The entire syntactic grammar for Smalltalk,with a syntax for top level classes as well""This is a very large method, but it does allow the entire grammar to be viewed as a unit" symbolConstant::  self pound,  [self symbol].  array:: (self  lparen,                   [(self number | [self symbolConstant] | [self symbol] | [self string] | [self characterConstant] | [self arrayConstant] | [self array]) star],                  [self rparen])		|		(self  lbracket, "Byte array literal"                  [self number star],                  [self rbracket]).                                                            arrayConstant:: self pound, [self array]. tuple::  self lcurly,           [self expression starSeparatedOrTerminatedBy: self dot],           [self rcurly].  literal:: self number | [self symbolConstant] | [self characterConstant] | [self string] |  [self arrayConstant] | [self tuple].                  variableName:: self identifier.                                                                                                                                                               unarySelector:: (UnarySelectorParser new on: self). " the one hack/flaw. See UnarySelector parser for details"                                           parenthesizedExpression:: self lparen, [self expression], [self rparen].                                                                                                           primary::  self variableName |                [self literal] |                [self block] |                [self parenthesizedExpression].  unaryExpression:: self primary, [self unarySelector star]. binaryMsg:: self binarySelector, [self unaryExpression]. binaryExpression::  self unaryExpression, [self binaryMsg star].                                                                 keywordMsg:: (self keyword, [self binaryExpression]) plus.                                                keywordExpression::  self binaryExpression, [self keywordMsg opt].                                                                                                                                                                                                                      cascadeMsg:: self semicolon, [self  keywordMsg | [self binaryMsg] | [self unarySelector]].                                                                                                                         cascadedMessageExpression:: self keywordExpression, [self cascadeMsg star].                                                                                           assignmentLHS:: self variableName, [self assignment].                                                                                                                     expression:: self assignmentLHS star,                 [self cascadedMessageExpression ].                                                returnStatement:: self hat,  [self expression], [self dot opt].                                                                                                                          furtherStatements:: self dot,  [self statements].                                                                           statementSequence:: ((self expression) , [self furtherStatements  opt]) | furtherStatements.                                           statements:: self returnStatement  |                     [self statementSequence] |                  [self empty].                               blockParameter:: self colon, [self variableDecl].                                            blockParameters::  self blockParameter plus, [self vbar].  varDecls:: self vbar, [self variableDecl star], [self vbar].  temporaries:: self varDecls.  codeBody:: self temporaries opt, [pragma star],   [self statements].                                block:: (self lbracket,  [self blockParameters opt], [self codeBody],  [self rbracket]) | (lbracket, blockParameter star, rbracket).                        variableDecl:: self identifier.                      unaryMsgPattern:: self unarySelector.  binaryMsgPattern:: self binarySelector,  [self variableDecl].                                                                keywordMsgPattern:: (self keyword, [self variableDecl]) plus.                                                                                                                            messagePattern::  self unaryMsgPattern |                         [self binaryMsgPattern] |                         [self keywordMsgPattern ].     "Yuck, a pragma can appear before or after | temps | "  pragma:: langleBracket, (unarySelector| (keyword, (literal | variableDecl)) plus) , rangleBracket.  methodBody:: pragma star, self codeBody.      method:: self messagePattern, [self methodBody], [self eoi]. "A method in a browser"                                                                                                                                                  "Top level productions for classes"  methodDecl:: self messagePattern, [self equalSign], [self lparen], [self methodBody], [self rparen].   category:: self string, [self methodDecl star].  classComment:: self whitespace, [self comment]. "A hack, to preserve comments from a complete class declaration"                                              classBody:: self lparen, [self classComment opt], [self varDecls opt], [self category star], [self rparen].  classSideDecl:: self colon, [self classBody ].  languageId:: self identifier.   classCategory:: self string "opt".  classFormat:: (tokenFromSymbol: #class) | (tokenFromSymbol: #weakclass) | (tokenFromSymbol: #variableclass) | (tokenFromSymbol: #variablebyteclass) | (tokenFromSymbol: #variablewordclass).                                                                   classDefinition:: self classCategory, classFormat, [self identifier], [self equalSign], [self identifier], [self classBody],[ self classSideDecl opt].  packageName::  "tokenFor: ((letter | digit | (char: $-)) plus wrap:[:chars | (String withAll: chars)] )." string.	   package:: languageId, (tokenFromSymbol: #package), packageName, equalSign, lparen, classDefinition star, rparen , eoi.)



)'as yet unclassified'

isLetter: char = (	"This is 12 times faster than Character>>isLetter and 6 times faster than Unicode class>>isLetter:"	| charCode |	charCode:: char asciiValue.	^charCode < 255		ifTrue: [AsciiLetterTable at: charCode + 1]		ifFalse: [Unicode isLetter: char])



methodDeclToMethod: source usingMessagePattern: p = (		| result |		assert: [source startsWith: p] message: ''.	result:: source copyFrom: 1 to: p size.		result:: result , (source copyFrom: (source indexOf: $()+1 to: (source lastIndexOf: $)) - 1).	^result	)



methodToMethodDecl: rawSource = (| ast output patternEnd end |ast:: parser method parse: rawSource readStream                         ifError:[:msg :pos |                                     Transcript show: msg; show: ' at position ';                                                  show: pos printString; show:' ', selector; cr                                  ]."determine end of pattern"patternEnd:: ast pattern concreteEnd."extract pattern from source and append to output"output:: WriteStream on: String new.ast pattern start to: patternEnd do:[:i | output nextPut: (rawSource at: i)].output nextPutAll: ' = ('."trim trailing crs..."end:: rawSource size.[end > 1 and: [(rawSource at: end) = Character cr]] whileTrue:	[end:: end - 1]."extract body from source and append to output"patternEnd + 1 to: end do:[:i | output nextPut: (rawSource at: i)].output cr; nextPut: $); cr.^{output contents asString . rawSource copyFrom: ast pattern start to: patternEnd})



)