Newspeak3
'HopscotchIDE'
class Inspecting usingPlatform: platform ide: ide =  (
"Presenters for inspecting objects.

Example usage:
platform := Platform new.
vmMirror := SqueakVmMirror usingPlatform: platform.
inspection := HopscotchInspecting usingPlatform: platform.
Hopscotch openSubject: (inspection ObjectSubject on: (vmMirror reflectOn: inspection))

   Copyright 2008, 2012 Cadence Design Systems, Inc.

   Licensed under the Apache License, Version 2.0 (the ''License'');
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an ''AS IS'' BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"|
	ProgrammingPresenter = ide tools ProgrammingPresenter.
	Subject = platform hopscotch core Subject.
	BlankFragment = platform hopscotch fragments BlankFragment.
	TextEditorFragment = platform hopscotch fragments TextEditorFragment.

	finalizer = ide finalizer.

	OrderedCollection = platform collections OrderedCollection.

	Color = platform blackMarket Graphics Color.
	Semaphore = platform blackMarket Kernel Semaphore.
	ToolSet = platform blackMarket System ToolSet.
	UnhandledError = platform blackMarket Exceptions UnhandledError.
	Error = platform blackMarket Exceptions Error.


	"My slots"
	detailAreaRatio = 1.6.
	captionColor = Color h: 240 s: 0.05 v: 0.9.
|)
(
class BrazilVisualTreePresenter onSubject: theSubject <BrazilVisualTreeSubject> = ProgrammingPresenter onSubject: theSubject ()
('as yet unclassified'
captionLine = (
	| thumb |
	thumb:: subject model agent inspectorIconOfSize: 20.
^
	row: {
		thumb ifNil: [nothing] ifNotNil: [linkImage: thumb action: []].
		mediumBlank.
		label: subject title.
		largeBlank.
		(link: 'flash' action: [subject model flash]) tinyFont.
		mediumBlank.
		(link: 'explore' action: [subject model explore]) tinyFont.
		filler.
		elastic:: inspectorToggle.
	}
)
captionLineWithToggleAction: aBlock = (
	| thumb |
	thumb:: subject model agent inspectorIconOfSize: 20.
^
	row: {
		thumb ifNil: [nothing] ifNotNil: [linkImage: thumb action: aBlock].
		mediumBlank.
		link: subject title action: aBlock.
		largeBlank.
		(link: 'flash' action: [subject model flash]) tinyFont.
		mediumBlank.
		(link: 'explore' action: [subject model explore]) tinyFont.
		filler.
		elastic:: inspectorToggle.
	}
)
childColumn = (
^
	column: 
		(subject children collect: 
			[:each |
			(BrazilVisualTreeSubject onModel: each) presenter])
)
definition = (
^
	subject hasChildren
		ifTrue: [expandableView]
		ifFalse: [captionLine]
)
expandableView = (
	| toggle |
	toggle::
		heading: (captionLineWithToggleAction: [toggle toggle])
		details: [childColumn].
	^toggle
)
inspectorToggle = (
^
	collapsed: [label: 'Inspect']
	expanded: [(ObjectSubject onModel: (vmMirror reflectOn: subject model)) presenter]
)) : ()
class BrazilVisualTreeSubject onModel: theModel <Visual> = Subject onModel: theModel (
"Part of the ''Meta'' window menu item implementation. The model is a Brazil visual.")
('as yet unclassified'
children = (
	^model children
)
createPresenter = (
	^BrazilVisualTreePresenter onSubject: self
)
hasChildren = (
	^model hasChildren
)
title = (
	^model printString
)) : ()
class EvaluatorPresenter onSubject: theSubject <ObjectSubject> = ProgrammingPresenter onSubject: theSubject (|
	editor
	results
|)
('as yet unclassified'
addDiscardIfNeeded = (
	results presenters isEmpty ifTrue:
	[results add: discardResultsDefinition].
)
addExceptionalResultPresenterFor: exception <Exception> in: thread <NewspeakDebugging ThreadSubject> = (
	addDiscardIfNeeded.
	results addFirst: (
		row: {
			elastic::
				collapsed: [ExceptionalResultPresenter on: exception in: thread]
				expanded: [buildExceptionDetails: exception in: thread].
		}
	)
)
addResultPresenterOn: result <ObjectMirror> = (
	addDiscardIfNeeded.
	results addFirst: (resultFragmentOn: (ObjectSubject onModel: result))
)
buildExceptionDetails: exception <Exception> in: thread <NewspeakDebugging ThreadSubject> = (
	^column: {
		elastic:: row: {filler. (link: 'debug' action: [enterSubject: thread]) tinyFont}.
		elastic:: (ObjectSubject onModel: (vmMirror reflectOn: exception)) presenter.
	}
)
clearResults = (
	results presenters: {}
)
createEditor = (
	editor:: TextEditorFragment new.
	editor
		changeResponse: [];
		acceptResponse: [respondToEvaluate];
		escapeKeyResponse: [sendUp deliveryOptional hideEvaluator].
	^editor
)
definition = (
	results:: list: {}.
	^(column: {
		smallBlank.
		row: {
			smallBlank.
			elastic:: column: {filler. createEditor. filler}.
			smallBlank.
			button: 'Evaluate' action: [respondToEvaluate].
			smallBlank.
		}.
		smallBlank.
		row: {
			elastic:: results
		}
	}) color: captionColor
)
discardResultsDefinition = (
	^row: {
		filler.
		(link: 'discard results' action: [clearResults]) tinyFont.
	}
)
respondToEvaluate = (
	editor removeMessages.
	addResultPresenterOn:: subject
		evaluate: editor maybeSelectCurrentLine
		ifCompilerError:
			[:message |
			^editor addMessage: message]
		ifError:
			[:thread :exception |
			^addExceptionalResultPresenterFor: exception in: thread]
)
resultFragmentOn: result <ObjectSubject> ^ <Fragment> = (
	| heading |
	heading:: link: result title action: [enterSubject: result].
	sendUp
		deliveryOptional;
		additionalResultFragment:
			[:extra <Fragment> |
			heading:: row: {
				heading.
				filler.
				extra.
			}] for: result objectMirror.
	^collapsed: [heading]
		expanded: [result presenter]
)) : ()
class ExceptionalResultPresenter on: ex <Exception> in: theSubject <NewspeakDebugging ThreadSubject> = ProgrammingPresenter onSubject: theSubject (|
	exception = ex.
|)
('as yet unclassified'
buildInspectException = (
	| message |
	message:: exception messageText ifNotNil: [:it | it withBlanksTrimmed].
	^message isEmptyOrNil
		ifTrue: [(link: 'inspect' action: [inspect: exception]) tinyFont]
		ifFalse: [link: message action: [inspect: exception]]
)
definition = (
	^row: {
		(link: (exception isNil 
			ifTrue: ['Error: ', subject title] 
			ifFalse: [exception description])
		action: [respondToDebug]) color: Color red
	}
)
respondToDebug = (
	enterSubject: self subject
)) : ()
class ObjectIndexedSlotSubject on: mirror <ObjectMirror> slotIndex: i <Integer> = ObjectSlotSubject onModel: mirror (
"Represents an indexed slot of an object, accessed using a vm mirror. For a subject to represent a value accessible by sending the public #at: message, see ObjectValueAtKeySubject."|
	slotIdentifier = i.
|)
('accessing'
value = (
	^self objectMirror indexedSlotAt: slotIdentifier
)
value: newValue = (
	self objectMirror indexedSlotAt: slotIdentifier put: newValue.
	^newValue
)) : ()
class ObjectLiteralSubject on: theMirror key: theKey = ObjectValueAtKeySubject on: theMirror key: theKey (
"Describe the class in this comment."|
|)
('as yet unclassified'
value =(
	^  model reflecteePerform: #literalAt: with: {key}  
)) : ()
class ObjectNamedSlotSubject on: mirror <ObjectMirror> slotName: slotName <String> = ObjectSlotSubject onModel: mirror (
"Represents a named slot of the model, to be accessed using a vm mirror."|
	slotIdentifier = slotName.
|)
('accessing'
value = (
	^self objectMirror slotNamed: slotIdentifier ifAbsent: [nil]
)
value: newValue <ObjectMirror> = (
	self objectMirror slotNamed: slotIdentifier put: newValue ifAbsent: [nil].
	^newValue
)) : ()
class ObjectPresenter onSubject: subj <ObjectSubject> = ProgrammingPresenter onSubject: subj (
"The outer shell of an inspector: shows the caption bar with an evaluator opening link. Also contains and manages (switches) presenters for the different views onto the object contents."|
	evaluatorLink
	evaluatorHolder
	selfCaption ::= 'self'.
	protected objectDetailsHolder
|)
('accessing'
title = (
	^'Inspector on ', subject title
)'actions'
goToSelf = (
	enterSubject: (ObjectSubject onModel: subject objectMirror)
)'as yet unclassified'
availableObjectViews ^<Collection[ObjectViewDescription]> = (
	^Array streamContents:
		[:s |
		(subject objectMirror reflecteePerformDirect: #isString) ifTrue:
			[s nextPut:
				(ObjectViewDescription
					title: 'Text' 
					presenterCreator: [ObjectPresenterAsStringView onSubject: subject])].
		(subject objectMirror reflecteePerformDirect: #isCompiledMethod) ifTrue:
			[s nextPut:
				(ObjectViewDescription
					title: 'Method' 
					presenterCreator: [ObjectPresenterMethodView onSubject: subject])].
		(subject objectMirror reflecteePerformDirect: #isDictionary) ifTrue:
			[s nextPut:
				(ObjectViewDescription
					title: 'Dictionary' 
					presenterCreator: [ObjectPresenterDictionaryView onSubject: subject])].
		(subject objectMirror reflecteePerformDirect: #isCollection) ifTrue:[
			(subject objectMirror reflecteePerformDirect: #isSequenceable) ifTrue:[
				s nextPut:
				(ObjectViewDescription
					title: 'Sequence' 
					presenterCreator: [ObjectPresenterSequenceView onSubject: subject])]].
		s nextPut: 
			(ObjectViewDescription
				title: 'Basic' 
				presenterCreator: [ObjectPresenterBasicView onSubject: subject]).
		]
)
buildEvaluatorLink ^<Fragment> = (
	evaluatorLink:: (link: 'interact' action: [toggleEvaluator]) tinyFont.
	^evaluatorLink
)
classInfoLine = (
	^row: {
		(label: 'class') width: 0 elasticity: 1.
		(row: {
			link: subject className action: [browseClass: subject modelClass].
			smallBlank.
			(link: '[inspect]' action: [inspect: subject modelClass]) tinyFont.
			filler.
			buildEvaluatorLink.			
		})width: 0 elasticity: detailAreaRatio.
 	
	}
)
detailsSwitcherBarWith: details = (

	^details size < 2 
		ifTrue: [nothing]
		ifFalse: 
			[(row: 
				{ mediumBlank }, 
				(switcherLinksWith: details)
			) color: captionColor]
)
evaluatorPresenter ^ <EvaluatorPresenter> = (
	^EvaluatorPresenter onSubject: subject
)
hideEvaluator = (
	evaluatorHolder content: nothing.
	evaluatorLink label: 'interact'
)
respondToInspectInSqueak = (
	subject inspectInSqueak
)
selfInfoLine = (
	^row: {
		(label: selfCaption asText allBold) width: 0 elasticity: 1.
		(row: {
			link: subject title action: [goToSelf].
			filler.
			dropDownMenu: [actionsMenu]
		}) width: 0 elasticity: detailAreaRatio.
	}
)
showEvaluator = (
	evaluatorHolder content: evaluatorPresenter.
	evaluatorLink label: 'discard interaction'
)
switchDetailsTo: aPresenter = (
	objectDetailsHolder content: aPresenter
)
switcherLinksWith: details =(
^
	Array streamContents:
		[:elements |
		details 
			do:
				[:each <ObjectDetailsView> |
				elements nextPut:
					(link: each title action: [switchDetailsTo: each presenter] fixTemps)]
			separatedBy:
				[elements nextPut: smallBlank]]
)
toggleEvaluator = (
	(evaluatorHolder content isKindOf: BlankFragment)
		ifTrue: [showEvaluator]
		ifFalse: [hideEvaluator]
)'definition'
definition = (
	| views |
	views:: availableObjectViews.
	evaluatorHolder:: holder: nothing.
	objectDetailsHolder:: holder: views first presenter. 
	^(column: {
		headerDefinition.
		evaluatorHolder.
		detailsSwitcherBarWith: views.
		row: {
			coloredBarWidth: 1.
			blank: 3.
			elastic:: objectDetailsHolder. 
				"was (ObjectPresenterBasicView on: subject)."
			blank: 2.
			coloredBarWidth: 1.
		}.
		coloredBarWidth: 1.
	}) color: Color white
)
headerDefinition = (
^
	captionBar:
		(column: {
			selfInfoLine.
			classInfoLine.
			}).
)'parameters'
actionsMenu = (
	^menuWithLabelsAndActions: {
		'Toggle Evaluator' -> [toggleEvaluator].
		'Inspect Presenter' -> [respondToInspectPresenter].
	}
)'private'
captionBar: body = (
	^(column: {
		smallBlank.
		row: {
			mediumBlank.
			elastic: body.
			smallBlank
			}.
		smallBlank
	})
		color: captionColor
)
coloredBarWidth: pixels = (
	^((row: {}) color: captionColor) width: pixels
)) : ()
class ObjectPresenterAsStringView onSubject: subj <ObjectSubject> = ProgrammingPresenter onSubject: subj (
"Presents an object that can be coerced to a String by sending #asString, by displaying the string it coerces to as a text block."|
|)
('as yet unclassified'
definition = (
	^ textDisplay: textToDisplay
)
textToDisplay = (
	^[subject objectMirror reflecteePrintStringLimitedTo: 1024]
		on: Error
		do: [:ex | ex return: '<an error occurred while sending #asString to the object>']
)) : ()
class ObjectPresenterBasicView onSubject: subj = ProgrammingPresenter onSubject: subj (
"Presents an object (the model of its subject) as a collection of its named and indexed slots.")
('as yet unclassified'
definition = (
	^list: slotPresenters
)
slotPresenters = (
	^Array streamContents:
		[:presenters |
		subject namedSlotNames do:
			[:each |
			presenters nextPut: 
				(ObjectSlotPresenter onSubject: 
					(ObjectNamedSlotSubject on: subject objectMirror slotName: each))].
		subject hasIndexedSlots ifTrue:
			[subject indexedSlotRange do:
				[:index |
				presenters nextPut: 
					(ObjectSlotPresenter onSubject:
						(ObjectIndexedSlotSubject on: subject objectMirror slotIndex: index))]]].
)) : ()
class ObjectPresenterDictionaryView onSubject: subj = ProgrammingPresenter onSubject: subj (
"Presents an object that understands #keys and #at:, i.e. something dictionary-like, by going through the keys and displaying an entry for each of them, with the value obtained by sending #at:."|
|)
('as yet unclassified'
definition = (
^
	list: entryPresenters
)
entryPresenters = (
	| presenters |
	presenters:: OrderedCollection new.
	subject model reflectee keys do:
		[:each |
		presenters add: 
			(ObjectValueAtKeySubject on: subject model key: each) presenter].
	^presenters
)) : ()
class ObjectPresenterMethodView onSubject: subj <ObjectSubject> = ProgrammingPresenter onSubject: subj (
"Presents a compiled method by showing its decompiled source and a disassembly of its bytecodes."|
|)
('as yet unclassified'
bytecodeString = (
	^[method reflecteePerformDirect: #symbolic]
		on: Error
		do: [:ex | ex return: '<error retrieving the method''s bytecodes>']
)
decompiledString = (
	^[method reflecteePerformDirect: #decompileString]
		on: Error
		do: [:ex | ex return: '<error decompiling the method>']
)
definition = (
^
	column: {
		smallBlank.
		minorHeadingBlock: (label: 'Decompiled').
		indentedBlock: (textDisplay: decompiledString).
		minorHeadingBlock: (label: 'Header').
		indentedBlock: (textDisplay: headerDescription withBlanksTrimmed).
		minorHeadingBlock: (label: 'Literals').
		indentedBlock: (literalPresenters).
		minorHeadingBlock: (label: 'Bytecodes').
		indentedBlock: (textDisplay: bytecodeString).
		}
)
headerDescription = (
	^[method reflecteePerformDirect: #headerDescription ]
		on: Error
		do: [:ex | ex return: '<error retrieving the method''s headerDescription>']
)
literalPresenters = (
	| presenters |
	presenters:: OrderedCollection new.
	1 to: (method reflecteePerformDirect: #numLiterals) do:
		[:index |
		presenters add: 
			(ObjectLiteralSubject on: subject model key: index) presenter].
	^list: presenters
)
method = (
	^subject objectMirror 
)) : ()
class ObjectPresenterSequenceView onSubject: subj = ProgrammingPresenter onSubject: subj (
"Presents objects that understand #size and #at:, most likely SequenceableCollections by stringing ObjectValueAtKeySubjects for indicex from 1 to <size>."|
|)
('as yet unclassified'
definition = (
^
	list: elementPresenters
)
elementPresenters = (
	^subject 

model reflectee size 
<= 200
		ifTrue: [elementPresentersAll]
		ifFalse: [elementPresentersSome]

)
elementPresentersAll = (
	| presenters |
	presenters:: OrderedCollection new.
	1 to: subject model reflectee size do:
		[:index |
		presenters add: 
			(ObjectValueAtKeySubject on: subject model key: index) presenter].
	^presenters
)
elementPresentersSome = (
	| presenters collectionSize |
	presenters:: OrderedCollection new.
	collectionSize:: subject model reflectee size.
	1 to: 100 do:
		[:index |
		presenters add: 
			(ObjectValueAtKeySubject on: subject model key: index) presenter].
	presenters add:
		(column: {
			largeBlank.
			row: {
				blank: 40.
				label: 'Skipping ', (collectionSize - 120 - 1) printString, ' elements...'.
			}.
			largeBlank.
		}).
	collectionSize - 20 to: collectionSize do:
		[:index |
		presenters add: 
			(ObjectValueAtKeySubject on: subject model key: index) presenter].
	^presenters
)) : ()
class ObjectSlotPresenter onSubject: subj = ProgrammingPresenter onSubject: subj (
"This presenter is used for most of object detail views, such as the list of object slots, collection elements, or dictionary entries. Thus the actual interpretation of what ''slot'' means is a responsibility of the subject. The subject is something like ObjectIndexedSlotSubject, ObjectNamedSlotSubject, or ObjectValueAtKeySubject. This presenter displays the subject as a row with the caption of the subject, followed by the value string provided the subject.")
('actions'
respondToValueClick = (
	enterSubject: subjectOnValue
)'as yet unclassified'
caption = (
	^row: {
		(label: subject caption) width: 0 elasticity: 1.
		(link: (subject briefValuePrintString) action: [respondToValueClick]) width: 0 elasticity: detailAreaRatio.
	}
)'definition'
definition = (
	^collapsed: caption expanded: [subjectOnValue presenter]
)'private'
subjectOnValue = (
	| valueSubject |
	valueSubject:: ObjectSubject onModel: subject value.
	valueSubject presenter selfCaption: subject caption.
	^valueSubject
)) : ()
class ObjectSlotSubject onModel: mirror <ObjectMirror> = Subject onModel: mirror ()
('as yet unclassified'
= another = (
	^self class = another class and:
		[self objectMirror = another objectMirror and:
			[self slotIdentifier = another slotIdentifier]]
)
briefValuePrintString = (
	^value reflecteePrintStringLimitedTo: 60
)
caption ^<String> = (
	"The short string a presenter could use to identify the slot."
	^slotIdentifier asString
)
createPresenter = (
	^ObjectSlotPresenter onSubject: self
)
hash = (
	^(self class hash bitXor: objectMirror hash) bitXor: slotIdentifier hash
)
objectMirror = (
	^self model
)
slotIdentifier = (
	subclassResponsibility
)) : ()
class ObjectSubject onModel: mirror <ObjectMirror> = Subject onModel: mirror (
"Part of inspector functionality. The model is the object being inspected.")
('as yet unclassified'
= another = (
	^self class = another class and:
		[objectMirror = another objectMirror]
)
className = (
	^modelClass simpleName
)
evaluate: expression  ifCompilerError: onCompilerError <[String]> ifError: onError <[NewspeakDebugging ThreadSubject, Exception]> ^<ObjectMirror> = (
	| compilerError failed sem result process |
	failed:: false.
	compilerError:: nil.
	sem:: Semaphore new.
	process::
		[[result:: objectMirror evaluate: expression ifError: [:message | compilerError:: message]. sem signal] on: UnhandledError do:
			[:ex |
			failed:: true.
			result:: ex exception.
			sem signal.
			process suspend]
		] newProcess.
	process
		name: 'Evaluating ', expression printString;
		resume.
	sem wait.
	process offList.
	compilerError ifNotNil: [:it | ^onCompilerError valueWithPossibleArgument: it].
	failed ifTrue:
		[^onError value: (finalizer subjectFor: result in: process) value: result].
	^result
)
exploreInSqueak = (
	objectMirror withReflecteeDo: [:it | ToolSet explore: it]
)
hash = (
	^self class hash bitXor: objectMirror hash
)
indexedSlotRange = (
	^1 to: objectMirror reflecteeBasicSize
)
inspectInSqueak = (
	objectMirror withReflecteeDo: [:it | ToolSet inspect: it]
)
modelClass = (
	^objectMirror reflecteeClass
)
namedSlotNames ^<Collection[String]> = (
	^objectMirror namedSlotNames
)
objectMirror = (
	^model
)
printOn: s <WriteStream> = (
	s
		nextPutAll: self class simpleName;
		nextPut: $:.
	objectMirror reflecteePrintOn: s
)
title = (
	^objectMirror reflecteePrintStringLimitedTo: 60
)'private'
createPresenter = (
	^ObjectPresenter onSubject: self
)'testing'
hasIndexedSlots = (
	^objectMirror hasIndexedSlots
)) : ()
class ObjectValueAtKeySubject on: theMirror key: theKey = Subject onModel: theMirror (
"Describe the class in this comment."|
	key = theKey.
|)
('as yet unclassified'
= another = (
	^self class = another class and:
		[self model == another model and:
			[self key = another key]]
)
briefValuePrintString = (
	^[value reflecteePrintStringLimitedTo: 60]
		on: Error
		do: [:ex | ex return: '<error printing the value>']
)
caption = (
	^[key printString]
		on: Error
		do: [:ex | ex return: '<error>']
)
createPresenter =(
	^ObjectSlotPresenter onSubject: self
)
hash = (
	^model identityHash bitXor: key hash
)
value =(
	^  model reflecteePerform: #at: with: {key}  
)) : ()
class ObjectViewDescription title: theTitle <String> presenterCreator: theCreator <Block> = (
"A collection of these is held onto by ObjectPresenter as a list of views available for the object being presented. If more that one view is available, the object presenter typically displays some selection widgets to allow switching between the views. An instance of this is responsible for lazily instantiating its presenter when asked for the presenter."|
	title = theTitle. 
	presenterCreator = theCreator.
	private presenterX
|)
('as yet unclassified'
presenter = (
	^presenterX ifNil:
		[presenterX:: presenterCreator value.
		presenterX]
)) : ()) : ()