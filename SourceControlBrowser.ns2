Newspeak3
'HopscotchIDE'
class SourceControlBrowser usingPlatform: platform <Platform> ide: ide = NewspeakObject (
"
   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"|
	brazil = platform brazil.
	Gradient <Gradient class> = brazil plumbing Gradient.
	MessageBox <MessageBox class> = brazil tools MessageBox.
	DirectoryPicker <DirectoryPicker class> = brazil tools DirectoryPicker.
	Duct = brazil plumbing Duct.

	Subject <Subject class> = platform hopscotch core Subject.
	Presenter <HPresenter class> = platform hopscotch core Presenter.
	TextEditorFragment <TextEditorFragment class> = platform hopscotch fragments TextEditorFragment.
	RowComposer <RowComposer class> = platform hopscotch composers RowComposer.
	ColumnComposer <ColumnComposer class> = platform hopscotch composers ColumnComposer.
	BlankFragment <BlankFragment class> = platform hopscotch fragments BlankFragment.

	IDEWindow = ide IDEWindow.
	ProgrammingPresenter = ide tools ProgrammingPresenter.
	MethodPresenter= ide browsing MethodPresenter.
	OneLineDefinitionTemplate = ide tools OneLineDefinitionTemplate.
	MethodSubject = ide browsing MethodSubject.
	ExpandableMethodPresenter = ide browsing ExpandableMethodPresenter.

	Dictionary = platform collections Dictionary.
	OrderedCollection = platform collections OrderedCollection.
	IdentitySet = platform collections IdentitySet.

	"ungood imports"
	Platform = platform blackMarket NsMultilanguage Platform.
	Smalltalk = platform blackMarket Smalltalk.
	NsSvnRepository = platform blackMarket NsSvnRepository.
	Monticello = platform blackMarket Monticello.
	MCCacheRepository <MCCacheRepository class> = Monticello MCCacheRepository.
	MCWorkingCopy <MCWorkingCopy class> = Monticello MCWorkingCopy.
	MCVersionInspector <MCVersionInspector class> = Monticello MCVersionInspector.
	MCPatchBrowser <MCPatchBrowser class> = Monticello MCPatchBrowser.
	MCVersionLoader <MCVersionLoader class> = Monticello MCVersionLoader.
	MCPackage <MCPackage class> = Monticello MCPackage.
	MCSnapshot <MCSnapshot class> = Monticello MCSnapshot.
	MCNoChangesException <MCNoChangesException class> = Monticello MCNoChangesException.
	MCMergeResolutionRequest <MCMergeResolutionRequest class> = Monticello MCMergeResolutionRequest.
	NsToolSet <NsToolSet class> = platform blackMarket NsToolSet NsToolSet.
	Date <Date class> = platform blackMarket Kernel Date.
	DateAndTime <DateAndTime class> = platform blackMarket Kernel DateAndTime.
	Color <Color class> = platform blackMarket Graphics Color.
	FileDirectory <FileDirectory class> = platform blackMarket Files FileDirectory.
	ThisOSProcess <ThisOSProcess class> = platform blackMarket OSProcess ThisOSProcess.
	TextDiffBuilder <TextDiffBuilder class> = platform blackMarket System TextDiffBuilder.
	Text <Text class> = platform blackMarket Collections Text.
	TextEmphasis <TextEmphasis class> = platform blackMarket Collections TextEmphasis.
	TextColor <TextColor class> = platform blackMarket Collections TextColor.
	PseudoClass <PseudoClass class> = platform blackMarket System PseudoClass.
	ChangeSet <ChangeSet class> = platform blackMarket System ChangeSet.
	BrazilSystemWindow <BrazilSystemWindow class> = platform blackMarket BrazilForMorphic BrazilSystemWindow.
	UnversionedSourceManager <UnversionedSourceManager class> = platform blackMarket SourceManagement UnversionedSourceManager.
	PackageOrganizer <PackageOrganizer class> = platform blackMarket PackageInfo PackageOrganizer.
	ProgressInitiationException <ProgressInitiationException class> = platform blackMarket Exceptions ProgressInitiationException.
	Monitor = platform blackMarket Kernel Monitor.
	Semaphore = platform blackMarket Kernel Semaphore.
	Utilities = platform blackMarket System Utilities.
	Project = platform blackMarket System Project.
	WorldState = platform blackMarket Morphic WorldState.

	private assert = platform blackMarket NewspeakCore Assert new.

	defaultCategory <Symbol> = platform blackMarket Kernel Categorizer default.
	nullCategory <Symbol> = platform blackMarket Kernel Categorizer nullCategory.
	requestModule <Request> = platform blackMarket HostSystem Request usingPlatform: platform blackMarket.
	logSubjects <NsSvnLogSubjects> = ide logSubjects.
	protected repositoryContentsCache
	protected repositoryContentsTimestamp
	protected updatesChannel = Duct owner: self.
	protected differences = Differences new.
	ignoreUpdates ::= false.
	protected mutex = Monitor new.
	protected processes = IdentitySet new.
	|setup)
(
class Differences = (|
	tabString
	eolString
	spaceString
	separatorCharacters = '(){}[]<>"''+-/.*' asSet.
	frameColor ::= Color gray: 0.92.
|hideWhitespace.
	separatorCharacters add: Character space.
	separatorCharacters add: Character cr.
	separatorCharacters add: Character tab.
	separatorCharacters add: Character lf.
	separatorCharacters add: Character newPage)
(
class ClassDefinitionDifferencePresenter onSubject: theSubject <ClassDefinitionDifferenceSubject> = ProgrammingPresenter onSubject: theSubject ()
('as yet unclassified'
definition = (
	^row: {
		(heading: [headingDefinition]  detailsExpanded: [subject changes presenter]) width: 0 elasticity: 1.
		blank: 13.
	}
)
headingDefinition = (
		^row: {
		(minorHeadingBlock: (row: {label: 'Class header' asText allBold. filler. link: 'select' action: [respondToSelectLeft]. mediumBlank. dropDownMenu: [leftMenuActions]})) width: 0 elasticity: 1.
		blank: 13.
		blank: 13 color: backgroundColor.
		blank: 13.
		(minorHeadingBlock: (row: {label: 'Class header' asText allBold. filler. link: 'select' action: [respondToSelectRight]. mediumBlank. dropDownMenu: [rightMenuActions]})) width: 0 elasticity: 1.
	}
)
leftMenuActions = (
	^menuWithLabelsAndActions: {
		'Load' -> [respondToLoadLeft]
	}
)
respondToLoadLeft = (
	^subject sideA ifNotNil: [:it | it load]
)
respondToLoadRight = (
	^subject sideB ifNotNil: [:it | it load]
)
respondToSelectLeft = (
	
)
respondToSelectRight = (
	
)
rightMenuActions = (
	^menuWithLabelsAndActions: {
		'Load' -> [respondToLoadRight]
	}
))
class ClassDefinitionDifferenceSubject onModel: op <MCPatchOperation> = Subject onModel: op ()
('as yet unclassified'
changes = (
	^SideBySideDiffSubject a: sourceA b: sourceB
)
createPresenter = (
	^ClassDefinitionDifferencePresenter onSubject: self
)
sideA = (
	model isAddition ifTrue: [^nil].
	^model isModification
		ifTrue: [model obsoletion]
		ifFalse: [model definition]
)
sideB = (
	model isRemoval ifTrue: [^nil].
	^model definition
)
sourceA = (
	^sideA ifNotNil: [:it | sourceOf: it]
)
sourceB = (
	^sideB ifNotNil: [:it | sourceOf: it]
)
sourceOf: def <MCClassDefinition> = (
	^String streamContents:
		[:stream |
		stream
			nextPutAll: '(* category: ';
			nextPutAll: (def category ifNil: ['']).
		def language isNewspeakLanguage2 ifFalse: [
			stream
				cr; nextPutAll: def comment; cr].
		stream
			nextPutAll: ' *)'; cr;
			nextPutAll: def source]
)
title = (
	^model summary
))
class ClassDifferencePresenter onSubject: theSubject <ClassDifferenceSubject> = ProgrammingPresenter onSubject: theSubject ()
('as yet unclassified'
definition = (
	^(column: {
		blank: 3.
		row: {
			(heading: [headingDefinition] details: [detailsDefinition]
				initiallyExpanded: (subject isRemoval or: [subject isAddition]) not) width: 0 elasticity: 1.
			blank: 13
		}.
		blank: 3.
	}) color: backgroundColor.
)
detailsDefinition = (
	| definitions |
	definitions:: Array streamContents:
		[:s |
		subject definitionDifferences, subject methodDifferences
			do: [:each | s nextPut: (differenceRow: each)]
			separatedBy: [s nextPut: (vblank: 2 color: backgroundColor)]].
	^column: definitions
)
differenceRow: difference <Subject> = (
	^(row: {difference presenter  width: 0 elasticity: 1}) color: frameColor
)
headingDefinition = (
	^row: {
		(majorHeadingBlock: (label: summary asText allBold)) width: 0 elasticity: 1.
		blank: 13.
		(majorHeadingBlock: (label: summary asText allBold)) width: 0 elasticity: 1.
	}
)
summary = (
	subject isAddition ifTrue: [^subject title, ' was added'].
	subject isRemoval ifTrue: [^subject title, ' was removed'].
	^subject title
))
class ClassDifferenceSubject onModel: changes = Subject onModel: changes ()
('as yet unclassified'
createPresenter = (
	^ClassDifferencePresenter onSubject: self
)
definitionDifferences = (
	^Array streamContents: [ :s | model value do: [ :op <MCPatchOperation> |
			op isMethodPatch ifFalse: [s nextPut: (ClassDefinitionDifferenceSubject onModel: op)]]]
)
isAddition = (
	model value do: [ :op <MCPatchOperation> | 
		(op isClassPatch and: [op isAddition]) ifTrue: [^true]].
	^false
)
isRemoval = (
	model value do: [ :op <MCPatchOperation> | 
		(op isClassPatch and: [op isRemoval]) ifTrue: [^true]].
	^false
)
language = (
	model value do: [ :op <MCPatchOperation> | op isClassPatch ifTrue: [^op definition language]].
	Smalltalk at: model key ifPresent: [ :cls | ^cls language].
	^nil
)
methodDifferences = (
	^Array streamContents: [ :s | model value do: [ :op <MCPatchOperation> |
			op isMethodPatch ifTrue: [s nextPut: (MethodDifferenceSubject on: op in: self)]]]
)
oldLanguage = (
	model value do: [ :op <MCPatchOperation> | op isClassPatch ifTrue: [^op obsoletion language]].
	Smalltalk at: model key ifPresent: [ :cls | ^cls language].
	^nil
)
title = (
	^model key asString
))
class DifferencePresenter onSubject: theSubject <DifferenceSubject> = ProgrammingPresenter onSubject: theSubject (|
	loadStatus
|)
('as yet unclassified'
conflicts = (
	^nil
)
conflictsHeading = (
	^nil
)
definition = (
	loadStatus:: Listener new.
	^(column: {
		row: {
			blank: 13.
			(majorHeadingBlock: (
				row: {
					label: subject nameA asText allBold.
					largeBlank.
					loadADefinition
				})) width: 0 elasticity: 1.
			blank: 13.
			(majorHeadingBlock: (
				row: {
					label: subject nameB asText allBold.
					largeBlank.
					loadBDefinition.
					filler.
					dropDownMenu: [menu]
				})) width: 0 elasticity: 1.
			blank: 13.
		}.
		blank: 6.
		row: {
			blank: 13.
			elastic: (majorHeadingBlock: (row: {loadStatus. label: ' '})).
			blank: 13.
		}.
		blank: 3.
		conflictsHeading.
		conflicts.
		differencesHeading.
		differences.
	}) color: backgroundColor
)
differences = (
	^list: [subject differences collect: [ :ea | ea presenter]]
)
differencesHeading = (
	^nil
)
loadADefinition = (
	^subject isVersionALoadable ifTrue: [link: 'load' action: [respondToLoadA]]
)
loadBDefinition = (
	^subject isVersionBLoadable ifTrue: [link: 'load' action: [respondToLoadB]]
)
menu = (
	^menuWithLabelsAndActions: {
		'Add changes to "', ChangeSet current name, '" change set' -> [respondToAddChangesToCurrentChangeSet].
		'Create change set ', subject nameA printString, ' and add these changes' -> [respondToAddChangesInAToChangeSet].
		'Create change set ', subject nameB printString, ' and add these changes' -> [respondToAddChangesInBToChangeSet].
		eolString isEmpty
			ifTrue: ['Show Whitespace' -> [showWhitespace. self refresh]]
			ifFalse: ['Hide Whitespace' -> [hideWhitespace. self refresh]].
	}
)
noticeInstallation = (
	| bounds |
	super noticeInstallation.
	bounds:: shell window bounds.
	bounds extent x < 970 ifTrue:
		[shell window area bounds: (bounds origin extent: 970 @ bounds extent y)]
)
respondToAddChangesInAToChangeSet = (
	subject addChangesInAToChangeSet
)
respondToAddChangesInBToChangeSet = (
	subject addChangesInBToChangeSet
)
respondToAddChangesToCurrentChangeSet = (
	subject addChangesToCurrentChangeSet
)
respondToLoadA = (
	loadStatus showMessage: 'Loading ', subject nameA, '...'.
	doInBackground: [subject loadVersionAIfNotLoadable: []]
		notifying: loadStatus
		whenDone: [enterSubject: mainSubject]
)
respondToLoadB = (
	loadStatus showMessage: 'Loading ', subject nameB, '...'.
	doInBackground: [subject loadVersionBIfNotLoadable: []]
		notifying: loadStatus
		whenDone: [enterSubject: mainSubject]
)
viewportColor = (
	^backgroundColor
))
class DifferenceSubject onModel: patch <MCPatch> = Subject onModel: patch (|
	nameA
	versionA
	nameB
	versionB
|)
('as yet unclassified'
addChangesInAToChangeSet = (
	addChangesToChangeSetNamed:: ChangeSet uniqueNameLike: nameA
)
addChangesInBToChangeSet = (
	addChangesToChangeSetNamed:: ChangeSet uniqueNameLike: nameB
)
addChangesToChangeSetNamed: changeSetName = (
	| currentChangeSet |
	currentChangeSet:: ChangeSet current.
	ChangeSet newChanges: (ChangeSet basicNewChangeSet: changeSetName).
	[addChangesToCurrentChangeSet] ensure: [ChangeSet newChanges: currentChangeSet]
)
addChangesToCurrentChangeSet = (
	| cs |
	cs:: ChangeSet current.
	model operations do: [ :item |
		item isMethodPatch ifTrue: [
			item isRemoval
				ifTrue: [cs removeSelector: item definition selector class: item targetClass priorMethod: nil lastMethodInfo: nil].
			(item isAddition or: [item isModification])
				ifTrue: [cs adoptSelector: item definition selector forClass: item targetClass]]
			ifFalse: [
				item isClassPatch ifTrue: [
					item isRemoval
						ifTrue: [cs noteRemovalOf: item targetClass].
					item isAddition
						ifTrue: [cs addClass: item targetClass].
					item isModification
						ifTrue:
							[cs atClass: item targetClass add: #change]]]])
createPresenter = (
	^DifferencePresenter onSubject: self
)
differences = (
	^Array streamContents: [ :s | | classNames |
		classNames:: Dictionary new.
		model operations do: [ :op <MCPatchOperation> |
			(op isClassPatch or: [op isMethodPatch])
				ifTrue: [ | cls |
					(classNames at: op definition className ifPresent: [:e|] ifAbsentPut: [{} asMutableArrayList]) add: op]
				ifFalse: [s nextPut: (PatchOperationSubject onModel: op)]].
		classNames associationsDo: [ :ea | s nextPut: (ClassDifferenceSubject onModel: ea)]]
)
isVersionALoadable = (
	^(versionA value ifNil: [^false]) isLoadable
)
isVersionBLoadable = (
	^versionB value isLoadable
)
loadVersionAIfNotLoadable: failAction <[]> = (
	| version <MCVersion | MCPackage> |
	version:: versionA value.
	version isLoadable ifFalse: [^failAction value].
	version load
)
loadVersionBIfNotLoadable: failAction <[]> = (
	| version <MCVersion | MCPackage> |
	version:: versionB value.
	version isLoadable ifFalse: [^failAction value].
	version load
)
refreshmentSubject = (
	^super refreshmentSubject
		nameA: nameA;
		versionA: versionA;
		nameB: nameB;
		versionB: versionB
)
title = (
	^'Changes'
))
class MergePresenter onSubject: theSubject = DifferencePresenter onSubject: theSubject (|
	mergeButton
|)
('as yet unclassified'
choseSideAOf: operation <MCPatchOperation> = (
	| conflict |
	conflict:: subject model conflicts detect: [:each | each operation == operation] ifNone: [^self].
	conflict chooseLocal.
	possiblyEnableMergeButton
)
choseSideBOf: operation <MCPatchOperation> = (
	| conflict |
	conflict:: subject model conflicts detect: [:each | each operation == operation] ifNone: [^self].
	conflict chooseRemote.
	possiblyEnableMergeButton
)
conflicts = (
	^list: [subject conflicts collect: [ :ea | ea presenter]]
)
conflictsHeading = (
	mergeButton:: (button: 'merge' action: [respondToMerge]) enabled: subject model isMerged.
	^row: {
		blank: 13.
		elastic: (majorHeadingBlock: (row: {(label: 'Conflicts') hugeFont. filler. mergeButton})).
		blank: 13.
	}.
)
differencesHeading = (
	^row: {
		blank: 13.
		elastic: (majorHeadingBlock: (row: {(label: 'Other Changes') hugeFont})).
		blank: 13.
	}.
)
isTransient = (
	^true
)
possiblyEnableMergeButton = (
	mergeButton enabled: subject model isMerged
)
respondToMerge = (
	loadStatus showMessage: 'Merging...'.
	doInBackground: [subject merge]
		notifying: loadStatus
		whenDone: [enterSubject: mainSubject]
))
class MergeSubject onModel: merger <MCThreeWayMerger> = Subject onModel: merger (|
	title <String>
	versionMerger <MCVersionMerger>
	version <MCVersion>
|)
('as yet unclassified'
conflicts = (
	^Array streamContents: [ :s | | classNames |
		classNames:: Dictionary new.
		model conflicts do:
			[:conflict <MCConflict> |
			(conflict operation isClassPatch or: [conflict operation isMethodPatch])
				ifTrue: [ | cls |
					(classNames 
						at: conflict operation definition className 
						ifPresent: [:e | ]
						ifAbsentPut: [{} asMutableArrayList]) add: conflict operation]
				ifFalse: [s nextPut: (PatchOperationSubject onModel: conflict operation)]].
		classNames associationsDo: [ :ea | s nextPut: (ClassDifferenceSubject onModel: ea)]]
)
createPresenter = (
	^MergePresenter onSubject: self
)
differences = (
	^Array streamContents: [ :s | | classNames |
		classNames:: Dictionary new.
		model operations do: [ :op <MCPatchOperation> |
			(op isClassPatch or: [op isMethodPatch])
				ifTrue: [ | cls |
					(classNames 
						at: op definition className 
						ifPresent:[:e |]
						ifAbsentPut: [{} asMutableArrayList]) add: op]
				ifFalse: [s nextPut: (PatchOperationSubject onModel: op)]].
		classNames associationsDo: [ :ea | s nextPut: (ClassDifferenceSubject onModel: ea)]]
)
isVersionALoadable = (
	^false
)
isVersionBLoadable = (
	^false
)
merge = (
	model loadWithNameLike: version info name.
	versionMerger records do: [:ea | ea updateWorkingCopy]
)
nameA = (
	^'Code in Image'
)
nameB = (
	| prefix |
	prefix:: 'Merging '.
	^(title beginsWith: prefix)
		ifTrue: [title allButFirst: prefix size]
		ifFalse: [prefix]
)
refreshmentSubject = (
	^super refreshmentSubject
		title: title;
		done: done
))
class MethodDifferencePartPresenter onSubject: theSubject = ExpandableMethodPresenter onSubject: theSubject (
"When viewing differences between versions, it is sometimes useful to load what is in the repository.  This representer exposes that API. "|
	protected color = Color transparent.
|)
('as yet unclassified'
methodActionsMenu = (
	"We could just add MenuItems to what the superclass returns, but at the cost of adding two more imports (SeparatorItem & MenuItem).  So for now, just reimplmement what the superclass has and add the items.  Obviously, this is a maintenance headache.  Is there a general API for exending menus?"
	
	^menuWithLabelsAndActions: {
		'Delete #', subject selector -> [respondToDelete].
		'Versions' -> [respondToVersions].
		#separator.
		'Inspect Presenter' -> [respondToInspectPresenter].
		#separator.
		'load' -> [respondToLoad]	
	}
)
respondToLoad = (
	subject load.
	sendUp collapseMethodDifferences
))
class MethodDifferencePartSubject onModel: m <MCMethodDefinition> language: lang = MethodSubject onModel: m (|
	language = lang.
|)
('as yet unclassified'
changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
	failureBlock value
)
compileNewSource: source <String> ifSuccess: successBlock ifNewMethod: newBlock1arg ifFailure: failureBlock = (
	#BOGUS yourself.
	failureBlock value
)
createPresenter = (

	^MethodDifferencePartPresenter  onSubject: self
)
implementingClass = (
	^model actualClass
)
isAnOverride = (
	^false
)
isOverridden = (
	^false
)
isPlainSmalltalk = (
	^language name = #Smalltalk
)
isValid = (
	^true
)
load = (

	model load
	
)
messages ^ <Collection[Symbol]> = (
	#BOGUS yourself.
	^{}
)
methodCategory = (
	^model category
)
selector = (
	^model selector
)
source = (
	^isPlainSmalltalk
		ifTrue: [model source copyReplaceAll: '_' with: ':=']
		ifFalse: [model source]
)
sourceAndMetadata = (
	^String streamContents: [ :s |
		defaultCategory == methodCategory ifFalse: [
			s nextPutAll: '(* category: ';
				nextPutAll: methodCategory asString printString;
				nextPutAll: ' *)'; cr].
		model timeStamp isEmptyOrNil ifFalse: [
			s nextPutAll: '(* time stamp: ';
				nextPutAll: model timeStamp;
				nextPutAll: ' *)'; cr].
		s nextPutAll: source]
)
variableBindingKeys ^ <Collection[Symbol]> = (
	^{}
))
class MethodDifferencePresenter onSubject: theSubject <MethodDifferenceSubject> = ProgrammingPresenter onSubject: theSubject (|
	protected frameColorLeft = frameColor.
	protected frameColorRight = frameColor.
	mydefinition
	theToggle
|)
('as yet unclassified'
collapseMethodDifferences = (
	theToggle collapse
)
definition = (
	theToggle:: heading: [headingDefinition] detailsExpanded: [details].
	^holder: [
		(row: {
			theToggle width: 0 elasticity: 1.
			blank: 13 color: frameColorRight
		}) color: frameColorLeft
	]
)
details = (
	 ^column: {
			row: {
				(vblank: 13 color: frameColorLeft) width: 0 elasticity: 1.
				blank: 13 color: backgroundColor.
				(vblank: 13 color: frameColorRight) width: 0 elasticity: 1.
			}.
			subject changes presenter frameColorRight: frameColorRight.
			row: {
				(vblank: 13 color: frameColorLeft) width: 0 elasticity: 1.
				blank: 13 color: backgroundColor.
				(vblank: 13 color: frameColorRight) width: 0 elasticity: 1.
			}.
			display: (subject sideA ifNil: [nothing] ifNotNil: [ :s | s presenter color: frameColorLeft]) color: frameColorLeft fcolor: frameColorLeft
			nextTo: (subject sideB ifNil: [nothing] ifNotNil: [ :s | s presenter color: frameColorRight]) color: frameColorRight fcolor: frameColorRight.
			row: {
				(vblank: 13 color: frameColorLeft) width: 0 elasticity: 1.
				blank: 13 color: backgroundColor.
				(vblank: 13 color: frameColorRight) width: 0 elasticity: 1.
			}
		}
)
hasPendingChanges = (
	^false
)
headingDefinition = (
	^row: {
		(minorHeadingBlock: (row: {label: subject title asText allBold. filler. link: 'select' action: [respondToSelectLeft]})) width: 0 elasticity: 1; color: frameColorLeft.
		blank: 13 color: frameColorLeft.
		blank: 13 color: backgroundColor.
		blank: 13 color: frameColorRight.
		(minorHeadingBlock: (row: {label: subject title asText allBold. filler. link: 'select' action: [respondToSelectRight]})) width: 0 elasticity: 1; color: frameColorRight.
	}
)
respondToSelectLeft = (
	frameColorLeft:: Color white.
	frameColorRight:: frameColor.
	self refresh.
	sendUp deliveryOptional choseSideAOf: subject model.
)
respondToSelectRight = (
	frameColorLeft:: frameColor.
	frameColorRight:: Color white.
	self refresh.
	sendUp deliveryOptional choseSideBOf: subject model.
))
class MethodDifferenceSubject on: patchOp <MCPatchOperation> in: cds <ClassDifferenceSubject> = Subject onModel: patchOp (|
	classDifference = cds.
	|assert true: [patchOp isMethodPatch])
('as yet unclassified'
changes = (
	^SideBySideDiffSubject a: sourceA b: sourceB
)
createPresenter = (
	^MethodDifferencePresenter onSubject: self
)
sideA = (
	model isAddition ifTrue: [^nil].
	model isModification ifTrue: [^MethodDifferencePartSubject onModel: model obsoletion language: classDifference oldLanguage].
	^MethodDifferencePartSubject onModel: model definition language: classDifference language
)
sideB = (
	model isRemoval ifTrue: [^nil].
	^MethodDifferencePartSubject onModel: model definition language: classDifference language
)
sourceA = (
	^sideA ifNotNil: [ :a | a sourceAndMetadata]
)
sourceB = (
	^sideB ifNotNil: [ :b | b sourceAndMetadata]
)
title = (
	| def |
	def:: model definition.
	^def className asString, (def classIsMeta ifTrue: [' class'] ifFalse: ['']), '>>', def selector
))
class OrganizationDefinitionSubject onModel: op <MCPatchOperation> = PatchOperationSubject protectedOnModel: op ()
(
class PatchPresenter onSubject: subj <PatchOperationSubject> = ProgrammingPresenter onSubject: subj ()
('as yet unclassified'
definition = (
	^(column: {
		minorHeadingBlock: (label: 'Organization changes' asText allBold).
		subject changes presenter.
	}) "color: (Color yellow)"
)))
class PatchOperationSubject protectedOnModel: op <MCPatchOperation> = Subject onModel: op ()
(
class PatchPresenter onSubject: subj <PatchOperationSubject> = ProgrammingPresenter onSubject: subj ()
('as yet unclassified'
definition = (
	^subject changes presenter
))'as yet unclassified'
changes = (
	^SideBySideDiffSubject a: sourceA b: sourceB
)
createPresenter = (
	^PatchPresenter onSubject: self
)
sideA ^<MCDefinition | nil> = (
	model isAddition ifTrue: [^nil].
	^model isModification
		ifTrue: [model obsoletion]
		ifFalse: [model definition]
)
sideB ^<MCDefinition | nil> = (
	model isRemoval ifTrue: [^nil].
	^model definition
)
sourceA = (
	| def |
	def:: sideA.
	^nil = def ifTrue: [nil] ifFalse: [def source]
)
sourceB = (
	| def |
	def:: sideB.
	^nil = def ifTrue: [nil] ifFalse: [def source]
)
title = (
	^model summary
)) : ('as yet unclassified'
on: op <MCPatchOperation> ^<PatchOperationSubject> = (
	op isMethodPatch ifTrue: [^MethodDifferenceSubject on: op "in: ? "].
	"The above is a type error. But what do we do to fix it?"
	op isClassPatch ifTrue: [^ClassDefinitionDifferenceSubject onModel: op].
	op definition isOrganizationDefinition ifTrue: [^OrganizationDefinitionSubject onModel: op].
	^protectedOnModel: op
)
onModel: op <MCPatchOperation> ^ <OrganizationDefinitionSubject | ClassDefinitionDifferenceSubject | MethodDifferenceSubject | PatchOperationSubject> = (
	op isMethodPatch ifTrue: [^MethodDifferenceSubject on: op "in: ? "].
	"The above is a type error. But what do we do to fix it?"
	op isClassPatch ifTrue: [^ClassDefinitionDifferenceSubject onModel: op].
	op definition isOrganizationDefinition ifTrue: [^OrganizationDefinitionSubject onModel: op].
	^protectedOnModel: op
))
class SideBySideDiffPresenter onSubject: theSubject <SideBySideDiffSubject> = Presenter onSubject: theSubject (|
	protected frameColorRight = Color transparent.
|)
('as yet unclassified'
colorFor: a and: b = (
	(a = b) ifTrue: [^Color transparent].
	a isNil ifTrue: [^Color paleGreen].
	b isNil ifTrue: [^Color paleRed].
	^Color paleYellow.
)
definition = (
	| col |
	col:: OrderedCollection new.
	subject changesInA with: subject changesInB do:
		[:a :b | | textA textB color |
		color:: colorFor: a and: b.
		textA:: Text streamContents:
			[:as |
			textB:: Text streamContents:
				[:bs |
				textFor: a with: as and: b with: bs]].
		col add: (display: (textDisplay: textA) nextTo: (textDisplay: textB) color: color)].
	^column: col
)
display: a nextTo: b color: color = (
	^display: a color: color fcolor: Color transparent nextTo: b color: (color = Color transparent ifTrue: [frameColorRight] ifFalse: [color]) fcolor: frameColorRight
)
textFor: a with: as <WriteStream> and: b with: bs <WriteStream> = (
	| patchSequence |
	(a = b or: [a isNil or: [b isNil]]) ifTrue: [
		as nextPutAll: (a ifNil: [' ']).
		bs nextPutAll: (b ifNil: [' ']).
		^self].
	patchSequence: (WordDiffBuilder from: a to: b) buildPatchSequence.
	patchSequence do:
		[:patch |
		#match = patch key ifTrue: [
			as nextPutAll: patch value.
			bs nextPutAll: patch value].
		#remove = patch key ifTrue: [
			as withAttributes: {TextColor red} do: [
				as nextPutAll: patch value]].
		#insert = patch key ifTrue: [
			bs withAttributes: {TextColor red} do: [
				bs nextPutAll: patch value]]]
))
class SideBySideDiffSubject a: valueForA <String> b: valueForB <String> = Subject onModel: nil (|
	a = valueForA.
	b = valueForB.
	titleA ::= 'version A'.
	titleB ::= 'version B'.
	private myChangesInA
	private myChangesInB
|)
('as yet unclassified'
calculateChanges = (
	| patchSequence sourceA sourceB sideAChanges sideBChanges |
	sourceA:: nil = a ifTrue: [' '] ifFalse: [a].
	sourceB:: nil = b ifTrue: [' '] ifFalse: [b].
	(nil = a or: [nil = b]) ifTrue: [
		myChangesInA:: {a ifNotNil: [:it | it asText]}.
		myChangesInB:: {b ifNotNil: [:it | it asText]}.
		^self].
	patchSequence:: (TextDiffBuilder from: sourceA to: sourceB) buildPatchSequence.
	sideAChanges:: Array streamContents: [ :as | sideBChanges:: Array streamContents: [ :bs |
		patchSequence do: [ :ea |
			[#match = ea key and: [as position < bs position]] whileTrue: [as nextPut: nil].
			[#match = ea key and: [bs position < as position]] whileTrue: [bs nextPut: nil].
			#match = ea key ifTrue: [as nextPut: ea value. bs nextPut: ea value].
			#remove = ea key ifTrue: [as nextPut: ea value].
			#insert = ea key ifTrue: [bs nextPut: ea value]].
		[as position < bs position] whileTrue: [as nextPut: nil].
		[bs position < as position] whileTrue: [bs nextPut: nil]]].
	myChangesInA:: sideAChanges.
	myChangesInB:: sideBChanges.
)
changesInA = (
	nil = myChangesInA ifTrue: [calculateChanges].
	^myChangesInA
)
changesInB = (
	nil = myChangesInB ifTrue: [calculateChanges].
	^myChangesInB
)
createPresenter = (
	^SideBySideDiffPresenter onSubject: self
)
title = (
	^titleA, ' compared to ', titleB
))
class WordDiffBuilder from: a to: b = TextDiffBuilder (|
|super from: a to: b)
('as yet unclassified'
split: string = (
	| separators previousSeparator |
	separators:: Array streamContents:
		[:s |
		string withIndexDo:
			[:each :i |
			(separatorCharacters includes: each)
				ifTrue: [s nextPut: i]]].
	separators isEmpty ifTrue: [^{string}].
	previousSeparator:: 0.
	^Array streamContents:
		[:s | | rest |
		separators do: [ :separator | | separatorChar |
			(separator - 1) <= previousSeparator ifFalse: [
				s nextPut: (string copyFrom: previousSeparator + 1 to: separator - 1)].
			separatorChar:: string at: separator.
			separatorChar = Character tab
				ifTrue: [s nextPut: tabString]
				ifFalse: [
					 separatorChar = Character space
						ifTrue: [s nextPut: spaceString]
						ifFalse: [s nextPut: separatorChar asString]].
			previousSeparator:: separator].
		rest:: string allButFirst: previousSeparator.
		rest isEmpty ifFalse: [s nextPut: rest].
		s nextPut: eolString]
))'as yet unclassified'
blank: size color: color = (
	^(ColumnComposer definitions: {RowComposer definitions: {BlankFragment size: size}}) color: color
)
display: a color: aColor fcolor: afColor nextTo: b color: bColor fcolor: bfColor = (
	^RowComposer definitions: {
		(ColumnComposer definitions: {RowComposer definitions: {((ColumnComposer definitions: {RowComposer definitions: {a width: 0 elasticity: 1}}) width: 0 elasticity: 1) color: aColor. BlankFragment size: 13}}) width: 0 elasticity: 1; color: afColor.
		(ColumnComposer definitions: {RowComposer definitions: {BlankFragment size: 13}}) color: backgroundColor.
		(ColumnComposer definitions: {RowComposer definitions: {BlankFragment size: 13. ((ColumnComposer definitions: {RowComposer definitions: {b width: 0 elasticity: 1}}) width: 0 elasticity: 1) color: bColor}}) width: 0 elasticity: 1; color: bfColor.
	}
)
display: a color: aColor nextTo: b color: bColor = (
	^display: a color: aColor fcolor: Color transparent nextTo: b color: bColor fcolor: Color transparent
)
display: a nextTo: b = (
	^display: a nextTo: b color: Color transparent
)
display: a nextTo: b color: color = (
	^display: a color: color nextTo: b color: color
)
hideWhitespace = (
	tabString:: Character tab asString.
	eolString:: ''.
	spaceString:: Character space asString.
)
showWhitespace = (
	tabString:: String withAll: {(Character value: 183). Character tab}.
	eolString:: (Character value: 182) asString.
	spaceString:: (Character value: 183) asString.
)
vblank: size color: color = (
	^(RowComposer definitions: {ColumnComposer definitions: {BlankFragment size: size}}) color: color
))
class Listener = Presenter onSubject: nil (|
	statusHolder
	messages = OrderedCollection new.
	percentComplete_slot
|)
('as yet unclassified'
addMessage: message = (
	messages add: message.
	updateStatus.
)
definition = (
	statusHolder:: holder: [(label: '')].
	^statusHolder
)
percentComplete: v <Number> = (
	percentComplete_slot: v.
	updateStatus.
)
removeLastMessage = (
	messages isEmpty
		ifFalse: [messages removeLast].
	updateStatus.
)
showMessage: message = (
	messages removeAllSuchThat: [:each | true].
	addMessage: message.
)
statusContent = (
	| bar |
	bar:: percentComplete_slot ifNotNil:
		[:it |
		{(column: {row: {blank: it asInteger}}) color: (Color h: 240 s: 0.3 v: 0.5).
		(column: {row: {blank: 100 - it asInteger}}) color: Color white.
		blank: 10}].
	^row: (bar ifNil: [{}]), (messages collect: [:each | (label: each, ' ')])
)
updateStatus = (
	messages isEmpty
		ifTrue: [percentComplete_slot:: nil].
	statusHolder content: statusContent
))
class MCSvnVersionInfoPresenter onSubject: theSubject <MCSvnVersionInfoSubject> = ProgrammingPresenter onSubject: theSubject ()
('as yet unclassified'
briefDefinition = (
	^column: {
		headerDefinition.
		logMessageFirstLineDefinition.
	}
)
changesMenu = (
	^menuWithLabelsAndActions:
		{
			('Changes I have made since ', subject shortTitle)
				-> [respondToChangesInImage].
			(subject shortTitle, ' compared to most recent version on server')
				-> [respondToChangesOnServer].
			(subject shortTitle, ' compared to ', subject ancestors first shortTitle)
				-> [respondToAncestorChanges].
			('Pick a version and compare it to ', subject shortTitle)
				-> [respondToPickChanges].
		}
)
definition = (
	^collapsed: [briefDefinition] expanded: [detailDefinition]
)
detailDefinition = (
	^column: {
		headerDefinition.
		logMessageFullDefinition.
		finePrint.
		"
		row: {label: 'Ancestors: ' asText allBold. label: subject model ancestors printString}.
		row: {label: 'Step children: ' asText allBold. label: subject model stepChildren printString}.
		row: {label: 'ID: ' asText allBold. label: subject model id printString}.
		row: {label: 'Name: ' asText allBold. label: subject model name}.
		row: {label: 'Message: ' asText allBold. label: subject model message}.
		row: {label: 'Date: ' asText allBold. label: subject model date printString}.
		row: {label: 'Time: ' asText allBold. label: subject model time printString}.
		row: {label: 'Author: ' asText allBold. label: subject model author}.
		row: {label: 'Package: ' asText allBold. label: subject model package name}.
		row: {label: 'Revision: ' asText allBold. label: subject model revision printString}.
		"
		smallBlank.
		list: [subject ancestors collect: [:ea | ea presenter]].
		smallBlank.
	}
)
finePrint = (
	^row: {
		(label: subject model author) tinyFont.
		(label: '@') tinyFont.
		(label: subject model time print24) tinyFont.
		smallBlank.
		(label: subject model date yyyymmdd) tinyFont.
		smallBlank.
		(label: '[') tinyFont.
		(label: 'r', subject model revision printString) tinyFont.
		(label: ', ') tinyFont.
		(label: subject model id printString) tinyFont.
		(label: ']') tinyFont.
	}
)
headerDefinition = (

	^elastic:: row: {
		label:: subject shortTitle asText allBold.
		mediumBlank.
		(link: 'changes' action: [respondToChanges]) tinyFont.
		dropDownMenu: [changesMenu].
		filler.
		dropDownMenu: [menuWithLabelsAndActions: {
			('Revert to ',  subject model name) -> [respondToRevert].
			('Adopt ',  subject model name) -> [respondToAdopt].
			('Copy comment to clipboard') -> [respondToCopyToClipboard].
			}].
		}.
)
logMessageFirstLineDefinition = (
	^(label: (subject model message readStream nextLine ifNil: [^nil]))
		smallFont color: Color gray
)
logMessageFullDefinition = (
	^(textDisplay: subject model message) smallFont
)
respondToAdopt = (
	confirm: 'Confirm adopt ', subject model name
		ifConfirmed: [sendUp respondToAdopt: subject]
)
respondToAncestorChanges = (
	notYetImplemented.
)
respondToChanges = (
	sendUp respondToChangesFor: subject
)
respondToChangesInImage = (
	notYetImplemented.
)
respondToChangesOnServer = (
	notYetImplemented.
)
respondToCopyToClipboard = (
	copyToClipboard: subject model message
)
respondToPickChanges = (
	enterSubject: subject versionPickerSubject
)
respondToRevert = (
	sendUp respondToRevertTo: subject
))
class MCWorkingCopyPresenter onSubject: theSubject <MCWorkingCopySubject> = ProgrammingPresenter onSubject: theSubject (|
	changesNotification
	messagesContainer
	inspectionHolder
|)
('as yet unclassified'
allVersionsDefinition = (
	^heading: [label: 'All Versions (Anchors) on Server']
	details: [
			list: (subject repositoryVersions collect: [:ea | ea presenter]), 				{smallBlank}]
)
ancestryDefinition = (
	^list: (subject ancestors collect: [:ea | ea presenter])
)
authorDefinition = (
	^subject author isEmptyOrNil
		ifTrue: [label:'']
		ifFalse: [label: subject author, ': ']
)
briefDefinition = (
	^column: {
		row: (presentTitle, presentLoadOrMerge, presentSave, presentChanges, presentInspector, presentRevert).
		row: {
			authorDefinition smallFont color: Color gray.
			logMessageFirstLineDefinition
		}
	}

)
changesMenu = (
	^menuWithLabelsAndActions:
		{
			('Changes I have made since ', subject versionSummaryString)
				-> [respondToImageChanges].
			(subject versionSummaryString, ' compared to most recent version on server')
				-> [respondToServerChanges].
		}
)
checking = (
	showMessage: 'checking...'
)
definition = (
	messagesContainer:: OrderedCollection new.
	^column: {
		row: {
			presentAge width: 45.
			elastic: (collapsed: [briefDefinition] expanded: [detailDefinition]).
		}.
		smallBlank.
	}
)
detailDefinition = (
	^column: {
		row: (presentTitle, presentLoadOrMerge, presentSave, presentChanges, presentInspector, presentRevert).
		logMessageFullDefinition.
		smallBlank.
		ancestryDefinition.
		smallBlank.
		newVersionsDefinition.
		obsoleteVersionsDefinition.
		allVersionsDefinition.
	}
)
hasPendingChanges = (
	^false
)
logMessageFirstLineDefinition = (
	^(label: (subject logMessage readStream nextLine ifNil: [^nil]))
		smallFont color: Color gray
)
logMessageFullDefinition = (
	| author |
	author:: subject author isEmptyOrNil
		ifTrue: ['']
		ifFalse: [subject author, ': '].
	^(textDisplay: author, subject logMessage) smallFont
)
newVersionsDefinition = (
	^heading: [label: 'Newer Histories on Server']
		details: [list: 
			(subject tips
				select: [ :tip | subject isOlderThan: tip]
				thenCollect: [ :ea | ea presenter]),
			{smallBlank}]
)
noChanges = (
	showMessage: ' no changes '
)
obsoleteVersionsDefinition = (
	^heading: [label: 'Obsolete Histories']
		details: [list:
			(subject tips
				select: [ :tip | tip isSupersededBy: subject]
				thenCollect: [ :ea | ea createPresenter]),
			{smallBlank}]
)
percentComplete: v <Number> = (
)
presentAge = (
	subject isRecent ifTrue: [
		^(link: '[active]' action: [confirm: 'New version published to server within the last week.' ifConfirmed:[]]) tinyFont color: Color gray
		].
	subject isOld ifTrue: [
		^(link: '[dormant]' action: [confirm: 'Latest published version is more than 30 days old.' ifConfirmed:[]]) tinyFont color: Color gray
		].
	^label: ''
)
presentChanges = (
	changesNotification:: holder: [(label: '') tinyFont].
	^{
		blank: 10. 
		(link: 'changes' action: [respondToChanges]) tinyFont.
		dropDownMenu: [changesMenu].
		blank: 10.
		changesNotification
	}
)
presentInspector = (
	inspectionHolder:: holder: [nothing].
	^{filler. inspectionHolder}
)
presentLoadOrMerge = (
	subject isUpdated ifFalse: [^{}].
	^subject isModified
		ifTrue: [{blank: 10. (link: 'merge' action: [respondToMerge]) tinyFont}]
		ifFalse: [{blank: 10. (link: 'load' action: [respondToLoad]) tinyFont}]
)
presentRevert = (
	^{smallBlank. dropDownMenu: [revertMenu]}
)
presentSave = (
	subject isModified ifFalse: [^{}].
	^{blank: 10. (link: 'publish' action: [respondToSave]) tinyFont}
)
presentTitle = (
	| age lbl |
	lbl:: (link: subject title asText allBold action: [respondToBrowse]) color: Color black.
	(subject isModified and: [subject isUpdated])
		ifTrue: [lbl color: Color red].
	^{lbl}
)
respondToAdopt: version <MCSvnVersionInfoSubject> = (
	showWaitCursorWhile: [subject adopt: version]
)
respondToBrowse = (
	browsePackage: subject model package name
)
respondToChanges = (
	checking.
	doInBackground: [subject changes] notifying: self
		whenDone: [ :changes |
			nil = changes
				ifTrue: [noChanges]
				ifFalse: [enterSubject: changes]]
)
respondToChangesFor: version <MCSvnVersionInfoSubject> = (
	| changes |
	checking.
	changes:: subject changesIn: version.
	nil = changes
		ifTrue: [noChanges]
		ifFalse: [enterSubject: changes]
)
respondToCopyComment = (
	copyToClipboard: subject logMessage
)
respondToImageChanges = (
	| changes |
	checking.
	changes:: subject compareToInstalledVersion.
	nil = changes
		ifTrue: [noChanges]
		ifFalse: [enterSubject: changes]
)
respondToLoad = (
	| nukeBrazil wasUpdate |
	wasUpdate:: subject isUpdated.
	nukeBrazil:: false.
	shiftWasPressed ifTrue:
		[nukeBrazil:: (MessageBox new yesNo: 'Close all Brazil windows?'; open) = #yes].
	nukeBrazil ifTrue:
		[updatesChannel detachAll.
		showWaitCursorWhile: [subject load: true].
		^self].
	showMessage: 'loading... '.
	doInBackground: [fullySuppressUpdatesDuring: [showWaitCursorWhile: [subject load: false]]] notifying: self whenDone:
		[wasUpdate
			ifTrue: [sendUp optional loadedPackage: self]
			ifFalse: [browsePackage: subject model packageName]]
)
respondToMerge = (
	| v merger |
	showMessage: 'merging...'.
	doInBackground:
		[[[v:: subject serverVersion.
		merger:: Monticello MCVersionMerger new.
		merger addVersion: v;
			mergeWithNameLike: v info name.
		'merged'] on: MCNoChangesException do:
			['no changes']] on: MCMergeResolutionRequest do:
				[:req | respondToResolveConflicts: req versionMerger: merger version: v. 'conflicts']]
	notifying: self
	whenDone: [:result | showMessage: result]
)
respondToMoveToNspackages = (
	| package newLocation |
	package:: subject svnVersionInfo.
	newLocation:: '/nspackages/', package name.
	package currentPath ifNil: [
		^showMessage: 'Cannot determine current location'].
	package currentPath = newLocation ifTrue: [
		^showMessage: 'Already in /nspackages'].
	showMessage: 'Moving... '.
	showWaitCursorWhile: [
		subject repository workingCopy
			move: package currentPath
			to: newLocation
			message: 'Moved ', package name, ' to /nspackages'.
			addMessage: 'done!'].
	sendUp refreshSubjectInBackground
)
respondToRemove = (
	| response |
	response:: MessageBox new
		title: 'Remove "', subject title, '" Package';
		message: 'Do you want to remove the classes (and extension methods) in "', subject title, '" from the image, or do you want to keep them?';
		buttonLabels:
			{'Cancel'.
		 	'Keep Classes'.
			'Remove Classes'}
			selections: {#cancel. #keepClasses. #removeClasses};
		open.
	#keepClasses = response ifTrue: [^respondToRemovePackageButKeepClasses].
	#removeClasses = response ifTrue: [^respondToRemovePackageAndDeleteClasses].
)
respondToRemovePackageAndDeleteClasses = (
	showWaitCursorWhile: [subject removePackageAndDeleteClasses]
)
respondToRemovePackageButKeepClasses = (
	showWaitCursorWhile: [subject removePackageButKeepClasses]
)
respondToResolveConflicts: req <MCMergeResolutionRequest> versionMerger: versionMerger <MCVersionMerger> version: version = (
	schedule: visual action:
		[enterSubject:: (differences MergeSubject onModel: req merger)
			title: req messageText;
			versionMerger: versionMerger;
			version: version]
)
respondToRevertTo: version <MCSvnVersionInfoSubject> = (
	showWaitCursorWhile: [subject revertTo: version]
)
respondToSave = (
	enterSubject: subject save
	"showWaitCursorWhile:
		[respondToChanges.
		subject save.
		sendUp monticelloSubpresenterRequestsRefresh]"
)
respondToServerChanges = (
	| changes newer older |
	newer:: subject serverVersion.
	older:: subject model ancestors first.
	checking.

	changes:: subject changesFrom: [subject versionWithInfo:older] title: older name
				to: [newer] title: newer info name
				ifEmpty: [^noChanges].
	nil = changes
		ifTrue: [noChanges]
		ifFalse: [enterSubject: changes]

)
revertItemResponderFor: item <Association[String,[]]>= (
	^item key -> [showWaitCursorWhile: [item value value]]
)
revertMenu = (
	^menuWithLabelsAndActions:
		(subject revertItems collect: [ :item | revertItemResponderFor: item]),
		{
			'Copy Comment to Clipboard' -> [respondToCopyComment].
			('Remove ', title) -> [respondToRemove].
			'Move to /nspackages' -> [respondToMoveToNspackages].
		}
)'messages container'
addMessage: msg <String> = (
	messagesContainer add: msg.
	updateNotificationArea
)
removeLastMessage = (
	messagesContainer isEmpty
		ifFalse: [messagesContainer removeLast].
	updateNotificationArea
)
showMessage: msg <String> = (
	messagesContainer removeAllSuchThat: [:each | true].
	addMessage: msg
)
updateNotificationArea = (
	changesNotification content:
		(row: (messagesContainer collect: [:each | (label: each, ' ') tinyFont]))
))
class MonticelloLoader = MCVersionLoader (|
	ignoreModifications ::= true.
|)
('as yet unclassified'
checkForModifications = (
	ignoreModifications ifFalse: [super checkForModifications]
))
class MonticelloPresenter onSubject: theSubject <MonticelloSubject> = ProgrammingPresenter onSubject: theSubject (|
	newPackages
	protected uninstalledList
	protected otherList
	protected legacyList
	status
	loadAllStatus
	deferredContent
	modifiedList
	updatedList
	helpHolder
	inspectionHolder
|)
(
class BootLogEntryPresenter onSubject: theSubject = Presenter onSubject: theSubject (|
	
|)
('as yet unclassified'
definition = (
	^self
		heading: [link: subject message action: [respondToDownload]]
		details: [list: [subject images collect: [ :n | link: (n reverse readStream upTo: $/) reverse action: [respondToDownload: n] fixTemps]]]
)
respondToDownload = (
	respondToDownload: (subject images reject: [:ea | (ea includesSubString: '/nsboot-') or: [ea includesSubString: '/experimental-']]) anyOne
)
respondToDownload: imageName = (
	| imageUrl shortName response |
	imageUrl:: distributionRepository repositoryUrl, imageName.
	shortName:: (imageName reverse readStream upTo: $/) reverse.
	response:: (requestModule NewFile new initialDirectory: FileDirectory default fullName; initialFile: shortName) openModal.
	nil = response ifTrue: [^self].
	imageUrl:: imageUrl allButLast: '.image' size.
	(response endsWith: '.image') ifTrue: [
		response:: response allButLast: '.image' size].
	showWaitCursorWhile:
		[
		{'.changes'. '.image'} do: [ :extension |
			distributionRepository nsSvnRepository export: imageUrl, extension to: response, extension].
			NsToolSet saveInterestingState.
			NsToolSet launchImageNamed: response, '.image']
))
class BootLogEntrySubject onModel: entry = Subject onModel: entry ()
('as yet unclassified'
createPresenter = (
	^BootLogEntryPresenter onModel: self
)
images = (
	^model paths select: [ :p | p path endsWith: '.image'] thenCollect: [ :p | p path]
)
message = (
	^model message
))
class DownloadImagePresenter onSubject: theSubject = Presenter onSubject: theSubject ()
('as yet unclassified'
definition = (
	^list: [subject nightlyBootLogEntries collect: [:ea | ea presenter]]
))
class DownloadImageSubject onModel: rep = Subject onModel: rep ()
('as yet unclassified'
createPresenter = (
	^DownloadImagePresenter onSubject: self
)
nightlyBootLogEntries = (
	| entries |
	entries:: model logEntries select: [:ea |
		(ea paths select: [ :p |
			(p path beginsWith: '/bootstrap/nightly/') and: [p path endsWith: '.image']]) isEmpty not].
	^entries reverse collect: [:ea  | BootLogEntrySubject onModel: ea]
)
title = (
	^'Download Image'
))
class MyRepositoryPresenter onSubject: theSubject = ProgrammingPresenter onSubject: theSubject (|
	definitions
	actualDefinitionsSlot
	inspectionHolder
|)
('as yet unclassified'
actualDefinitions = (
	^actualDefinitionsSlot
)
actualDefinitions: defs = (
	actualDefinitionsSlot:: defs.
	definitions setPresenters: actualDefinitionsSlot.
)
clearErrors = (
	definitions setPresenters: actualDefinitions
)
definition = (
	definitions:: list.
	refreshDefinition.
	^definitions
)
notifyError: message = (
	| errors |
	errors:: (message findTokens: Character cr) collect:
		[:line | (label: line) color: Color red].
	definitions setPresenters:
		actualDefinitions,
		errors,
		{blank: 10}
)
presentAdvancedConfiguration = (
	^column: {
		presentAdvancedDocumentation.
		OneLineDefinitionTemplate new
			caption: 'Enter URL: ';
			initialText: subject directoryUrlString;
			acceptResponse:
				[:t | respondToOpenUrl: t text asString withBlanksTrimmed]
	}
)
presentAdvancedDocumentation = (
	^textDisplay: 'Use a non-local Subversion repository by entering the URL below. This repository must already be configured with the same initial layout as one created by clicking on the "Create new repository" button. Most users can ignore this option.'
)
presentConfigure = (
	inspectionHolder:: holder: [nothing].
	^{
		row: {
			(label: 'Configure My Repository' asText allBold) largeFont.
			smallBlank.
			column: {filler. inspectionHolder. filler}.
		}.
		presentDocumentation.
		row: {
			button: 'Browse for repository' action: [respondToBrowse].
			blank: 10.
			button: 'Create new repository' action: [respondToCreate].
		}.
		blank: 10.
		heading: [label: 'Advanced'] details: [presentAdvancedConfiguration].
		blank: 10.
	}
)
presentDocumentation = (
	^textDisplay:
'My Repository is a place where you can keep your own classes under Subversion source code control.
	To get started, you should create a new repository. If you already have a repository, you can browse for it.'
)
presentNoUserRepository = (
	inspectionHolder:: holder: [nothing].
	^{
		row: {
			button: 'Configure My Repository' action: [respondToConfigure].
			smallBlank.
			column: {filler. inspectionHolder. filler}.
		}.
		blank: 10.
	}
)
presentStatus = (
	inspectionHolder:: holder: [nothing].
	^{
		row: {
			(label: 'My Repository: ', subject userRepository repositoryUrl, ' ') tinyFont.
			filler.
			inspectionHolder.
		}
	}
)
refreshDefinition = (
	actualDefinitions:: subject hasUserRepository
		ifTrue: [presentStatus]
		ifFalse: [presentNoUserRepository]
)
requestDirectoryIfAborted: abortAction = (
	| selectedFile |
	selectedFile:: request directory
		openModal.
	selectedFile
		ifNil: [abortAction value]
		ifNotNil: [subject directory: (FileDirectory on: selectedFile)]
)
requestNewDirectoryIfAborted: abortAction = (
	| selectedFile |
	selectedFile:: request newFile
		initialDirectory: subject directory containingDirectory fullName;
		initialFile: subject directory localName;
		openModal.
	selectedFile
		ifNil: [abortAction value]
		ifNotNil: [subject directory: (FileDirectory on: selectedFile)]
)
respondToBrowse = (
	clearErrors.
	requestDirectoryIfAborted: [^self].
	subject openRepositoryIfError: [:msg | ^notifyError: msg].
	shell refresh.
)
respondToConfigure = (
	^actualDefinitions: presentConfigure
)
respondToCreate = (
	clearErrors.
	requestNewDirectoryIfAborted: [^self].
	subject createRepositoryIfError: [:msg | ^notifyError: msg].
	shell refresh.
)
respondToOpenUrl: url = (
	clearErrors.
	subject openRepositoryUrl: url ifError: [:msg | ^notifyError: msg].
	shell refresh.
))
class MyRepositorySubject onModel: theSubject <MonticelloSubject> = Subject onModel: theSubject (|
	directory ::= FileDirectory default directoryNamed: 'My Repository'.
|)
('as yet unclassified'
createPresenter = (
	^MyRepositoryPresenter onSubject: self
)
createRepositoryIfError: errorAction = (
	distributionRepository
		createRepository: directory
		ifError: [:msg | errorAction value: msg].
	openRepositoryUrl: directoryUrlString ifError: errorAction
)
directoryUrlString ^<String> = (
	^directory asUrl asString copyReplaceAll: '%20' with: ' '
)
hasUserRepository = (
	^model repositories size > 1
)
openRepositoryIfError: errorAction = (
	openRepositoryUrl: directoryUrlString ifError: errorAction
)
openRepositoryUrl: url ifError: errorAction = (
	distributionRepository addRepository: url ifError: errorAction
)
userRepository = (
	^hasUserRepository ifTrue: [model userRepository]
))'as yet unclassified'
= other = (
	^class == other class
)
advancedMenu = (
	^menuWithLabelsAndActions: {
		'Monticello Browser' -> [NsToolSet openMonticelloBrowser].
		#separator.
		'Flush Monticello''s Cache' -> [NsToolSet resetMonticello].
		#separator.
		'Reset Source Control UI' -> [respondToResetUi].
	}
)
createClassFromTemplate: template <DefinitionTemplate> = (
	| clsName |
	clsName:: template text asString withBlanksTrimmed.
	(reflection isValidTopLevelName: clsName)
		ifFalse: [^template editor showMessage: 'Illegal name'].
	Smalltalk at: clsName asSymbol ifPresent:
		[:cls | ^template editor showMessage: 'Class already exists'].
	(MCPackage named: clsName) hasWorkingCopy ifTrue:
		[^template editor showMessage: 'Package already exists'].
	(Smalltalk organization categories includes: clsName) ifTrue: 
		[^template editor showMessage: 'Category already exists'].
	suppressUpdatesDuring:
		[majorUpdate:
			[newPackages remove: template.
			subject createNewPackageNamed: clsName.
			subject createNewNsClassNamed: clsName usingReflection: reflection.
			browseClassNamed: clsName asSymbol]]
)
createPackageFromTemplate: template <DefinitionTemplate> = (
	suppressUpdatesDuring:
		[majorUpdate:
			[newPackages remove: template.
			subject createNewPackageNamed: template text asString withBlanksTrimmed]].
)
definition = (
	newPackages:: list.
	helpHolder:: list.
	status:: holder: [(label: 'refreshing...') tinyFont].
	deferredContent:: holder: [(label: '') tinyFont].
	refreshSubjectInBackground.
	^column: {
		helpHolder.
		list: [presentLoadImageIfOld].
		(MyRepositorySubject onModel: subject) presenter.
		"heading: [label: 'Documentation'] details: [presentDocumentation]."
		blank: 10.
		deferredContent.
	}
)
distributionRepository = (
	^subject repositories first
)
hasPendingChanges = (
	^false
)
hash = (
	^class hash
)
isTransient = (
	^false
)
labelTextForAgeInMinutes: ageInMinutes = (
	ageInMinutes < 120 ifTrue:
		[^'Package status on server has not been checked for ',
			ageInMinutes printString, 
			' minutes.'].
	^'Package status on server has not been checked for over ',
		(ageInMinutes // 60) printString, 
		' hours.'
)
loadedPackage: package <MCWorkingCopyPresenter> = (
	majorUpdate:
		[remove: package from: modifiedList.
		remove: package from: legacyList.
		remove: package from: uninstalledList.
		remove: package from: updatedList.
		otherList ifNotNil:
			[:it |
			it presenters size > 1 ifTrue: [it addFirst: package]]].
)
noticeImminentExposure = (
	deferredContent isNil ifTrue: [^self].
	deferredContent content: (label: '') tinyFont.
	refreshSubjectInBackground
)
presentDocumentation = (
	^{
		row: {
			filler.
			(link: 'close help' action: [respondToCloseHelp]) tinyFont.
		}.
		textDisplay: 'Source Control provides an overview of what changes you have made and what others have made available.
	This view is centered around packages which are transitory remnants of the underlying Squeak system. Eventually, packages will become unnecessary as they are replaced by Newspeak modules. Incidentally, a package corresponds to a directory in your repository.
	Create a new module (aka top-level class) by clicking the button with a green plus, but not until you have configured "My Repository".'.
	}
)
presentHelp = (
	^(link: '[?]' action: [respondToHelp]) tinyFont
)
presentInspector = (
	inspectionHolder:: holder: [nothing].
	^inspectionHolder
)
presentLegacy = (
	| packages |
	packages:: subject legacyPackages.
	packages ifEmpty: [^{}].
	legacyList:: list.
	legacyList add:
		(link: packages size asString, ' packages. Show them...' action: [respondToShowThem: packages in: legacyList])
			tinyFont.
	legacyList add: mediumBlank.
	^{majorHeadingBlock: (row: {label: 'Legacy' asText allBold}).
	legacyList}
)
presentLoadImageIfOld = (
	| ageInDays advanced |
	advanced:: dropDownMenu: [advancedMenu].
	inspectionHolder:: holder: [nothing].
	^true
		ifTrue: [{row: {status. filler. inspectionHolder. smallBlank. presentHelp. smallBlank. advanced}}]
	"	ifFalse:
			[ageInDays:: NsBoot ageInDays.
			ageInDays < 90 ifTrue:
				[ | link |
				link:: link: 'get latest nightly boot image' action: [respondToDownloadNewImage].
				link tinyFont.
				ageInDays < 1 ifTrue: [link color: Color gray].
				ageInDays > 2 ifTrue: [link color: Color red].
				^{row: {status. filler. link. smallBlank. inspectionHolder. smallBlank. presentHelp. smallBlank. advanced}}].
			{
				row: {status. filler. inspectionHolder. smallBlank. presentHelp. smallBlank. advanced}.
				(column: {
					blank: 50.
					centered: (label: 'This image is more than ' asText, (ageInDays printString, ' days old.') asText allBold).
					largeBlank.
					centered: (button: 'Download New Image' action: [respondToDownloadNewImage]).
					blank: 50
					}
				) color: (Color h:0 s: 0.6 v: 0.9).
				mediumBlank
			}]"
)
presentModified = (
	| packages |
	packages:: subject modifiedPackages collect:
		[ :ea <MCWorkingCopySubject> | ea presenter].
	modifiedList:: list: 
		[packages isEmpty
			ifTrue: [{(label: 'no modifications') tinyFont color: Color gray}]
			ifFalse: [packages]].

	^{
		majorHeadingBlock: ( row: {
			label: 'Modified in Image' asText allBold.
			largeBlank.
			addButtonWithAction: [respondToAddPackage].
			filler.
		}).
		newPackages.
		modifiedList.
	}
)
presentOther = (
	| packages remaining |
	packages:: subject allPackages asOrderedCollection.
	packages removeAllFoundIn: subject modifiedPackages.
	packages removeAllFoundIn: subject packagesNotOnServer.
	packages removeAllFoundIn: subject updatedPackages.
	packages removeAllFoundIn: subject legacyPackages.
	packages ifEmpty: [^{}].
	otherList:: list.
	otherList add:
		(link: packages size asString, ' packages. Show them...' action: [respondToShowThem: packages in: otherList])
			tinyFont.
	otherList add: mediumBlank.
	^{majorHeadingBlock: (label: 'Up to Date' asText allBold).
	otherList}
)
presentUninstalled = (
	| packages |
	packages:: subject uninstalledPackages.
	packages ifEmpty: [^{}].
	uninstalledList:: list.
	uninstalledList add:
		(link: packages size asString, ' packages. Show them...' action: [respondToShowThem: packages in: uninstalledList])
			tinyFont.
	uninstalledList add: mediumBlank.
	^{majorHeadingBlock: (label: 'Not in Image' asText allBold).
	uninstalledList}
)
presentUnpackaged = (
	| packages |
	packages:: subject packagesNotOnServer collect:
		[ :ea <MCWorkingCopySubject> | ea presenter].
	packages ifEmpty: [^{}].
	^{majorHeadingBlock: (label: 'Not Under Source Management' asText allBold).
	list: (packages) }
)
presentUpdated = (
	| packages |
	loadAllStatus:: Listener new.
	packages:: subject updatedPackages collect:
		[ :ea <MCWorkingCopySubject> | ea presenter].
	updatedList:: list: packages.
	packages ifEmpty: [^{}].
	^{
		majorHeadingBlock: (
			row: {
				label: 'Updated on Server' asText allBold.
				blank: 20.
				link: 'load all' action: [respondToLoadAllUpdated].
				blank: 10.
				loadAllStatus.
			}
		).
		updatedList
	}
)
presentersFor: subjects <Collection[Subject]> = (
	^subjects collect: [ :ea <MCWorkingCopySubject> | ea presenter]
)
refreshLater = (
	subject needsRefresh: true.
	self refreshWhenDone:
		[subject needsRefresh
			ifTrue:
				[subject needsRefresh: false.
				subject refresh]]
)
refreshSubject = (
	schedule: visual action: [
		deferredContent content: (label: '') tinyFont].
	subject repositories do: [ :rep | rep addDependent: self].
	showWaitCursorWhile: [
		repositoryContentsCache:: nil.
		subject refresh].
	subject repositories do: [ :rep | rep removeDependent: self].
	schedule: visual action: [
		deferredContent content: slowContentDefinition.
		status content: (label: '') tinyFont]
)
refreshSubjectInBackground = (
	rememberProcess::
		[[refreshSubject] ensure: [forgetActiveProcess]] forkAt: 30 named: 'Refreshing: ', subject title
)
remove: package <MCWorkingCopyPresenter> from: presenters <PresenterList> = (
	presenters ifNotNil: [:it | it remove: package]
)
repository = (
	Error signal: 'Internal error'.
	^nil
)
respondToAddPackage = (
	| template addNewspeakClass |
	addNewspeakClass:: shell shiftWasPressed not.
	template:: OneLineDefinitionTemplate new
		initialText: '';
		cancelResponse: [newPackages remove: template].
	addNewspeakClass
		ifTrue:
			[template
				caption: 'Add new module named: ';
				acceptResponse: [:t | createClassFromTemplate: t]]
		ifFalse:
			[template
				caption: 'Add new package named: ';
				acceptResponse: [:t | createPackageFromTemplate: t]].
	majorUpdate: [newPackages add: template]
)
respondToCloseHelp = (
	helpHolder setPresenters: {}
)
respondToDownloadNewImage = (
	enterSubject:: DownloadImageSubject onModel: distributionRepository
)
respondToHelp = (
	helpHolder setPresenters: presentDocumentation
)
respondToLoadAllUpdated = (
	| nukeBrazil |
	nukeBrazil:: false.
	shiftWasPressed ifTrue:
		[nukeBrazil:: (MessageBox new yesNo: 'Close all Brazil windows?'; open) = #yes].
	nukeBrazil ifTrue: [updatesChannel detachAll].
	loadAllStatus showMessage: 'Loading ', subject updatedPackages size asString, ' packages'.
	doInBackground: [
		subject loadAllUpdated: nukeBrazil ifModified:
			[:msg |
			loadAllStatus showMessage: msg]
		] notifying: loadAllStatus whenDone: [refreshSubjectInBackground]
)
respondToRefreshRepository = (
	subject repositories do: [ :rep | rep addDependent: self].
	showWaitCursorWhile: [
		repositoryContentsCache:: nil.
		subject refresh.
		self refresh.
		status content: (label: '') tinyFont].
	subject repositories do: [ :rep | rep removeDependent: self]
)
respondToResetUi = (
	tearDown.
	enterSubject: HopscotchIDE theSourceManager mainSubject
)
respondToShowThem: packages in: pList <PresenterList> = (
	| presenters |
	presenters:: packages collect: [ :ea <MCWorkingCopySubject> | ea presenter].
	majorUpdate: [pList presenters: presenters]
)
slowContentDefinition = (
	^column: {
		list: [presentModified].
		list: [presentUnpackaged].
		list: [presentUpdated].
		list: [presentUninstalled].
		list: [presentOther].
		list: [presentLegacy]}
)
update: who <MCSvnRepository> with: what <String> = (
	| message |
	message:: ''.
	what = #refresh ifTrue: [message:: 'Reading log entries at ', who repositoryUrl, '...'].
	what = #xml ifTrue: [message:: 'Scanning log entries at ', who repositoryUrl, '...'].
	what = #done ifTrue: [message:: status content text asString, ' done!'].
	what isSymbol ifFalse: [message:: what, ' ', who description].
	schedule: visual action: [status content: (label: message) tinyFont]
))
class MonticelloSubject onModel: packages = Subject onModel: packages (|
	title ::= 'Source Control'.
	protected allModifiedPackages
	protected allPackagesNotOnServer
	protected allUpdatedPackages
	protected allLegacyPackages
	protected allUninstalledPackages
	protected allUnpackagedCategories
	protected updatesOutlet "keeping this alive while I'm alive"
	protected rightNow
	protected sevenDaysAgo
	protected oneMonthAgo
	public needsRefresh
	|setup)
(
class MCSvnVersionInfoSubject onModel:  theSubject <MCSvnVersionInfo> = Subject onModel: theSubject ()
(
class VersionDifferencePickerSubject onModel: theSubject <MCSvnVersionInfoSubject> = Subject onModel: theSubject ()
(
class VersionDifferencePickerPresenter onSubject: theSubject = Presenter onSubject: theSubject ()
('as yet unclassified'
definition = (
	^list: [
		subject workingCopy repositoryVersions collect: [:ea |
			row: {
				(link: 'Compare to ' action: [respondToCompareTo: ea] fixTemps) tinyFont.
				ea presenter
			}
		]
	]
)
respondToCompareTo: v = (
	| changes |
	changes:: workingCopy
		changesFrom: (versionWithInfo: v model) title: v title
		to: subject version title: subject model title
		ifEmpty: [^self].
	enterSubject: changes
))'as yet unclassified'
createPresenter = (
	^VersionDifferencePickerPresenter onSubject: self
)
title = (
	^'Compare ', model title, ' to?'
)
version = (
	^versionWithInfo: model model
)
workingCopy = (
	^allPackages detect: [:ea | ea model package = version package] ifNone: []
))'as yet unclassified'
ancestors = (
	^model ancestors collect: [ :ea | MCSvnVersionInfoSubject onModel: ea]
)
createPresenter = (
	^MCSvnVersionInfoPresenter onSubject: self
)
isSupersededBy: wc <MCWorkingCopySubject> ^<Boolean> = (
	wc model ancestors isEmpty ifTrue: [^false].
	^nil = (wc model ancestors
		detect: [ :ea | model hasAncestor: ea] ifNone: []) 
)
shortTitle = (
	| t |
	t:: title.
	^t allButFirst: (t lastIndexOf: $- ifAbsent: [0])
)
title = (
	^(model name beginsWith: 'Name: ')
		ifTrue: [model name allButFirst: 6]
		ifFalse: [model name]
)
versionPickerSubject = (
	^VersionDifferencePickerSubject onModel: self
))
class MCWorkingCopySubject onModel: wc <MCWorkingCopy> = Subject onModel: wc (|
	protected tips0|)
('as yet unclassified'
= other = (
	^class == other class and: [model = other model]
)
adopt: version <MCSvnVersionInfoSubject> = (
	subscribeToMonticelloChanges.
	model ancestry addAncestor: version model.
	model modified: true.
)
ancestors = (
	^model ancestors collect: [ :ea | MCSvnVersionInfoSubject onModel: ea]
)
author = (
	^(svnVersionInfo ifNil: [^'']) owner asString
)
changes = (
	isModified ifTrue: [^compareToInstalledVersion].
	^isUpdated
		ifTrue: [compareToUpdatesOnServer]
		ifFalse: [compareToInstalledVersion]
)
changesFrom: versionA <[MCVersion | MCPackage]> title: titleA <String> to: versionB <[MCVersion | MCPackage]> title: titleB <String> ifEmpty: emptyAction <[]> = (
	| patch |
	presenter showWaitCursorWhile: [ | snapshotA snapshotB |
		snapshotA:: (versionA value ifNil: [MCSnapshot empty] ifNotNil: [ :v | v snapshot]).
		snapshotB:: (versionB value ifNil: [MCSnapshot empty] ifNotNil: [ :v | v snapshot]).
		patch:: snapshotB patchRelativeToBase: snapshotA].
	nil = patch ifTrue: [^nil]. "TODO: this is probably an error condition, when, for example, the package is not store in repository"
	patch isEmpty ifTrue: [^emptyAction value].
	^(differences DifferenceSubject onModel: patch) nameA: titleA; nameB: titleB; versionA: versionA; versionB: versionB
)
changesIn: version <MCSvnVersionInfoSubject> = (
	| newer older |
	newer:: version model.
	older:: version model ancestors first.
	^changesFrom: [versionWithInfo: older] title: older name
				to: [versionWithInfo: newer] title: newer name
				ifEmpty: [^nil]
)
compareToInstalledVersion = (
	| older olderTitle ancestors |
	ancestors:: model ancestry ancestors.
	olderTitle:: String streamContents: [ :s |
		ancestors do: [ :ea | s nextPutAll: ea name; nextPutAll: ' ']].
	older:: ancestors isEmpty
		ifTrue: [[nil]]
		ifFalse: [[repository closestAncestorVersionFor: model ancestry ifNone: [nil]]].
	model modified: true.
	^changesFrom: older title: olderTitle withBlanksTrimmed to: [model package] title: 'Code in Image' ifEmpty: [
		model modified: false.
		^nil]
)
compareToUpdatesOnServer = (
	| newer |
	newer:: presenter showWaitCursorWhile: [serverVersion].
	^changesFrom: [model package] title: 'Code in Image' to: [newer] title: newer info name ifEmpty: [
		model modified: false.
		^nil]
)
createPresenter = (
	^MCWorkingCopyPresenter onSubject: self
)
hash = (
	^model hash
)
isModified = (
	^model modified
)
isOld = (
	^(svnVersionInfo ifNil: [^false]) timestamp < oneMonthAgo
)
isOlderThan: version <MCSvnVersionInfoSubject> = (
	model ancestors isEmpty ifTrue: [^true].
	(model ancestors select: [ :ea | ea revision < version model revision]) 
		size = model ancestors size
		ifTrue: [^true].
	^nil ~= (model ancestors
		detect: [ :ea | version model hasAncestor: ea] ifNone: []) 
)
isRecent = (
	^(svnVersionInfo ifNil: [^false]) timestamp > sevenDaysAgo
)
isUpdated = (
	^(allUpdatedPackages select: [ :ea | ea = model]) isEmpty not
		or: [(allUninstalledPackages select: [ :ea | ea = model]) isEmpty not]
)
load: nukeBrazil = (
	| registeredWorkingCopy |
	assert true: [repository ~= MCCacheRepository default].
	registeredWorkingCopy:: MCWorkingCopy forPackage: model package.
	model == registeredWorkingCopy ifFalse: [
		"Handle unregistered working copies used to represent packages not in image. This should be revisited."
		registeredWorkingCopy repositoryGroup: model repositoryGroup].
	nukeBrazil ifTrue: [nukeBrazilWindows].
	loadVersions: {serverVersion} ignoreModifications: false nukeBrazil: nukeBrazil.
	announceUpdates.
	flush
)
logMessage = (
	| svi |
	svi:: svnVersionInfo.
	svi ifNil: [^''].
	^svi message
)
removePackageAndDeleteClasses = (
	model unload.
	model packageInfo systemCategories do: [ :cat |
		Smalltalk organization removeSystemCategory: cat].
	PackageOrganizer default unregisterPackage: model packageInfo.
	announceUpdates
)
removePackageButKeepClasses = (
	model unregister.
	announceUpdates
)
repository = (
	^model repositoryGroup repositories last
)
repositoryIfCacheOnly: action = (
	| rep |
	rep:: self repository.
	rep = MCCacheRepository default ifTrue: [action value].
	^rep
)
repositoryVersions = (
	^(((repositoryIfCacheOnly: [^{}]) versionsAvailableForPackage: model package)
		collect: [ :v | MCSvnVersionInfoSubject onModel: v]) asArray
)
revertItem: version <MCVersionInfo> = (
	^'Revert to ', version name ->
		[loadVersions: {repository versionWithInfo: version} ignoreModifications: true] fixTemps
)
revertItems = (
	^Array streamContents: [ :a |
		a nextPut: 'Revert to Latest Version on Server' ->
			[loadVersions: {serverVersion} ignoreModifications: true] fixTemps.
		model ancestors do: [ :ea | a nextPut: (revertItem: ea)]]
)
revertTo: version <MCSvnVersionInfoSubject> = (
	| registeredWorkingCopy |
	assert true: [repository ~= MCCacheRepository default].
	registeredWorkingCopy:: MCWorkingCopy forPackage: model package.
	model == registeredWorkingCopy ifFalse: [
		"Handle unregistered working copies used to represent packages not in image. This should be revisited."
		registeredWorkingCopy repositoryGroup: model repositoryGroup].
	loadVersions: {versionWithInfo: version model} ignoreModifications: true
)
save = (
	^SaveNewVersionSubject onModel: self
)
serverVersion ^<MCVersion> = (
	^versionWithInfo: svnVersionInfo logEntries last versionInfo
)
svnVersionInfo ^<SVNVersionedEntity> = (
	repositoryContents. "Force cache initialization"
	^(repositoryContentsCache at: repository ifAbsent: [^nil])
		detect: [ :ea <SVNVersionedEntity> | model package name = ea name] ifNone: [nil]
)
tips = (
	nil = tips0 ifTrue: [ | done |
		tips0:: Dictionary new.
		repositoryVersions do: [ :ea | tips0 at: ea model put: ea].
		ancestors do: [ :ea |
			tips0 removeKey: ea model ifAbsent: [].
			ea model breadthFirstAncestorsDo:
				[ :ans | tips0 removeKey: ans ifAbsent: []]].
		done:: false.
		[done] whileFalse:
			[done:: true.
			tips0 keys do: [ :ea |
				ea breadthFirstAncestorsDo: [ :ans |
					(tips0 removeKey: ans ifAbsent: []) ifNotNil: [done:: false]]]].
		tips0:: tips0 values asArray.
		tips0 sort: [ :a :b | a model revision > b model revision]].
	^tips0
)
title = (
	^model package name
)
uniqueVersionName = (
	| mcSuggestedName |
	mcSuggestedName:: model uniqueVersionName.
	(mcSuggestedName beginsWith: model package name)
		ifTrue: [^mcSuggestedName].
	^model package name, '-',  Utilities authorInitials, '.1'
)
versionSummaryString = (
	^String streamContents: [ :s |
		ancestors
			do: [ :ea <MCSvnVersionInfoSubject> |
				s nextPutAll: ea shortTitle]
			separatedBy: [ s nextPut: $,]]
)
versionWithInfo: versionInfo = (
	^model repositoryGroup versionWithInfo: versionInfo
))
class SaveNewVersionSubject onModel: wc <MCWorkingCopySubject> = Subject onModel: wc (|
	newVersionName = wc uniqueVersionName.
	logMessage ::= 'empty log message'.
|)
('as yet unclassified'
changes = (
	^model compareToInstalledVersion
)
createPresenter = (
	^SaveNewVersionPresenter onSubject: self
)
save = (
	| info version ancestry |
	assert true: [model repository ~= MCCacheRepository default].
	
	info:: model model ancestry infoWithName: newVersionName message: logMessage.
	version:: Monticello MCVersion new.
	version
		setPackage: model model package
		info: info
		snapshot: model model package snapshot
		dependencies: {}.
	info:: model repository storeVersion: version.
	ancestry:: Monticello MCWorkingAncestry new addAncestor: info.
	version
		setPackage: version package
		info: info
		snapshot: version snapshot
		dependencies: {}.
	model model ancestry: ancestry.
	model model modified: false.
	"version addToCache."
	#BOGUS yourself. "Cannot cache 'version' because it contains MCPolyglotClassInSystemDefinition"

	repositoryContentsCache: nil
)
title = (
	^newVersionName
))
class UnpackagedCategorySubject onModel: cat <String> = Subject onModel: cat ()
('as yet unclassified'
= other = (
	^class == other class and: [model = other model]
)
createPresenter = (
	^UnpackagedCategoryPresenter onSubject: self
)
deleteItems = (
	^{('Delete all classes in ', model) -> [removeFromSystem]}
)
hash = (
	^model hash
)
publishItem: rep <MCSvnTCPRepository> = (
	^('Publish ', model, ' to ', rep description) -> [saveIn: rep]
)
publishItems = (
	^Array streamContents: [ :a |
		repositories do: [ :rep | a nextPut: (publishItem: rep)]]
)
removeFromSystem = (
	Smalltalk organization removeSystemCategory: model.
	announceUpdates
)
saveIn: rep <MCSvnTCPRepository> = (
	| wc |
	wc:: MCWorkingCopy forPackage: (MCPackage named: model).
	wc modified: true.
	wc repositoryGroup addRepository: rep.
	wc newVersion ifNotNil: [ :v |
		(MCVersionInspector new version: v) show.
		rep storeVersion: v.
		flush]
)
title = (
	^model
))'as yet unclassified'
ageOfData = (
	nil = repositoryContentsTimestamp ifTrue: [^0].
	nil = repositoryContentsCache ifTrue: [^0].
	^(DateAndTime now - repositoryContentsTimestamp) asSeconds // 60
)
allPackages = (
	^allWorkingCopies collect: [ :ea | MCWorkingCopySubject onModel: ea]
)
allWorkingCopies = (
	^model registry values sort: [:a :b | a package name <= b package name]
)
calculateLegacyPackages = (
	^selectPackages: [ :wc <MCWorkingCopy> :repositoryRevision <Integer | nil> :imageRevision <Integer> |
		legacyPackageNames includes: wc package name]
)
calculateModifiedPackages = (
	^selectPackages: [ :wc <MCWorkingCopy> :repositoryRevision <Integer | nil> :imageRevision <Integer> |
		wc modified]
)
calculateOtherPackages = (
	^selectPackages: [ :wc <MCWorkingCopy> :repositoryRevision <Integer | nil> :imageRevision <Integer> |
		true]
)
calculatePackagesNotOnServer = (
	^selectPackages: [ :wc <MCWorkingCopy> :repositoryRevision <Integer | nil> :imageRevision <Integer> |
		wc repositoryGroup repositories size = 1
			and: [(legacyPackageNames includes: wc package name) not]]
)
calculateUninstalledPackages = (
	| packageNames |
	packageNames:: (repositoryContents collect: [ :ea | ea name]) asSet.
	allWorkingCopies do:
		[ :ea  | packageNames remove: ea package name ifAbsent:[]].
	^(packageNames collect: [ :ea | | wc |
		wc:: MCWorkingCopy new initializeWithPackage: (MCPackage named: ea).
		wc repositoryGroup addRepository: (repositoryOf: ea).
		wc])
		asArray sort: [:a :b | a package name <= b package name]
)
calculateUnpackagedCategories = (
	^(Smalltalk organization categories asSet removeAllFoundIn: (Array streamContents: [ :a | MCWorkingCopy registry do: [ :ea | a nextPutAll: ea packageInfo systemCategories ]]); asSortedArray) reject: [ :ea | (ea endsWith: '-nested') or: [legacyPackageNames includes: ea]]
)
calculateUpdatedPackages = (
	^selectPackages: [ :wc <MCWorkingCopy> :repositoryRevision <Integer | nil> :imageRevision <Integer> |
		repositoryRevision notNil and: [imageRevision ~= -1 and: [repositoryRevision > imageRevision]]]
)
createNewNsClassNamed: clsName usingReflection: reflection = (
	| builder sourceMirror |
	builder:: reflection classBuilderFromSource: 'class ', clsName, ' = NewspeakObject (
	"Undocumented class."
|
|
) ().'.
	builder validateIfError: [:message :pos | ^false].
	sourceMirror:: builder asMirror.
	reflection installToplevelClass: sourceMirror categorized: clsName asSymbol.
)
createNewPackageNamed: packageName <String> = (

	Smalltalk organization addCategory: packageName.
	(((MCPackage named: packageName) packageInfo; workingCopy) modified: true)
		repositoryGroup addRepository: userRepository.
	refresh.
)
createPresenter = (
	^MonticelloPresenter onSubject: self
)
distributionRepository = (
	"Newspeak distribution repository."
	^repositories first
)
getRepositoryContents =(
	| content |
	content:: Dictionary new.
	mutex critical: [
		repositories do: [ :rep |
			rep refresh.
			onProgressDuring: [content at: rep put: rep topLevelPackageContents]
				do: [:msg | rep changed: rep with: msg]]].
	^content
)
highestRevisionFor: wc <MCWorkingCopy> = (
	"Answer the highest revision number amongst the ancestors, or -1 if none."
	^wc ancestry ancestors inject: -1 into: [ :max :ancestor | max max: (ancestor revision ifNil: [-1])]
)
legacyPackages = (
	^allLegacyPackages collect: [ :ea | MCWorkingCopySubject onModel: ea]
)
loadAllUpdated: nukeBrazil <Boolean> ifModified: modifiedAction <[String]> = (
	| serverVersions |
	updatedPackages do:
		[ :ea | ea isModified ifTrue:[^modifiedAction value: ea title, ' has unsaved changes']].
	nukeBrazil ifTrue: [nukeBrazilWindows].
	serverVersions:: Array streamContents:
		[:s |
		updatedPackages
			do: [:each | s nextPut: each serverVersion]
			displayingProgress: 'Parsing'].
	loadVersions: serverVersions ignoreModifications: true nukeBrazil: nukeBrazil
)
loadVersions: versions <Collection> ignoreModifications: ignore <Boolean> = (
	loadVersions: versions ignoreModifications: ignore nukeBrazil: false
)
loadVersions: versions <Collection> ignoreModifications: ignore <Boolean> nukeBrazil: nukeBrazil <Boolean> = (
	| loader |
	loader:: MonticelloLoader new.
	loader ignoreModifications: ignore.
	versions do: [ :ea | loader addVersion: ea].
	sourceManager doSilently: [loader load].
	announceUpdates
)
modifiedPackages = (
	^allModifiedPackages collect: [ :ea | MCWorkingCopySubject onModel: ea]
)
nukeBrazilWindows = (
	brazil resetDesktop.
	World submorphs
		select: [ :ea | ea isKindOf: BrazilSystemWindow]
		thenDo: [ :ea | ea delete]
)
packagesNotOnServer = (
	^(allUnpackagedCategories collect: [ :ea | UnpackagedCategorySubject onModel: ea]),
	(allPackagesNotOnServer collect: [ :ea | MCWorkingCopySubject onModel: ea])
)
refresh = (
	mutex critical:
		[allModifiedPackages:: calculateModifiedPackages.
		allPackagesNotOnServer:: calculatePackagesNotOnServer.
		allUpdatedPackages:: calculateUpdatedPackages.
		allLegacyPackages:: calculateLegacyPackages.
		allUninstalledPackages:: calculateUninstalledPackages.
		allUnpackagedCategories:: calculateUnpackagedCategories.
		rightNow:: DateAndTime now.
		sevenDaysAgo:: (Date today subtractDays: 30) asDateAndTime.
		oneMonthAgo:: (Date today subtractDays: 30) asDateAndTime].
)
refreshmentSubject = (
	shiftWasPressed ifTrue: [flush].
	^super refreshmentSubject
)
repositories = (
	^repositoryGroup repositories allButFirst
)
repositoryContents = (
	repositoryContentsCache ifNil:
		[| ts |
		ts:: DateAndTime now.
		repositoryContentsCache:: getRepositoryContents.
		repositoryContentsTimestamp:: ts].
	^Array streamContents: [ :s | repositoryContentsCache do: [ :ea | s nextPutAll: ea]]
)
repositoryGroup = (
	^Monticello MCRepositoryGroup default
)
repositoryOf: pkgname <String> = (
	repositoryContents. "Ensure cache is non-nil"
	repositoryContentsCache keysAndValuesDo:
		[:rep <MCSvnTCPRepository> :sves <Collection[SVNVersionedEntity]> |
		sves do: [ :sve <SVNVersionedEntity> | sve name = pkgname ifTrue: [^rep]]].
	self halt
)
selectPackages: action <[":wc <MCWorkingCopy> :repositoryRevision <Integer | nil> :imageRevision <Integer>"]> = (
	| packageRevisions pkgs |
	packageRevisions:: Dictionary new.
	repositoryContents do: [:sve| packageRevisions at: sve name put: sve revision].
	^allWorkingCopies
		select: [ :wc | action
				value: wc
				value: (packageRevisions at: wc package name ifAbsent: []) 
				value: (highestRevisionFor: wc)]
)
setup = (
	"refresh."
	updatesOutlet:: subscribeToUpdates: [updateNotification]
)
subjectFor: packageName <String> ^<Subject> = (
	| idx pkgs |
	refresh.
	pkgs:: allPackages.
	idx:: pkgs findFirst: [:ea |ea title = packageName].
	0 = idx ifTrue: [^nil].
	^pkgs at: idx
)
uninstalledPackages = (
	^allUninstalledPackages collect: [ :ea | MCWorkingCopySubject onModel: ea]
)
updateNotification = (
	presenter refreshLater
)
updatedPackages = (
	^allUpdatedPackages collect: [ :ea | MCWorkingCopySubject onModel: ea]
)
userRepository = (
	"User's own repository (aka My Repository). This is where new pacakges are published to."

	^repositories last
)
versionWithInfo: info = (
	^repositoryGroup versionWithInfo: info ifNone: [nil]
)) : ('as yet unclassified'
createPresenter = (
	^MonticelloPresenter onSubject: self
))
class SaveNewVersionPresenter onSubject: theSubject <SaveNewVersionSubject> = ProgrammingPresenter onSubject: theSubject (|
	saveStatus
|)
('as yet unclassified'
definition = (
	saveStatus:: Listener new.
	^column: {
		majorHeadingBlock: (label: 'Publish ', subject title).
		editorDefinition.
		blank: 6.
		majorHeadingBlock: (row: {saveStatus. label: ' '}).
		heading: (label: 'changes') details: [fullChangesPresenter].
	}
)
editorDefinition = (
	^TextEditorFragment new
		text: subject logMessage;
		acceptResponse: [:editor | respondToAccept: editor];
		cancelResponse: [respondToCancel].
)
fullChangesPresenter = (
	 | changesArea |
	changesArea:: holder: [label: ''].
	saveStatus showMessage: 'Checking...'.
	doInBackground: [subject changes]
		notifying: saveStatus
		whenDone:
			[:changes |
				majorUpdate: [
					changesArea content: (nil = changes
						ifTrue: [textDisplay: 'no changes']
						ifFalse: [changes presenter]).
					saveStatus removeLastMessage]].
	^changesArea
)
isTransient = (
	^true
)
respondToAccept: editor = (
	editor defaultAcceptResponse.
	subject logMessage: editor text asString.
	saveStatus showMessage: 'Publishing ', subject title, '...'.
	doInBackground: [subject save] notifying: saveStatus whenDone: [enterSubject: mainSubject]
)
respondToCancel = (
	enterSubject: mainSubject
)
viewportColor = (
	^backgroundColor
))
class UnpackagedCategoryPresenter onSubject: theSubject <UnpackagedCategorySubject> = ProgrammingPresenter onSubject: theSubject (|
	inspectionHolder
|)
('as yet unclassified'
confirmResponderFor: item = (
	^item key -> [confirm: 'Confirm ', item key ifConfirmed: [item value value]]
)
definition = (
	inspectionHolder:: holder: [nothing].
	^row: {
		blank: 40.
		elastic: (column: {
			row: {
				(link: subject title asText allBold action: [respondToBrowse]) color: Color black.
				filler.
				inspectionHolder.
				smallBlank.
				dropDownMenu: [publishMenu]
			}.
			smallBlank.
		})
	}
)
publishMenu = (
	^menuWithLabelsAndActions:
		(subject publishItems collect: [ :item | responderFor: item]), (subject deleteItems collect: [ :item | confirmResponderFor: item])
)
respondToBrowse = (
	browseClassCategory: subject title asSymbol
)
responderFor: item = (
	^item key -> [showWaitCursorWhile: [item value value]]
))'as yet unclassified'
ActiveEvent ^<MorphicEvent | nil> = (
	#BOGUS yourself. "Use of global"
	^Smalltalk at: #ActiveEvent
)
World ^<PasteUpMorph> = (
	#BOGUS yourself. "Use of global"
	^Smalltalk at: #World
)
announceUpdates = (
	ignoreUpdates = true ifTrue: [^self].
	updatesChannel send: nil
)
backgroundColor = (
	^Color gray
)
browsePackages = (
	| subject |
	subject:: MonticelloSubject onModel: MCWorkingCopy.
	IDEWindow openSubject: subject
)
doInBackground: action notifying: listener whenDone: doneAction = (
	ignoreUpdates:: true.
	rememberProcess:: [ | value |
	brazil theDesktop disableUserInputDuring:
		[[
			[
				value:: onProgressDuring: [action value]
					do: [ :msg | schedule: listener visual action: [listener addMessage: msg]]
					done: [schedule: listener visual action: [listener removeLastMessage]]
					status: [:v | schedule: listener visual action: [listener percentComplete: v]].
				schedule: listener visual action:  [doneAction valueWithPossibleArgument: value]
			] ifError: [ :desc | schedule: listener visual action: [listener showMessage: desc]]
		] ensure:
			[ignoreUpdates:: false.
			forgetActiveProcess]]
	] forkAt: 35
)
flush = (
	repositoryContentsCache:: nil.
	announceUpdates
)
forgetActiveProcess = (
	processes removeAllSuchThat: [:each | each isActiveProcess]
)
fullySuppressUpdatesDuring: action = (
	| oldValue |
	oldValue:: ignoreUpdates.
	ignoreUpdates: true.
	^[action value] ensure: [ignoreUpdates:: oldValue]
)
legacyPackageNames = (
	^{
		'TrueType'.
		'VersionNumber'
	} asSet
)
mainSubject = (
	"This is the main entry point for creating a subject representing the main Source Control page.
	It returns a new subject on each invocation."
	^MonticelloSubject onModel: MCWorkingCopy
)
onProgressDuring: action do: begin done: end = (
	[^action value]
		on: ProgressInitiationException
		do: [:ex |
			begin value: ex progressTitle.
			[onProgressDuring: [ex sendNotificationsTo: [ :min :max :curr |]] do: begin done: end]
				ensure: [end value]]
)
onProgressDuring: action do: begin done: end status: bar <[Number]> = (
	[^action value]
		on: ProgressInitiationException
		do: [:ex |
			begin value: ex progressTitle.
			[onProgressDuring: [ex sendNotificationsTo: [ :min :max :current | reportProgressTo: bar min: min max: max current: current]] do: begin done: end]
				ensure: [end value]]
)
onProgressDuring: action do: listener = (
	^onProgressDuring: action do: listener done: []
)
refreshUi = (
	Project uiProcess isActiveProcess ifTrue: [	World doOneCycle]
)
rememberProcess: process = (
	processes add: process
)
reportProgressTo: bar min: min max: max current: current = (
	| normalizedMax normalizedCurrent |
	normalizedMax:: max - min + 1.
	normalizedMax < 0.0001 ifTrue: [^self].
	normalizedCurrent:: current - min + 1.
	normalizedMax < 0.0001 "never compare floats to zero" ifTrue: [^self].
	bar value: normalizedCurrent * 100 / normalizedMax asFloat.
)
schedule: visual action: action = (
	visual desktop ifNotNil: [ :dt | dt scheduleUIAction: action fixTemps].
	refreshUi
)
scheduleMorphicAction: action = (
	#BOGUS yourself. "Uses Monticello UI"
	WorldState addDeferredUIMessage: action.
)
setup = (
	updatesChannel beWeak.
	subscribeToMonticelloChanges.
)
shiftWasPressed = (
	^ActiveEvent ifNotNil: [ :ev | ev shiftPressed] ifNil: [false]
)
sourceManager = (
	^UnversionedSourceManager new
)
subscribeToMonticelloChanges = (
	MCWorkingCopy addDependent: self.
	MCWorkingCopy allManagers do: [ : ea | ea addDependent: self].
)
subscribeToUpdates: action <BlockContext> = (
	action fixTemps.
	^updatesChannel => [ :ignored | action value] fixTemps
)
suppressProgressBarDuring: action = (
	^onProgressDuring: action do:[ :msg|]
)
suppressUpdatesDuring: action = (
	| oldValue |
	oldValue:: ignoreUpdates.
	ignoreUpdates: true.
	^[action value] ensure: [ignoreUpdates:: oldValue. announceUpdates]
)
tearDown = (
	HopscotchIDE nilTheSourceManager.
	MCWorkingCopy removeDependent: self.
	MCWorkingCopy allManagers do: [ : ea | ea removeDependent: self]
)
update: ignored <Symbol> = (
	subscribeToMonticelloChanges.
	announceUpdates
))