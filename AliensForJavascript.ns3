Newspeak3
'AliensForJavascript'
class AliensForJavascript usingPlatform: platform = (
(*Aliens and Expats allow Newspeak- and Javascript objects to interact in an application-developer friendly way.

Aliens allow developers to access arbitrary Javascript objects and their properties using normal message sends.

Expats expose the slots/methods/classes of Newspeak objects as normal Javascript properties.

This code needs to be revised so it implements a systematic algebra of conversions. As its stands its too flakey.

   Copyright 2012 SAP AG.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)|
	private Dictionary = platform collections Dictionary.
	private Set = platform collections Set.
	
	private LowLevelObjectMirror = platform mirrors LowLevelObjectMirror.
	private ObjectMirror = platform mirrors ObjectMirror.
	private ClassMirror = platform mirrors ClassMirror.
	
	private reservedWords = Set withAll: {
		(*keywords*)
		'break'.  'case'.  'catch'.  'continue'.  'debugger'.  'default'.  'delete'.
		'do'.  'else'.  'finally'.  'for'.  'function'.  'if'.  'in'.  'instanceof'.
		'new'.  'return'.  'switch'.  'this'.  'throw'.  'try'.  'typeof'.  'var'.
		'void'.  'while'.  'with'.
		(*FutureReservedWords*)
		'class'.  'const'.  'enum'.  'export'.  'extends'.  'import'.  'super'.
		(*FutureReservedWords in strict mode*)
		'implements'.  'interface'.  'let'.  'package'.  'private'.  'protected'.
		'public'.  'static'.  'yield'.
		(*NullLiteral*)
		'null'.
		(*BooleanLiteral*)
		'true'.  'false'}.

	private expats = Expats new.

	public Expat = expats Expat.
	public NaiveExpat = expats NaiveExpat.
	public SmartExpat = expats Expat.
	public requestedNameMapping = RequestedNameMapping new.
|JavascriptEvaluator addJavascriptEvaluatorPrimitiveMethods)
(
class Alien privateConstructor: javascriptObject = ((*Allows regular Javascript objects to be used by Newspeak code

== Intent ==

Developers can create an alien using 'Alien onJavascriptObject: javascriptObject'. The returned object tries to translate any messages sent to it into appropriate actions on the underlying Javascript object. Possible actions are reading a property, setting a property, and calling a method.

Here's a small example for Alien usage. Assume the following Javascript object has somehow found its way into a Newspeak program.

{
	x : 21,
	f : function(p) {return 2 * p;}
}

If the object is known as 'javascriptObject', the following Newspeak code creates an alien, reads the property x, calls the function f with 1 added to the value of x, and writes the property x.

alien:: Alien onJavascriptObject: javascriptObject.
alien x: (alien f: {1 + alien x}).

The translation mechanism is designed with the goal of allowing convenient access to most Javascript object, rather than with the goal of allowing all Javascript objects to be accessible. This has the following consequences:

- Javascript properties that end in a colon (:) are not supported.
- Arguments to functions must always be passed in an array, even if the function expects only a single argument
- Arguments to property setters are not passed as arrays (opinions?)
- Messages sent to aliens return aliens, unless the returned object is a basic object (Number, String, Array, Boolean).
- Referencing a property that stores a function always results in this function being executed. If function objects are required, function access must be wrapped in blocks, e.g.
{
	f : function() {return 21;},
	g : function(h) {return 2 * h();}
}
alien g: {[alien f]}


== Calling Conventions / Two Kinds of Aliens ==

Two use-cases for aliens can be distinguished: (a) aliens that are used by code that intends to interact with Javascript and (b) aliens that are passed into methods that do not know that they are receiving aliens (covert aliens).
    
These two use cases for aliens differ in what methods can be called on them. Regular aliens are known to be Javascript objects. They thus do not have multi-keyword methods. In order to support methods that take multiple arguments, arguments must always be wrapped in an array. Covert aliens, on the contrary, are aliens that are passed to Newspeak code that does not know that it interacts with aliens. A concrete use case for this scenario are #apply: methods of an AST-visitor that are being called from Javascript code. In this use case, the aliens stand in for regular Newspeak objects and the Newspeak code tries to call keyword messages on them without wrapping arguments in collections.

Our implementation distinguishes these two kinds of aliens and introduces two calling conventions. Regular Aliens are created through the onJavascriptObject: factory and expect arguments of methods to be wrapped in collections. Covert aliens are created automatically, when arguments are passed to methods of an expat and do not expect arguments to be wrapped.
    
The approach of implementing different calling conventions for both use cases for aliens is only a first cut. An alternate solution might be to come up with a generic calling convention that can be shared by both use cases. This might especially be required if use-cases exist where methods on an expat are called with arguments and it is desirable to create regular aliens for them.

== Implementation ==

The Alien implementation consists of three classes, the class Alien and its two nested classes PublicInterface and DoesNotUnderstandHandler. An alien has one javascriptObject and one public interface. The public interface is the object that is returned by 'Alien onJavascriptObject: '. The public interface intercepts any messages sent to it using doesNotUnderstand and creates a new DoesNotUnderstandHandler that performs the appropriate action on the Javascript object.

PublicInterface does not implement any methods but #doesNotUnderstand:. It accesses the DoesNotUnderstandHandler through its lexical context. By not implementing any methods but #doesNotUnderstand the chance of name conflicts between the alien's methods and javascript object's properties is reduced.

The code is designed to be simple and correct, but not efficient. Here are a few problems that might pop up:

Sending a message to an Alien creates a new DoesNotUnderstandHandler. Creating this object could for example be avoided by keeping the the complete message translation logic within #doesNotUnderstand.

Aliens are currently recognized through a 'magic' JavaScript field that is currently re-added every time a new Alien is created. Should such a field turn out to be the way that we want to identify Aliens, we should come up with a more efficient implementation.

The implementation is Newspeak-specific. It expects setter methods to end in a colon (:).*)|
	private javascriptObject = javascriptObject.
	private llm = LowLevelObjectMirror reflecting: javascriptObject.
	public publicInterface = PublicInterface new.
	public expectArgumentsToBeWrappedInCollection ::= true.
|markPublicInterface)
(
class DoesNotUnderstandHandler message: message = ((*Translates messages received by the alien to access to the Javascript object


Examples

Open questions:

 - (How) do we expose access to Javascript operators
 - Do slot writes have to be wrapped in {}
 - e.g. do we want 'alien setFoo: 42' or 'alien setFoo: {42}'*)|
	message = message.
|)
('actions'
handle = (

	| result |
	(llm hasProperty: unmangledSelector) ifFalse: [
		^ super doesNotUnderstand: message].

	result:: propertyLlm type = 'function'
		ifTrue: [handleFunctionCall]
		ifFalse: [message arguments isEmpty
			ifTrue: [handlePropertyRead]
			ifFalse: [handlePropertyWrite]].

	^ Alien onJavascriptObject: result
)'private'
handleFunctionCall = (

	| argumentArray unwrappedArguments |

	argumentArray:: message arguments isEmpty
		ifTrue: [{}]
		ifFalse: [
			expectArgumentsToBeWrappedInCollection
				ifTrue: [message arguments at: 1]
				ifFalse: [message arguments]].
		
	(*TODO: Ensure that argumentArray is actually a collection. Developers may accidentally forget to wrap arguments in {}*)
		
	unwrappedArguments:: argumentArray collect: [:each |
		asJavascriptObject: each].

	^ propertyLlm on: javascriptObject apply: unwrappedArguments
)
handlePropertyRead = (

	^ property
)
handlePropertyWrite = (

	| newValue |
	newValue:: asJavascriptObject: (message arguments at: 1).
	llm propertyAt: unmangledSelector put: newValue.
	^ publicInterface
)
property = (

	(*should be a lazily computed slot*)
	^ llm propertyAt: unmangledSelector
)
propertyLlm = (

	(*should be a lazily computed slot*)
	^ LowLevelObjectMirror reflecting: property.
)
unmangledSelector = (

	(*We don't have to remove a leading $#, as this is and should be done by the mechanism calling doesNotUnderstand. We nevertheless want to remove a trailing $:*)

	^ (message selector at: message selector size) = $:
		ifTrue: [allButLast: message selector]
		ifFalse: [message selector]
)) : ('actions'
handle: message = (

	^ (self message: message) handle
))
class PublicInterface = ((*The alien object exposed to developers. Responds only to doesNotUnderstand:*))
('as yet unclassified'
doesNotUnderstand: message = (

	^ DoesNotUnderstandHandler handle: message
)) : ()'private'
asJavascriptObject: potentialAlien = (

	| llmPotentialAlien |
	llmPotentialAlien:: (LowLevelObjectMirror reflecting: potentialAlien).
	^ (llmPotentialAlien hasProperty: propertyIdentifyingAlien)
		ifTrue: [unwrapAlien: potentialAlien]
		ifFalse: [ Expat onNewspeakObject: potentialAlien]
)
markPublicInterface = (

	^ (LowLevelObjectMirror reflecting: publicInterface)
		propertyAt: propertyIdentifyingAlien
		put: true
)
propertyIdentifyingAlien = (

	^ 'I''mAnAlien'
)) : ('factory'
covertAlienOnJavascriptObject: javascriptObject = (

	(*Don't create aliens for Newspeak / primitive objects*)
	^ (ObjectMirror canReflectOn: javascriptObject)
		ifTrue: [javascriptObject]
		ifFalse: [ | alien |
			alien:: (Alien privateConstructor: javascriptObject).
			alien expectArgumentsToBeWrappedInCollection: false.
			alien publicInterface]
)
onJavascriptObject: javascriptObject = (
| llm |
	(*Don't create aliens for Newspeak / primitive objects*)
	^ (ObjectMirror canReflectOn: javascriptObject)
		ifTrue: [javascriptObject]
		ifFalse: [
			(*Test if it's an expat by checking if it has a #realNewspeakObject property. and if so, unwrap it by accessing that*)
			llm:: LowLevelObjectMirror reflecting: javascriptObject.
			(llm hasProperty: 'realNewspeakObject')
			 ifTrue:[llm propertyAt: 'realNewspeakObject']
			ifFalse:[(Alien privateConstructor: javascriptObject) publicInterface]
			(*Otherwise, create a real Alien*)
			]
))
class Expats = ((*Allows Newspeak objects to be used by regular Javascript code

== Intent ==

Developers can create an expat using 'Expat onNewspeakObject: newspeakObject'. The returned Javascript object will have function-properties for all of newspeakObjects' methods, nested classes, and slot getters and setters.

Here's a small example for Expat usage. Assume an expat has been created for an instance of the following Newspeak class.

class Sample = (
|
	number ::= 42.
|
)
(
	''cat''
	foo = (^ 23)
)

The following Javascript code reads the slot number, calls method foo, and sets the slot number.

expat.set_number(expat.foo() + expat.number());

The name mangling works as follows:

- Selectors are translated one-by-one, ordered by selector.
- An external name mapping can be requested through the expatNameMapping dictionary of the top-level Alien module. Keys are fully qualified class names and values are dictionaries that map Newspeak names to Javascript names.
- Slot setter methods are prefixed with 'set_'.
- All ':' are removed
- If the name in not unique, it is postfixed with the minimum number of '_' required to make it unique

== Limitations ==

If expats are created on arrays, the array's elements are not wrapped in expats.

== Implementation ==
*)|
	public Expat = ExpatBuilder new.
	public NaiveExpat = NaiveExpatBuilder new.
|NaiveExpatBuilder addMakeNaiveExpatFactory)
(
class ExpatBuilder = ((*Constructs a Javascript object that implements the Newspeak object's protocol*)|
	private cachedExpatFactories = Dictionary new.
|)
('accessing'
onNewspeakObject: newspeakObject = (

	(*Someone might pass in a regular Javascript object. 
	Silently return the object itself in that case.*)
	^ (((ObjectMirror canReflectOn: newspeakObject) not) 
		or: [ canActAsExpat: newspeakObject])
		ifTrue: [newspeakObject]
		ifFalse: [expatFor: (Delay ensureIsNoDelay: newspeakObject)]
)'private'
canActAsExpat: newspeakObject = (

	^ LowLevelObjectMirror hasObject: newspeakObject property: #canActAsExpat
)
expatFactoryForNewspeakObject: newspeakObject = (

	| klass |
	klass:: newspeakObject class.
	^ cachedExpatFactories
		at: klass
		ifPresent: [:x | x]
		ifAbsentPut:[(ExpatFactoryBuilder onClass: newspeakObject class) factory]
)
expatFor: newspeakObject = (

	| factory |
	factory:: expatFactoryForNewspeakObject: newspeakObject.
	^ factory value: newspeakObject
)) : ()
class ExpatFactoryBuilder onClass: klass = (
(*Constructs a Javascript object that serves as a prototype for all expats that share the class*)|
	private klass = klass.
	private llmPrototype = LowLevelObjectMirror emptyObject.
|)
('accessing'
factory = (

	^ JavascriptEvaluator
		evalFunction: 'function(prototype, propertyStoringRealObject) {
			var MakeExpat = function(object) {
				this[propertyStoringRealObject] = object;
				this.canActAsExpat = true;
			};
			MakeExpat.prototype = prototype;
			return function(object) { return new MakeExpat(object);};
		}'
		with: {prototype. propertyStoringRealObject}
)'private'
at: property addAccessorFor: selector = (

	| accessor |
	accessor:: JavascriptEvaluator
		evalFunction: 'wrapMethodForExpat'
		with: {Expat. Alien. selector. propertyStoringRealObject}.
	llmPrototype
		propertyAt: property
		put: accessor.
)
propertyStoringRealObject = (

	^ #realNewspeakObject
)
prototype = (

	| nameMapper |
	nameMapper:: NewspeakToJavascriptNameMapper onClass: klass.
	nameMapper keysAndValuesDo: [:k :v |
		at: v addAccessorFor: k].
	
	^ llmPrototype reflectee
)) : ()
class NaiveExpatBuilder = (|
|)
('as yet unclassified'
canActAsExpat: newspeakObject = (

	^ LowLevelObjectMirror hasObject: newspeakObject property: #canActAsExpat
)
expatFactory = (
	^	makeNaiveExpatFactoryForExpatClass: NaiveExpat 
		alienClass: Alien 
		propertyStoringRealObject: propertyStoringRealObject
)
expatFor: newspeakObject = (
	^ expatFactory value: newspeakObject
)
onNewspeakObject: newspeakObject = (
	| llm |
	(*Someone might pass in a regular Javascript object. 
	Silently return the object itself in that case.*)
	^ (((ObjectMirror canReflectOn: newspeakObject) not) 
		or: [ canActAsExpat: newspeakObject])
		ifTrue: [ newspeakObject ]
		ifFalse: [ 	(*Must check if it is an Alien, and if so, return the underlying
				JS object. *)
			llm:: LowLevelObjectMirror reflecting: newspeakObject.
			(llm hasProperty: propertyIdentifyingAlien)
				ifTrue:[unwrapAlien: newspeakObject]
				ifFalse:[expatFor: (Delay ensureIsNoDelay: newspeakObject) ]
			]
)
propertyIdentifyingAlien = (
	^ 'I''mAnAlien'
)
propertyStoringRealObject = (
	^ 'realNewspeakObject'
)) : ()) : ()
class JavascriptEvaluator = (
(*Allows evaluating arbitrary Javascript code. Currently used by expats and the testing environment.*)|
|)
('as yet unclassified'
eval: string = (

	implementedByInfrastructure
)
evalFunction: string with: arguments = (

	implementedByInfrastructure
)) : ('as yet unclassified'
eval: source = (

	^ self new eval: source
)
evalFunction: source with: arguments = (

	^ self new evalFunction: source with: arguments 
))
class NewspeakToJavascriptNameMapper onClass: klass = (|
	private classMirror = ClassMirror reflecting: klass.
	private requestedMapping = requestedNameMapping atClassMirror: classMirror.
	private nonUniqueMapping = Dictionary new.
	private implementedMapping = Dictionary new.
|populateMapping)
('as yet unclassified'
keysAndValuesDo: block = (

	implementedMapping keysAndValuesDo: block
)
mangleReservedWord: potentialReservedWord = (

	(*Rhino (in contrast to the ECMA spec) disallows reserved words as property names, so we mangle them*)
	^ (reservedWords includes: potentialReservedWord)
		ifTrue: [potentialReservedWord, '_']
		ifFalse: [potentialReservedWord]
)'private'
addNonUniqueMappingFor: selector = (

	| initialSuggestion withoutReservedWord |

	initialSuggestion:: suggestMappingFor: selector.
	withoutReservedWord:: mangleReservedWord: initialSuggestion.
	nonUniqueMapping
		at: selector
		put: withoutReservedWord
)
generateUniqueMappingFor: selector suggest: translation = (

	| uniqueTranslation |
	uniqueTranslation:: translation.
	^ implementedMapping
		at: selector
		ifPresent: [:x | x]
		ifAbsentPut: [
			[implementedMapping values includes: uniqueTranslation] whileTrue: [
				uniqueTranslation:: uniqueTranslation, '_'].
			uniqueTranslation]
)
populateMapping = (

	classMirror slots do: [:each |
		#BOGUS yourself.
(*It would be better if SlotMirrors exposed the names of getter and setter messages.*)
		addNonUniqueMappingFor: each simpleName.
		each isMutable ifTrue: [
			nonUniqueMapping at:
				each simpleName, ':'
				put: 'set_', each simpleName]].
	classMirror methods do: [:each |
		addNonUniqueMappingFor: each simpleName].
	classMirror nestedClassDeclarations do: [:each |
		addNonUniqueMappingFor: each simpleName].
	(*Make sure we sort by selectors, so that we end up with a more-predictable mapping that doesn't depend on the order of selectors.*)
	
	nonUniqueMapping associations asSortedList do: [:a |
		generateUniqueMappingFor: a key suggest: a value].
	
)
suggestMappingFor: selector = (

	^ requestedMapping
		at: selector
		ifAbsent: [
			for: selector
			collectAndConcat: [:each | each = $: ifTrue: [''] ifFalse: [each]]].

)) : ()
class RequestedNameMapping = (
(*Allows requesting Newspeak-to-Javascript name mappings.*)|
	dictionary = Dictionary new.
|)
('accessing'
at: fullyQualifiedName put: mapping = (

	dictionary at: fullyQualifiedName put: mapping
)
atClassMirror: classMirror = (

	| result |
	result:: Dictionary new.
	withSuperClassesOf: classMirror do: [:each |
		dictionaryAt: each fullyQualifiedName ifPresent: [:x |
			(*can we do an addAll: or something of the like?*)
			x keysAndValuesDo: [:k :v |
				result at: k put: v]]].
	^ result
)'private'
dictionaryAt: key ifPresent: block = (

	| v |
	v:: dictionary at: key ifAbsent: [^self].
	^ block value: v
)
withSuperClassesOf: classMirror do: block = (

	(({classMirror}, classMirror allSuperclasses) reverse) do: block
)) : ()
class StringIndexedDictionary = (
(*Implements (parts of) the Dictionary interface using Javascript objects as Dictionaries*)|
		llm = LowLevelObjectMirror reflecting: Array new. (*Could be any object*)
|)
('as yet unclassified'
at: key = (

	^ llm propertyAt: key
)
at: key ifAbsent: absentBlock = (

	^ (includesKey: key)
		ifTrue: [self at: key]
		ifFalse: absentBlock
)
at: key ifPresent: presentBlock ifAbsentPut: absentBlock = (

	^ (includesKey: key)
		ifTrue: [presentBlock value: (self at: key)]
		ifFalse: [at: key put: absentBlock value]
)
at: key put: value = (

	llm propertyAt: key put: value.
	^ value
)
do: block = (

	llm ownPropertiesDo: [:name | | value |
		value:: llm propertyAt: name.
		block value: value].
)
includesKey: key = (

	^ keys includes: key
)
keys = (

	^ llm ownProperties
)
keysAndValuesDo: block = (

	llm ownPropertiesDo: [:name | | value |
		value:: llm propertyAt: name.
		block value: name value: value].
)
reject: aBlock = (
	| result |
	result:: Array new. (*Assuming JS array-backed Arrays which are actually ordered collections.*)
	self do:
		[:each |
		(aBlock value: each) ifFalse: [result add: each]].
	^result
)
select: aBlock = (
	| result |
	result:: Array new. (*Assuming JS array-backed Arrays which are actually ordered collections.*)
	self do:
		[:each |
		(aBlock value: each) ifTrue: [result add: each]].
	^result
)
size = (

	^ llm ownProperties size
)
values = (

	| result counter |
	result:: Array new: size.
	counter:: 1.
	llm ownPropertiesDo: [:each |
		result
			at: counter
			put: (llm propertyAt: each).
		counter:: counter + 1].
	^ result
)) : ()'as yet unclassified'
evalJavascript: source = (

	^ JavascriptEvaluator eval: source
)
javascriptEngineName ^ <String> = (

	^ JavascriptEvaluator eval: 'javascriptEngineName()'
)
setExpat: str = (
	str = 'Expat'
		ifTrue: [ Expat:: expats Expat ]
		ifFalse: [ Expat:: expats NaiveExpat]
)
unwrapAlien: alien = (
	^(((ObjectMirror reflecting: alien) getClassIfFail:[]) enclosingObject getSlot: #javascriptObject ifFail:[]) reflectee
)'private-infrastructure'
allButLast: string = (

	^ string copyFrom: 1 to: string size - 1
)
for: string collectAndConcat: aBlock = (

	| result |
	result:: ''.
	string do: [:each |
		result:: result, (aBlock value: each)].
	^ result
)) : ()