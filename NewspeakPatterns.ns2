Newspeak3
'Newspeak3'
class NewspeakPatterns usingLib: platform = NewspeakObject (
"An experimental module implementing pattern matching."|
	Dictionary = platform Collections Dictionary.
|)
(
class Binding of: b from: dict = (
"A Binding is in the result of a pattern match."| bindee ::= b. map = dict. |)
('as yet unclassified'
doesNotUnderstand: msg = (
     ^map at: msg selector ifAbsent:[super doesNotUnderstand: msg]
  )) : ('as yet unclassified'
from: dict   = (
	^of: nil from: dict
))
class PatternFactory = (
"<kw1: .. kwK: eK ... kwN:>

is shorthand for

PatternMaker kw1: WildcardPattern new ... kwK: eK ... kwN: WildcardPattern new.

PatternMaker is an instance of PatternFactory.
PattrenFactory has a doesNotUnderstand: method which 
produces a new pattern instance as follows:

PatternMaker maintains a dictionary mapping selectors to classes. It uses the selector, s,
of the incoming message to look up a class. If none exists, it is created.
The looked up class C is a subclass of PatternMatcher. It has a method with the 
selector s, that does the proper matching of its arguments recursively and composes a 
binding from them. It inherits from PatternMatcher it's doesNotUnderstand:,
which returns nil for everything. C has a factory with selector s, that invokes
the superclass factory, which takes a tuple as its argument.

 Now C is instantiated by sending it the incoming msg, which will provide it with
the set of arguments it needs to do the submatching. This the result - the desired
pattern literal instance."|
	classDict = Dictionary new.
|)
('as yet unclassified'
doesNotUnderstand: msg = (
| klass |
   klass:: classDict at: msg selector ifAbsent:[makeNewPatternClass: msg].
   ^klass perform: msg selector with: msg arguments
)
makeNewPatternClass: msg = (
"Given a msg kw1: p1 ... kwN: pN, this method produces a class C of the form:

class C kw1:a1 ... kwN: aN = PatternMatcher kws: {#kw1. ... #kwN} args:: {a1. ... aN} ()
(

  kw1: p1 ... kwN: pN = (
     ^doMatch: {p1. ... . pN}
  )
)
"
))
class PatternMatcher kws: ks args: as = (
"Describe the class in this comment."| subpatterns = as. keywords = ks. |assert:[keywords size = subpatterns size] 
  message: 'Number of keywords differs from number of subpatterns!')
('as yet unclassified'
doMatch: actuals = (
  | subbindings bindingMap |
  assert:[actuals size = subpatterns size].
  subbindings:: (1 to: actuals size)
                            collect:[:i  | ((actuals at:i) match: (subpatterns at:i)) ifNil:[^nil]].
  bindingMap: Dictionary new.
  keywords with: subbindings do:[:kw :b | bindingMap at:kw put: b].
  ^Binding from: bindingMap "build custom object from dictionary" 
"Ouch! Who is the bindee? Maybe case:of:do: will set it"
)
doesNotUnderstand: msg = (^nil))
class WildcardPattern = (
"A pattern that matches anything.")
('as yet unclassified'
match: e <Object> = (
	^Binding of: e from: Dictionary new.
)))