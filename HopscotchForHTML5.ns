Newspeak3
'Hopscotch'
class HopscotchForHTML5 usingPlatform: p runtime: r = (|
	private Color = p graphics Color.
	private Context = p graphics Context.
	private Timer = p actors Timer.
	private List = p collections OrderedCollection.
	private Map = p collections Dictionary.

	private window = p aliens global.
	private document = window at: 'document'.
	private body = document at: 'body'.
	private history = window at: 'history'.
	
	sharedNavigationHistory
	embeddedWindowMap = Map new.
	sharedBackButtonListener
	currentHopscotchWindow
	
	private accept16px = r accept16px.
	private cancel16px = r cancel16px.
	private disclosureClosedImage = r disclosureClosedImage.
	private disclosureTransitionImage = r disclosureTransitionImage.
	private disclosureOpenImage = r disclosureOpenImage.
	
	private deferredContentQueue = List new.
	
	public core = self. (* Polymorphic with HopscotchForBrazil *)
	public fragments = self. (* Polymorphic with HopscotchForBrazil *)
|) (
class BlankFragment = LeafFragment (|
|) (
'as yet unclassified'
createVisual = (
	^document createElement: 'div'
)
) : (
)
class ButtonFragment label: l action: a = LeafFragment (|
	label = l.
	action = a.
|) (
'as yet unclassified'
createVisual = (
	^(document createElement: 'button')
		appendChild: (document createTextNode: label);
		at: 'onclick' put: [action value. false];
		yourself
)
) : (
)
class CanvasFragment withExtent: e = LeafFragment (|
private alien = document createElement: 'canvas'.
|alien at: 'width' put: e x.
alien at: 'height' put: e y.
(alien at: 'style') at: 'position' put: 'relative') (
'as yet unclassified'
public context = (
	^Context on: (alien getContext: '2d')
)
createVisual = (
	^alien
)
public keyDownAction: onKeyPressed <[:String]> = (
	(* The canvas element itself doesn't seem to get key events. *)
	body
		addEventListener: 'keydown'
		with: [:e | onKeyPressed value: (String fromCharCode: (e at: 'keyCode'))]
)
public mouseDownAction: onMouseDown <[:Point]> = (
	alien
		addEventListener: 'mousedown'
		with: [:e | onMouseDown value: (e at: 'offsetX') @ (e at: 'offsetY')].
)
public mouseMovedAction: onMouseMoved <[:Point]> = (
	alien
		addEventListener: 'mousemove'
		with: [:e | onMouseMoved value: (e at: 'offsetX') @ (e at: 'offsetY')].
)
) : (
)
class ColumnComposer definitions: fragments = SequenceComposer definitions: fragments (|
|) (
'as yet unclassified'
flexDirection = (
	^'column'
)
) : (
)
class Composer = Fragment () (
) : (
)
class DeferredContentComposer initialContent: ic contentSource: cs = Composer (|
	initialContent <Fragment> = ic.
	contentSource <[Fragment]> = cs.
|) (
'as yet unclassified'
createVisual = (
	| div initialVisual |
	div:: document createElement: 'div'.
	initialVisual:: initialContent visual.
	div appendChild: initialVisual.
	deferAction: [
		| deferredFragment = contentSource value. |
		deferredFragment parent: self.
		(* replace: new with: old due to stupid DOM argument ordering *)
		div replaceChild: deferredFragment visual with: initialVisual].
	^div
)
) : (
)
public class EmbeddedHopscotchWindow into: container openSubject: s = HopscotchShell (|  localNavigator = LocalNavigationHistory new. |container appendChild: contentHolder.
  enterSubject: s) (
'as yet unclassified'
public displayPresenter: p <Presenter> = (
	super displayPresenter: p.
	document at: 'title' put: p title.
)
public enterPresenter: p <Presenter> = ( 
      currentHopscotchWindow:: self.
      embeddedWindowMap at: p ifAbsentPut:[self].
      localNavigator visit: p.
	super enterPresenter: p
)
public enterSubject: s <Subject> fromSnippet: snippet <SnippetSubject> = (
      embeddedWindowMap at: snippet presenter ifAbsentPut:[self].
	enterSubject: s.
)
public goBack = (
	localNavigator goBack.
	displayPresenter: localNavigator current.
)
listenForBackButton = (
	sharedBackButtonListener ifNil: [
		sharedBackButtonListener:: [:e | 
			      | p <Presenter> = navigator presenterFor: (e at: 'state').  
			        priorWindow = embeddedWindowMap at: p. |
				currentHopscotchWindow goBack. (* might be better to enterPresenter:? *)
				currentHopscotchWindow:: priorWindow.
			].
		window at: 'onpopstate' put: sharedBackButtonListener.
		].
)
navigationHistory = (
	^sharedNavigator
)
) : (
'as yet unclassified'
public openSubject: s = (
	^into: body openSubject: s
)
)
class Fragment = (|
	visualX
	public parent
	public size ::= nil.
	public expansibility ::= 0. 
	public compressibility ::= 0. 
	|) (
'as yet unclassified'
createVisual = (
	subclassResponsibility
)
public elasticity: x = (
	expansibility: x.
	compressibility: x.
)
public hasVisual = (
	^visualX isNil not
)
shell = (
	^parent isNil
		ifTrue: [Error signal: 'hierarchy not installed in a shell']
		ifFalse: [parent shell]
)
public visual = (
	visualX isNil ifTrue: [visualX:: createVisual].
	^visualX
)
public width: w elasticity: e= (
	size: w.
	expansibility: e.
	compressibility: e.
)
) : (
)
public class Gradient from: a to: b = (|
	topColor = a.
	bottomColor = b.
|) (
'as yet unclassified'
public applyToStyle: style = (
	| value |
	value:: '(top,', topColor asCSSString, ',', bottomColor asCSSString, ')'.
	style setProperty: 'background-image' to: '-webkit-linear-gradient', value.
	style setProperty: 'background-image' to: '-moz-linear-gradient', value.
)
) : (
)
class HolderComposer withContent: definition = Composer (|
	contentSource ::= definition.
	actualContent
|) (
'as yet unclassified'
public content ^<Fragment> = (
	actualContent isNil ifTrue: 
		[actualContent:: contentSource value.
		actualContent parent: self].
	^actualContent
)
public content: fragment = (
	fragment parent: self.
	hasVisual ifTrue:
		[ | oldContent newContent |
		oldContent:: actualContent.
		newContent:: actualContent:: fragment.
		(* replace: new with: old due to stupid DOM argument ordering *)
		visual replaceChild: newContent visual with: oldContent visual]
	ifFalse: [actualContent:: fragment]
)
createVisual = (
	| div |
	div:: document createElement: 'div'.
	div appendChild: content visual.
	^div
)
public refresh = (
	(contentSource isBlock and: [hasVisual])
		ifTrue:
			[ | oldContent newContent |
			oldContent:: actualContent.
			actualContent:: nil.
			newContent:: content.
			(* replace: new with: old due to stupid DOM argument ordering *)
			visual replaceChild: newContent visual with: oldContent visual]
		ifFalse:
			[actualContent refresh].
)
) : (
)
class HopscotchShell = (|
	navigator = navigationHistory.
	currentPresenterX
	contentHolder = document createElement: 'div'.
|listenForBackButton) (
'as yet unclassified'
public displayPresenter: p = (
	(* TODO: noticeX events *)
	p parent: self.
	contentHolder hasChildNodes
		ifTrue: [contentHolder replaceChild: p visual from: (contentHolder at: 'firstChild')]
		ifFalse: [contentHolder appendChild: p visual]
)
public enterPresenter: p = (
	(* TODO: Hopscotch History stuff *)
	
	(((document at: 'location') at: 'protocol') = 'file:') 
		ifFalse: [history pushState: (navigator idFor: p) title: p title].
	displayPresenter: p
)
public enterSubject: s <Subject> = (
	self enterPresenter: s presenter
)
listenForBackButton = (
	window at: 'onpopstate' put: [:e | userBack: e]
)
navigationHistory = (
	^NavigationHistory new
)
public shell = (
	^self
)
userBack: e = (
	| p <Presenter> = navigator presenterFor: (e at: 'state'). |
	displayPresenter: p
)
) : (
)
public class HopscotchWindow into: container openSubject: s = HopscotchShell (container appendChild: contentHolder.
	enterSubject: s) (
'as yet unclassified'
public displayPresenter: p = (
	super displayPresenter: p.
	document at: 'title' put: p title.
)
) : (
'as yet unclassified'
public openSubject: s = (
	^into: body openSubject: s
)
)
class HyperlinkFragment label: l action: a = LeafFragment (|
	label = l.
	action = a.
	public color ::= Color r: 0 g: 0 b: 1.
|) (
'as yet unclassified'
createVisual = (
	| anchor |
	anchor:: document createElement: 'a'.
	anchor at: 'href' put: '#'.
	anchor appendChild: (document createTextNode: label).
	anchor at: 'onclick' put: [action value. false].
	(anchor at: 'style')
		at: 'textDecoration' put: 'none'; (* No underline *)
		at: 'overflow' put: 'hidden';
		setProperty: 'white-space' to: 'nowrap'.
	color isNil ifFalse:
		[(anchor at: 'style') setProperty: 'color' to: color asCSSString].
	^anchor
)
) : (
)
class HyperlinkImageFragment image: i action: a = LeafFragment (|
	image = i.
	action = a.
|) (
'as yet unclassified'
createVisual = (
	| img |
	img:: image cloneNode: false (* Not deep *).
	img at: 'onclick' put: [action value. false].
	^img
)
) : (
)
class LeafFragment = Fragment () (
) : (
)
class LocalNavigationHistory = (
(* LocalNavigationHistory is a richly structured collection that maintains a web browser-like history of ''visits''. Visits are arbitrary objects. NavigationHistory makes no assumptions about visits other than that they can be compared using #=.

The important attributes of a history are: the ''current'' visit, the ''past'', the ''future'' and ''allVisits''. A history starts off empty. To visit an object, send the #visit: message to the history with the object as the argument. This makes the object the ''current'' object of the history.

The ''past'' is a queue of visits that used to be the current (most recently current object last). Sending the #goBack message makes the most recently current object from the past the current again, while the current object becomes the first member of the ''future'' queue. Sending the #goForward message reverses the process. Visiting an object other than the first element of the ''future'' queue erases the future queue.

All visits visited by a history are remembered in the ''allVisits'' set. This set is never emptied, other than on an explicit request.

A history can optionally be configured with a transientTestBlock. The test block is applied to visits to determine whether they are transient or not. Transient visits are not recorded in the ''past'' and ''future'' queues and in the ''allVisits'' set. By default all visits are considered to be non-transient.
*)|
	currentVisitSlot
	public allVisits <List>
	public past <List>
	public future <List>
	public transientTestBlock <[:Object | Boolean]> ::= [:element | false].
|erase) (
'as yet unclassified'
public current ^ <Object> = (
	^currentVisitSlot
)
public do: aBlock = (
	(* Do the current visit separately if transient because it's not among allVisits. *)
	(isTransient: currentVisitSlot) ifTrue:
		[aBlock value: currentVisitSlot].
	allVisits do: aBlock
)
public equalVisitOr: anObject ^ <Object> = (
	(* Return a visit from the history equal to the argument, or the argument itself if there is no equal visit in the history. *)
	^allVisits detect: [:some | some = anObject] ifNone: [anObject]
)
public erase = (
	currentVisitSlot:: nil.
	allVisits:: List new.
	erasePast.
	eraseFuture.	
)
public eraseEntry: anObject = (
	allVisits remove: anObject.
	past remove: anObject ifAbsent: [].
	future remove: anObject ifAbsent: []. (* can it ever be in the future list? *)
)
eraseFuture = (
	future:: List new.
)
erasePast = (
	past:: List new.
)
public goBack = (
	isPastEmpty ifFalse:
		[(isTransient: currentVisitSlot) ifFalse:
			[future addFirst: currentVisitSlot].
		currentVisitSlot:: past removeLast]	
)
public goForward = (
	isFutureEmpty ifFalse:
		[(isTransient: currentVisitSlot) ifFalse:
			[past addLast: currentVisitSlot].
		currentVisitSlot:: future removeFirst]	
)
public goToFutureItem: anObject = (
	[currentVisitSlot = anObject or: [isFutureEmpty]]
		whileFalse: [goForward]
)
public goToPastItem: anObject = (
	[currentVisitSlot = anObject or: [isPastEmpty]]
		whileFalse: [goBack]
)
includesVisit: anObject ^ <Boolean> = (
	^allVisits includes: anObject
)
isEmpty ^ <Boolean> = (
	^allVisits isEmpty
)
public isFutureEmpty ^ <Boolean> = (
	^future isEmpty
)
public isPastEmpty ^ <Boolean> = (
	^past isEmpty
)
isTransient: anObject ^ <Boolean> = (
	^transientTestBlock value: anObject
)
next ^ <Object> = (
	(* Answer the closest visit from the future. Fail if the future is empty. *)
	^future first
)
previous ^ <Object> = (
	(* Answer the most recent visit from the past. Fail if the past is empty. *)
	^past last
)
replace: anObject with: replacement = (
	(* Replace all references to anObject that we have with references to 'replacement'. *)
	allVisits remove: anObject ifAbsent: [].
	(isTransient: replacement) ifFalse: [allVisits add: replacement].
	currentVisitSlot = anObject ifTrue: [currentVisitSlot:: replacement].
	past keysAndValuesDo:
		[:index :each | each = anObject ifTrue: [past at: index put: replacement]].
	future keysAndValuesDo:
		[:index :each | each = anObject ifTrue: [future at: index put: replacement]]
)
public replaceCurrentWith: anObject = (
	self replace: currentVisitSlot with: anObject
)
public visit: anObject = (
	(* Make the argument the current object of the history. The prior current object becomes the last object of the 'past' queue. The 'future' queue is erased, unless the visit is equal to the first element of the future. *)
	currentVisitSlot = anObject ifTrue: [^self].
	(currentVisitSlot notNil and: [(isTransient: currentVisitSlot) not]) ifTrue:
		[past addLast: currentVisitSlot].
	currentVisitSlot:: anObject.
	(isTransient: anObject) ifFalse:
		[allVisits 
			remove: anObject ifAbsent: [];
			add: anObject].
	future isEmpty not ifTrue:
		[future first = currentVisitSlot
			ifTrue: [future removeFirst]
			ifFalse: [eraseFuture]].
)
) : (
)
class NavigationHistory = (| nextId ::= 1. ids <Map[Presenter, Integer]> = Map new. |) (
'as yet unclassified'
public idFor: x <Presenter> ^ <Integer> = (
	^ids at: x ifAbsentPut: [nextId:: nextId + 1]
)
public presenterFor: x <Integer> ^ <Presenter> = (
	^ids keyAtValue: x
)
) : (
)
class PaddedFrameComposer content: c offsets: o = Composer (|
	content = c.
	offsets = o.
	public color
|) (
'as yet unclassified'
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style')
		at: 'paddingLeft' put: (offsets at: 1) printString, 'px';
		at: 'paddingTop' put: (offsets at: 2) printString, 'px';
		at: 'paddingRight' put: (offsets at: 3) printString, 'px';
		at: 'paddingBottom' put: (offsets at: 4) printString, 'px'.
	color isNil ifFalse: [color applyToStyle: (div at: 'style')].
	content parent: self.
	div appendChild: content visual.
	^div
)
) : (
)
public class Presenter onSubject: aSubject = Fragment (|
subject ::= aSubject.
|) (
''
linkImage: image action: block = (
	^HyperlinkImageFragment image: image action: block
)
'as yet unclassified'
alert: text = (
	window alert: text
)
blank: size = (
	^BlankFragment new size: size
)
button: label <String> action: block <[]>= (
	^ButtonFragment label: label action: block
)
canvas: extent <Point> = (
	^CanvasFragment withExtent: extent
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> ^<Fragment> = (
	^collapsed: collapsed expanded: expanded initiallyExpanded: false
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> initiallyExpanded: flag <Boolean>
^<Fragment> = (
	^ToggleComposer
		collapsedDefinition: collapsed
		expandedDefinition: expanded
		initiallyExpanded: flag
)
column: definitions = (
	^ColumnComposer definitions: definitions
)
createVisual = (
	| substance = definition. |
	substance parent: self.
	^substance visual
)
deferred: contentSource <[Fragment]> ^<Fragment> = (
	^DeferredContentComposer initialContent: nothing contentSource: contentSource
)
public definition ^<Fragment> = (
	subclassResponsibility
)
enterSubject: s = (
	(* TODO: use sendUp and open a new window if undelivered *)
	^shell enterSubject: s
)
enterSubject: s <Subject> fromSnippet: snippet <SnippetSubject> = (
	(* TODO: use sendUp and open a new window if undelivered *)
	^shell enterSubject: s fromSnippet: snippet
)
expanded: expanded <[Fragment]> collapsed: collapsed <[Fragment]> ^<Fragment> = (
	^collapsed: collapsed expanded: expanded initiallyExpanded: true
)
filler = (
	^BlankFragment new expansibility: 1; compressibility: 1
)
holder: definition <[Fragment]> = (
	^HolderComposer withContent: definition
)
image: image = (
	^StaticImageFragment image: image
)
initially: initialContent <Fragment> deferred: contentSource <[Fragment]> ^<Fragment> = (
	^DeferredContentComposer initialContent: initialContent contentSource: contentSource
)
label: label <String> = (
	^StaticLabelFragment text: label
)
link: label <String> action: block <[]> = (
	^HyperlinkFragment label: label action: block
)
mediumBlank = (
	^blank: 10
)
nothing = (
	^BlankFragment new
)
padded: definition with: offsets = (
	^PaddedFrameComposer content: definition offsets: offsets
)
row: definitions = (
	^RowComposer definitions: definitions
)
textDisplay: string = (
	^TextDisplayFragment text: string
)
textField: initialText onAccept: blk = (
(* experimental *)
	 ^fragments TextEditorFragment new 
            text: initialText; 
            acceptResponse: blk (*[: editor | blk valueWithPossibleArgument: editor. editor defaultAcceptResponse] *)
)
public title ^<String> = (
	^subject title
)
) : (
)
class RowComposer definitions: fragments = SequenceComposer definitions: fragments (|
|) (
'as yet unclassified'
flexDirection = (
	^'row'
)
) : (
)
class SequenceComposer definitions: fragments = Composer (|
	definitions = fragments.
	public color
|) (
'as yet unclassified'
createVisual = (
	| container |
	container:: document createElement: 'div'.
	(container at: 'style')
		at: 'overflow' put: 'hidden';
		at: 'display' put: '-webkit-flex';
		at: 'display' put: 'flex';
		at: '-webkit-flex-direction' put: flexDirection;
		setProperty: 'flex-direction' to: flexDirection.
	color isNil ifFalse: 
		[color applyToStyle: (container at: 'style')].
	definitions do: [:fragment |
		| cell |
		fragment parent: self.
		cell:: document createElement: 'div'.
		cell appendChild: fragment visual.
		(cell at: 'style')
			at: '-webkit-flex-grow' put: fragment expansibility;
			setProperty: 'flex-grow' to: fragment expansibility;
			at: '-webkit-flex-shrink' put: fragment compressibility;
			setProperty: 'flex-shrink' to: fragment compressibility.
		fragment size isNil ifFalse:
			[(cell at: 'style') 
				at: 'flexBasis' put: fragment size printString, 'px';
				at: '-webkit-flex-basis' put: fragment size printString, 'px'].
		container appendChild: cell].
	^container
)
) : (
)
class StaticImageFragment image: i = LeafFragment (|
	image = i.
|) (
'as yet unclassified'
createVisual = (
	^image cloneNode: false (* Not deep *)
)
) : (
)
class StaticLabelFragment text: t = LeafFragment (|
	text = t.
	public color
|) (
'as yet unclassified'
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style') 
		at: 'overflow' put: 'hidden';
		setProperty: 'white-space' to: 'pre'.
	div at: 'textContent' put: text.
	color isNil ifFalse:
		[(div at: 'style') setProperty: 'color' to: color asCSSString].
	^div
)
) : (
)
public class Subject onModel: aModel = (|
	protected model ::= aModel.
	protected presenterX <Presenter>
|) (
'as yet unclassified'
public createPresenter ^<Presenter> = (
	subclassResponsibility
)
public presenter ^<Presenter> = (
	presenterX isNil ifTrue: [presenterX:: createPresenter].
	^presenterX
)
public title ^<String> = (
	^self printString
)
) : (
)
class TextDisplayFragment text: t = LeafFragment (|
	textX ::= t.
|) (
'as yet unclassified'
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style') setProperty: 'white-space' to: 'pre-wrap'.
	div at: 'textContent' put: textX.
	^div
)
public text = (
	^textX
)
public text: newText = (
	textX: newText.
	hasVisual ifTrue: [visual at: 'textContent' put: textX]
)
) : (
)
public class TextEditorFragment = LeafFragment (|
	textX ::= ''.
	counterfactualBarX
	editorX
	public textBeingAccepted
	isInEditState ::= false.
	public changeResponse
	public acceptResponse
	public cancelResponse
|) (
'as yet unclassified'
controlBarColor = (
	^Color r: 0.95 g: 0.792 b: 0.475
)
createVisual = (
	| frame editorWrapper accept cancel |
	frame:: document createElement: 'div'.
	(frame at: 'style')
		at: 'display' put: '-webkit-flex';
		at: 'display' put: 'flex'.
	editorX:: document createElement: 'div'.
	editorX at: 'contentEditable' put: 'true'.
	(editorX at: 'style')
		at: 'borderStyle' put: 'solid';
		at: 'borderWidth' put: '1px';
		at: 'borderColor' put: 'gray';
		setProperty: 'background-color' to: 'white';
		at: 'flex' put: 1;
		at: '-webkit-flex' put: 1;
		at: '-moz-flex' put: 1;
		setProperty: 'white-space' to: 'pre-wrap';
		at: 'display' put: 'block'.
	editorX at: 'textContent' put: textX.
	editorX addEventListener: 'input' with: [respondToChange].
	counterfactualBarX:: document createElement: 'span'.
	(counterfactualBarX at: 'style')
		at: 'backgroundColor' put: controlBarColor asCSSString;
		at: 'flex' put: 'none';
		at: '-webkit-flex' put: 'none';
		at: '-moz-flex' put: 'none'.
	accept:: document createElement: 'img'.
	accept at: 'src' put: (accept16px yourself at: 'src').
	(accept at: 'style') at: 'margin' put: '3px'.
	accept at: 'onclick' put: [respondToAccept].
	cancel:: document createElement: 'img'.
	cancel at: 'src' put: (cancel16px yourself at: 'src').
	(cancel at: 'style') at: 'margin' put: '3px'.
	cancel at: 'onclick' put: [respondToCancel].
	counterfactualBarX appendChild: accept.
	counterfactualBarX appendChild: cancel.
	frame appendChild: editorX.
	(* frame appendChild: counterfactualBarX. *)
	^frame
)
public defaultAcceptResponse = (
	textX:: textBeingAccepted.
	leaveEditState
)
defaultCancelResponse = (
	setVisualText: textX.
	leaveEditState
)
defaultChangeResponse = (
	enterEditState
)
enterEditState = (
	isInEditState ifFalse:
		[visual appendChild: counterfactualBarX.
		isInEditState:: true].
	visual scrollIntoView: true (* alignWithTop *).
)
public leaveEditState = (
	isInEditState ifTrue:
		[visualX removeChild: counterfactualBarX.
		isInEditState:: false.
		(*removeMessages*)]
)
respondToAccept = (
	textBeingAccepted:: editorX at: 'textContent' (*withSqueakLineEndings*).
	acceptResponse 
		ifNil: [defaultAcceptResponse]
		ifNotNil: [acceptResponse cull: self]
)
respondToCancel = (
	(*confirm: 'Confirm Cancel' ifConfirmed:
		[*)cancelResponse 
			ifNil: [defaultCancelResponse]
			ifNotNil: [cancelResponse cull: self](*]*)
)
respondToChange = (
	textBeingAccepted:: editorX at: 'textContent'.
	changeResponse 
		ifNil: [defaultChangeResponse]
		ifNotNil: [changeResponse cull: self]
)
setVisualText: aText = (
	hasVisual ifTrue: [editorX at: 'textContent' put: aText]
)
public text = (
	^textX
)
public text: t = (
	textX: t.
	setVisualText: textX.
)
) : (
)
class ToggleComposer collapsedDefinition: collapsed
 expandedDefinition: expanded
 initiallyExpanded: flag = Composer (|
expandedDefinition = expanded.
collapsedDefinition = collapsed.
isExpanded ::= flag.
expandedPresenter
collapsedPresenter
contentHolder
toggleWidget
|) (
'as yet unclassified'
public collapse = (
	installCollapsedPresenter
)
createVisual = (
	| toggleDiv div |
	contentHolder:: document createElement: 'div'.
	
	toggleDiv:: document createElement: 'div'.
	toggleWidget:: document createElement: 'img'.
	toggleWidget at: 'onclick' put: [userToggle].
	toggleDiv appendChild: toggleWidget.
	
	(contentHolder at: 'style') 
		at: '-webkit-flex-grow' put: 1;
		setProperty: 'flex-grow' to: 1;
		at: '-webkit-flex-shrink' put: 1;
		setProperty: 'flex-shrink' to: 1.
	(toggleDiv at: 'style') 
		at: '-webkit-flex-grow' put: 0;
		setProperty: 'flex-grow' to: 0;
		at: '-webkit-flex-shrink' put: 0;
		setProperty: 'flex-shrink' to: 0;
		at: 'paddingTop' put: '2px';
		at: 'paddingRight' put: '3px'.
	toggleWidget at: 'align' put: 'top'.
	
	isExpanded
		ifTrue: [installExpandedPresenter]
		ifFalse: [installCollapsedPresenter].
		
	div:: document createElement: 'div'.
	(div at: 'style')
		at: 'display' put: '-webkit-flex';
		at: 'display' put: 'flex';
		at: '-webkit-flex-direction' put: 'row';
		setProperty: 'flex-direction' to: 'row'.
	div appendChild: toggleDiv.
	div appendChild: contentHolder.
	^div
)
public expand = (
	installExpandedPresenter
)
installCollapsedPresenter = (
	collapsedPresenter isNil ifTrue: 
		[collapsedPresenter:: collapsedDefinition value.
		collapsedPresenter parent: self].
	installContentVisual: collapsedPresenter visual.
	toggleWidget at: 'src' put: (disclosureClosedImage at: 'src').
)
installContentVisual: newVisual = (
	contentHolder hasChildNodes
		ifTrue:
			[ | oldVisual = contentHolder at: 'firstChild'. |
			contentHolder replaceChild: newVisual with: oldVisual]
		ifFalse: [contentHolder appendChild: newVisual].
)
installExpandedPresenter = (
	expandedPresenter isNil ifTrue:
		[expandedPresenter:: expandedDefinition value.
		expandedPresenter parent: self].
	installContentVisual: expandedPresenter visual.
	toggleWidget at: 'src' put: (disclosureOpenImage at: 'src').
)
userToggle = (
	isExpanded:: isExpanded not.
	isExpanded
		ifTrue: [installExpandedPresenter]
		ifFalse: [installCollapsedPresenter].
)
) : (
)
'as yet unclassified'
deferAction: action = (
	deferredContentQueue add: action.
	deferredContentQueue size = 1 ifTrue:
		[nextFrameDo: [nextDeferredAction]].
)
nextDeferredAction = (
	| action = deferredContentQueue removeFirst. |
	deferredContentQueue size > 0 ifTrue:
		[nextFrameDo: [nextDeferredAction]].
	action value.
)
nextFrameDo: action = (
	(* Our goal is to run the argument after images have been loaded and rendered. window.requestAnimationFrame runs the callback *before* the next frame. We register another callback in the callback so the first deferred action runs *after* the next frame. We register *that* callback in another RAF callback to let new images added from a deferred block load and render before the next deferred block runs. RAF is also a relative new feature, so simply schedule a timer if it is not available. *)
	(window at: 'requestAnimationFrame') isUndefined
		ifTrue: [Timer after: 200 do: action]
		ifFalse: [window requestAnimationFrame: [
					window requestAnimationFrame: [
						window requestAnimationFrame: action]]].
)
sharedNavigator ^ <NavigationHistory> = (
	sharedNavigationHistory ifNil:[
		sharedNavigationHistory:: NavigationHistory new.
		].
	^sharedNavigationHistory
)
) : (
)
