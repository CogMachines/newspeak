Newspeak3
'Newspeak3CompilerAdaptor'
class Newspeak3CompilerAdaptor usingPlatform: platform = (
(*
Copyright (c) 2010  Felix Geller. 
Copyright (c) 2011  Ryan Macnak and Cadence Design Systems

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ''Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. *)|

	Language = platform blackMarket NsMultilanguage Language.
	LanguageCompiler = platform blackMarket NsMultilanguage LanguageCompiler.
	LanguageFileWriter = platform blackMarket NsMultilanguage LanguageFileWriter.
	SHRange = platform blackMarket Shout SHRange.
	ImplementationBase = platform blackMarket NewspeakCore ImplementationBase.
	TextColor = platform blackMarket Collections TextColor.
	TextEmphasis = platform blackMarket Collections TextEmphasis.
	Color = platform blackMarket Graphics Color.
	Error = platform blackMarket Exceptions Error.
	Smalltalk = platform blackMarket Smalltalk.
	
	Dictionary = platform collections Dictionary.
	OrderedCollection = platform collections OrderedCollection.
	TokenizingParser = platform mirrors parserLib TokenizingParser.	
	TypedNS3Grammar = platform mirrors grammar TypedNS3Grammar.
	compilation = platform mirrors compilation.
	Compiler = compilation Compiler.
	mirrors = platform mirrors.
	
	NSObject = platform kernel Object.
	ns3Lang = NewspeakLanguage3 new.
	blackMarket = platform blackMarket.
	vmmirror = blackMarket VMMirror new.
|)
(
class NS3BrowserColorizer = NS3Colorizer (|
	coloredText
|)
('as yet unclassified'
applyColor: kind from: start to: end  = (
(* Hacked up to roughly match the table in SHTextStylerST80 newsqueakStyleTable.
The advantage is that this code is not dependent on Shout *)

	({#error. #undefinedUnary. #undefinedKeyword. #undefinedBinary.} includes: kind)
		ifTrue:
			[ coloredText addAttribute: TextColor red from: start to: end.
			coloredText addAttribute: TextEmphasis underlined from: start to: end.
			^self ].

	({#shadowingTempVar. #obsoleteMessage} includes: kind)
		ifTrue:
			[coloredText addAttribute: TextEmphasis bold from: start to: end.
			coloredText addAttribute: (TextColor color: Color orange) from: start to: end.
			coloredText addAttribute: TextEmphasis underlined from: start to: end.
			^self ].

	({#incompleteKeyword. #incompleteBinary. #incompleteUnary.} includes: kind)
		ifTrue:
			[ coloredText addAttribute: TextEmphasis underlined from: start to: end. ^self ].

	({ #self. #super. #outer. #true. #false. #nil. #string. #symbol. #stringSymbol. #number. #character.  #protected. #private. #public } includes: kind)
		ifTrue:
			[ 
			 coloredText addAttribute: TextColor gray from: start to: end. 
			^self 
			].
		
	({#tempVar. #blockTempVar. #blockPatternArg. #patternArg. #patternTempVar} includes: kind)
		ifTrue:
			[ coloredText addAttribute: TextEmphasis bold from: start to: end. 
			  coloredText addAttribute: TextColor gray from: start to: end. 
			^self 
			].
		
			({#methodTempBar. #leftParenthesis. #rightParenthesis.  #leftParenthesis3. #rightParenthesis3.  #leftParenthesis6. #rightParenthesis6. #blockStart. #blockEnd.  #blockStart3. #blockEnd3.  #blockStart6. #blockEnd6.  #leftBrace. #rightBrace.  #leftBrace3. #rightBrace3.  #leftBrace6. #rightBrace6. 
} includes: kind)
		ifTrue:
			[ coloredText addAttribute: TextEmphasis bold from: start to: end. 
			  coloredText addAttribute: TextColor black from: start to: end. 
			^self 
			].
	#slotDecl = kind
		ifTrue:
			[ coloredText addAttribute: TextEmphasis bold from: start to: end. 
			  coloredText addAttribute: TextColor gray from: start to: end. 
			^self 
			].

	#messagePatternDecl = kind
		ifTrue:
			[ coloredText addAttribute: TextEmphasis bold from: start to: end. ^self ].
		
	kind = #comment
		ifTrue:[ coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end. 
			^self ].
		
		({#type. #return. #leftParenthesis1. #rightParenthesis1.  #leftParenthesis4. #rightParenthesis4. #leftParenthesis7. #rightParenthesis7. #blockStart1. #blockEnd1.  #blockStart4. #blockEnd4.  #blockStart7. #blockEnd7.  #leftBrace1. #rightBrace1.  #leftBrace4. #rightBrace4.  #leftBrace7. #rightBrace7.} includes: kind)
		ifTrue:
			[ coloredText addAttribute: TextEmphasis bold from: start to: end. 
			  coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end. 
			^self ].
		({#leftParenthesis2. #rightParenthesis2. #leftParenthesis5. #rightParenthesis5.   #blockStart2. #blockEnd2.  #blockStart5. #blockEnd5.  #leftBrace2. #rightBrace2.  #leftBrace5. #rightBrace5 } includes: kind)
		  ifTrue:[coloredText addAttribute: TextEmphasis bold from: start to: end. 
			  coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end. 
			].

	(* Transcript show: kind; cr. *)
)
applyRanges =(	
	rangeMap do: [ :blk | blk value ].
	^coloredText
)
classDefinitionTemplate = (
	^(tokenFromSymbol: #class), [classHeader]
)
noteRange: kind from: start to: end = (
	start = 0 ifTrue:[^self].
	rangeMap add: [ applyColor: kind from: start to: end ].
)
parseText: s <String> fromClass: c <Class> usingSelector: selector <Symbol> ^<Text> = (
	| stream parser |

	assert: [s isString].

	inputSize:: s size.
	klass:: c.
	bracketDepth:: 0.
	braceDepth:: 0.
	parenDepth:: 0.
	rangeMap:: OrderedCollection new.
	cachedScopeStack: nil.

	coloredText:: s asText.
	stream:: s readStream.

	parser:: (perform: selector), [eoi].
	parser parse: stream ifError: [ :msg :pos | 
		noteRange: #error from: pos to: inputSize. 
		^applyRanges ].
	^applyRanges
)
rangesIn: s classOrMetaClass: c workspace: w environment: e = (
^Error signal
)) : ()
class NS3Colorizer = TypedNS3Grammar (|
	cachedScopeStack
	klass
	rangeMap
	inputSize
	startComment
	braceDepth
	bracketDepth
	parenDepth
	isFirst ::= true.
|)
('as yet unclassified'
accessModifier = (
	^super accessModifier wrapper: [ :mod :ws |
		noteRange: mod token asSymbol from: mod start to: mod end.
		mod]
)
assignment = (
	^super assignment
		 wrap:[:t | self noteRange: #assignment from: t start to: t end].
)
beginComment = (
	^ (TokenizingParser new parser: super beginComment) 
			wrap:[:t | 
				self noteRange: #unfinishedComment from: t start to: self inputSize. t].
)
binaryMsgPattern = (
^super binaryMsgPattern
    wrapper:[:sel <Token>  :p <Tuple[Token, Token]> |
	          self pushScope.
	          self currentScope at: p first token put: #parameter.
                self noteRange: #messagePatternDecl from: sel start to: sel end.
                self noteRange: #patternArg from: p first start to: p first end.             
               ].
)
binarySelector = (
^super binarySelector
   wrap:[:t | 
           (Symbol hasInterned: t token ifTrue:[:s | self noteRange: #binary from: t start to: t end])
              ifFalse:[(Symbol thatStartsCaseSensitive: t token skipping: nil) isNil
                          ifTrue:[self noteRange: #undefinedBinary from: t  start to: t end]
                          ifFalse:[self noteRange: #incompleteBinary from: t start to: t end]
                      ].
           t.
         ].
)
block = (
^super block 
   wrapper:[:lb :params :cb :rb |
                  params isNil ifFalse:[params isEmpty ifFalse:[self popScope]].
                  {lb. params. cb. rb}
  ]
)
blockParameter = (
	^super blockParameter wrapper: [ :cn :sd | (* blockParameter ::= colon, slotDecl *)
		| kind |
		kind:: (symbolInScope: sd first token) ifTrue: [#shadowingTempVar] ifFalse: [#blockPatternArg].
		noteRange: kind from: sd first start to: sd first end.
		sd]
)
blockParameters = (
^super blockParameters
   wrapper:[:ps :vb  | self pushScope. 
	                         ps do:[:p | self currentScope at: p first token put: #parameter].
	                         {ps. vb}
	          ]
)
braceLevelString = (
^self braceDepth = 1 ifTrue:[''] ifFalse:[self braceDepth printString]
)
bracketLevelString = (
	^ self bracketDepth = 1 ifTrue:[''] ifFalse:[self bracketDepth printString]
)
characterConstant = (
	^ super characterConstant 
		   wrap:[: t | self noteRange: #'$' from: t start to: t end. t].
)
classHeader = (
	^super classHeader
		wrap:
			[ :tokens |
			(tokens at: 7) = nil ifFalse:
				[ | decs |
					decs:: (tokens at: 7) size = 3 ifTrue: [
						((tokens at: 7) at: 2) ] ifFalse: [(tokens at: 7) at: 3].			
					
					decs
					do: [ :each | noteRange: #slotDecl from: (each at: 2) first start to: (each at: 2) first end ] ].
			tokens ]
)
codeBody = (
^super codeBody
  wrapper:[:litMsg :tmps :stmts | tmps isNil ifFalse:[tmps isEmpty ifFalse:[self popScope]].
	                                 {tmps. stmts}
	         ]
)
currentScope = (
self assert: [self scopeStack isEmpty not].
^self scopeStack last
)
decreaseBraceLevel = (
	self braceDepth: (self braceDepth - 1) \\ 7.
)
decreaseBracketLevel = (
self bracketDepth: (self bracketDepth - 1) \\ 7.
)
decreaseParenLevel = (
self parenDepth: (self parenDepth - 1) \\ 7.
)
endComment = (
^(TokenizingParser new parser: super endComment) wrap:[:t | self rangeMap removeLast. t].
)
extendedCanUnderstand: sel = (
	| k |
	k: klass.
	[k isNil] whileFalse: [
		(k canUnderstand: sel) ifTrue: [^true].
		k: k enclosingClass.
	].

	klass mixin applications do: [:any | ^any canUnderstand: sel].
	^Object canUnderstand: sel
)
increaseBraceLevel = (
self braceDepth: (self braceDepth + 1) \\ 7.
)
increaseBracketLevel = (
self bracketDepth: (self bracketDepth + 1) \\ 7.
)
increaseParenLevel = (
	self parenDepth: (self parenDepth + 1) \\ 7.
)
keywordHereSend = (
	^super keywordHereSend wrap:[ :kws | | sel  kind  |
		sel:: String streamContents: [ :s |
			kws do: [ :kwd |
				self rangeMap removeLast.
				s nextPutAll: kwd first token]].
		kind:: symbol: sel
			ifInScope: [#instVar] ifNotInScope: [#undefinedKeyword] ifObsolete: [#obsoleteMessage].
		kws do: [:kwp |
			self noteRange: kind from: kwp first start to: kwp first end]]
)
keywordMsg = (
^super keywordMsg
          wrap:[:kws  |
                  | sel  kind  |
                    sel:: (kws inject:'' into:[:s    :kwd   | 
                                                 s, (kwd at:1) token
                                               ]) asString.
                  (Symbol hasInterned: sel ifTrue:[:s | kind:: #keyword])
                     ifFalse:[(Symbol thatStartsCaseSensitive: sel skipping: nil) isNil
                          ifTrue:[kind:: #undefinedUnary]
                          ifFalse:[kind:: #incompleteUnary]
                      ].
                    
                    kws do:[:kwp |  
                              self noteRange: kind from: kwp first start to: kwp first end. 
                             ].                         
                 ].
)
keywordMsgPattern = (
	^super keywordMsgPattern wrap: [ :kws |
		assert: [kws isEmpty not].
		pushScope.
		kws do: [ :kwp | | kind |
			kind:: (symbolInScope: kwp last first token) ifTrue: [#shadowingTempVar] ifFalse: [#patternArg].
			currentScope at: kwp last first token put: #parameter.
			noteRange: #messagePatternDecl from: kwp first start to: kwp first end.
			noteRange: kind from: kwp last first start to: kwp last first end]]
)
lbracket = (
^super lbracket
   wrap:[:t | 
           | range |
           self increaseBracketLevel.
           range:: ('blockStart', self bracketLevelString) asSymbol.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
lcurly = (
^super lcurly
   wrap:[:t | 
           | range |
           self increaseBraceLevel.
           range:: ('leftBrace', self braceLevelString) asSymbol.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
lparen = (
^super lparen 
   wrap:[:t | 
           | range |
           self increaseParenLevel.
           range:: ('leftParenthesis', self parenLevelString) asSymbol.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
method = (
| res |
  self pushScope.
  res:: super method.
  self popScope.
  ^res
)
methodDef = (
| res |
  self pushScope.
  res:: super methodDef.
  self popScope.
  ^res
)
noteRange: kind from: start to: end  = (
self rangeMap addLast: (SHRange new start: start; end: end; type: kind).
)
number = (
^super number
   wrap:[: t | self noteRange: #number from: t start to: t end. t].
)
parenLevelString = (
	^self parenDepth = 1 ifTrue:[''] ifFalse:[self parenDepth printString]
)
pascalComment = (
^super pascalComment
    wrapper:[:token | self noteRange: #comment from: token start to: token end].
)
pattern = (
^super pattern
   wrap:[ :tpl | self noteRange: #string 
					from: (tpl at: 1) start 
					to: (tpl at: 3) end.
			tpl at: 2 ]
)
popScope = (
	self scopeStack removeLast
)
pushScope = (
self scopeStack addLast: Dictionary new
)
rangesIn: s classOrMetaClass: c workspace: w environment: e = (
| defaultRange input  |

self inputSize: s size.
self rangeMap: (OrderedCollection new: self inputSize).
self klass: c.
self bracketDepth: 0.
self braceDepth: 0.
self parenDepth: 0.
input:: s readStream.

defaultRange:: SHRange new start:1; end: self inputSize; type: #default.
self rangeMap add: defaultRange.
self methodDecl parse: input ifError:[:msg :pos | 
                                        self rangeMap add:( SHRange new start:(pos max:1); end: self inputSize; type:#excessCode).
                                        ^self rangeMap.
                                       ].
input position < self inputSize 
   ifTrue:[self rangeMap add:( SHRange new start: input position + 1 ; end: self inputSize; type:#excessCode)].
^self rangeMap
)
rbracket = (
^super rbracket
   wrap:[:t | 
           | range |
           range:: ('blockEnd', self bracketLevelString) asSymbol.
           self decreaseBracketLevel.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
rcurly = (
^super rcurly 
   wrap:[:t | 
           | range |
           range:: ('rightBrace', self braceLevelString) asSymbol.
           self decreaseBraceLevel.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
returnStatement = (
^super returnStatement
  wrapper:[:h <Token>  : expr :od <Token>  | 
               self noteRange: #return from: h start to: h end.
               expr
             ].
)
returnType = (
^super returnType
   wrapper:[:h <Token> :t | self noteRange: #type from: h start to: h end. t]
)
rparen = (
^super rparen 
   wrap:[:t | 
           | range |
           range:: ('rightParenthesis', self parenLevelString) asSymbol.
           self decreaseParenLevel.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
scopeStack = (
	(* deal with forwarding reference *)
	cachedScopeStack isCollection 
		ifFalse: [ cachedScopeStack:: OrderedCollection new ].
	^ cachedScopeStack
)
semicolon = (
^super semicolon
  wrap:[:t | self noteRange: #cascadeSeparator from: t start to: t end. t].
)
setterKeyword = (
	^super setterKeyword wrap:[ :skw <Token> | | kind  |
		kind:: (self symbolInScope: (skw token copyUpToLast: $:))
			ifTrue:[#instVar]
			ifFalse:[#undefinedKeyword].
		self noteRange: kind from: skw  start to: skw end.
		skw]
	)
slotDef = (
	^ super slotDef wrap: [ :tokens | | sd kind |
		sd:: (tokens at: 2) first.
		noteRange: #slotDecl from: sd start to: sd end.
		
		(* isFirst ifTrue: [pushScope. isFirst: false]. *)
		
		tokens]
)
slotName = (
	^super slotName wrap: [:n <Token> |
		| kind |
		kind:: ({'self'. 'super'. 'outer'. 'true'. 'false'. 'nil'. 'thisContext'} includes: n token)
			ifTrue: [n token asSymbol]
                  ifFalse: [symbol: n token
			ifInScope: [#instVar] ifNotInScope: [#undefinedUnary] ifObsolete: [#obsoleteMessage]].
		noteRange: kind from: n start to: n end.
		n]
)
smalltalkComment = (
^super smalltalkComment
    wrapper:[:oq :b :eq | self noteRange: #comment from: oq start to: eq end].
)
string = (
^super string
   wrap:[:t | self noteRange: #string from: t start to: t end. t]
)
symbol: aString <String> ifInScope: inScopeAction ifNotInScope: notInScopeAction ifObsolete: obsoleteAction = (
	scopeStack do: [:s | (s includesKey: aString) ifTrue:[^inScopeAction value]].
	Symbol hasInterned: aString ifTrue: [ :sel <Symbol> |
		scopeStack do: [:s | (s includesKey: sel) ifTrue:[^inScopeAction value]].
		(extendedCanUnderstand: sel) ifTrue:[
			(ImplementationBase canUnderstand: sel)
				ifTrue: [^obsoleteAction value]
				ifFalse: [^inScopeAction value]]].
	^notInScopeAction value
)
symbolConstant = (
^super symbolConstant
   wrapper:[:p <Token>  :s | 
               self noteRange: #symbol from: p start to: s end.
               s.
              ].
)
symbolInScope: aString <String> ^ <Boolean> = (
	scopeStack do: [:s | (s includesKey: aString) ifTrue:[^true]].
	^Symbol hasInterned: aString ifTrue: [ :sel <Symbol> |
		scopeStack do: [:s | (s includesKey: sel) ifTrue:[^true]].
		(extendedCanUnderstand: sel) ifTrue:[^true].
		^false]
)
tempSlotDef = (
	^ super slotDef wrap: [ :tokens | | sd kind |
		sd:: (tokens at: 2) first.
		noteRange: #slotDecl from: sd start to: sd end.
		
		isFirst ifTrue: [pushScope. isFirst: false].
		
		kind:: (symbolInScope: sd token) ifTrue: [#shadowingTempVar] ifFalse: [#tempVar].
		currentScope at: sd token put: #temporary.
		currentScope at: sd token, ':' put: #temporary.
		noteRange: kind from: sd start to: sd end.
		
		tokens]
)
temporaries = (

	|
	tempSlotDefs = tempSlotDef star.
 	tempSeqSlotDecls = vbar, tempSlotDefs, vbar.
 	tempSimSlotDecls = vbar, vbar, tempSlotDefs, vbar, vbar.
 	tempSlotDecls = tempSimSlotDecls | tempSeqSlotDecls.
	|

^ tempSlotDecls wrap: [ :parts | 
	| vb1 vb2 vds vb3 vb4 |
	
	parts size = 3 ifTrue: [ 
		vb1:: parts at: 1.
		vb2:: vb1. 
		vds:: parts at: 2. 
		vb3:: parts at: 3.
		vb4:: vb3] ifFalse: [ 
		vb1:: parts at: 1. 
		vb2:: parts at: 2.
		vds:: parts at: 3.
		vb3:: parts at: 4.
		vb4:: parts at: 5].
	
	isFirst: true.
	noteRange: #methodTempBar from: vb1 start to: vb2 end.
	noteRange: #methodTempBar from: vb3 start to: vb4 end.
	vds]
)
type = (
^super type
   wrapper:[:lb :te : rb | self noteRange: #type from: lb start to: rb end. te]
)
unaryMsgPattern = (
	^super unaryMsgPattern
		wrap:
			[:sel <Symbol> |
			self noteRange: #messagePatternDecl from: sel start to: sel end.
			sel ].
)
unarySelector = (
^super unarySelector
   wrap:[:t | 
           (Symbol hasInterned: t token ifTrue:[:s | self noteRange: #unary from: t start to: t end])
              ifFalse:[(Symbol thatStartsCaseSensitive: t token skipping: nil) isNil
                          ifTrue:[self noteRange: #undefinedUnary from: t  start to: t end]
                          ifFalse:[self noteRange: #incompleteUnary from: t start to: t end]
                      ].
           t.
         ].
)
variableName = (
^super variableName
  wrap:[:n <Token> |   n token = 'self'
                  ifTrue:[self noteRange: #self from: n start to: n end]
                  ifFalse:[n token = 'super' ifTrue:[self noteRange: #super from: n start to: n end]
                  ifFalse:[n token = 'true' ifTrue:[self noteRange: #true from: n start to: n end]
                  ifFalse:[n token = 'false' ifTrue:[self noteRange: #false from: n start to: n end]
                  ifFalse:[n token = 'nil' ifTrue:[self noteRange: #nil from: n start to: n end]
                  ifFalse:[n token = 'thisContext' ifTrue:[self noteRange: #thisContext from: n start to: n end]
                  ifFalse:[]]]]]].
             n.
         ]
)) : ()
class Newspeak3CompilerAdaptor = LanguageCompiler (
(* I'd rather subclass Newspeak2Compilation`Compiler but this fails because of a bug in NS2Compiler, which doesn't set the enclosingObject slots correctly. *)|
	language = ns3Lang.
	compiler = Compiler new language: language; yourself.
|)
('as yet unclassified'
compileClassHeader: src <Stream> of: klassMirror <NS2Mixin> ^ <Class> = (
	self halt.
(*	|
		newRep <MixinRep>
		klass <Class>
		metadata <DefiningClassMetadata>
		compiledMixinMirror <CompiledMixinMirror>
		mixinRep <MixinRep>
		klassMixinRep <MixinRep>
	|
	
	klass:: klassMirror implementationMirror implementationClass.
	metadata:: SystemMetadata definingClassMetadataOf: klass.
	newRep:: compiler compileClassHeader: src of: klassMirror.
	^(metadata enclosingClass)
		ifNil:[
			mixinRep:: mirrors mixinRepFor: klass.
			compiledMixinMirror: newRep first.
			mixinRep at: 1 put: compiledMixinMirror.
			(reflection installMixinReps: { mixinRep }) first ]
		ifNotNil:[:ec |
			mixinRep:: mirrors mixinRepFor: ec.
			klassMixinRep:: (mixinRep at: 2) detect: [ :mr | (mr first name) = klass name].
			compiledMixinMirror:: newRep last first first.	
			klassMixinRep at: 1 put: compiledMixinMirror.
			reflection installMixinReps: { {newRep first. mixinRep last} }.
 			klass ] *)
)
compileMethodSource: src <ReadStream> 
category: category <String> 
within: cls <Class> ^ <Symbol> = (

	| builder methodBuilder |
	builder:: mirrors MixinBuilder reflecting: cls mixin.
	methodBuilder:: (builder methods addFromSource: src).
	methodBuilder category: category.
	builder declaration install.
	^methodBuilder simpleName
)
compileMethodSource: src <ReadStream> 
within: cls <Class> ^ <Symbol> = (
	^ compileMethodSource: src category: #'as yet unclassified' within: cls.
)
compileNestedClass: ns <ClassDeclarationAST> within: aClass <Class> = (
	self halt.
(*	| 
		moduleClass <Class>
		moduleMixinRep <MixinRep>
		enclosingClassMixinRep <MixinRep>
		nestedClasses 	<Collection[MixinRep]>		
		classMirror <NS2ClassStencilMirror>
		classSource <String>
		compilationResult <Collection[MixinRep]>
		installedClass <Class>
		nestedClassName <String>
	| 
	classSource:: (wrapClassSource: input contents for: aClass) readStream.
	
	moduleClass:: (SystemMetadata definingClassMetadataOf: aClass) definingModule.
	moduleMixinRep:: mirrors mixinRepFor: moduleClass.

	enclosingClassMixinRep:: findMixinRepOfClassNamed: aClass name inMixinReps: { moduleMixinRep }.	
	classMirror:: reflection mixinFor: aClass. 

	compilationResult:: compiler compileClassSource: classSource within: classMirror.
	
	enclosingClassMixinRep at: 1 put: compilationResult first.
	
	nestedClassName:: (compilationResult at: 2) first first name.
	enclosingClassMixinRep second removeAllSuchThat: [ :mr | mr first name = nestedClassName ].
	enclosingClassMixinRep second add: (compilationResult at: 2) first.

	installedClass:: (reflection installMixinReps: { moduleMixinRep }) anyOne.
	^ (SystemMetadata allNestedClassesOf: installedClass) detect: [ :nc | nc name = nestedClassName] *)
)
compileNestedClassSource: src <String> within: aClass <Class> = (
	
	| enclosing newClass |
	enclosing:: mirrors MixinBuilder reflecting: aClass mixin.
	newClass:: enclosing nestedClasses addFromSource: src.
	^newClass install reflectee definingClass
)
compileUnit: src <Stream> ^ <Class> = (
		(* Compile File *)
	| builder mixinMirror klass |
	builder:: mirrors ClassDeclarationBuilder fromUnitSource: src.
	Smalltalk at: builder simpleName ifPresent: [:it | builder prvtExistingMixin: it mixin].
	mixinMirror:: builder install.
	klass:: mixinMirror reflectee apply: NSObject withName: mixinMirror simpleName.
	Smalltalk at: klass name put: klass.
	klass category: mixinMirror reflectee definingClass category.
	blackMarket SystemOrganization classify: klass name under: klass category.
	^klass
)
evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag = (
	
	| string |
	string:: textOrStream readStream contents asString. (* Ugly coercion *)

	aContext ifNil: [
		(* Inspector DoIt *)
		^((mirrors ObjectMirror reflecting: receiver) evaluate: string) reflectee
	] ifNotNil: [
		(* Debugger DoIt *)
		^((mirrors ActivationMirror reflecting: aContext) evaluate: string) reflectee
	].
)
findMixinRepOfClassNamed: className <String> inMixinReps: mixinReps <MixinRep> ^ <MixinRep> = (
	
	(* Do a breadth-first-search on mixin reps.
	Why do we do it this way? We could make use of the naming scheme and only follow the right mixins. *)
	| nestedMixinReps |
	nestedMixinReps:: OrderedCollection new.
	mixinReps do: [:mr |
		mr first name = className
			ifTrue: [^ mr]
			ifFalse: [nestedMixinReps addAll: (mr at: 2)]].

	nestedMixinReps isEmpty
		ifTrue: [mixinReps errorNotFound: className]
		ifFalse: [^ findMixinRepOfClassNamed: className inMixinReps: nestedMixinReps].
)
wrapClassSource: src for: aClass = (
	| cat <String> |
	cat:: aClass category.
	cat isNil ifTrue:[cat:: 'Uncategorized NS3'].
	^ 'Newspeak3 ''', cat,''' ',src
)) : ('as yet unclassified'
evaluate: textOrString for: anObject logged: logFlag = (
	^self evaluate: textOrString for: anObject notifying: nil logged: logFlag
)
evaluate: textOrString for: anObject notifying: aController logged: logFlag = (
	(* Compile and execute the argument, textOrString with respect to the class 
	of anObject. If a compilation error occurs, notify aController. If both 
	compilation and execution are successful then, if logFlag is true, log 
	(write) the text onto a system changes file so that it can be replayed if 
	necessary. *)

	^ self new
				evaluate: textOrString
				in: nil
				to: anObject
				notifying: aController
				ifFail: [^nil]
				logged: logFlag.
))
class NewspeakColorizerPreferences = (
(*  *)|  |)
('as yet unclassified'
Nil ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
      ].
)
Self ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
      ].
)
Super ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
      ].
)
applyColor: kind <Symbol> from: start <Integer> to: end  <Integer> = (
	(perform: kind) value: start value: end
)
blockEnd ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockEnd1 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockEnd2 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockEnd3 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockEnd4 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockEnd5 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockEnd6 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockEnd7 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockPatternArg ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockStart ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockStart1 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockStart2 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockStart3 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockStart4 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockStart5 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockStart6 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockStart7 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
blockTempVar ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
boolean ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
      ].
)
character ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
      ].
)
comment ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
      ].
)
error ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor red from: start to: end.
	coloredText addAttribute: TextEmphasis underlined from: start to: end.
      ].
)
incompleteBinary ^ <[]> = (
	^[ :start :end |
	coloredText addAttribute: TextEmphasis underlined from: start to: end.
      ].
)
incompleteKeyword ^ <[]> = (
	^[ :start :end |
	coloredText addAttribute: TextEmphasis underlined from: start to: end.
      ].
)
incompleteUnary ^ <[]> = (
	^[ :start :end |
	coloredText addAttribute: TextEmphasis underlined from: start to: end.
      ].
)
leftBrace ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftBrace1 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftBrace2 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftBrace3 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftBrace4 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftBrace5 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftBrace6 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftBrace7 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftParenthesis ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftParenthesis1 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftParenthesis2 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftParenthesis3 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftParenthesis4 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftParenthesis5 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftParenthesis6 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
leftParenthesis7 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
messagePatternDecl ^ <[]> = (
	^[ :start :end | 
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
methodTempBar ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
number ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
      ].
)
patternArg ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
patternTempVar ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
return ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightBrace ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightBrace1 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightBrace2 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightBrace3 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightBrace4 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightBrace5 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightBrace6 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightBrace7 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightParenthesis ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightParenthesis1 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightParenthesis2 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightParenthesis3 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightParenthesis4 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightParenthesis5 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightParenthesis6 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor black from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
rightParenthesis7 ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
slotDecl ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
string ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
      ].
)
stringSymbol ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
      ].
)
symbol ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
      ].
)
tempVar ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor gray from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
type ^ <[]> = (
	^[ :start :end | coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end.
	coloredText addAttribute: TextEmphasis bold from: start to: end.
      ].
)
undefinedBinary ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor red from: start to: end.
	coloredText addAttribute: TextEmphasis underlined from: start to: end.
      ].
)
undefinedKeyword ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor red from: start to: end.
	coloredText addAttribute: TextEmphasis underlined from: start to: end.
      ].
)
undefinedUnary ^ <[]> = (
	^[ :start :end | coloredText addAttribute: TextColor red from: start to: end.
	coloredText addAttribute: TextEmphasis underlined from: start to: end.
      ].
)) : ()
class NewspeakLanguage3 = Language (|
	parserClass = compilation Parser.
	parser = parserClass.
	parserInstance = parser new.
|)
('as yet unclassified'
= other = (
	^ self name = other name
)
activationMirrorFor: context using: activationMirrors = (
	^activationMirrors ActivationMirrorCompiledByNewspeak onContext: context
)
becomeLanguageFor: cls = (
	self halt.
)
becomeLanguageFor: cls metadata: md = (
	self halt.
)
browserColorizer = (
	^ NS3BrowserColorizer
)
classSubjectFor: aClass using: ide = (
	^ide browsingNS3 ClassSubject onModel: 
		(mirrors ClassDeclarationMirror reflecting: aClass mixin)
)
colorizer = (
	^ NS3Colorizer
)
compiler = (
	^Newspeak3CompilerAdaptor
)
fileExtension = (
	^ 'ns3'
)
isConstructorSelector: sel forMixin: mxn = (
	^mirrors isConstructorSelector: sel forMixin: mxn
)
isNestedClassAccessorSelector: sel forMixin: mxn = (
	| ts <OrderedCollection[String]> |
	ts:: sel findTokens: syntheticNameSeparator.
	^ (ts size = 1 and: [mxn classes includesMirrorNamed: ts anyOne])
		or: [ ts size > 2 
			and: [(ts last = 'slot' or: [ts last = 'slot:']) 
				and: [mxn classes includesMirrorNamed: (ts at: ts size - 1)]]]
)
isNewspeakLanguage3 = (
	^ true.
)
name = (
	^ #'Newspeak3'
)
removeClass: victim <Class> = (
	self halt.
)
sourceMirrorClass = (
	self halt.
	^ NS2SourceMirrorParser
)
syntheticNameSeparator = (
	^ Language syntheticNameSeparator.
)
syntheticNameSeparatorCharacter = (
	^ Language syntheticNameSeparatorCharacter.
)
writer = (
	self halt.
)) : ()) : ()