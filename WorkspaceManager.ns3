Newspeak3
'HopscotchIDE'
class WorkspaceManager usingPlatform: p <Platform> ide: ide <HopscotchIDE> = (|
	private ClassDeclarationBuilder  = p mirrors ClassDeclarationBuilder.
	private ClassDeclarationMirror = p mirrors ClassDeclarationMirror.	

	private Dictionary = p collections Dictionary.
	private OrderedCollection = p collections OrderedCollection.

	private Color = p Graphics Color. 
	private Gradient = p brazil plumbing Gradient.
			
	private Presenter = p hopscotch core Presenter.
	private Subject = p hopscotch core Subject.
	private TextEditorFragment = p hopscotch fragments TextEditorFragment. 
		
	private ProgrammingPresenter = ide tools ProgrammingPresenter.	
	private DefinitionListPresenter = ide tools DefinitionListPresenter.
	private ExceptionalResultPresenter = ide inspection ExceptionalResultPresenter.
	private ObjectSubject = ide inspection ObjectSubject.
	private MethodGroupSubject = ide browsingNS3 MethodGroupSubject.
	private SlotGroupSubject = ide browsingNS3 SlotGroupSubject.
	
	private cachedPlatform = p.
	private cachedIde = ide.
	
	"ungood imports"
	private cachedBlackMarket = p blackMarket.
	protected vmMirror <SqueakVmMirror> = 
		p blackMarket NewspeakCore ImplementationBase vmMirror.
	
	"module state"
	private workspaces <Dictionary[Symbol, Workspace]> = OrderedCollection new.
	private workspaceCounter <Integer> ::= 0.
|)
(
class AllWorkspacesPresenter onSubject: s = DefinitionListPresenter onSubject: s (
"This is the top-level presenter displayed when following the Workspaces link from the home page. It displays a list of WorkspacePresenters on all existing workspaces.")
('actions'
respondToAddWorkspace = (
	subject addWorkspace.
	refresh.
)'as yet unclassified'
expandableLineForWorkspace: ws <Workspace> = (
	| toggle |
	toggle::
		collapsed: [workspaceRowFor: ws]
		expanded: [
			(WorkspaceSubject onModel: ws) presenter]
		initiallyExpanded: workspaces size = 1.
	toggle onUserToggled: [toggle requestVisibility].
	^toggle
)
respondToDeleteWorkspace: ws <Workspace> = (
	subject deleteWorkspace: ws.
	refresh.
)
workspaceListMenu = (
	^menuWithLabelsAndActions: {
		'Inspect Presenter' -> [respondToInspectPresenter].
		}
)
workspaceMenuFor: ws <Workspace>  = (
	^menuWithLabelsAndActions: {
		('Delete workspace ', ws class name) -> [respondToDeleteWorkspace: ws]
		}
)
workspaceRowFor: ws <Workspace> = (
	^row: {
		link: ws class name
			action: [ | s = WorkspaceSubject onModel: ws. | 
				enterSubject: s.
                  ]
			dragSubject: [WorkspaceSubject onModel: ws]
			withImage: nil.
		filler.
		dropDownMenu: [workspaceMenuFor: ws].
	}
)'definition'
definition = (
	^column: {
		minorHeadingBlock: (
			row: {
				label: 'Workspaces' asText allBold.
				largeBlank.		
				addButtonWithAction: [respondToAddWorkspace].
				filler.
				expandButtonWithAction: [expandAll].
				blank: 3.
				collapseButtonWithAction: [collapseAll].
				dropDownMenu:[workspaceListMenu]
				}
			).
		mediumBlank.
		super definition.
		mediumBlank.	
	}	
)'notifications'
presenterRequestsWorkspaceDeletion: workspace <Workspace> = (
	subject deleteWorkspace: workspace.
	refresh.
)'private'
contentPresenters ^ <Collection[Presenter]> = (
	^subject allWorkspaces collect:[:ws | expandableLineForWorkspace: ws]
)) : ()
class AllWorkspacesSubject onModel: dontCare = Subject onModel: dontCare (
"Subject for the list of all workspaces. It is responsible for creating and deleting workspace classes and instances.")
('accessing'
addWorkspace = (
	| ws <Workspace> |
	ws:: (defineClass: newWorkspaceClassDefinition) new.
	workspaces add: ws. 	
)
allWorkspaces ^ <Collection[Workspace]> = (
	"Ensure there is always a workspace to work with."
	workspaces isEmpty ifTrue: [addWorkspace].
	^workspaces
)
deleteWorkspace: ws <Workspace>  = (
	workspaces remove: ws.
)
hash ^<Integer> = (
	^self class hash
)
title ^<String> = (
	^'Workspaces'
)'as yet unclassified'
= anotherSubject ^<Boolean> = (
	"All workspace subjects are considered the same so that clicking the Workspaces link on the home page always takes us to the same page instead of multiplying them."
	^self class = anotherSubject class
)'private'
defineClass: definitionString <String> ^<Class> = (
	| builder mixin klass |
	builder:: ClassDeclarationBuilder fromSource: definitionString.
	mixin:: builder install reflectee.
	klass:: mixin apply: Workspace withName: builder simpleName.
	^klass	
)
newWorkspaceClassDefinition ^<String> = (
	"Produce definition source for a new workspace class. The class should include a slot named workspaceText."
	| wsNumber <String> |
	wsNumber:: currentWorkspaceNumberString.
	^'class Workspace_', wsNumber, ' = Workspace (
"This is a workspace class automatically generated by the IDE. It has a single instance, workspace number ', wsNumber, '. You may add methods or slots at your convenience."
|
	workspaceText
|
) ()'
)'restricted'
createPresenter ^ <AllWorkspacesPresenter> = (
	^AllWorkspacesPresenter onSubject: self
)) : ('as yet unclassified'
new = (
"An AllWorkspacesSubject always has its module as its model. This method is a dummy to satisfy the requirements of the Subject class protocol. Hence it doesn't care about the formal parameter  'dontCare'. "
	^onModel: nil
))
class Workspace = (
"The superclass of workspaces."|
|)
('as yet unclassified'
public aliens = (^platform aliens)
public blackMarket = (
	^cachedBlackMarket
)
public brazil = (^platform brazil)
public collections = (^platform collections)
protected doesNotUnderstand: message = (
	^message sendTo: blackMarket
)
public exceptions = (^platform exceptions)
public files = (^platform files)
public graphics = (^platform graphics)
public hopscotch = (^platform hopscotch)
public ide = (
	^cachedIde
)
public kernel = (^platform kernel)
public mirrors = (^platform mirrors)
public past = (^platform past)
public platform = (
	^cachedPlatform
)
public streams = (^platform streams)
public time = (^platform time)) : ()
class WorkspacePresenter onSubject: s = ProgrammingPresenter onSubject: s (
"A presenter for an individual workspace. A cross between an inspector and a browser with access to both instance and class information."|
	editor <TextEditorFragment>
	results <ColumnComposer>
|)
('actions'
respondToBrowseClass = (
	browseClass: subject workspaceClass
)
respondToDelete = (
	sendUp presenterRequestsWorkspaceDeletion: subject model
)
respondToDiscardResults = (
	results children size timesRepeat: [results removeAt: 1]
)
respondToEvaluate = (
	| result <ObjectMirror> |
	editor removeMessages.
	result::	(ObjectSubject onModel: subject modelMirror)
		evaluate:
			editor maybeSelectCurrentLine
		ifCompilerError:
			[:message |
			^editor addMessage: message]
		ifError:
			[:thread :exception |
			^addExceptionalResultPresenterFor: exception in: thread].
	addResultPresenterOn: result.
)'definition'
definition = (
	^column: {
		majorHeadingBlock: definitionForHeader.
		row: {
			frameLine.
			elastic: (column: {
				minorHeadingBlock: 
					(row: {
						label: 'Evaluation Results'.
						filler.
						link: '[clear]' action: [respondToDiscardResults].
					}).
				results:: column: {}.
				sectionLabelled: 'Methods' presenting: subject methodsSubject.
			}).
			frameLine.
		}.
		frameLine.
		smallBlank.
	}
)
definitionForHeader = (
	^column: {
		row: {
			elastic: evaluationEditor.
			smallBlank.
			column: {
				button: 'Evaluate' action: [respondToEvaluate].
				filler.
				row: {
					filler.
					dropDownMenu: [workspaceMenu]
				}
			}
		}.
	}
)
evaluationEditor = (
	editor:: TextEditorFragment new.
	editor
		changeResponse: [subject saveText: editor editedText];
		acceptResponse: [respondToEvaluate];
		text: (subject savedText ifNil: [initialText]).
	^editor
)'parameters'
frameColor = (
	^Color h: 240 s: 0.15 v: 0.74
)
frameLine = (
	^((row: {}) color: frameColor) width: 1
)
initialText = (
	^'

'
)
majorHeadingColor = (
	^Gradient 
		from: (Color h: 240 s: 0.1 v: 0.8) 
		to: frameColor
)
workspaceMenu = (
	^menuWithLabelsAndActions: {
		'Go to Class' -> [respondToBrowseClass].
		#separator.
		'Delete this Workspace' -> [respondToDelete].
		'Inspect Presenter' -> [respondToInspectPresenter].
	}
)'private'
addExceptionalResultPresenterFor: exception <Exception> in: thread <NewspeakDebugging ThreadSubject> = (
	results addFirst: 
		(collapsed: [ExceptionalResultPresenter on: exception in: thread]
		expanded: [buildExceptionDetails: exception in: thread])
)
addResultPresenterOn: result <Object> = (
	results addFirst:
		(resultFragmentOn: (ObjectSubject onModel: result)).
)
buildExceptionDetails: exception <Exception> in: thread <NewspeakDebugging ThreadSubject> = (
	^column: {
		ExceptionalResultPresenter on: exception in: thread.
		(ObjectSubject onModel: (vmMirror reflectOn: exception)) presenter.
	}
)
resultFragmentOn: result <ObjectSubject> ^ <Fragment> = (
	^collapsed: [link: result title action: [enterSubject: result]]
		expanded: [result presenter]
)
sectionLabelled: title <String> presenting: groupSubject <MirrorGroupSubject> = (
	| groupPresenter |
	^column: {
		minorHeadingBlock: (
			row: {
				label: title.
				largeBlank.
				addButtonWithAction: [groupPresenter addNewItemTemplate].
				filler.
				expandButtonWithAction: [groupPresenter expandAll].
				blank: 3.
				collapseButtonWithAction: [groupPresenter collapseAll].
				}
			).
		row: {
			elastic: (groupPresenter:: groupSubject presenter).
			smallBlank.
		}.
	}
)) : ()
class WorkspaceSubject onModel: workspaceInstance = Subject onModel: workspaceInstance (
"The subject of a WorkspacePresenter. Mostly responsible for suppying various mirrors on the workspace instance itself and on its class."|
	
|)
('accessing'
= another = (
	^class = another class and: [model = another model]
)
hash = (
	^model hash
)
methodsSubject ^<MethodGroupSubject> = (
	"Return a subject presenting the methods of the workspace class."
	^MethodGroupSubject onModel: modelClassMirror instanceSide methods
)
modelClassMirror ^<ClassDeclarationMirror> = (
	"Return a mirror on the workspace class."
	^ClassDeclarationMirror reflecting: model class mixin
)
modelMirror ^<ObjectMirror> = (
	"Return a mirror on the workspace object."
	^vmMirror reflectOn: model
)
saveText: text <String> = (
	"Save the provided text in the workspace instance. We do that on every change in the presenter's text editor."
	model workspaceText: text
)
savedText ^<String> = (
	"Return the text saved in the workspace object."
	^model workspaceText
)
slotsSubject ^<SlotGroupSubject> = (
	"Return a mirror on the slots of the workspace class."
	^SlotGroupSubject onModel: modelClassMirror instanceSide slots
)
workspaceClass = (
	"Return the raw workspace class metaobject."
	^model class
)'restricted'
createPresenter = (
	^WorkspacePresenter onSubject: self
)) : ()'as yet unclassified'
currentWorkspaceNumberString ^ <String> = (
	workspaceCounter:: workspaceCounter + 1.
	^workspaceCounter printString
)) : ()