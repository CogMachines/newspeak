Newspeak3
'NewspeakObjectFormat'
class NewspeakObjectFormat usingPlatform: p vmMirror: vmm = (
(* A serializer and deserializer for Newspeak-on-Squeak.

NOF can achieve partial serialization when given a list of objects that are available to both the serializing and deserializing party, so-called base objects. References to base objects are encoded symbolically. This module provides a default set of base objects suitable for serializing module definitions (baseObjectsForApplicationDelivery).

Issues:
Deserializing instances of compact classes.
Assumes that #class does not lie.
Assumes SmallIntegers are 31 bits (probably will change with new object memory).
Assumes CompiledMethod's accessors do not lie.
Assumes all Symbols are ByteSymbols (or, rather, it only interns ByteSymbols).
Can only either zap all weak references or treat them all as strong.
Performance: consider switching from a recursive algorithm to an interative one with an explicit stack, a la Fuel.
Consider using the Strongtalk IdentityDictionary in place of BloatedHistory, which wasn't available when NOF was originally written.
Consider omitting the initialization of partially deserialized objects with a special marker.
Modularity: conceavably one might need only either serialization or deserialization and should not be required to deploy with both.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2012 Ryan Macnak

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0. *)|
	(* Imports *)
	private OrderedCollection = p collections OrderedCollection.
	private Dictionary = p collections Dictionary.
	private Smalltalk = p blackMarket Smalltalk.
	private CompiledMethod = p blackMarket CompiledMethod.

	(* Newspeak Object Format constants *)
	fmtBytes = 2r00.
	fmtWords = 2r01.
	fmtPointers = 2r10.
	fmtWeakPointers = 2r11.
	sFmtNormal = 2r00.
	sFmtSplitIndexable = 2r01.
	sFmtSpecial = 2r10.
	fmtWidth = 2.
	fmtMask = 2r11.
	headerTag = 2r01.
	tagMask = 2r11.
	noSize = 16rFFE.
	sizeExtension = 16rFFF.
	nilCode = 0.
	falseCode = 1.
	trueCode = 2.
	symbolCode = 3.
	symbolicClassReferenceCode = 2r1001.
	
	private vmUtil = VMMirrorHelper usingVmMirror: vmm.
|)
(
class BaseObjects with: clsNames <Collection[String]> = (
(* This class provide utilities for obtaining base objects suitable for serializing and deserializing data using NewspeakObjectFormat. *)|
	protected classNames = clsNames.
|)
('as yet unclassified'
private baseClasses = (	
	| classes |
	classes:: classNames collect: [:each | Smalltalk associationAt: each].
	(Smalltalk associations select:
		[:each |
		(each value isBehavior and: [each key == each value name])]) asArray.
	classes sort: [:a :b | a key < b key].
	^classes
)
baseObjects = (
	| specialObjects classes  |
	^Array streamContents:
		[:s |
		specialObjects:: specialObjectsAsUniqueArray copyFrom: 1 to: 55.
		assert: [specialObjects size = specialObjects asIdentitySet size]
			message: 'Internal error: special objects are not unique'.
		s nextPutAll: specialObjects.
		specialObjects:: specialObjects asIdentitySet.
		0 to: 255 do:
			[:i | s nextPut: i asCharacter].
		classes:: baseClasses.
		classes, globals do:
			[:each <Association> |
			(specialObjects includes: each) ifFalse: [s nextPut: each].
			(specialObjects includes: each value) ifFalse: [s nextPut: each value]].
		classes do:
			[:each <Association> |
			(specialObjects includes: each value class)
				ifFalse: [s nextPut: each value class]]]
)
globalSymbols = (
	^{
		#Smalltalk.
	}
)
globals = (
	^globalSymbols collect: [:each | Smalltalk associationAt: each]
)
private specialObjectsAsUniqueArray = (
	^Array streamContents:
		[:s |
		Smalltalk specialObjectsArray withIndexDo:
			[:each :index |
			s nextPut: (each ifNil: [String fromString: 'special object nil #', index asString])]]
)) : ('as yet unclassified'
forApplicationDelivery = (
	^with:
		{
		      #AdditionalMethodState.
			#Array.
			#ArrayedCollection.
			#Association.
			#BlockContext.
			#Boolean.
			#ByteArray.
			#ByteString.
			#ByteSymbol.
			#Character.
			#Class.
			#ClassOrganizer.
			#Collection.
			#CompiledMethod.
			#Dictionary.
			#False.
			#Float.
			#Fraction.
			#Language.
			#LookupKey.
			#Magnitude.
			#Metaclass.
			#MethodDictionary.
			#MethodProperties.
			#NewspeakObject.
			#Object.
			#Pragma.
			#ProtoObject.
			#ReadOnlyVariableBinding.
			#RemoteString.
			#SequenceableCollection.
			#Set.
			#String.
			#Symbol.
			#True.
			#UndefinedObject.
			#WeakArray.
			#WeakSet.
			
			#IdentitySet.
			#ImplementationBase.
			#Integer.
			#NewspeakError.
			#Error.
			#OrderedCollection.	
			#VMMirror.
			#DelayForBoot.
			#FutureForBoot.
		}
))
class BloatedHistory withShift: s = (
(* An identity dictionary that is faster than Squeak's for large sets. *)|
	shift = s.
	bucketSize = 1 << shift - 3.
	nothing = Object new.
	array = Array new: 4096 * (bucketSize + 3) withAll: nothing.
|assert: [shift > 1] message: 'Invalid shift')
('as yet unclassified'
at: key = (
	^at: key ifAbsent: [halt]
)
at: key ifAbsent: absentAction = (
	| bucketStart overflow |
	bucketStart:: bucketStartFor: key.
	bucketStart to: bucketStart + bucketSize by: 2 do:
		[ :i | (array at: i) == key ifTrue: [^array at: i + 1]].
	overflow:: overflowAtBucket: bucketStart.
	overflow == nothing ifFalse:
		[1 to: overflow size by: 2 do:
			[ :i | | k |
			k:: overflow at: i.
			k == key ifTrue: [^overflow at: i + 1].
			k == nothing ifTrue: [absentAction value]]].
	^absentAction value
)
at: key put: value = (
	| bucketStart overflow |
	bucketStart:: bucketStartFor: key.
	bucketStart to: bucketStart + bucketSize by: 2 do:
		[ :i | (array at: i) == nothing ifTrue:
			[array at: i put: key.
			^array at: i + 1 put: value]].
	overflow:: overflowAtBucket: bucketStart.
	overflow == nothing ifTrue:
		[overflow:: Array new: 2 withAll: nothing.
		overflowAtBucket: bucketStart put: overflow].
	1 to: overflow size - 1 by: 2 do:
		[ :i | (overflow at: i) == nothing ifTrue:
			[overflow at: i put: key.
			^overflow at: i + 1 put: value]].
	overflow:: overflow, (Array new: overflow size withAll: nothing).
	overflowAtBucket: bucketStart put: overflow.
	(overflow size >> 1) + 1 to: overflow size - 1 by: 2 do:
		[ :i | (overflow at: i) == nothing ifTrue:
			[overflow at: i put: key.
			^overflow at: i + 1 put: value]].	
	halt (* should not happen *)
)
bucketEndFor: key = (
	^(((key identityHash bitAnd: 4095) + 1) << shift) - 2
)
bucketStartFor: key = (
	^((key identityHash bitAnd: 4095) << shift) + 1
)
includesKey: key  = (
	at: key ifAbsent: [^false].
	^true
)
overflowAtBucket: bucketStart = (
	^array at: bucketStart + bucketSize + 1
)
overflowAtBucket: bucketStart put: value  = (
	^array at: bucketStart + bucketSize + 1 put: value
)) : ()
class Deserializer from: s <ReadStream> withBaseObjects: baseObjects <SequenceableCollection> = (
(* This class deserializes objects from a stream as described in Newspeak Object Format. *)|
	private stream = s.
	private history ::= Array new: 16r10000.
	private undefined = Undefined new.
	private formatVisitor = FormatVisitor new.
	private isSpecial ::= false.
	private pseudoClasses = Dictionary new.
	private streamOffset = baseObjects size * 4.
	private initialStreamOffset = stream position.
	localHistory ::= OrderedCollection new.
|initializeHistory: baseObjects)
(
class CompiledMethodFiller = (|
|)
('as yet unclassified'
fillIn: obj <Object> ^<Object> = (	
	make: nextValue classOf: obj.
	vmUtil
		namedSlotIndicesOfMethod: obj do:
			[ :i | (* Read header followed by literals *)
			vmUtil namedSlotOfMethod: obj at: i put: nextValue];
		indexedSlotIndicesOfMethod: obj do:
			[ :i | (* Read bytecodes *)
			vmUtil indexedSlotOf: obj at: i put: stream next].
	skipPadding.
	^obj
)) : ()
class FormatVisitor = (|
	protected compiledMethodFiller = CompiledMethodFiller new.
	protected indexableByteObjectFiller = IndexableByteObjectFiller new.
	protected indexableWordObjectFiller = IndexableWordObjectFiller new.
	protected regularObjectFiller = RegularObjectFiller new.
|)
('as yet unclassified'
visitCompiledMethod: object <Object> ^<Object> = (
	^compiledMethodFiller
)
visitIndexableByteObject: object <Object> ^<Object> = (
	^indexableByteObjectFiller
)
visitIndexableWordObject: object <Object> ^<Object> = (
	^indexableWordObjectFiller
)
visitRegularObject: object <Object> ^<Object> = (
	^regularObjectFiller
)) : ()
class IndexableByteObjectFiller = (|
|)
('as yet unclassified'
fillIn: obj <Object> ^<Object> = (
	make: nextValue classOf: obj.
	vmUtil
		indexedSlotIndicesOf: obj do:
			[ :i | (* Read indexable byte fields *)
			vmUtil indexedSlotOf: obj at: i put: stream next].
	skipPadding.
	^obj
)) : ()
class IndexableWordObjectFiller = (|
|)
('as yet unclassified'
fillIn: obj <Object> ^<Object> = (
	make: nextValue classOf: obj.
	vmUtil
		indexedSlotIndicesOf: obj do:
			[ :i | (* Read indexable word fields *)
			vmUtil indexedSlotOf: obj at: i put: (stream nextLittleEndianNumber: 4)].
	^obj
)) : ()
class PseudoClass named: n = (
(* Describe the class in this comment. *)|
	superclass
	methodDict
	format
	instanceVariables
	organization
	subclasses
	name = n.
	classPool
	sharedPools
	environment
	category
	metadata
	mixin
|)
() : ()
class RegularObjectFiller = (|
|)
('as yet unclassified'
fillIn: obj <Object> ^<Object> = (
	make: nextValue classOf: obj.
	vmUtil
		namedSlotIndicesOf: obj do:
			[ :i | (* Read instance variables *)
			vmUtil namedSlotOf: obj at: i put: nextValue];
		indexedSlotIndicesOf: obj do:
			[ :i | (* Read indexable fields *)
			vmUtil indexedSlotOf: obj at: i put: nextValue].
	^obj
)) : ()'accessing'
nextValue ^<Object> = (
	#BOGUS. (*Should be named #next for parallelism with the serializer's #nextPut:*)

	stream peek even ifTrue: [^readInteger].
	^((stream peek bitAnd: tagMask) = headerTag)
		ifTrue: [readObject]
		ifFalse: [readReference]
)'private'
allocateObject ^<Object> = (
	| lsb pos f1 f2 sf instanceSize indexableSize obj |
	pos:: (position >> 2) + 1.
	lsb:: stream next.
	sf:: (lsb >> 2) bitAnd: fmtMask.
	f2:: (lsb >> 4) bitAnd: fmtMask.
	f1:: (lsb >> 6) bitAnd: fmtMask.
	indexableSize:: stream next.
	instanceSize:: stream next.
	indexableSize:: (instanceSize << 8 bitAnd: 16rF00) + indexableSize.
	instanceSize:: (stream next << 4) + (instanceSize >> 4).
	instanceSize = noSize ifTrue: [instanceSize:: -1].
	instanceSize = sizeExtension ifTrue: [instanceSize:: stream nextLittleEndianNumber: 4].
	indexableSize = noSize ifTrue: [indexableSize:: -1].
	indexableSize = sizeExtension ifTrue: [indexableSize:: stream nextLittleEndianNumber: 4].
	obj:: allocateObject: instanceSize indexableSize: indexableSize f1: f1 f2: f2 sf: sf.
	historyAt: pos put: obj.
	^obj
)
allocateObject: instanceSize <integer> indexableSize: indexableSize <Integer> f1: f1 <Integer> f2: f2 <Integer> sf: sf <Integer> = (
	sf = sFmtSpecial ifTrue: [^readSpecialObject: instanceSize indexableSize: indexableSize f1: f1 f2: f2 sf: sf].
	sf = sFmtNormal ifTrue:
		[ | obj |
		obj:: vmUtil
			allocateObjectOfFixedSize: instanceSize
			variableSize: indexableSize
			bytes: f2 = fmtBytes
			pointers: f2 > 1
			weak: f2 = fmtWeakPointers.
		vmUtil namedSlotIndicesOf: obj do:
			[ :i | vmUtil namedSlotOf: obj at: i put: undefined].
		^obj].
	sf = sFmtSplitIndexable ifTrue:
		[^vmUtil
			allocateCompiledMethod: instanceSize - 1
			byteCount: indexableSize].
	halt. (* Unknown sf *)
)
growToSize: size = (
	[history size < size] whileTrue:
		[history:: history, (Array new: history size)]
)
historyAt: pos <Integer> put: obj <Object> = (
	growToSize: pos.
	history at: pos put: obj.
	(nil == obj or: [true == obj or: [false == obj]]) ifFalse: [localHistory add: obj]
)
initializeHistory: baseObjects <SequenceableCollection> = (
	assert: [baseObjects isSequenceable] message: 'baseObjects must be ordered'.
	growToSize: baseObjects size.
	history replaceFrom: 1 to: baseObjects size with: baseObjects startingAt: 1.
)
make: cls <Object> classOf: obj <Object> = (
	|
	indexOfSuperclassInBehavior = 1.
	indexOfMethodDictInBehavior = 2.
	indexOfFormatInBehavior = 3.
	oldSize oldClass
	|
	oldClass:: vmUtil classOf: obj.
	oldSize:: vmUtil indexedSlotsOf: obj.
	
	(* cls might not be fully deserialized as this point. need to at least set the format so the change class primitive will succeed. niling the methoddictionary means will give an mdFault instead of a vm crash. *)
	vmUtil namedSlotOf: cls at: indexOfSuperclassInBehavior test: undefined andSet: [nil (* oldClass *)].
	vmUtil namedSlotOf: cls at: indexOfMethodDictInBehavior test: undefined andSet: [nil (* MethodDictionary new *)].
	vmUtil namedSlotOf: cls at: indexOfFormatInBehavior test: undefined andSet: [vmUtil formatOf: oldClass].
	
	vmUtil make: cls classOf: obj.
	
	assert: [oldSize = (vmUtil indexedSlotsOf: obj)].
)
position = (
	^stream position + streamOffset - initialStreamOffset
)
readInteger ^<SmallInteger> = (
	| lsb b2 b3 msb |
	lsb:: stream next.
	b2:: stream next.
	b3:: stream next.
	msb:: stream next.
	^(lsb bitShift: -1) + (b2 bitShift: 7) + (b3 bitShift: 15)
		+ ((msb bitAnd: 16r7F) - (msb bitAnd: 16r80) bitShift: 23)
)
readObject ^<Object> = (
	| newObject |
	newObject:: allocateObject.
	isSpecial ifTrue: [^skipSpecialObjectClass: newObject].
	^(vmUtil switchOn: newObject using: formatVisitor) fillIn: newObject.
)
readReference ^<Object> = (
	| lsb b2 b3 msb |
	lsb:: stream next.
	b2:: stream next.
	b3:: stream next.
	msb:: stream next.
	^history at: ((lsb >> 2) + (b2 << 6) + (b3 << 14) + (msb << 22)) + 1
)
readSpecialObject: instanceSize <integer> indexableSize: indexableSize <Integer> f1: f1 <Integer> f2: f2 <Integer> sf: sf <Integer> = (
	| code |
	code:: readInteger.
	isSpecial:: true.
	code == nilCode ifTrue: [^nil].
	code == falseCode ifTrue: [^false].
	code == trueCode ifTrue: [^true].
	code == symbolCode ifTrue: [^readSymbol: indexableSize].
	code == symbolicClassReferenceCode ifTrue: [^readSymbolicClassReference: indexableSize].
	halt (* unrecognized code *)
)
readSymbol: size <Integer> = (
	| bytes |
	bytes:: ByteArray new: size.
	1 to: size do: [ :i | bytes at: i put: stream next].
	skipPadding.
	^bytes asString asSymbol
)
readSymbolicClassReference: size <Integer> = (
	| cls clsName |
	clsName:: nextValue.
	cls:: Smalltalk classNamed: clsName.
	nil = cls ifTrue: [
		error: 'Class not found: ', clsName asString printString.
		cls:: pseudoClasses at: clsName ifAbsentPut: [PseudoClass named: clsName]].
	isSpecial:: true. (* This may be reset during nextValue above *)
	^cls
)
skipPadding = (
	| padding |
	padding:: 4 - (position \\ 4).
	padding = 4 ifFalse: [stream skip: padding]
)
skipSpecialObjectClass: obj = (
	isSpecial:: false.
	nextValue. (* skip the class of the special object *)
	^obj
)) : ()
class Serializer on: strm <WriteStream> withBaseObjects: baseObjects <SequenceableCollection> = (
(* This class serializes objects on a stream as described in Newspeak Object Format. *)|
	private stream = strm.
	private history = BloatedHistory withShift: 3.
	private positionOfNil
	private positionOfFalse
	private positionOfTrue
	private globals = OrderedCollection new.
	private streamOffset = baseObjects size * 4.
	private initialStreamPosition ::= stream position.
	private localHistory ::= OrderedCollection new.
	
	(* Useful for figuring out the source of underdesired references. *)
	private debugStack = OrderedCollection new.
	
	(* Options *)
	public useSymbolicClassReferences ::= false.
	public prohibitSqueakClasses ::= true.
	public zapWeakReferences ::= true. (* If true, all weak references are replaced with nil. If false, weak references act like strong references: they will cause an object to be serialized even if it is only reached by weak references. *)
	public convertBehaviorFormats ::= false.
|initializeHistory: baseObjects)
('accessing'
public nextPut: obj <Object> = (
	debugStack push: obj.
	nextPut2: obj.
	debugStack pop.
)'as yet unclassified'
newClassFormatFor: oldClass = (
	(* OLD: 		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>
	 NEW: 		<5 bits inst spec><16 bits inst size> *)
	| oldFormat instSize newInstSpec |
	(0 class == oldClass or: ["A" class == oldClass])
		ifTrue: [^ 7 (* instSpecForImmediateClasses *) << 16].
	oldFormat:: oldClass format.
	instSize:: ((oldFormat bitShift: -10) bitAnd: 16rC0) + ((oldFormat bitShift: -1) bitAnd: 16r3F) - 1.
	newInstSpec:: {0. 1. 2. 3. 4. nil. 10. 9. 16. 16. 16. 16. 24. 24. 24. 24} at: ((oldFormat bitShift: -7) bitAnd: 16rF) + 1.
	^newInstSpec << 16 + instSize
)'private'
initializeHistory: baseObjects <SequenceableCollection> = (
	assert: [baseObjects isSequenceable] message: 'baseObjects must be ordered'.
	baseObjects withIndexDo: [:object :index | history at: object put: (index-1)*4]
)
nextPut16BitUnsignedInteger: i <SmallInteger> = (
	stream
		nextPut: (i bitAnd: 16rFF);
		nextPut: (i >> 8 bitAnd: 16rFF)
)
nextPut2: obj <Object> = (

	nil == obj ifTrue: [^nextPutNil].
	false == obj ifTrue: [^nextPutFalse].
	true == obj ifTrue: [^nextPutTrue].
	obj class == #nextPut: class ifTrue: [^nextPutSymbol: obj].
	obj class == 1 class ifTrue: [^nextPut31BitInteger: obj].
	obj isCompiledMethod ifTrue: [^nextPutCompiledMethod: obj].
	obj class isMeta ifTrue: [^nextPutClass: obj].
	nextPutObject: obj.
	assert: [(position bitAnd: 2r11) = 0] message: 'Alignment error'.
)
nextPut31BitInteger: i <SmallInteger> = (
	nextPut16BitUnsignedInteger:: (i bitAnd: 16r7FFF) << 1.
	nextPut16BitUnsignedInteger:: i >> 15 bitAnd: 16rFFFF
)
nextPut32BitInteger: i <SmallInteger> = (
	nextPut16BitUnsignedInteger:: (i bitAnd: 16rFFFF).
	nextPut16BitUnsignedInteger:: i >> 16 bitAnd: 16rFFFF
)
nextPutByte: byte <Integer> = (
	(* assert: [byte negative not].
	assert: [byte < 256]. *)
	stream nextPut: byte.
)
nextPutClass: cls <Class> = (
	cls isMeta ifTrue: [^nextPutObject: cls].
	useSymbolicClassReferences ifTrue: [^nextPutSymbolicClassReference: cls].
	
	^nextPutReferenceTo: cls ifFirstTime:
		[prohibitSqueakClasses ifTrue:
			[cls language isSmalltalkLanguage ifTrue: 
				[Error signal: 'Encountered a Squeak class'.
				(*Usually this means you are missing a base object.*)]].
		nextPutObjectNoReference: cls]
)
nextPutCompiledMethod: m <CompiledMethod> = (
	nextPutReferenceTo: m ifFirstTime:
		[nextPutMethodHeader: m.
		nextPutClass: m class.
		vmUtil namedSlotIndicesOfMethod: m do: [ :i | nextPutLiteral:: vmUtil namedSlotOfMethod: m at: i].
		vmUtil indexedSlotIndicesOfMethod: m do: [ :i | nextPutByte:: vmUtil indexedSlotOf: m at: i].
		stream padTo: 4 put: 0
		]
)
nextPutFalse = (
	nil = positionOfFalse
		ifTrue: [
			positionOfFalse:: position.
			nextPutObjectHeader: false isSpecial: true.
			nextPut31BitInteger: falseCode.
			nextPutClass: false class]
		ifFalse: [
			nextPutReference: positionOfFalse]
)
nextPutLiteral: lit <Object> = (
	lit isVariableBinding ifFalse: [^nextPut: lit].
	lit key ifNil: [^nextPut: lit].
	nextPutReferenceTo: lit ifFirstTime:
		[globals add: lit.
		nextPutObjectNoReference:: (* unbind: *) lit]
)
nextPutMethodHeader: m <CompiledMethod> = (
	|
	literalCount <Integer>
	byteCount <Integer>
	f1 <Integer>
	f2 <Integer>
	sf <Integer>
	fmt <Integer>
	|
	literalCount:: m numLiterals + 1. (* method header *)
	byteCount:: m size - m initialPC + 1.
	assert: [literalCount < noSize]. (* Deal with large objects later *)
	assert: [byteCount < noSize]. (* Deal with large objects later *)
	assert: [literalCount negative not].
	assert: [byteCount negative not].
	f1:: fmtPointers.
	f2:: fmtBytes.
	sf:: sFmtSplitIndexable.
	fmt:: f1.
	fmt:: (fmt << fmtWidth) + f2.
	fmt:: (fmt << fmtWidth) + sf.
	fmt:: (fmt << fmtWidth) + headerTag.
	stream
		nextPut: fmt;
		nextPut: (byteCount bitAnd: 16rFF);
		nextPut: ((literalCount bitAnd: 16rF) << 4 bitOr: byteCount >> 8);
		nextPut: literalCount >> 4
)
nextPutNil = (
	nil = positionOfNil
		ifTrue: [
			positionOfNil:: position.
			nextPutObjectHeader: nil isSpecial: true.
			nextPut31BitInteger: nilCode.
			nextPutClass: nil class]
		ifFalse: [
			nextPutReference: positionOfNil]
)
nextPutObject: obj <Object> = (
	nextPutReferenceTo: obj ifFirstTime: [nextPutObjectNoReference: obj]
)
nextPutObjectHeader: obj <Object> = (
	^nextPutObjectHeader: obj isSpecial: false
)
nextPutObjectHeader: obj <Object> isSpecial: isSpecial <Boolean> = (
	| fixedSize indexableSize instSpec |
	instSpec:: obj class instSpec.
	fixedSize:: obj class instSize.
	fixedSize:: (fixedSize = 0 and: [instSpec ~= 3 or: [instSpec ~= 4]])
		ifTrue: [-1]
		ifFalse: [fixedSize].
	indexableSize:: obj class isVariable
		ifTrue: [obj basicSize]
		ifFalse: [-1].
	self
		nextPutObjectHeader: fixedSize
		variableSize: indexableSize
		bytes: obj class isBytes
		pointers: obj class isPointers
		weak: obj class isWeak
		isSpecial: isSpecial
)
nextPutObjectHeader: instanceVariableCount <Integer> variableSize: variableSize <Integer> bytes: isBytes <Boolean> pointers: isPointers <Boolean> weak: isWeak <Boolean> isSpecial: isSpecial <Boolean> = (
	| namedSize indexableSize f1 f2 sf fmt |

	namedSize:: instanceVariableCount < noSize
		ifTrue: [instanceVariableCount] ifFalse: [sizeExtension].
	namedSize:: namedSize negative
		ifTrue: [noSize] ifFalse: [namedSize].
	indexableSize:: variableSize < noSize
		ifTrue: [variableSize] ifFalse: [sizeExtension].
	indexableSize:: indexableSize negative
		ifTrue: [noSize] ifFalse: [indexableSize].

	f1:: fmtPointers.
	f2:: isBytes
		ifTrue: [fmtBytes]
		ifFalse: [isPointers
					ifTrue: [isWeak
								ifTrue:[fmtWeakPointers]
								ifFalse: [fmtPointers]]
					ifFalse: [fmtWords]].
	sf:: isSpecial ifTrue: [sFmtSpecial] ifFalse: [sFmtNormal].
	fmt:: f1.
	fmt:: (fmt << fmtWidth) + f2.
	fmt:: (fmt << fmtWidth) + sf.
	fmt:: (fmt << fmtWidth) + headerTag.
	stream
		nextPut: fmt;
		nextPut: (indexableSize bitAnd: 16rFF);
		nextPut: ((namedSize bitAnd: 16rF) << 4 bitOr: indexableSize >> 8);
		nextPut: namedSize >> 4.

	namedSize = sizeExtension ifTrue: [nextPut32BitInteger: instanceVariableCount].
	indexableSize = sizeExtension ifTrue: [nextPut32BitInteger: variableSize]
)
nextPutObjectNoReference: obj <Object> = (
	nextPutObjectHeader: obj.
	nextPutClass: obj class.
	vmUtil namedSlotIndicesOf: obj do: [:i | 
		| slotValue ::= vmUtil namedSlotOf: obj at: i. |
		(convertBehaviorFormats and: [i == 3] and: [obj isBehavior])
			ifTrue: [slotValue:: newClassFormatFor: obj. slotValue out].
		nextPut:: slotValue.
	].
	obj class isPointers
		ifTrue:
			[obj class isWeak & zapWeakReferences
				ifTrue: [vmUtil indexedSlotIndicesOf: obj do: [ :i | nextPutNil ]]
				ifFalse: [vmUtil indexedSlotIndicesOf: obj do: [ :i | nextPut:: vmUtil indexedSlotOf: obj at: i]]]
		ifFalse:
			[obj class isBytes
				ifTrue: [ vmUtil indexedSlotIndicesOf: obj do: [ :i | nextPutByte:: vmUtil indexedSlotOf: obj at: i].
					stream padTo: 4 put: 0]
				ifFalse: [ vmUtil indexedSlotIndicesOf: obj do: [ :i | nextPut32BitInteger:: vmUtil indexedSlotOf: obj at: i]]
			]
)
nextPutReference: pos <Integer> = (
	assert: [(pos bitAnd: 2r11) = 0] message: 'Alignment error'.
	nextPut16BitUnsignedInteger:: (pos bitAnd: 16rFFFF) bitOr: 2r11.
	nextPut16BitUnsignedInteger:: pos >> 16 bitAnd: 16rFFFF
)
nextPutReferenceTo: obj <Object> ifFirstTime: action <[]> = (
	| pos |
	obj class == 1 class ifTrue:
		[nextPut31BitInteger: obj.
		^self].
	pos:: history at: obj ifAbsent:
		[history at: obj put: position.
		localHistory add: obj.
		assert: [(position bitAnd: 2r11) = 0] message: 'Alignment error'.
		action value.
		^self].
	nextPutReference: pos
)
nextPutSymbol: sym <ByteSymbol> = (
	nextPutReferenceTo: sym ifFirstTime:
		[nextPutObjectHeader: sym isSpecial: true.
		nextPut31BitInteger: symbolCode.
		vmUtil indexedSlotIndicesOf: sym do: [ :i | nextPutByte:: vmUtil indexedSlotOf: sym at: i].
		stream padTo: 4 put: 0.
		nextPutClass: sym class]
)
nextPutSymbolicClassReference: cls <Class> = (
	nextPutReferenceTo: cls ifFirstTime:
		[nextPutObjectHeader: cls isSpecial: true.
		nextPut31BitInteger: symbolicClassReferenceCode.
		nextPut: cls name.
		nextPut: nil (* class of cls *)]
)
nextPutTrue = (
	nil = positionOfTrue
		ifTrue: [
			positionOfTrue:: position.
			nextPutObjectHeader: true isSpecial: true.
			nextPut31BitInteger: trueCode.
			nextPutClass: true class]
		ifFalse: [
			nextPutReference: positionOfTrue]
)
position = (
	^stream position + streamOffset - initialStreamPosition
)
unbind: binding <LookupKey> = (
	^binding class newFrom: (LookupKey newFrom: binding)
)) : ()
class Undefined = (
(* A filler used in partially deserialized objects. *))
('as yet unclassified'
printOn: s <WriteStream> = (
	s nextPutAll: '<undefined>'
)) : ()
class VMMirrorHelper usingVmMirror: vmm = (
(* TODO: move much of this to low level mirrors *)|
private vmmirror = vmm.

mockClasses = Dictionary new.

(*TODO: not all used*)
SqNoFields = 2r0000.
SqFixedPointerFields = 2r001.
SqIndexablePointerFields = 2r0010.
SqFixedAndIndexablePointerFields = 2r0011.
SqIndexableAndWeakIndexablePointerFields = 2r0100.
SqIndexableWordFields = 2r0110.
SqIndexableByteFields = 2r1000.
SqHashWidth = 12.
SqCciWidth = 5.
SqFmtWidth = 4.
SqSizeWidth = 6.
SqHtWidth = 2.
SqSizeMaskLow = 2r111111.
SqIntegerTagWidth = 1.
SqMaxFieldsShifted = 4.

protected v3switchTable = {
		#visitRegularObject:. (* 0: no fields *)
		#visitRegularObject:. (* 1: fixed pointer fields *)
		#visitRegularObject:. (* 2: indexable pointer fields *)
		#visitRegularObject:. (* 3: both fixed and indexable pointer fields *)
		#visitRegularObject:. (* 4: both fixed and indexable pointer fields (pointer fields are weak) *)
		#visitUnused:. (* 5: unused *)
		#visitIndexableWordObject:. (* 6: indexable word fields *)
		#visitUnused:. (* 7: unused *)
		#visitIndexableByteObject:. (* 8: indexable byte fields *)
		#visitUnused:. (* 9: unused *)
		#visitUnused:. (* 10: unused *)
		#visitUnused:. (* 11: unused *)
		#visitCompiledMethod:. (* 12: compiled method *)
	}.
	
protected spurSwitchTable = {
		#visitRegularObject:. (* 0: no fields *)
		#visitRegularObject:. (* 1: fixed pointer fields *)
		#visitRegularObject:. (* 2: indexable pointer fields *)
		#visitRegularObject:. (* 3: both fixed and indexable pointer fields *)
		#visitRegularObject:. (* 4: both fixed and indexable pointer fields (pointer fields are weak) *)
		#visitRegularObject:. (* 5: weak non-indexable objects with inst vars (ephemerons)  *)
		#visitUnused:. (* 6: unused *)
		#visitUnused:. (* 7: unused *)
		#visitUnused:. (* 8: unused *)
		#visitUnused:. (* 9: unused (64-bit indexable?) *)
		#visitIndexableWordObject:. (* 10: indexable word fields *)
		#visitIndexableWordObject:. (* 11: indexable word fields *)
		#visitUnused:. (* 12: unused *)
		#visitUnused:. (* 13: unused *)
		#visitUnused:. (* 14: unused *)
		#visitUnused:. (* 15: unused *)
		#visitIndexableByteObject:. (* 16: indexable byte fields *)
		#visitIndexableByteObject:. (* 17: indexable byte fields *)
		#visitIndexableByteObject:. (* 18: indexable byte fields *)
		#visitIndexableByteObject:. (* 19: indexable byte fields *)
		#visitIndexableByteObject:. (* 20: indexable byte fields *)
		#visitIndexableByteObject:. (* 21: indexable byte fields *)
		#visitIndexableByteObject:. (* 22: indexable byte fields *)
		#visitIndexableByteObject:. (* 23: indexable byte fields *)
		#visitCompiledMethod:. (* 24: compiled method *)
		#visitCompiledMethod:. (* 25: compiled method *)
		#visitCompiledMethod:. (* 26: compiled method *)
		#visitCompiledMethod:. (* 27: compiled method *)
		#visitCompiledMethod:. (* 28: compiled method *)
		#visitCompiledMethod:. (* 29: compiled method *)
		#visitCompiledMethod:. (* 30: compiled method *)
		#visitCompiledMethod:. (* 31: compiled method *)
	}.
|)
(
class MockBehavior withFormat: f = (|
	superclass = Object.
	methodDictionary
	format = f.
|)
() : ()''
isSpur = (
	^$A class instSize == 0
)'as yet unclassified'
allocateCompiledMethod: literalCount byteCount: byteCount = (

	^CompiledMethod
		newMethod: byteCount
		header: (compiledMethodHeader: literalCount)	
)
allocateObjectOfFixedSize: instanceVariableCount <Integer> variableSize: variableSize <Integer> bytes: isBytes <Boolean> pointers: isPointers <Boolean> weak: isWeak <Boolean> ^<Object> = (
	(* Allocate an object.
	The allocated object will have the following properties:
	* fixed fields if instanceVariableCount is not negative.
	* variable fields if variableSize is not negative.
	* byte-sized variable fields if isBytes is true, word sized otherwise.
	* all fields are pointers if isPointers is true.
	* the variable section is weak pointers if isWeak is true. *)
	| format cls |
	format:: self classFormat: (instanceVariableCount max: 0) variable: variableSize >= 0 bytes: isBytes pointers: isPointers weak: isWeak.
	cls:: mockClassForHeaderWord: format.
	^variableSize negative
		ifTrue: [vmmirror instantiateFixedClass: cls ifFail: [halt]]
		ifFalse: [vmmirror instantiateVariableClass: cls withSize: variableSize ifFail: [halt]]
)
classFormat: instanceVariableCount <Integer> variable: isVariable <Boolean> bytes: isBytes <Boolean> pointers: isPointers <Boolean> weak: isWeak <Boolean> ^<Integer> = (
	^isSpur
		ifTrue: [spurClassFormat: instanceVariableCount variable: isVariable bytes: isBytes pointers: isPointers weak: isWeak]
		ifFalse: [v3classFormat: instanceVariableCount variable: isVariable bytes: isBytes pointers: isPointers weak: isWeak]
)
classOf: o = (
	^vmmirror classOf: o
)
compiledMethodHeader: literalCount = (
	(* Use a V4 header to accommodate the maximium number of literals. *)
	assert: [literalCount between: 0 and: 65535].
	^ -1073741824 + literalCount
)
formatOf: cls <Object> = (
	^namedSlotOf: cls at: 3
)
headerWord: instanceVariableCount <Integer> format: format <Integer> ^ <Integer> = (
	| fixedSize <Integer> headerWord <Integer> |
	fixedSize:: instanceVariableCount negative
		ifTrue: [ 1 ]
		ifFalse: [ instanceVariableCount + 1 ]. (* One extra for header word *)
	headerWord:: fixedSize >> SqSizeWidth.
	assert: [headerWord < SqMaxFieldsShifted].
	headerWord:: headerWord << SqCciWidth. (* Ignoring compact classes *)
	headerWord:: (headerWord << SqFmtWidth) bitOr: format.
	headerWord:: (headerWord << SqSizeWidth) bitOr: (fixedSize bitAnd: SqSizeMaskLow).
	headerWord:: headerWord << SqHtWidth.
	^headerWord >> SqIntegerTagWidth
)
indexedSlotIndicesOf: object <Object> do: action <[:Integer]> = (
	1 to: (vmmirror indexedSlotsOf: object) do: [:index | action value: index]
)
indexedSlotIndicesOfMethod: object <Object> do: action <[:Integer]> = (
	object initialPC to: object size do: [ :i | action value: i]
)
indexedSlotOf: object at: index = (
	^vmmirror indexedSlotOf: object at: index ifFail: [halt]
)
indexedSlotOf: object at: index put: value = (
	^vmmirror indexedSlotOf: object at: index put: value ifFail: [halt]
)
indexedSlotsOf: obj = (
	^vmmirror indexedSlotsOf: obj
)
instanceSizeOf: cls <Object> = (
	| format |
	format:: formatOf: cls.
	isSpur ifTrue: [^format bitAnd: 16rFFFF].	
	^((format bitShift: -10) bitAnd: 16rC0) + ((format bitShift: -1) bitAnd: 16r3F) - 1
)
instanceSpecOf: cls <Object> = (
	| format |
	format:: formatOf: cls.
	isSpur ifTrue: [^(format bitShift: -16) bitAnd: 16r1F].
	^(format bitShift: -7) bitAnd: 16rF
)
make: cls classOf: obj = (
	vmmirror changeClassOf: obj to: cls ifFail: [
		'change class failure' out.
		(formatOf: obj class) out. 
		(formatOf: cls) out.
		halt.
	]. 
)
mockClassForHeaderWord: headerWord <Integer> ^<Class> = (
	^mockClasses at: headerWord ifAbsent:
		[ | cls |
		cls:: MockBehavior withFormat: headerWord.
		mockClasses at: headerWord put: cls.
		cls]
)
namedSlotIndicesOf: object <Object> do: action <[:Integer]> = (
	1 to: (instanceSizeOf: (vmmirror classOf: object)) do: [:index <Integer> | action value: index]
)
namedSlotIndicesOfMethod: object <Object> do: action <[:Integer]> = (
	1 to: object numLiterals + 1 do: [ :i | action value: i]
)
namedSlotOf: object at: index = (
	^vmmirror namedSlotOf: object at: index ifFail: [halt]
)
namedSlotOf: object at: index put: value = (
	^vmmirror namedSlotOf: object at: index put: value ifFail: [halt]
)
namedSlotOf: obj <Object> at: index <Integer> test: oldValue <Object> andSet: newValue <BlockContext> = (
	oldValue == (namedSlotOf: obj at: index)
		ifTrue: [namedSlotOf: obj at: index put: newValue value. ^true].
	^false
)
namedSlotOfMethod: object at: index = (
	^object objectAt: index
)
namedSlotOfMethod: object at: index put: value = (
	^object objectAt: index put: value
)
spurClassFormat: instanceVariableCount <Integer> variable: isVariable <Boolean> bytes: isBytes <Boolean> pointers: isPointers <Boolean> weak: isWeak <Boolean> ^<Integer> = (
	(* Answer the format inst var value for a class whose instances have the given properties.

	Compute the format for the given instance specification.
	instanceVariableCount	- the number of named inst vars (e.g. Point's x,y => nInstVars = 2).
	isVariable				- true if indexable inst vars.
	isBytes					- true for bit objects organized as bytes
	isPointers				- true for pointer objects (except CompiledMethod) false otherwise
	isWeak					- true if indexable, named weak collection
	 Above Cog Spur the class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
		 0 = 0 sized objects (UndefinedObject True False et al)
		 1 = non-indexable objects with inst vars (Point et al)
		 2 = indexable objects with no inst vars (Array et al)
		 3 = indexable objects with inst vars (MethodContext AdditionalMethodState et al)
		 4 = weak indexable objects with inst vars (WeakArray et al)
		 5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
		 6,7,8 unused
		 9 (?) 64-bit indexable
		 10 - 11 32-bit indexable
		 12 - 15 16-bit indexable
		 16 - 23 byte indexable
		 24 - 31 compiled method *)
	| instSpec |
	instSpec:: isWeak
					ifTrue: [isVariable ifTrue: [4] ifFalse: [5]]
					ifFalse:
						[isPointers
							ifTrue:
								[(isVariable ifTrue: [2] ifFalse: [0])
								+ (instanceVariableCount > 0 ifTrue: [1] ifFalse: [0])]
							ifFalse:
								[isBytes ifTrue: [16] ifFalse: [10]]].
	^(instSpec bitShift: 16) + (instanceVariableCount max: 0)
)
switchOn: object <Object> using: visitor <FormatVisitor> = (
	^visitor perform: (switchTable at: (instanceSpecOf: (classOf: object)) + 1) with: object
)
switchTable = (
	^isSpur ifTrue: [spurSwitchTable] ifFalse: [v3switchTable]
)
v3classFormat: instanceVariableCount <Integer> variable: isVariable <Boolean> bytes: isBytes <Boolean> pointers: isPointers <Boolean> weak: isWeak <Boolean> ^<Integer> = (
	(*Answer the format inst var value for a class whose instances have the given properties.This method was derived from the same method in ClassBuilder, and
	somewhat cleaned up.
	
	Compute the format for the given instance specification.
	nInstVars - the number of named inst vars (e.g. Point's x,y => nInstVars = 2).
	isVar  true if indexable inst vars.
	isWords  true for bit objects not organized as bytes (Float would you believe)
	isPointers  true for pointer objects (except CompiledMethod) false otherwise
	isWeak, true if indexable, named weak collection *)
	| cClass instSpec sizeHiBits fmt |
	(*NOTE: This code supports the backward-compatible extension to 8 bits of instSize. The format word is...
		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>*)
	sizeHiBits:: (instanceVariableCount+1) // 64.
	cClass:: 0. 
	instSpec:: isWeak
					ifTrue:[4]
					ifFalse:[isPointers
							ifTrue: [isVariable
									ifTrue: [instanceVariableCount>0 ifTrue: [3] ifFalse: [2]]
									ifFalse: [instanceVariableCount>0 ifTrue: [1] ifFalse: [0]]]
							ifFalse: [isBytes ifTrue: [8] ifFalse: [6]]].
	fmt:: sizeHiBits.
	fmt:: (fmt bitShift: 5) + cClass.
	fmt:: (fmt bitShift: 4) + instSpec.
	fmt:: (fmt bitShift: 6) + ((instanceVariableCount+1)\\64).  (* +1 since prim size field includes header*)
	fmt:: (fmt bitShift: 1). (*This shift plus integer bit lets wordSize work like byteSize*)
	^fmt
)) : ()'as yet unclassified'
baseObjectsForApplicationDelivery = (
	^BaseObjects forApplicationDelivery baseObjects
)
deserializerFrom: s <ReadStream> ^<Deserializer> = (
	^Deserializer from: s withBaseObjects: baseObjectsForApplicationDelivery
)
deserializerFrom: s <ReadStream> withBaseObjects: baseObjects <SequenceableCollection> ^<Deserializer> = (
	^Deserializer from: s withBaseObjects: baseObjects
)
isSpur ^<Boolean> = (
	^$A class instSize == 0
)
serializerOn: s <WriteStream> ^<Serializer> = (
	^Serializer on: s withBaseObjects: baseObjectsForApplicationDelivery
)
serializerOn: s <WriteStream> withBaseObjects: baseObjects <SequenceableCollection> ^<Serializer> = (
	^Serializer on: s withBaseObjects: baseObjects
)'private'
private assert: blockOrBool  = (
	assert: [blockOrBool value] message: 'Assert failed'
)) : ()