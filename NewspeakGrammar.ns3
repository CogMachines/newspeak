Newspeak3
'Newspeak'
class NewspeakGrammar parserLib: parsers = (
"The Newspeak grammar, both with and without type declarations.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2010 Felix Geller and Ryan Macnak
Copyright 2012 Ryan Macnak
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
private ExecutableGrammar = parsers ExecutableGrammar.
private CollectingCommentParser = parsers CollectingCommentParser.
 
private PredicateTokenParser = parsers PredicateTokenParser.
private CombinatorialParser = parsers CombinatorialParser.
private ParserError = parsers ParserError.
private Token = parsers Token.
|)
(
class NS3Grammar = ExecutableGrammar ( 
"Grammar for Newspeak3 (without types)."| 
 whitespace = super whitespace. "cache whitespace parser"
 colon =  tokenFromChar: $:.
 comma =  tokenFromChar: $,.
 dollar = tokenFromChar: $$.
 dot = tokenFromChar: $..
 equalSign = tokenFromChar:$=.
 hat = tokenFromChar: $^.
 lbracket = tokenFromChar: $[.
 lcurly = tokenFromChar: ${.
 lparen = tokenFromChar: $(.
 langleBracket = tokenFromChar: $<.
 pound = tokenFromChar: $#.
 rangleBracket = tokenFromChar: $>.
 rbracket = tokenFromChar: $].
 rcurly = tokenFromChar: $}.
 rparen = tokenFromChar: $).
 semicolon = tokenFromChar: $;.
 slash = tokenFromChar: $/.
 vbar = tokenFromChar: $|.
 mixinOperator =  tokenFromSymbol: {# '$:>$'}.
 digit = charBetween: $0 and: $9.
 digits =  digit plus.
 uppercaseLetter = charBetween: $A and: $Z.
 extendedDigits = (digit | uppercaseLetter) plus.
 radix = digits, (char: $r).                  
 fraction =  dot, digits.
 extendedFraction =  dot, extendedDigits.                    
 exponent = (char: $e), (char: $- ) opt, digits.
 decimalNum = (char: $-)  opt,  
                  digits, 
                  fraction opt,
                  exponent opt.
 radixNum = radix,
               (char: $-)  opt,  
               extendedDigits, 
               extendedFraction opt,
               exponent opt.       
 num =   radixNum | decimalNum.
 "must distinguish internal use of productions from use as tokens"                              
 number =  tokenFor: num.
 letter = PredicateTokenParser new accept:[:c | c isLetter]
                                                      errorMsg: 'letter expected'.
 specialCharacter = (char: $+ )  | (char: $/ ) |  
                                       (char: $\ ) | (char: $* )   |
                                       (char: $~ ) | (char: $<) | (char: $>) |
                                       (char: $=) | (char: $@ )  |
                                       (char: $% ) | (char: $| )  |
                                       (char: $& ) | (char: $? )  |
                                       (char: $! ) |  (char: $, ).                                                    
 character = digit | letter | specialCharacter | (char: $[  ) | (char: $]  ) |
                        (char: ${ ) | (char: $} ) | (char: $(  ) |
                        (char:$) ) | (char: $^ ) | (char: $; ) | (char: $$ ) | (char: $#  ) |
                        (char: $: ) | (char: $. ) | (char: $-) | (char: $_) | (char: $`) "the Smalltalk grammar neglects to add - to characters, or to comments. It does add | [self char: $' ], but these are both bugs. We intend to support underscores, which Squeak insists on turning into assignment arrows. However, we do not support these as assignments. At the moment, we do not accept them in identifiers, but this will change in time.".
                        

  id =  (letter | _),  ((letter | digit | _)) star
                 wrapper:[:fst   :snd  | fst asString, (String withAll: snd)].
                                           
 identifier =  tokenFor: id.

 aChar = (char: $$),  (character | (char: $' ) | (char: $" ) | (char:$ )).

 characterConstant = tokenFor: aChar.

 twoQuotes = (char: $' ),  (char: $' )
                   wrapper:[:q1 : q2 | ''''].

 str = (char: $' ),
           stringBody,
                   "[(character | [aWhitespaceChar] | (char: $" ") | twoQuotes) star],"
          (char: $')
              wrapper:[:oq :es :eq | es inject:'' into:[:s : e | s, e asString]].
 
 string = tokenFor: str.

 kw = id, (char: $:) wrapper:[: i  :c   | i, $: asString]. 

 kwds = kw plus wrap:[:c | c inject: '' into:[:s :e | s, e]].   
  
 keyword = tokenFor: kw. 

 setterKw = kw, (char: $:) wrapper:[: i  :c   | i, $: asString]. 

 setterKeyword = tokenFor: setterKw. 

 sym = str | kwds | binSel | id. 
 
 symbol = tokenFor: sym.
 
 commentDelimiter = char: $".

 beginComment = commentDelimiter.

 endComment = commentDelimiter.

 twoDblQuotes = (char: $" ),  (char: $" )
                   wrapper:[:q1 : q2 | '"'].

 smalltalkComment = beginComment, commentBody, endComment.

 pascalComment = PascalCommentParser new.

 comment = smalltalkComment | pascalComment.

 binSel =  (specialCharacter | (char: $- )), specialCharacter star
                          wrapper:[:c1  :c2  |
                                              c2 isEmpty ifTrue:[c1 asString asSymbol]
                                                             ifFalse:[(c1 asString, (c2 inject: '' into:[:s :e | s, e asString])) asSymbol ]
                                           "probably delay interning as symbol until later phase"
                                           ].
                                           
 binarySelector = tokenFor: binSel. "maybe intern as symbol here" 


"syntactic productions"

symbolConstant =   pound,  symbol.

 tuple =   lcurly,
           (expression starSeparatedOrTerminatedBy:  dot),
           rcurly.
 

"patterns"

"adding literals for patterns"
literal =
  pattern | number | symbolConstant | characterConstant | string | tuple.

pattern =  (tokenFromChar: $<), patternLiteral, (tokenFromChar: $>).
patternLiteral = wildcardPattern | literalPattern | keywordPattern.

wildcardPattern = tokenFromChar: $_.

"values which are comparable by means of #="
literalPattern = tokenFor:
  number | symbolConstant | characterConstant | string | tuple.

"keyword patterns"
keywordPattern = kwPatternPair plus.
kwPatternPair = keyword, kwPatternValue opt.
kwPatternValue =
  wildcardPattern | literalPattern | variablePattern | nestedPatternLiteral.
variablePattern = tokenFor: ( (char: $?), id ).
nestedPatternLiteral = tokenFor: ( pattern ).
                                  
 slotName =  identifier.                                                                                                                                                               
 unarySelector = UnarySelectorParser new on: self. " the one hack/flaw. See UnarySelectorParser for details"
                                          
 parenthesizedExpression =  lparen, expression, rparen.
                                                                                                          
 primary =  slotName | 
                   literal | 
                   block | 
                   parenthesizedExpression.
 
 unaryExpression = primary, unarySelector star.

 binaryMsg = binarySelector, unaryExpression.

 binaryExpression = unaryExpression, binaryMsg star.
                                                                
 keywordMsg =  (keyword, binaryExpression) plus.

 message = keywordMsg | unarySelector | binaryMsg.

 nontrivialUnaryMessages = unarySelector plus, binaryMsg star,  keywordMsg opt.

 nontrivialBinaryMessages = binaryMsg plus, keywordMsg opt.

 keywordMessages = keywordMsg.

 nonEmptyMessages = nontrivialUnaryMessages |
						nontrivialBinaryMessages  |
						keywordMessages.
                                               
 keywordExpression =  binaryExpression, keywordMsg opt.

 keywordHereSend = keywordMsg.

 cascadeMsg = semicolon, (keywordMsg | binaryMsg | unarySelector).

 msgCascade = nonEmptyMessages, cascadeMsg star.
                                                                                                                        
 cascadedMessageExpression = primary, msgCascade opt.

 sendExpression = keywordHereSend | cascadedMessageExpression. 

 expression = setterKeyword star, sendExpression.
                                              
 returnStatement = hat,  expression, dot opt.
                                                                                                                        
 furtherStatements = dot,  statements.             
                                                            
 statementSequence = expression, furtherStatements  opt.
                                         
 statements = returnStatement  |   
                  statementSequence |
                  empty.
                             
 blockParameter = colon, slotDecl.
                                          
 blockParameters =  blockParameter plus, vbar.

 slotDefs = slotDef star.
 seqSlotDecls = vbar, slotDefs, vbar.
 simSlotDecls = vbar, vbar, slotDefs, vbar, vbar.
 slotDecls = simSlotDecls | seqSlotDecls.

 temporaries = slotDecls.

beginNSComment = (char: $(), (char: $*).
endNSComment = (char: $*), (char: $)).
keywordAndLiteral = keyword, literal.
literalMessage = unarySelector | keywordAndLiteral plus.
literalMessageComment = beginNSComment, (tokenFromSymbol:#':literalmessage:'), literalMessage, whitespace opt,  endNSComment.


 codeBody = (literalMessageComment | pascalComment | smalltalkComment | whitespace) star, temporaries opt,  statements.
                              
 block = lbracket,  blockParameters opt, codeBody,  rbracket.
                      
 slotDecl = identifier.

 accessModifier =  ((tokenFromSymbol: #private) | 
                              (tokenFromSymbol: #public) | 
                              (tokenFromSymbol: #protected)), whitespace.

 slotDef =  accessModifier opt, slotDecl, 
                    (((tokenFromSymbol: #=) | 
                      (tokenFromSymbol: #'::=')
                     ), expression, dot) opt.
                    
 initExprs = expression starSeparatedOrTerminatedBy: dot.

 unaryMsgPattern = unarySelector.

 binaryMsgPattern = binarySelector, slotDecl.  
                                                         
 keywordMsgPattern = (keyword, slotDecl) plus.                                        
                                                                                  
 messagePattern =  unaryMsgPattern |
                                binaryMsgPattern |
                                keywordMsgPattern.       

 method = messagePattern, codeBody, eoi. "A method in a browser"
                                                                 
 methodHeader = accessModifier opt, [messagePattern].         
     
                                                                 "Top level productions for classes"

 methodDecl = accessModifier opt, messagePattern, equalSign, lparen, codeBody, rparen.

 methodDef = methodDecl | method. "For now, a rule that accepts either old browser form or new file form"

optionalFactorySection =  messagePattern opt, equalSign.

"Binding the message pattern for the primary factory to the following equal sign is an odd factoring of the grammar designed to work around some ugly problems.

The two would naturally be separated in classPrefix below, e.g.,

 classPrefix =  (tokenFromSymbol: #class), identifier, message Pattern opt, equalSign 
                        superclassClause opt. 

Alas, this odesn't work. If the primary factory signature is omitted, the equal sign and following superclass clause is matched. This eventually fails.  Unlike BNF,  the '|' operator  'cuts' at the first successful branch  rather than evaluating all branches in parallel or backtracking, so the message opt is not retried. We'd have to use a more general and expensive BNF style combinator.

Originally, we split this into two branches - one using a mandatory messagePattern and one with empty (the messagePattern could not simply be dropped, because the arity of the wrapper for each branch would differ).

This solution seems cleaner.
AS YET UNTESTED.
"

 classPrefix =  (tokenFromSymbol: #class), identifier, optionalFactorySection, 
                        superclassClause opt. 

 mixinApplication =  classPrefix , mixinOperator,  superclassClause. 

 nestedClassDecl = accessModifier opt, classDeclaration.
 
 category = string, methodDecl star.

 smalltalkClassComment = whitespace opt, smalltalkComment. "A hack, to preserve comments from a complete class declaration"
 pascalClassComment = whitespace opt, pascalComment.
 classComment = smalltalkClassComment | pascalClassComment.              

 sideDecl =  lparen, nestedClassDecl star, category star, rparen.

 classSideDecl = colon, lparen, category star, rparen.

 languageId = identifier.

 classCategory = string opt.

 superclassClause = slotName, message opt.

 classHeader =  (identifier, messagePattern, equalSign, 
                        superclassClause opt, lparen,  classComment opt, 
                        slotDecls opt, initExprs,  rparen) |
                        (identifier, empty, equalSign,
                        superclassClause opt, lparen,  classComment opt, 
                        slotDecls opt,  initExprs, rparen).
"A gross hack to allow for a default constructor pattern.  This should at least be refactored (note the awful use of empty to keep the arity the same for the wrapper in the parser. Ugh). 
It would be nice to just say messagePattern opt]. Alas, because the '|' operator  'cuts' at the first successful branch  rather than evaluating all branches in parallel or backtracking, this won't work."
 classDeclaration = (tokenFromSymbol: #class), classHeader, sideDecl, classSideDecl opt.

 toplevelClass = classCategory, classDeclaration.

 compilationUnit =  languageId, toplevelClass, eoi.
|)
('as yet unclassified'
_ = (
	^char: $_
)'grammar'
commentBody = (


"As an optimization, we process the body of a comment with a dedicated scanning parser. 
It should be equivalent to:

 ^(self character | self aWhitespaceChar | (self char: $' ) | self twoDblQuotes) star, "
^CollectingCommentParser new 
   termBlock:[: input | | c|
                c: input peek.
                c isNil 
                    ifTrue:[false] "let main routine handle end of input"
                    ifFalse:[c = $" 
                              ifFalse:[false]
                              ifTrue:[| pos | 
                                         pos: input position.
                                       input next.
                                       input peek = $" ifTrue:[false] ifFalse:[input position: pos. true]
                                     ]
                            ]
             ]
)
stringBody = (


"As an optimization, we process the body of a string with a dedicated scanning parser.
It should be equivalent to:

  ^(self character | self aWhitespaceChar | (self char: $"" ) | self twoQuotes) star"
^CollectingCommentParser new 
   termBlock:[: input | | c|
                c: input peek.
                c isNil 
                    ifTrue:[false] "let main routine handle end of input"
                    ifFalse:[c = $' 
                              ifFalse:[false]
                              ifTrue:[| pos | 
                                       pos: input position.
                                       input next.
                                       input peek = $' ifTrue:[false] ifFalse:[input position: pos. true]
                                     ]
                             ]
               ]
)) : ()
class PascalCommentParser = CombinatorialParser (
"As an optimization, we handle Pascal comments with a dedicated parser. It should be equivalent to:

beginPascalComment = (char: $(), (char: $*).
endPascalComment = (char: $*), (char: $)).
metadataTag = (char: $:), id, (char: $:).
any = charBetween: (Character value: 0) and: (Character value: 16r10FFFF).
pascalComment = beginPascalComment, 
	metadataTag opt, 
	((endPascalComment not, any) | pascalComment) star,
	endPascalComment.
	
This should be renamed to CommentParser after we remove support for Smalltalk-style comments.")
('as yet unclassified'
parse: input <ReadStream> inContext: context ifError: blk = (
	| pos = input position. body = {} asOrderedCollection. "cheat" |
	
	(input next = $( and: [input next = $*]) ifFalse: 
		[input position: pos.
		^blk value: '(* expected' value: pos].
	
	[ | c = input next. | 
	body add: c.
	c = $( ifTrue: 
		[ | d = input next. |
		d = $* ifTrue: [
			| res |
			body removeLast. " not part of comment body"
			input position: input position - 2.
			res:: self parse: input inContext: context ifError: 
				[:msg :pos2 |
				input position: pos.
				^blk value: '(* expected 2' value: pos].
			body addAll: res token.
		] ifFalse: [
			body add: d.
		]].
	c = $* ifTrue: 
		[| d = input next. |
		d = $) ifTrue: [
			body removeLast. " not part of comment body"
			^Token new
				for: (String withAll: body)
				start: pos end: input position]
		ifFalse: [
			input position: input position - 1. "Consider next char as possible end star-paren"
		]].
	c = nil ifTrue: 
		[input position: pos.
		^blk value: '(* expected' value: pos].
	] repeat.
)) : ()
class TypedNS3Grammar = NS3Grammar (
"A parser for Strongtalk syntax. Adds productions for the Strongtalk type expression sublanguage, and the changes needed to use types in Newsqueak code."|                   

 arg = tokenFromSymbol: #arg.
 for = tokenFromSymbol: #for.
 generic = tokenFromSymbol: #generic.
 inheritedTypeOf = tokenFromSymbol: #inheritedTypeOf.
 is = tokenFromSymbol: #is.
 mssg = tokenFromSymbol: #message.
 of = tokenFromSymbol: #of.

 receiverType = tokenFromSymbol: #receiverType.
 subtypeOf = tokenFromSymbol: #subtypeOf.
 typeArg = tokenFromSymbol: #typeArg.
 where = tokenFromSymbol: #where.
 returnType = hat, type.

                                                                 "Type Grammar"
                                                                 
  type = langleBracket, typeExpr,  rangleBracket.
  typePrimary = identifier, typeArguments opt.
  typeFactor =  typePrimary |
                   blockType | newBlockType |
                   tupleType |
                   parenthesizedTypeExpression.
  parenthesizedTypeExpression =  lparen,  typeExpr,  rparen.
  typeTerm = typeFactor, identifier star.
  typeExpr = typeTerm, ((vbar | semicolon | slash), typeExpr) opt.
  typeArguments = lbracket, (typeExpr plusSeparatedBy: comma),  rbracket. 
  blockType =  lbracket, blockTypeArgList,  rbracket.
  tupleType = lcurly, (typeExpr starSeparatedBy: dot), rcurly.
  nonEmptyBlockTypeArgList = (typeExpr plusSeparatedBy: comma), 
                                     (comma, blockReturnType) opt.
  blockTypeArgList =  nonEmptyBlockTypeArgList |
                                   blockReturnType opt.
  blockReturnType =  hat, typeExpr.

  newBlockArgType = colon, typeExpr.
  newBlockReturnType = typeExpr.
  newNonEmptyBlockArgList = newBlockArgType plus, (vbar, newBlockReturnType) opt.
  newBlockType = lbracket, (newNonEmptyBlockArgList | newBlockReturnType opt), rbracket.
                                        
                                         "Type inference"
                                         
  typePattern = langleBracket, typeFormal, (semicolon, typeFormal) star,  rangleBracket. "changed from {} to <> brackets to avoid conflict with tuples"
  typeFormal =  where, identifier, typeParamConstraint opt, is, inferenceClause.
  typeParamConstraint =  langleBracket,  typeBoundQualifier opt,  typeExpr, rangleBracket.
  typeBoundQualifier =  subtypeOf | inheritedTypeOf.
  inferenceClause = receiverType | 
                                      (returnType, returnTypeInferenceClause) |
                                      typeArgInferenceClause |
                                      (arg,  number, (of, msgSelector) opt).
  returnTypeInferenceClause =  of, msgSelector.
  msgSelector =  symbolConstant, mssg, of, inferenceClause.
  typeArgInferenceClause = typeArg, number, for, generic, symbolConstant, of, inferenceClause. 
 |)
('grammar'
messagePattern = (
     ^super messagePattern, returnType opt, typePattern opt. "Type annotations"
  )
slotDecl = (
    ^super slotDecl , type opt.
  )) : ()
class UnarySelectorParser = CombinatorialParser (
"In the absence of a separate lexer, an ambiguity arises, which this parser deals with.
 The problem is that when parsing a unary expression that is an argument to a keyword
 message, one expects a unary selector, which is an identifer.  However, it may be that the next
 token is actually a keyword, part of the surrounding message. If we aren't actually tokenizing,
 the prefix of the keyword will be misinterpreted as an identifier and hence as another unary
 message being sent to the argument.
 
 Using a lexer solves this but introduces a subtlety around the assignment operator :=. In that case
 if there is no whitespace between a variable name and the assignment, the variable name will
 be tokenized as a keyword rather than as an identifier. The Strongtalk parser, DeltaParser, deals
 with this specially. In the longterm, that is probably the way to go."| p |)
('as yet unclassified'
on: s = (
	p: s.
)
parse: input inContext: context ifError: blk = (
	| pos |
	pos:: input position.
	p keyword
		parse: input inContext: context
		ifError: [:msg :position | 
			input position: pos.
			^p identifier parse: input inContext: context ifError: blk].
	input position: pos.
	blk value: 'should not print' value: pos
)) : ()) : ()