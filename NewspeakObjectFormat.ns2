Newspeak3
'NewspeakObjectFormat'
class NewspeakObjectFormat vmMirror: vmMirror <SqueakVmMirror> usingPlatform: platform  <Platform> = NewspeakObject (
"
   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"|
       nofOuter = self. "in order to fix boot image build process (ns2->ns0 conversion fails for explicit outer sends"
	"Imports"
	private FileStream = platform Files FileStream.
	private String = platform Collections String.
	private IdentityDictionary = platform Collections IdentityDictionary.
	private Dictionary = platform Collections Dictionary.
	private ByteString = platform Collections ByteString.
	private ByteSymbol = platform Collections ByteSymbol.
	private ByteArray = platform Collections ByteArray.
	private LookupKey = platform Collections LookupKey.
	private Transcript = platform Transcript.
	private MessageNotUnderstood = platform Exceptions MessageNotUnderstood.
	private Behavior = platform Kernel Behavior.
	private MethodDictionary = platform Kernel MethodDictionary.
	private Error = platform Exceptions Error.
	private OrderedCollection = platform Collections OrderedCollection.
	private BloatedHistory = platform NewspeakObjectFormat BloatedHistory.
	private SqueakVmMirrorInspector = platform VmMirror SqueakVmMirrorInspector.
	private DefiningClassMetadata = platform NewsqueakMixins DefiningClassMetadata.
	private WeakArray = platform Collections WeakArray.
	
	private assert = platform NewspeakCore Assert new.

	"VM Mirrors"
	private sqVmMirror = vmMirror.
	private objectUtil = sqVmMirror objectUtil.
	private methodUtil = sqVmMirror methodUtil.
	private classUtil = sqVmMirror classUtil.
	
	"Global variables"
	private Smalltalk = platform Smalltalk.
	private Undeclared = platform Undeclared.

	"Newspeak Object Format"
	fmtBytes = 2r00.
	fmtWords = 2r01.
	fmtPointers = 2r10.
	fmtWeakPointers = 2r11.
	sFmtNormal = 2r00.
	sFmtSplitIndexable = 2r01.
	sFmtSpecial = 2r10.
	fmtWidth = 2.
	fmtMask = 2r11.
	headerTag = 2r01.
	tagMask = 2r11.
	noSize = 16rFFE.
	sizeExtension = 16rFFF.
	nilCode = 0.
	falseCode = 1.
	trueCode = 2.
	symbolCode = 3.
	symbolicClassReferenceCode = 2r1001.

	"Core object format"
	indexOfSuperclassInBehavior = 1.
	indexOfMethodDictInBehavior = 2.
	indexOfFormatInBehavior = 3.

	"Hack to work around NS2 compiler bug"
	NewspeakObjectFormat = self.
|)
(
class NewspeakObjectFormatDeserializer from: s <ReadStream> withBaseObjects: baseObjects <SequenceableCollection> = (
"This class deserializes objects from a stream as described in Newspeak Object Format."|
	"My real slots"
	protected stream = s.
	protected history ::= Array new: 16r10000.
	protected undefined = Undefined new.
	protected formatVisitor = FormatVisitor new.
	protected newCompiledMethodClass
	protected isSpecial ::= false.
	protected pseudoClasses = Dictionary new.
	streamOffset = baseObjects size * 4.
	initialStreamOffset = stream position.
	localHistory ::= OrderedCollection new.
|initializeHistory: baseObjects)
(
class CompiledMethodFiller = (|
|)
('as yet unclassified'
fillIn: obj <Object> ^<Object> = (
	newCompiledMethodClass: nextValue. "Skip the class, we cannot change the class of a CompiledMethod, but we save the new CompiledMethod class"
	methodUtil
		namedSlotIndicesOf: obj do:
			[ :i | "Read header followed by literals"
			methodUtil namedSlotOf: obj at: i put: nextValue];
		indexedSlotIndicesOf: obj do:
			[ :i | "Read bytecodes"
			methodUtil indexedSlotOf: obj at: i put: stream next].
	skipPadding.
	^obj
))
class FormatVisitor = (|
	protected compiledMethodFiller = CompiledMethodFiller new.
	protected indexableByteObjectFiller = IndexableByteObjectFiller new.
	protected indexableWordObjectFiller = IndexableWordObjectFiller new.
	protected regularObjectFiller = RegularObjectFiller new.
|)
('as yet unclassified'
visitCompiledMethod: object <Object> ^<Object> = (
	^compiledMethodFiller
)
visitIndexableByteObject: object <Object> ^<Object> = (
	^indexableByteObjectFiller
)
visitIndexableWordObject: object <Object> ^<Object> = (
	^indexableWordObjectFiller
)
visitRegularObject: object <Object> ^<Object> = (
	^regularObjectFiller
))
class IndexableByteObjectFiller = (|
|)
('as yet unclassified'
fillIn: obj <Object> ^<Object> = (
	make: nextValue classOf: obj.
	objectUtil
		indexedSlotIndicesOf: obj do:
			[ :i | "Read indexable byte fields"
			objectUtil indexedSlotOf: obj at: i put: stream next].
	skipPadding.
	^obj
))
class IndexableWordObjectFiller = (|
|)
('as yet unclassified'
fillIn: obj <Object> ^<Object> = (
	make: nextValue classOf: obj.
	objectUtil
		indexedSlotIndicesOf: obj do:
			[ :i | "Read indexable word fields"
			objectUtil indexedSlotOf: obj at: i put: (stream nextLittleEndianNumber: 4)].
	^obj
))
class PseudoClass named: n = (
"Describe the class in this comment."|
	superclass
	methodDict
	format
	instanceVariables
	organization
	subclasses
	name = n.
	classPool
	sharedPools
	environment
	category
	metadata
	mixin
|)
()
class RegularObjectFiller = (|
|)
('as yet unclassified'
fillIn: obj <Object> ^<Object> = (
	make: nextValue classOf: obj.
	objectUtil
		namedSlotIndicesOf: obj do:
			[ :i | "Read instance variables"
			objectUtil namedSlotOf: obj at: i put: nextValue];
		indexedSlotIndicesOf: obj do:
			[ :i | "Read indexable fields"
			objectUtil indexedSlotOf: obj at: i put: nextValue].
	^obj
))'as yet unclassified'
allocateObject ^<Object> = (
	| lsb pos f1 f2 sf instanceSize indexableSize obj |
	pos:: (position >> 2) + 1.
	lsb:: stream next.
	sf:: (lsb >> 2) bitAnd: fmtMask.
	f2:: (lsb >> 4) bitAnd: fmtMask.
	f1:: (lsb >> 6) bitAnd: fmtMask.
	indexableSize:: stream next.
	instanceSize:: stream next.
	indexableSize:: (instanceSize << 8 bitAnd: 16rF00) + indexableSize.
	instanceSize:: (stream next << 4) + (instanceSize >> 4).
	instanceSize = noSize ifTrue: [instanceSize:: -1].
	instanceSize = sizeExtension ifTrue: [instanceSize:: stream nextLittleEndianNumber: 4].
	indexableSize = noSize ifTrue: [indexableSize:: -1].
	indexableSize = sizeExtension ifTrue: [indexableSize:: stream nextLittleEndianNumber: 4].
	beginReadingObject: lsb instanceSize: instanceSize indexableSize: indexableSize.
	obj:: allocateObject: instanceSize indexableSize: indexableSize f1: f1 f2: f2 sf: sf.
	historyAt: pos put: obj.
	^obj
)
allocateObject: instanceSize <integer> indexableSize: indexableSize <Integer> f1: f1 <Integer> f2: f2 <Integer> sf: sf <Integer> = (
	sf = sFmtSpecial ifTrue: [^readSpecialObject: instanceSize indexableSize: indexableSize f1: f1 f2: f2 sf: sf].
	sf = sFmtNormal ifTrue:
		[ | obj |
		obj:: sqVmMirror
			allocateObjectOfFixedSize: instanceSize
			variableSize: indexableSize
			bytes: f2 = fmtBytes
			pointers: f2 > 1
			weak: f2 = fmtWeakPointers.
		objectUtil namedSlotIndicesOf: obj do:
			[ :i | objectUtil namedSlotOf: obj at: i put: undefined].
		^obj].
	sf = sFmtSplitIndexable ifTrue:
		[^sqVmMirror
			allocateCompiledMethod: instanceSize - 1
			byteCount: indexableSize].
	halt. "Unknown sf"
)
beginReadingObject: format <Integer> instanceSize: instanceSize indexableSize: indexableSize = (
	"| f1 f2 sf |
	sf:: (format >> 2) bitAnd: fmtMask.
	f2:: (format >> 4) bitAnd: fmtMask.
	f1:: (format >> 6) bitAnd: fmtMask.
	log
		cr; nextPutAll: '<object';
		cr; nextPutAll: '    pos=""', (stream position - 4) asString, '""';
		cr; nextPutAll: '    f1=""', (formatAsSymbol: f1), '""';
		cr; nextPutAll: '    f2=""', (formatAsSymbol: f2), '""';
		cr; nextPutAll: '    compiledMethod=""', (sf ~= sFmtNormal) asString, '""';
		cr; nextPutAll: '    instanceSize=""', instanceSize asString, '""';
		cr; nextPutAll: '    indexableSize=""', indexableSize asString, '"">'.
	openTags:: openTags + 1."
)
closeTags = (
	"1 to: openTags do: [:i | log cr; nextPutAll: '</object>']"
)
doneReadingObject: obj = (
	"log cr; nextPutAll: '</object>'.
	openTags:: openTags - 1."
	^obj
)
formatAsSymbol: fmt <Integer> = (
	fmt = 2r00 ifTrue: [^#bytes].
	fmt = 2r01 ifTrue: [^#words].
	fmt = 2r10 ifTrue: [^#pointers].
	fmt = 2r11 ifTrue: [^#weakPointers].
)
growToSize: size = (
	[history size < size] whileTrue:
		[history:: history, (Array new: history size)]
)
historyAt: pos <Integer> put: obj <Object> = (
	growToSize: pos.
	history at: pos put: obj.
	(nil == obj or: [true == obj or: [false == obj]]) ifFalse: [localHistory add: obj]
)
initializeHistory: baseObjects <SequenceableCollection> = (
	assert true: [baseObjects isSequenceable].
	"assert: [baseObjects asIdentitySet size = baseObjects size]."
	growToSize: baseObjects size.
	history replaceFrom: 1 to: baseObjects size with: baseObjects startingAt: 1.
)
make: cls <Object> classOf: obj <Object> = (
	| oldSize oldClass |
	oldClass:: objectUtil classOf: obj.
	oldSize:: objectUtil indexedSlotsOf: obj.
	"assert: [oldClass isVariable = (classUtil isVariable: oldClass)].
	assert: [oldClass isPointers = (classUtil isPointers: oldClass)].
	assert: [oldClass isBytes = (classUtil isBytes: oldClass)].
	assert: [oldClass instSize = (classUtil instanceSizeOf: oldClass)].
	assert: [oldClass instSpec = (classUtil instanceSpecOf: oldClass)].
	assert: [obj basicSize = oldSize]."
	objectUtil namedSlotOf: cls at: indexOfSuperclassInBehavior test: undefined andSet: [nil "oldClass"].
	objectUtil namedSlotOf: cls at: indexOfMethodDictInBehavior test: undefined andSet: [nil "MethodDictionary new"].
	objectUtil namedSlotOf: cls at: indexOfFormatInBehavior test: undefined andSet: [classUtil formatOf: oldClass].
	"assert: [oldClass isVariable = (classUtil isVariable: cls)].
	assert: [oldClass isPointers = (classUtil isPointers: cls)].
	assert: [oldClass isBytes = (classUtil isBytes: cls)].
	assert: [oldClass instSize = (classUtil instanceSizeOf: cls)].
	assert: [oldClass instSpec = (classUtil instanceSpecOf: cls)].
	changeClassFailures add: obj -> cls."
	objectUtil changeClassOf: obj to: cls.
	assert true: [oldSize = (objectUtil indexedSlotsOf: obj)].
)
nextValue ^<Object> = (
	stream peek even ifTrue: [^readInteger].
	^((stream peek bitAnd: tagMask) = headerTag)
		ifTrue: [readObject]
		ifFalse: [readReference]
)
noteReadInteger: i <Integer> = (
	"log cr; nextPutAll: '<int value=""', i asString, '""/>'."
	^i
)
noteReadReference: ref <Integer> = (
	"log cr; nextPutAll: '<ref value=""', (ref << 2) asString, '""/>'."
	^ref
)
position = (
	^stream position + streamOffset - initialStreamOffset
)
readInteger ^<SmallInteger> = (
	| lsb b2 b3 msb |
	lsb:: stream next.
	b2:: stream next.
	b3:: stream next.
	msb:: stream next.
	 ^noteReadInteger: (lsb bitShift: -1) + (b2 bitShift: 7) + (b3 bitShift: 15)
			+ ((msb bitAnd: 16r7F) - (msb bitAnd: 16r80) bitShift: 23)
)
readObject ^<Object> = (
	| newObject |
	newObject:: allocateObject.
	isSpecial ifTrue: [^skipSpecialObjectClass: newObject].
	^doneReadingObject:: (objectUtil switchOn: newObject using: formatVisitor) fillIn: newObject.
)
readReference ^<Object> = (
	| lsb b2 b3 msb |
	lsb:: stream next.
	b2:: stream next.
	b3:: stream next.
	msb:: stream next.
	^history at: (noteReadReference: (lsb >> 2) + (b2 << 6) + (b3 << 14) + (msb << 22)) + 1
)
readSpecialObject: instanceSize <integer> indexableSize: indexableSize <Integer> f1: f1 <Integer> f2: f2 <Integer> sf: sf <Integer> = (
	| code |
	code:: readInteger.
	isSpecial:: true.
	code == nilCode ifTrue: [^nil].
	code == falseCode ifTrue: [^false].
	code == trueCode ifTrue: [^true].
	code == symbolCode ifTrue: [^readSymbol: indexableSize].
	code == symbolicClassReferenceCode ifTrue: [^readSymbolicClassReference: indexableSize].
	halt "unrecognized code"
)
readSymbol: size <Integer> = (
	| bytes |
	bytes:: ByteArray new: size.
	1 to: size do: [ :i | bytes at: i put: stream next].
	skipPadding.
	^bytes asString asSymbol
)
readSymbolicClassReference: size <Integer> = (
	| cls clsName |
	clsName:: nextValue.
	cls:: Smalltalk classNamed: clsName.
	nil = cls ifTrue: [
		error: 'Class not found: ', clsName asString printString.
		cls:: pseudoClasses at: clsName ifAbsentPut: [PseudoClass named: clsName]].
	isSpecial:: true. "This may be reset during nextValue above"
	^cls
)
skipPadding = (
	| padding |
	padding:: 4 - (position \\ 4).
	padding = 4 ifFalse: [stream skip: padding]
)
skipSpecialObjectClass: obj = (
	isSpecial:: false.
	nextValue. "skip the class of the special object"
	^obj
))
class NewspeakObjectFormatSerializer on: s <WriteStream> withBaseObjects: baseObjects <SequenceableCollection> = (
"This class serializes objects on a stream as described in Newspeak Object Format."|
	"Copy down hack"
	private FileStream = nofOuter FileStream.
	private String = nofOuter String.
	private IdentityDictionary = nofOuter IdentityDictionary.
	private Dictionary = nofOuter Dictionary.
	private ByteString = nofOuter ByteString.
	private ByteSymbol = nofOuter ByteSymbol.
	private ByteArray = nofOuter ByteArray.
	private LookupKey = nofOuter LookupKey.
	private Transcript = nofOuter Transcript.
	private MessageNotUnderstood = nofOuter MessageNotUnderstood.
	private Behavior = nofOuter Behavior.
	private MethodDictionary = nofOuter MethodDictionary.
	private Error = nofOuter Error.
	private OrderedCollection = nofOuter OrderedCollection.
	private DefiningClassMetadata = nofOuter DefiningClassMetadata.
	private sqVmMirror = nofOuter sqVmMirror.
	private objectUtil = nofOuter objectUtil.
	private methodUtil = nofOuter methodUtil.
	private classUtil = nofOuter classUtil.
	private Smalltalk = nofOuter Smalltalk.
	private Undeclared = nofOuter Undeclared.
	private fmtBytes = nofOuter fmtBytes.
	private fmtWords = nofOuter fmtWords.
	private fmtPointers = nofOuter fmtPointers.
	private fmtWeakPointers = nofOuter fmtWeakPointers.
	private sFmtNormal = nofOuter sFmtNormal.
	private sFmtSplitIndexable = nofOuter sFmtSplitIndexable.
	private sFmtSpecial = nofOuter sFmtSpecial.
	private fmtWidth = nofOuter fmtWidth.
	private fmtMask = nofOuter fmtMask.
	private headerTag = nofOuter headerTag.
	private tagMask = nofOuter tagMask.
	private noSize = nofOuter noSize.
	private indexOfSuperclassInBehavior = nofOuter indexOfSuperclassInBehavior.
	private indexOfMethodDictInBehavior = nofOuter indexOfMethodDictInBehavior.
	private indexOfFormatInBehavior = nofOuter indexOfFormatInBehavior.
	private nilCode = nofOuter nilCode.
	private falseCode = nofOuter falseCode.
	private trueCode = nofOuter trueCode.
	private symbolCode = nofOuter symbolCode.
	private symbolicClassReferenceCode = nofOuter symbolicClassReferenceCode.

	"My real slots"
	stream = s.
	history = BloatedHistory withShift: 3 usingAssert: assert.
	positionOfNil
	positionOfFalse
	positionOfTrue
	globals = OrderedCollection new.
	useSymbolicClassReferences ::= false.
	streamOffset = baseObjects size * 4.
	initialStreamPosition ::= stream position.
	localHistory ::= OrderedCollection new.

	weakSwap ::= IdentityDictionary new.
|initializeHistory: baseObjects)
('accessing'
nextPut: obj <Object> = (

	nil == obj ifTrue: [^nextPutNil].
	false == obj ifTrue: [^nextPutFalse].
	true == obj ifTrue: [^nextPutTrue].

	obj class == WeakArray ifTrue: [
		nextPutObject: (
			weakSwap at: obj ifAbsentPut: (WeakArray new: obj size)
		).
		^assert true: [(position bitAnd: 2r11) = 0].
	].

	obj class == #nextPut: class ifTrue: [^nextPutSymbol: obj].
	obj class == 1 class ifTrue: [^nextPut31BitInteger: obj].
	obj isCompiledMethod ifTrue: [^nextPutCompiledMethod: obj].
	obj class isMeta ifTrue: [^nextPutClass: obj].
	nextPutObject: obj.
	assert true: [(position bitAnd: 2r11) = 0].
)
nextPutClass: cls <Class> = (
	cls isMeta ifTrue: [^nextPutObject: cls].
	useSymbolicClassReferences ifTrue: [^nextPutSymbolicClassReference: cls].
	nextPutReferenceTo: cls ifFirstTime:
		["Transcript cr; show: cls name."
		assert true: [cls class instSize >= 14].
		assert true: [cls class isVariable not].
		nextPutObjectHeader: cls.
		nextPutClass: cls class.
		(DefiningClassMetadata of: cls) userData serialization
			storeClassSlotsOf: cls on: self using: sqVmMirror]
)
nextPutClassFormat: format <Integer> = (
	nextPut31BitInteger:: format bitAnd: 16r7FFF07FF
)'as yet unclassified'
initializeHistory: baseObjects <SequenceableCollection> = (
	assert true: [baseObjects isSequenceable].
	"assert: [baseObjects asIdentitySet size = baseObjects size]."
	baseObjects withIndexDo: [ :obj :i | history at: obj put: (i-1)*4]
)
nextPut32BitInteger: i <SmallInteger> = (
	nextPut16BitUnsignedInteger:: (i bitAnd: 16rFFFF).
	nextPut16BitUnsignedInteger:: i >> 16 bitAnd: 16rFFFF
)
nextPutByte: byte <Integer> = (
	assert true: [byte negative not].
	assert true: [byte < 256].
	stream nextPut: byte.
)
nextPutClassEnvironment: dict <SystemDictionary> = (
	assert true: [dict ~~ Smalltalk].
	nextPut: dict.
)
nextPutClassPool: dict <Dictionary> = (
	nil = dict ifTrue: [^nextPutNil].
	nextPutReferenceTo: dict ifFirstTime:
		["self halt."
		nextPutObjectNoReference: #'NukedDictionary']
)
nextPutFalse = (
	nil = positionOfFalse
		ifTrue: [
			positionOfFalse:: position.
			nextPutObjectHeader: false isSpecial: true.
			nextPut31BitInteger: falseCode.
			nextPutClass: false class]
		ifFalse: [
			nextPutReference: positionOfFalse]
)
nextPutLanguageData: languageData = (
	nextPut: languageData
)
nextPutLiteral: lit <Object> = (
	lit isVariableBinding ifFalse: [^nextPut:lit].
	lit key ifNil: [^nextPut:lit].
	nextPutReferenceTo: lit ifFirstTime:
		[globals add: lit.
		nextPutObjectNoReference:: "unbind:" lit]
)
nextPutMethodHeader: m <CompiledMethod> = (
	|
	literalCount <Integer>
	byteCount <Integer>
	f1 <Integer>
	f2 <Integer>
	sf <Integer>
	fmt <Integer>
	|
	literalCount:: m numLiterals + 1. "method header"
	byteCount:: m size - m initialPC + 1.
	assert true: [literalCount < noSize]. "Deal with large objects later"
	assert true: [byteCount < noSize]. "Deal with large objects later"
	assert true: [literalCount negative not].
	assert true: [byteCount negative not].
	f1:: fmtPointers.
	f2:: fmtBytes.
	sf:: sFmtSplitIndexable.
	fmt:: f1.
	fmt:: (fmt << fmtWidth) + f2.
	fmt:: (fmt << fmtWidth) + sf.
	fmt:: (fmt << fmtWidth) + headerTag.
	stream
		nextPut: fmt;
		nextPut: (byteCount bitAnd: 16rFF);
		nextPut: ((literalCount bitAnd: 16rF) << 4 bitOr: byteCount >> 8);
		nextPut: literalCount >> 4
)
nextPutMixin: mixin = (
	nextPut: mixin
)
nextPutNil = (
	nil = positionOfNil
		ifTrue: [
			positionOfNil:: position.
			nextPutObjectHeader: nil isSpecial: true.
			nextPut31BitInteger: nilCode.
			nextPutClass: nil class]
		ifFalse: [
			nextPutReference: positionOfNil]
)
nextPutObjectHeader: instanceVariableCount <Integer> variableSize: variableSize <Integer> bytes: isBytes <Boolean> pointers: isPointers <Boolean> weak: isWeak <Boolean> isSpecial: isSpecial <Boolean> = (
	| namedSize indexableSize f1 f2 sf fmt |

	namedSize:: instanceVariableCount < noSize
		ifTrue: [instanceVariableCount] ifFalse: [sizeExtension].
	namedSize:: namedSize negative
		ifTrue: [noSize] ifFalse: [namedSize].
	indexableSize:: variableSize < noSize
		ifTrue: [variableSize] ifFalse: [sizeExtension].
	indexableSize:: indexableSize negative
		ifTrue: [noSize] ifFalse: [indexableSize].

	f1:: fmtPointers.
	f2:: isBytes
		ifTrue: [fmtBytes]
		ifFalse: [isPointers
					ifTrue: [isWeak
								ifTrue:[fmtWeakPointers]
								ifFalse: [fmtPointers]]
					ifFalse: [fmtWords]].
	sf:: isSpecial ifTrue: [sFmtSpecial] ifFalse: [sFmtNormal].
	fmt:: f1.
	fmt:: (fmt << fmtWidth) + f2.
	fmt:: (fmt << fmtWidth) + sf.
	fmt:: (fmt << fmtWidth) + headerTag.
	stream
		nextPut: fmt;
		nextPut: (indexableSize bitAnd: 16rFF);
		nextPut: ((namedSize bitAnd: 16rF) << 4 bitOr: indexableSize >> 8);
		nextPut: namedSize >> 4.

	namedSize = sizeExtension ifTrue: [nextPut32BitInteger: instanceVariableCount].
	indexableSize = sizeExtension ifTrue: [nextPut32BitInteger: variableSize]
)
nextPutObjectHeader: obj <Object> = (
	^nextPutObjectHeader: obj isSpecial: false
)
nextPutObjectHeader: obj <Object> isSpecial: isSpecial <Boolean> = (
	| fixedSize indexableSize instSpec |
	instSpec:: obj class instSpec.
	fixedSize:: obj class instSize.
	fixedSize:: (fixedSize = 0 and: [instSpec ~= 3 or: [instSpec ~= 4]])
		ifTrue: [-1]
		ifFalse: [fixedSize].
	indexableSize:: obj class isVariable
		ifTrue: [obj basicSize]
		ifFalse: [-1].
	self
		nextPutObjectHeader: fixedSize
		variableSize: indexableSize
		bytes: obj class isBytes
		pointers: obj class isPointers
		weak: obj class isWeak
		isSpecial: isSpecial
)
nextPutObjectNoReference: obj <Object> = (
	nextPutObjectHeader: obj.
	nextPutClass: obj class.
	objectUtil namedSlotIndicesOf: obj do: [ :i | nextPut:: objectUtil namedSlotOf: obj at: i].
	obj class isPointers
		ifTrue:
			[objectUtil indexedSlotIndicesOf: obj do: [ :i | nextPut:: objectUtil indexedSlotOf: obj at: i]]
		ifFalse:
			[obj class isBytes
				ifTrue: [objectUtil indexedSlotIndicesOf: obj do: [ :i | nextPutByte:: objectUtil indexedSlotOf: obj at: i].
					stream padTo: 4 put: 0]
				ifFalse: [objectUtil indexedSlotIndicesOf: obj do: [ :i | nextPut32BitInteger:: objectUtil indexedSlotOf: obj at: i]]
			]
)
nextPutReference: pos <Integer> = (
	assert true: [(pos bitAnd: 2r11) = 0].
	nextPut16BitUnsignedInteger:: (pos bitAnd: 16rFFFF) bitOr: 2r11.
	nextPut16BitUnsignedInteger:: pos >> 16 bitAnd: 16rFFFF
)
nextPutReferenceTo: obj <Object> ifFirstTime: action <BlockContext> = (
	| pos |
	obj class == 1 class ifTrue:
		[nextPut31BitInteger: obj.
		^self].
	pos:: history at: obj ifAbsent:
		[history at: obj put: position.
		localHistory add: obj.
		assert true: [(position bitAnd: 2r11) = 0].
		action value.
		^self].
	nextPutReference: pos
)
nextPutSharedPools: pools = (
	nil = pools ifTrue: [^nextPutNil].
	nextPutReferenceTo: pools ifFirstTime:
		["self halt."
		nextPutObjectNoReference: #'NukedDictionary']
)
nextPutSubclassesArray: subclasses= (
	nextPutNil
)
nextPutSuperclass: cls <Class> = (
	nil = cls ifTrue: [^nextPutNil].
	assert true: [cls class isMeta].
	assert true: [cls isMeta not].
	nextPutClass: cls
)
nextPutSymbol: sym <ByteSymbol> = (
	nextPutReferenceTo: sym ifFirstTime:
		[nextPutObjectHeader: sym isSpecial: true.
		nextPut31BitInteger: symbolCode.
		objectUtil indexedSlotIndicesOf: sym do: [ :i | nextPutByte:: objectUtil indexedSlotOf: sym at: i].
		stream padTo: 4 put: 0.
		nextPutClass: sym class]
)
nextPutSymbolicClassReference: cls <Class> = (
	nextPutReferenceTo: cls ifFirstTime:
		[nextPutObjectHeader: cls isSpecial: true.
		nextPut31BitInteger: symbolicClassReferenceCode.
		nextPut: cls name.
		nextPut: nil "class of cls"]
)
nextPutTrue = (
	nil = positionOfTrue
		ifTrue: [
			positionOfTrue:: position.
			nextPutObjectHeader: true isSpecial: true.
			nextPut31BitInteger: trueCode.
			nextPutClass: true class]
		ifFalse: [
			nextPutReference: positionOfTrue]
)
position = (
	^stream position + streamOffset - initialStreamPosition
)
unbind: binding <LookupKey> = (
	^binding class newFrom: (LookupKey newFrom: binding)
)'basic kinds'
nextPut31BitInteger: i <SmallInteger> = (
	nextPut16BitUnsignedInteger:: (i bitAnd: 16r7FFF) << 1.
	nextPut16BitUnsignedInteger:: i >> 15 bitAnd: 16rFFFF
)
nextPutCompiledMethod: m <CompiledMethod> = (
	nextPutReferenceTo: m ifFirstTime:
		[nextPutMethodHeader: m.
		nextPutClass: m class.
		methodUtil namedSlotIndicesOf: m do: [ :i | nextPutLiteral:: methodUtil namedSlotOf: m at: i].
		methodUtil indexedSlotIndicesOf: m do: [ :i | nextPutByte:: methodUtil indexedSlotOf: m at: i].
		stream padTo: 4 put: 0
		]
)
nextPutObject: obj <Object> = (
	nextPutReferenceTo: obj ifFirstTime: [nextPutObjectNoReference: obj]
)'private'
nextPut16BitUnsignedInteger: i <SmallInteger> = (
	stream
		nextPut: (i bitAnd: 16rFF);
		nextPut: (i >> 8 bitAnd: 16rFF)
))
class Switch on: expr <Object> = (|
	expression = expr.
	result
	done ::= false.
|)
('as yet unclassified'
default: action <[]|[Object]> = (
	^on: [true] do: action	
)
end = (

	^result
)
on: condition <BlockContext> do: block <BlockContext> = (


	done ifTrue: [ ^nil ].
	^(condition isBlock
			ifTrue:	[ (condition valueWithPossibleArgument: expression)]
			ifFalse:	[ condition == expression ])
		ifTrue: [ done: true. result:: block valueWithPossibleArgument: expression ]
))
class Undefined = ()
('as yet unclassified'
printOn: s <WriteStream> = (
	s nextPutAll: '<undefined>'
))'as yet unclassified'
deserializerFrom: s <ReadStream> ^<NewspeakObjectFormatDeserializer> = (
	^NewspeakObjectFormatDeserializer from: s withBaseObjects: {}
)
deserializerFrom: s <ReadStream> withBaseObjects: baseObjects <SequenceableCollection> ^<NewspeakObjectFormatDeserializer> = (
	^NewspeakObjectFormatDeserializer from: s withBaseObjects: baseObjects
)
serializerOn: s <WriteStream> ^<NewspeakObjectFormatSerializer> = (
	^NewspeakObjectFormatSerializer on: s withBaseObjects: {}
)
serializerOn: s <WriteStream> withBaseObjects: baseObjects <SequenceableCollection> ^<NewspeakObjectFormatSerializer> = (
	^NewspeakObjectFormatSerializer on: s withBaseObjects: baseObjects
)
testSwitchOn: obj = (
	^(Switch on: obj)
		on: ByteString do: [ #String ];
		on: ByteSymbol do: [ #Symbol ];
		on: ByteString do: [ #FallThrough ];
		end
)) : ('as yet unclassified'
deserializeApplicationFrom: stream <ReadStream> usingPlatform: platform <Platform> ^  <Object> = (
" Sample usage:
| app |
app := (NewspeakObjectFormat 
	deserializeApplicationFrom: (StandardFileStream readOnlyFileNamed: 'someFile.nof') binary
	usingPlatform: Platform new).
	"
	|
	nof <Instance>
	baseObjects <Array>
	deser <NewspeakObjectFormatDeserializer>
	app <Object>
	|
	nof::  vmMirror: vmMirror usingPlatform: platform.
	baseObjects:: (platform NofBaseObjects forApplicationDeliveryUsingPlatform: platform) baseObjects.	
	deser:: nof deserializerFrom:  stream withBaseObjects: baseObjects.
	app:: deser nextValue.
	deser localHistory do: [:each | [each rehash] ifError: []].
	^app
)
deserializePlatformFrom: stream <ReadStream> usingPlatform: platform <Platform> = (
	|
	Smalltalk <SystemDictionary>
	nof <self instance>
	deserializer <NewspeakObjectFormatDeserializer>
	compactClassesCount <Integer>
	mockCompactClasses <Array[Object]>
	specialObjects <Array>
	compactClasses <Array[Class]>
	identityHashCount <Integer>
	arguments <Array>
	mainObject
	|
	Smalltalk:: platform Smalltalk.
	nof:: self vmMirror: vmMirror usingPlatform: platform.
	deserializer:: nof deserializerFrom: stream.
	compactClassesCount:: deserializer readInteger.
	mockCompactClasses:: ((1 to: compactClassesCount) collect: [Object new]) asArray.
	deserializer:: nof deserializerFrom: stream withBaseObjects: mockCompactClasses.
	specialObjects:: deserializer nextValue.
	compactClasses:: deserializer nextValue.
	identityHashCount:: deserializer nextValue.
	1 to identityHashCount do:
		[ :i |
		setIdentityHashOf: (deserializer localHistory at: i) to: (deserializer nextValue)].
	arguments:: deserializer nextValue.
	mainObject:: deserializer nextValue.
	mockCompactClasses elementsForwardIdentityTo: compactClasses.
	Smalltalk specialObjectsArray become: specialObjects.
	^mainObject main: arguments
)
serializeApplication: mainObject on: stream <WriteStream> usingPlatform: platform <Platform> = (
"Sample usage:
		FileStream forceNewFileNamed: 'myApp.nof' do:
		[:s |
		s binary.
		NewspeakObjectFormat
			serializeApplication: myAppObject
			on: s
			usingPlatform: Platform new]

"
	|
	nof <Instance>
	baseObjects <Array>
	|
	nof:: vmMirror: vmMirror usingPlatform: platform.
	baseObjects:: (platform NofBaseObjects forApplicationDeliveryUsingPlatform: platform) baseObjects.	
	(nof serializerOn: stream withBaseObjects: baseObjects) nextPut: mainObject.
)
serializePlatform: platform <Platform> mainObject: mainObject arguments: arguments <Array> on: stream <WriteStream> = (
	|
	Smalltalk <SystemDictionary>
	nof <self instance>
	serializer <NewspeakObjectFormatSerializer>
	specialObjects <Array>
	compactClasses <Array[Class]>
	|
	Smalltalk:: platform Smalltalk.
	nof:: self vmMirror: vmMirror usingPlatform: platform.
	specialObjects:: Smalltalk specialObjectsArray.
	compactClasses:: Smalltalk compactClassesArray copyWithout: nil.
	compactClasses:: (compactClasses collect: [:each | each clone]) asArray.
	serializer:: nof serializerOn: stream withBaseObjects: compactClasses.
	serializer nextPut31BitInteger: compactClasses size.
	serializer initialStreamPosition: stream position.
	serializer nextPutObject: specialObjects.
	serializer nextPutObject: compactClasses.
	serializer nextPutObject: serializer localHistory size - compactClasses size.
	(serializer localHistory allButFirst: compactClasses size) do:
		[:each | serializer nextPutObject: each identityHash].
	serializer nextPutObject: arguments.
	serializer nextPutObject: mainObject.
))