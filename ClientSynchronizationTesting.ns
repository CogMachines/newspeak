Newspeak3
'OrthogonalSynchronization'
class ClientSynchronizationTesting usingPlatform: p model: clientSync minitest: m  = (
|
	StoreClient = clientSync StoreClient.
	ChangeTrackingContext = clientSync ChangeTrackingContext.
	ClientUpdater = clientSync ClientUpdater.
	List = p collections List.
	Map = p collections Map.
	ObjectMirror = p mirrors ObjectMirror.
	TestContext = m TestContext.
	public toDoListModel 
	public clientServerModule
	public versioningModule
	
		
|
) (
public class ClientSynchronizationTests = TestContext (
|
	storeClient = StoreClient new.
	server
	initialObjectsByName
|
	server: createServer. 
	initialObjectsByName: createInitialObjectsForTestsByName. 

) (
class ServerMock clientServerSyncModule: csSyncModule withObjectsByName:  objectsByNameMap = (
|
	objectsByName = objectsByNameMap.
	versionsServer = versioningModule VersionsServer new.
	store = versionsServer createStoreNamed: 'myStore' .
	clientServerSyncModule = csSyncModule.
	idsByName = Map new. 
|
	
) (
createDefinitionsForNewObjects = (
	^ newObjects collect: [ :each |	serverChangeTrackingContext createObjectDefinitionWithIdForExisting: each ].
)
createIdsMap: objects = (
	|   map   idGenerator |
	idGenerator:: IdGenerator seed: 1 nextIdBlock: [ :x | x + 1].
	map::  Map new.
	objects do: [ :each | map at: each put:  idGenerator nextId. ].
	^ map.
)
public currentAnchorId = (
	^ store anchorVersionId.
)
public idForObject: anObject   = (
	^ serverChangeTrackingContext idForObject: anObject.
)
public idForObjectNamed: aName  = (
	^ idsByName at:  aName.
)
public installInitialVersion = (
	| client rootOnServer map initialVersion rootObjectDefinition newStoreVersion |
	
	client:: 	StoreClient new.

	rootOnServer:: RootModel new.
	map:: Map new.
	map at: rootOnServer put: 0.
	client cto  installNewObjectsFromIObjectToIdsMap: map.


	rootObjectDefinition:: clientServerSyncModule ObjectDefinition classNamed: 'RootModel'  enclosingObjectReference: (clientServerSyncModule UnidentifiableObject for: nil) withContents: Map new.	


	initialVersion:: store createNewInitialVersionWithId: 0.
	newStoreVersion: store newVersionFromAnchor.
	newStoreVersion addObjectVersionWithParent: initialVersion versionedData: rootObjectDefinition.
	store defineAsAnchor: newStoreVersion.
	
	
	client currentVersion: store anchorVersionId.
	rootOnServer task: (objectsByName at: 'task1' ).
	rootOnServer toDoListModel:  (objectsByName at: 'toDoListModel' ).
	client synchronizeWithServer: self.
	
	objectsByName keysAndValuesDo: [ :name :object |  (name = 'root') 
									ifFalse: [ idsByName at: name put: (client idForObject:  object)] ].
								
	idsByName at: 'root' put: 0.
)
public objectNamed: aName = (
	^ objectsByName at: aName.
)
public synchronize: aChangeLogFromClient = (
	^ store synchronizeWith: aChangeLogFromClient.

)
) : (
)
aa = (

	|  newTask anotherNewTask values   ids changes  internalTasksArray   | 


	anotherNewTask::  ToDoTask describedBy: 'another new task' dependsOn: task2.
	newTask::  ToDoTask describedBy: 'my new task' dependsOn: anotherNewTask.

	
	

	internalTasksArray::  contentForSlot: #contents in: tasks.

	
	ids::  Map new.
	ids at: task1 put: 1.
	ids at: task2 put: 2	.
	ids at: task3 put: 3.
	ids at: root put: 4.
	ids at: tasks put: 5.
	ids at: internalTasksArray put: 6.

	
	
	cto installNewRoot: root identifiedBy: ids.

(*	changes:: cto detectChanges.	*)
	(* no changes *)

	tasks at: 1 put: task2.
	tasks at: 2 put: anotherNewTask.

(*
	tasks add: task1.
	tasks add: task1.
	tasks add: task1.
	tasks add: task1.
	tasks add: task1.
	tasks add: task1.
	tasks add: task1.
*)	
	internalTasksArray:: nil. 

	changes:: cto detectChanges.	

(*	assert: exp equals:   *)
	


	 
)
contentForSlot: aSlotName in: anObject  = (
	| mirror |
	mirror:: ObjectMirror  reflecting: anObject.
	^  (mirror getSlot: aSlotName) reflectee.
)
createInitialObjectsForTestsByName = (
	| map internalTasksArray 	task1 	task2 	task3   	root	tasks  | 

	task3::  ToDoTask describedBy: 'my task 3' dependsOn: nil.
	task2::   ToDoTask describedBy: 'my task 2' dependsOn: task3.
	task1::  ToDoTask describedBy: 'my task 1' dependsOn: task2.

	root::  RootModel new.

	tasks:: List new.
	tasks add: task1.
	tasks add: task2.
	tasks add: task3.

	root task: task1.
	(*root elements: tasks. *)
	
	(* internalTasksArray:: contentForSlot: #contents in: tasks. *)
	

	map:: Map new.
	map at: 'task1' put:  task1.
	map at: 'task2' put:  task2.	
	map at: 'task3' put:  task3.
(*	map at: 'tasks' put:  tasks. *)
(*	map at: 'internalTasksArray' put:  internalTasksArray. *)
	map at: 'root' put:  root.
	map at: 'toDoListModel' put: toDoListModel. 
	
	^ map.

)
createServer = (
	^ ServerMock clientServerSyncModule: clientServerModule withObjectsByName: createInitialObjectsForTestsByName.
)
cto  = (

	^storeClient cto.
)
initialStoreVersion  = (
	^ server currentAnchorId.  
)
installContextFromLocal   = (
	| map nextId | 
	map:: Map new.

	nextId:: 1.	
	initialObjectsByName keysAndValuesDo: [ :name :obj |  
													map at: obj put: nextId. 
													nextId:: nextId +1.  ]. 
	storeClient cto  installNewRoot: (initialObjectsByName at: 'root' ) identifiedBy: map.
	 
)
installContextFromServer   = (
	server installInitialVersion.
	installContextFromServerInto: storeClient using: initialObjectsByName.

)
installContextFromServerInto: aStoreClient using: anInitialObjectsMap   = (
	| map | 
	map:: Map new.
	
	anInitialObjectsMap keysAndValuesDo: [ :name :obj |  map at: obj put: (server idForObjectNamed: name )  ]. 
	aStoreClient cto  installNewRoot: (anInitialObjectsMap at: 'root' ) identifiedBy: map.
	aStoreClient currentVersion: initialStoreVersion. 
)
objectNamed: aName  = (
	^ initialObjectsByName at: aName.
)
synchronize = (
	^ storeClient synchronizeWithServer: server.
)
public   testChangesAreDetectedWhenModifyingBasicValueForSlot = (
	|   task1 changeLog newTextForTask changeRecord| 

	installContextFromLocal.

	newTextForTask::  'modified task1' .
	task1:: objectNamed:  'task1' .
	 task1 text: newTextForTask.

	changeLog:: cto detectChanges changeLog.

	assert: changeLog changeRecords size equals: 1.

	changeRecord:: changeLog changeRecords first.
	assert:  (changeRecord  refersTo: task1 in: cto).
	
	assert:  changeRecord changes  size equals: 1.
	assert:  (changeRecord changes includesKey: #text).
	assert:  ((changeRecord changes at: #text) refersTo: newTextForTask inContext: cto).
	
		
	assert:  changeLog  hasNoNewObjectsDefinitions.
	 
)
public   testClientGetsUpdatedCorrectlyAfterMultipleVersionChanges = (
	| task2  task3     newTextForTask2 newTextForTask3  |  

	installContextFromServer.
	
	task2:: objectNamed: 'task2' .	
	task3:: objectNamed: 'task3' .	


	newTextForTask2:: 'changed task2'.		
	newTextForTask3:: 'changed task3'.		

	withNewClientDo: [ :newClient |
		| task2OnNewSession |
		task2OnNewSession:: newClient objectById: (storeClient idForObject:  task2)  .
		task2OnNewSession text: newTextForTask2 .
	].


	withNewClientDo: [ :newClient |
		| task3OnNewSession |
		task3OnNewSession:: newClient objectById: (storeClient idForObject:  task3)  .
		task3OnNewSession text: newTextForTask3 .
	].


	synchronize.


	assert: storeClient currentVersion equals: server  currentAnchorId.
	assert: task2 text equals: 	newTextForTask2.
	assert: task3 text equals: 	newTextForTask3.
				
	 
)
public   testClientUpdateWithNewObjectFromServer = (
	| task1   newTask newTaskOnNewSession anotherClient   |  

	installContextFromServer.
	
	task1:: objectNamed: 'task1' .

	anotherClient::  withNewClientDo: [ :newClient |
		| task1OnNewSession |
		task1OnNewSession:: newClient objectById: (storeClient idForObject:  task1)  .
		newTaskOnNewSession:: ToDoTask describedBy: 'new task' dependsOn: nil .
		task1OnNewSession dependsOn: newTaskOnNewSession.
	].

	(* server markAsNewObjects: { (server objectNamed: 'task1') dependsOn   }.    *)

	synchronize.


	(* maybe replace the multiple assertions with something like this or even create a generic version for any pair of objects *)
	(* assertLocalTask: newTask correspondsTo: newTaskOnSession on: anotherContext. *)

	newTask:: task1 dependsOn.		
	assert: (storeClient isTracked: newTask) description: 'New task is not tracked on client' .
	assert: (storeClient idForObject: newTask) equals:  (anotherClient idForObject: newTaskOnNewSession) .
	assert: newTask text equals: newTaskOnNewSession text .
	 
)
public   testNewObjectsAreDetectedOnClient = (
	|   task1 changeLog newTask changeRecord newReference newTaskDefinition| 

	installContextFromLocal.

	task1:: objectNamed: 'task1' .

	newTask:: ToDoTask describedBy: 'new task' dependsOn: nil .
	task1 dependsOn: newTask.

	changeLog:: cto detectChanges changeLog.

	assert: changeLog changeRecords size equals: 1.

	changeRecord:: changeLog changeRecords first.
	assert:  (changeRecord  refersTo: task1 in: cto).
	
	assert:  changeRecord changes  size equals: 1.
	assert:  (changeRecord changes includesKey: #dependsOn).

	newReference:: changeRecord changes at: #dependsOn.

	assert:  newReference isKindOfNewObjectReference.
	
	assert:  changeLog newObjectsDefinitions size equals: 1.
	newTaskDefinition:: changeLog newObjectsDefinitions first.
	
	assert:  newReference identifier  equals: newTaskDefinition id.
	
	assert: (newTaskDefinition definition slotNamed: #text hasValue: newTask text).
	assert: (newTaskDefinition definition slotNamed: #dependsOn hasValue: newTask dependsOn).
	 
)
public   testNoChangesAreDetectedWhenNothingHasChanged = (
	|   changeLog  | 
	installContextFromLocal.
	changeLog:: cto detectChanges changeLog.	
	assert:  changeLog hasNoChanges.
	 
)
withNewClientDo: aBlock = (
	| newClient |
	newClient:: StoreClient new.  
	installContextFromServerInto: newClient using: createInitialObjectsForTestsByName .
	aBlock value: newClient.
	newClient synchronizeWithServer: server.
	^ newClient
	
)
) : (
TEST_CONTEXT = ()
)
public class VersionsServerTests = TestContext (
|
	versionsServer = versioningModule VersionsServer new.
	store  = versionsServer createStoreNamed: storeName.
	
|
) (
createFooObjectChangeLog = (
	| changeLog fooObjectDefinition fooObjectDefinitionWithId valuesBySlot |
	
	valuesBySlot:: Map new. 
	valuesBySlot at: 'slot1'  put: (ServerToClientChangeLog UnidentifiableObject value: 1). 
	
	fooObjectDefinition:: ServerToClientChangeLog ObjectDefinition classNamed: 'Foo'  enclosingObjectReference: nil withContents: valuesBySlot.
	
	fooObjectDefinitionWithId:: ServerToClientChangeLog ObjectDefinitionWithIdentification id: 1 definition: fooObjectDefinition.
	
	^ ServerToClientChangeLog withChanges: {}  withNewObjects: { fooObjectDefinitionWithId }.
)
dummyChangeLog = (
	^ nil
)
storeName  = (
	^ ' MyStore' 
)
public testBranchesAreCreatedCreatedCorrectly   = (
	| newVersionId1  newVersionId11 newVersionId12 |

	newVersionId1:: store register: dummyChangeLog asChildOfVersionIdentifiedBy: store initialVersionId.  
	newVersionId11:: store register: dummyChangeLog asChildOfVersionIdentifiedBy: newVersionId1.  
	newVersionId12:: store register: dummyChangeLog asChildOfVersionIdentifiedBy: newVersionId1.  

	assert: (store isVersion: newVersionId1 childOf: store initialVersionId).
	assert: (store isVersion: newVersionId11 childOf: newVersionId1).
	assert: (store isVersion: newVersionId12 childOf: newVersionId1).
	
	 	
)
public testNewStoreVersionIsCreatedCorrectly   = (
	| newVersionId |
	newVersionId:: store register: dummyChangeLog asChildOfVersionIdentifiedBy: store initialVersionId.  
	assert: (store isVersion: newVersionId childOf: store initialVersionId).
	assert: (store isVersion: store initialVersionId parentOf:  newVersionId ).  
	 	
)
public testStoreIsCreatedCorrectly  = (
	| newServer newStore |
	newServer:: versioningModule VersionsServer new.
	newStore:: newServer createStoreNamed: storeName.
	assert: newStore name equals: storeName.
	assert: (newServer containsStoreNamed: storeName).
	assert: newServer storesCount equals: 1.
)
) : (
TEST_CONTEXT = (
)
)
ClientToServerChangeLog  = (
	^clientServerModule ClientToServerChangeLog.
)
RootModel = (
	^ toDoListModel RootModel.
)
ServerToClientChangeLog  = (
	^clientServerModule ServerToClientChangeLog.
)
ToDoTask = (
	^ toDoListModel ToDoTask.
)
) : (
)
