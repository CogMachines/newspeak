Newspeak3
'Win32API'
class Win32API platform: platform = Object platform: platform (
(* This module provides access to select functions of Windows API from the following libraries: Kernel, GDI, User, Msimg32 and GDI+.

All of those functions are defined by nested subclasses of WinLibrary. For example, the functions from the User DLL are defined by the UserLibrary class. The module holds an instance of UserLibrary in its UserDLL slot. The same pattern is used for all the other libraries.

Most functions defined by the nested libraries are re-exported at the module level, so that it is possible to retrieve them by sending messages to the module. For example, instead of sending #GetLastError to KernelDLL it is possible to send the same message directly to Win32API instance. An exception to this rule is GDIplusFlatDLL. Its functions are not re-exported. Intead, the GDIplus inner module provides a class-based Newspeak wrapper interface, similar to that of the official C++ based GDI+ API.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2012 Cadence Design Systems, Inc.
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)|
	public KernelDLL = KernelLibrary new.
	public GDIDLL = GDILibrary new.
	public UserDLL = UserLibrary new.
	public MsimgDLL = MsimgLibrary new.
	public GDIplusFlatDLL = GDIplusLibrary new.
	public Comdlg32DLL = Comdlg32Library new.
	
	public CHARFORMAT = platform blackMarket Win32API Win32apiCHARFORMAT.
	public CHARFORMAT2 = platform blackMarket Win32API Win32apiCHARFORMAT2.
	public CHARRANGE = platform blackMarket Win32API Win32apiCHARRANGE.
	public FIND_DATA = platform blackMarket Win32API Win32apiFINDDATA.
	public GRADIENT_RECT = platform blackMarket Win32API Win32apiGRADIENTRECT.
	public MSG = platform blackMarket Win32API Win32apiMSG.
	public MSGFILTER = platform blackMarket Win32API Win32apiMSGFILTER.
	public NMHDR = platform blackMarket Win32API Win32apiNMHDR. (* MSFT hs a wy wth wrds *)
	public OPENFILENAME = platform blackMarket Win32API Win32apiOPENFILENAME.
	public PAINTSTRUCT = platform blackMarket Win32API Win32apiPAINTSTRUCT.
	public PARAFORMAT = platform blackMarket Win32API Win32apiPARAFORMAT.
	public POINT = platform blackMarket Win32API Win32apiPOINT.
	public PROCESS_INFORMATION = platform blackMarket Win32API Win32apiPROCESSINFORMATION.
	public RECT = platform blackMarket Win32API Win32apiRECT.
	public REQRESIZE = platform blackMarket Win32API Win32apiREQRESIZE.
	public SCROLLINFO = platform blackMarket Win32API Win32apiSCROLLINFO.
	public SECURITY_ATTRIBUTES = platform blackMarket Win32API Win32apiSECURITYATTRIBUTES.
	public STARTUPINFO = platform blackMarket Win32API Win32apiSTARTUPINFO.
	public TRACKMOUSEEVENT = platform blackMarket Win32API Win32apiTRACKMOUSEEVENT.
	public TRIVERTEX = platform blackMarket Win32API Win32apiTRIVERTEX.
	public WNDCLASS = platform blackMarket Win32API Win32apiWNDCLASS.
	public WINDOWPOS = platform blackMarket Win32API Win32apiWINDOWPOS.
	public WindowProc = platform blackMarket Win32API Win32apiWindowProc.
	public WCharAlien = platform blackMarket NsFFI WCharAlien.

	public GiveUp = platform blackMarket Win32API GiveUp.

	CrLfFileStream = platform blackMarket Files CrLfFileStream.
	Delay = platform blackMarket Kernel Delay.
	FileDirectory  = platform blackMarket Files FileDirectory.
|addLibrary: KernelDLL.
	addLibrary: GDIDLL.
	addLibrary: UserDLL.
	addLibrary: MsimgDLL.
	addLibraryNoImport: GDIplusFlatDLL.
	addLibrary: Comdlg32DLL)
(
class Comdlg32Library = WinLibrary name: 'comdlg32' (
(* Common Dialog Boxes aka. comdlg32.dll.
http://msdn.microsoft.com/en-us/library/ms645524(VS.85).aspx *)|
|)
('as yet unclassified'
GetOpenFileNameA = (
(* BOOL GetOpenFileName(      
    LPOPENFILENAME lpofn
); *)
	^functionNamed: #GetOpenFileNameA argc: 1
)
GetSaveFileNameA = (
(*
BOOL GetSaveFileName(      
    LPOPENFILENAME lpofn
);
*)	^functionNamed: #GetSaveFileNameA argc: 1
)
exportFunctionsTo: capi = (
	(* Please keep the list sorted alphabetically. *)
	capi
		exportFunction: GetOpenFileNameA as: #GetOpenFileName;
		exportFunction: GetSaveFileNameA as: #GetSaveFileName
)) : ()
class CommonDataTypes = (
(*  *))
() : ('as yet unclassified'
specification = (
	(* See http://msdn.microsoft.com/en-us/library/aa505945.aspx *)
	^'
typedef int BOOL, *PBOOL, *LPBOOL;

typedef BYTE  BOOLEAN, *PBOOLEAN;

typedef WCHAR  * BSTR;

typedef unsigned char BYTE, *PBYTE, *LPBYTE;

typedef char CHAR, *PCHAR;

typedef unsigned long DWORD, *PDWORD, *LPDWORD;

typedef ULONGLONG  DWORDLONG, *PDWORDLONG;

typedef ULONG_PTR  DWORD_PTR;

typedef unsigned int DWORD32;

typedef unsigned __int64  DWORD64;

typedef int INT, *LPINT;

typedef signed char INT8;

typedef signed short INT16;

typedef signed int INT32;

typedef signed __int64 INT64;

typedef long LONG, *LPLONG;

typedef signed int LONG32;

typedef __int64  LONG64;

typedef LPCSTR  LPCTSTR;

typedef unsigned __int64  QWORD;

typedef short SHORT;

typedef unsigned char UCHAR, *PUCHAR;

typedef unsigned int UINT;

typedef unsigned char UINT8;

typedef unsigned short UINT16;

typedef unsigned int UINT32;

typedef unsigned __int64  UINT64;

typedef unsigned long ULONG, *PULONG;

typedef unsigned int ULONG32;

typedef unsigned __int64  ULONG64;

typedef unsigned short UNSIGNED16;

typedef unsigned long UNSIGNED32;

typedef unsigned short USHORT;

typedef void VOID, *PVOID;

typedef wchar_t  WCHAR, *PWCHAR;

typedef unsigned short WORD, *PWORD, *LPWORD;
'
))
class File = (|
	name
	handle
|)
('as yet unclassified'
close = (
	closeHandle: handle
)
deleteAfter: action <[:ReadStream]> = (
	| result |
	[result:: do: action] ensure: [FileDirectory deleteFilePath: name].
	^result
)
do: action <[:ReadStream]> = (
	^CrLfFileStream readOnlyFileNamed: name do: action
)
openReadOnly = (
	^CrLfFileStream readOnlyFileNamed: name
)) : ()
class GDILibrary = WinLibrary name: 'GDI' (
(* Defines the functions of the GDI (the classic one, not GDI+) dll we are using. *)||)
('as yet unclassified'
CreateFontA = (
	^functionNamed: #CreateFontA argc: 14
)
CreatePen = (
	^functionNamed: #CreatePen argc: 3
)
CreateSolidBrush = (
	^functionNamed: #CreateSolidBrush argc: 1
)
DeleteObject = (
	^functionNamed: #DeleteObject argc: 1
)
Ellipse = (
	^functionNamed: #Ellipse argc: 5
)
ExtTextOutA = (
	(* BOOL ExtTextOut(
  		HDC hdc,          // handle to DC
		int X,            // x-coordinate of reference point
		int Y,            // y-coordinate of reference point
		UINT fuOptions,   // text-output options
		CONST RECT* lprc, // optional dimensions
		LPCTSTR lpString, // string
		UINT cbCount,     // number of characters in string
		CONST INT* lpDx   // array of spacing values
); *)
	^functionNamed: #ExtTextOutA argc: 8
)
GetStockObject = (
	^functionNamed: #GetStockObject argc: 1
)
GetTextExtentPoint32A = (
	(* BOOL GetTextExtentPoint32(
		HDC hdc,           // handle to DC
		LPCTSTR lpString,  // text string
		int c,      // characters in string
		LPSIZE lpSize      // string size
	); *)
	^functionNamed: #GetTextExtentPoint32A argc: 4
)
LineTo = (
	^functionNamed: #LineTo argc: 3
)
MoveToEx = (
	^functionNamed: #MoveToEx argc: 4
)
Polygon = (
(* BOOL Polygon(
  HDC hdc,                // handle to DC
  CONST POINT *lpPoints,  // polygon vertices
  int nCount              // count of polygon vertices
); *)
	^functionNamed: #Polygon argc: 3
)
Rectangle = (
	^functionNamed: #Rectangle argc: 5
)
SelectObject = (
	^functionNamed: #SelectObject argc: 2
)
SetBkMode = (
	^functionNamed: #SetBkMode argc: 2
)
SetDCBrushColor = (
	^functionNamed: #SetDCBrushColor argc: 2
)
SetDCPenColor = (
	^functionNamed: #SetDCPenColor argc: 2
)
SetTextColor = (
	^functionNamed: #SetTextColor argc: 2
)
TextOutA = (
	(* BOOL TextOut(
		HDC hdc,           // handle to DC
		int nXStart,       // x-coordinate of starting position
		int nYStart,       // y-coordinate of starting position
		LPCTSTR lpString,  // character string
		int cbString       // number of characters
); *)
	^functionNamed: #TextOutA argc: 5
)
exportFunctionsTo: capi = (
	(* Please keep the list sorted alphabetically. *)
	capi
		exportFunction: CreateFontA as: #CreateFont;
		exportFunction: CreatePen;
		exportFunction: CreateSolidBrush;
		exportFunction: DeleteObject;
		exportFunction: Ellipse;
		exportFunction: ExtTextOutA as: #ExtTextOut;
		exportFunction: GetStockObject;
		exportFunction: GetTextExtentPoint32A as: #GetTextExtentPoint32;
		exportFunction: LineTo;
		exportFunction: MoveToEx;
		exportFunction: Polygon;
		exportFunction: Rectangle;
		exportFunction: SelectObject;
		exportFunction: SetBkMode;
		exportFunction: SetDCBrushColor;
		exportFunction: SetDCPenColor;
		exportFunction: SetTextColor;
		exportFunction: TextOutA as: #TextOut
)) : ()
class GDIplus = (
(* This is a nested module providing a Newspeak wrapper around GDI+ flat api, similar to the C++ wrapper provided by Microsoft as the official GDI+ API. *)|
	private token <Alien | nil>
	protected flatAPI = GDIplusFlatDLL.
|)
(
class Bitmap = GDIplusObject (
(* Provides a subset of the functionality of the Bitmap class of the official GDI+ API. *)|
	nativeImagePtr <Integer> ::= 0. (* a raw pointer to the native bitmap object *)
	bits <Alien | nil> (* Holds onto the memory with the bitmap data of those bitmaps created from bits *)
|)
('as yet unclassified'
initWidth: width 
height: height 
format: format 
= (
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateBitmapFromScan0
		unsignedValue: width
		value: height
		value: 0
		value: format
		value: 0
		value: pointerBox address.
	lastResult = 0 ifFalse: 
		[pointerBox free.
		^GiveUp signal: 'Bitmap creation failed with status: ', lastResult asString,  ' (', getLastErrorMessage, ')'].
	nativeImagePtr:: pointerBox asUnsignedLong.
	pointerBox free.
)
initWidth: width 
height: height 
stride: stride 
format: format 
bits: data <Alien> = (
	(* The last argument must be an alient pointing to a static buffer with the bitmap data. That buffer should stay around and be valid for the lifetime of the GDI+ bitmap object. The Bitmap will free it on receipt of #release. *)
	| pointerBox |
	bits:: data.
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateBitmapFromScan0
		unsignedValue: width
		value: height
		value: stride
		value: format
		value: bits address
		value: pointerBox address.
	lastResult = 0 ifFalse: 
		[pointerBox free.
		^reportError: 'Bitmap creation failed with status: ', lastResult printString].
	nativeImagePtr:: pointerBox asUnsignedLong.
	pointerBox free.
)
initWidth: width <Integer>
height: height <Integer>
target: target <Graphics> = (
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateBitmapFromGraphics
		unsignedValue: width
		value: height
		value: target nativeGraphicsPtr
		value: pointerBox address.
	lastResult = 0 ifFalse:
		[pointerBox free.
		^reportError: 'Bitmap creation failed with status: ', lastResult printString].
	nativeImagePtr:: pointerBox asUnsignedLong.
	pointerBox free.
)
release = (
	nativeImagePtr ~= 0 ifTrue:
		[flatAPI GdipDisposeImage value: nativeImagePtr.
		nativeImagePtr:: 0].
	bits notNil ifTrue:
		[bits free.
		bits:: nil]
)) : ('as yet unclassified'
width: width <Integer> height: height <Integer> target: target <Graphics> = (
	^self new
		initWidth: width
		height: height
		target: target
)
width: width height: height format: f = (
	^self new
		initWidth: width 
		height: height 
		format: f 
)
width: width height: height stride: stride format: f bits: bits <Alien> = (
	^self new
		initWidth: width 
		height: height 
		stride: stride 
		format: f 
		bits: bits
))
class Brush = GDIplusObject (
(* Corresponds to (a subset of) the C++ class Brush of the official GDI+ API. This class is abstract. *)|
	nativeBrushPtr <Integer> ::= 0.
|)
('as yet unclassified'
release = (
	nativeBrushPtr ~= 0 ifTrue:
		[flatAPI GdipDeleteBrush value: nativeBrushPtr.
		nativeBrushPtr:: 0]
)) : ()
class CachedBitmap = GDIplusObject (
(* Same as the CachedBitmap class of the official GDI+ API. *)|
	nativeCachedBitmap ::= 0.
|)
('as yet unclassified'
initBitmap: bitmap <Bitmap> graphics: graphics <Graphics> = (
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateCachedBitmap
		unsignedValue: bitmap nativeImagePtr
		value: graphics nativeGraphicsPtr
		value: pointerBox address.
	nativeCachedBitmap:: pointerBox asUnsignedLong.
	lastResult = 0 ifFalse: [reportError: 'CachedBitmap creation failed with status: ', lastResult printString].
	pointerBox free.
)
release = (
	nativeCachedBitmap ~= 0 ifTrue:
		[flatAPI GdipDeleteCachedBitmap value: nativeCachedBitmap.
		nativeCachedBitmap:: 0]
)) : ('as yet unclassified'
bitmap: bitmap <Bitmap> graphics: graphics <Graphics> = (
	^self new initBitmap: bitmap graphics: graphics
))
class Color fromArgb: argb_ = (
(* Corresponds to the GDI+ Color class encoding 32-bit ARGB color values. The maximum value of each color component is 255. The alpha value of 255 means fully opaque. In this default constructor we trust the sender to provide us with values within their acceptable ranges. All objects of this module expect this as the color values they operate with rather than the Squeak color things. *)|
	public argb <Integer> = argb_.
|)
('as yet unclassified'
alpha ^<Integer> = (
	^argb >> 24
)
asColorref ^<Integer> = (
	^argb bitAnd: 16rFFFFFF
)
blue ^<Integer> = (
	^argb bitAnd: 16rFF
)
green ^<Integer> = (
	^argb >> 8 bitAnd: 16rFF
)
red ^<Integer> = (
	^argb >> 16 bitAnd: 16rFF
)) : ('as yet unclassified'
a: alpha r: red g: green b: blue = (
	(* The quick and not fully safe constructor from components that doesn't clip them to correct bit sizes. *)
	^fromArgb: (alpha << 24) | (red << 16) | (green << 8) | blue
)
alpha: alpha <Integer> red: red <Integer> green: green <Integer> blue: blue <Integer> = (
	(* This range-clipping variant of the constructor is safer in that out-of-range values of a color will not affect other color components. *)
	^a: (alpha bitAnd: 16rFF)
	  r: (red bitAnd: 16rFF)
	  g: (green bitAnd: 16rFF)
	  b: (blue bitAnd: 16rFF)
)
black = (
	^a: 255 r: 0 g: 0 b: 0
)
blue = (
	^a: 255 r: 0 g: 0 b: 255
)
fromColorref: colorref <Integer> = (
	^fromArgb: 16rFF000000 | colorref
)
fromSqueakColor: color <Color> = (
	^a: color privateAlpha
	  r: (color red * 255) rounded
	  g: (color green * 255) rounded
	  b: (color blue * 255) rounded
)
gray = (
	^a: 255 r: 128 g: 128 b: 128
)
gray: value = (
	^a: 255 r: value g: value b: value
)
green = (
	^a: 255 r: 0 g: 255 b: 0
)
orange = (
	^a: 255 r: 255 g: 16rA5 b: 0
)
red = (
	^a: 255 r: 255 g: 0 b: 0
)
transparent = (
	^a: 0 r: 255 g: 255 b: 255
)
white = (
	^a: 255 r: 255 g: 255 b: 255
)
yellow = (
	^a: 255 r: 255 g: 255 b: 0
))
class GDIplusObject = (
(* The common superclass of other GDI+ objects. Not much stuff here so far, but I'm sure we'll find what to put here. *)|
	lastResult <Integer> ::= 0.
|)
('as yet unclassified'
ensureOkStatusAfter: functionName = (
	lastResult = 0 ifFalse:
		[^reportError: functionName, ' failed with status: ', (statusStringFor: lastResult)]
)) : ()
class Graphics = GDIplusObject (
(* A minimal subset of the Graphics class from GDI+. *)|
	nativeGraphicsPtr <Integer> ::= 0.
	private gdiPlus_
|)
('as yet unclassified'
clear: color <Color> = (
	lastResult:: flatAPI GdipGraphicsClear
		unsignedValue: nativeGraphicsPtr
		value: color argb.
	^lastResult
)
drawCachedBitmap: bitmap <CachedBitmap> at: point <Point> = (
	lastResult:: flatAPI GdipDrawCachedBitmap
		unsignedValue: nativeGraphicsPtr
		value: bitmap nativeCachedBitmap
		value: point x
		value: point y.
	^lastResult
)
drawEllipse: bounds <Rectangle> using: pen <Pen> = (
	lastResult:: flatAPI GdipDrawEllipseI
		unsignedValue: nativeGraphicsPtr
		value: pen nativePenPtr
		value: bounds left
		value: bounds top
		value: bounds width
		value: bounds height.
	^lastResult
)
drawImage: image <Bitmap> at: point <Point> = (
	lastResult:: flatAPI GdipDrawImageI
		unsignedValue: nativeGraphicsPtr
		value: image nativeImagePtr
		value: point x
		value: point y.
	^lastResult
)
drawLineFrom: from <Point> to: to <Point> using: pen <Pen> = (
	lastResult:: flatAPI GdipDrawLineI
		unsignedValue: nativeGraphicsPtr
		value: pen nativePenPtr
		value: from x rounded
		value: from y rounded
		value: to x rounded
		value: to y rounded.
	^lastResult
)
drawPolygon: vertices <Sequence[Points]> using: pen <Pen> = (
	withPointArrayFrom: vertices do:
		[:pointBuffer |
		lastResult:: flatAPI GdipDrawPolygonI
			unsignedValue: nativeGraphicsPtr
			value: pen nativePenPtr
			value: pointBuffer address
			value: vertices size].
	^lastResult
)
drawRectangle: bounds <Rectangle> using: pen <Pen> = (
	lastResult:: flatAPI GdipDrawRectangleI
		unsignedValue: nativeGraphicsPtr
		value: pen nativePenPtr
		value: bounds left rounded
		value: bounds top rounded
		value: bounds width rounded
		value: bounds height rounded.
	^lastResult
)
fillEllipse: bounds <Rectangle> using: brush <Brush> = (
	lastResult:: flatAPI GdipFillEllipseI
		unsignedValue: nativeGraphicsPtr
		value: brush nativeBrushPtr
		value: bounds left
		value: bounds top
		value: bounds width
		value: bounds height.
	^lastResult
)
fillPolygon: vertices <Sequence[Points]> using: brush <Brush> = (
	withPointArrayFrom: vertices do:
		[:pointBuffer |
		lastResult:: flatAPI GdipFillPolygonI
			unsignedValue: nativeGraphicsPtr
			value: brush nativeBrushPtr
			value: pointBuffer address
			value: vertices size
			value: 0 (* FillModeAlternate, the default in the C++ mapping *)].
	^lastResult
)
fillRectangle: rect <Rectangle> using: brush <Brush> = (
	lastResult:: flatAPI GdipFillRectangleI
		unsignedValue: nativeGraphicsPtr
		value: brush nativeBrushPtr
		value: rect left rounded
		value: rect top rounded
		value: rect width rounded
		value: rect height rounded.
	^lastResult
)
flush = (
	lastResult:: flatAPI GdipFlush
		unsignedValue: nativeGraphicsPtr
		value: 1 (* FlushIntentionSync *)
)
gdiPlus ^<GDIplus> = (
	(* The module this graphics instance belongs to. *)
	^gdiPlus_ ifNil:
		[gdiPlus_:: outer GDIplus yourself.
		gdiPlus_]
)
getHDC ^<Integer> = (
	| hdcBox hdc |
	hdcBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipGetDC
		unsignedValue: nativeGraphicsPtr
		value: hdcBox address.
	lastResult = 0 ifFalse:
		[hdcBox free.
		^reportError: 'GdipGetDC() failed with status ', lastResult printString].
	hdc:: hdcBox asUnsignedLong.
	hdcBox free.
	^hdc
)
getHDCWhile: action <[:Integer]> = (
	(* Get hdc, feed it to the block and make sure to clean up. Do this, C++! *)
	| hdc |
	hdc:: getHDC.
	^[action value: hdc] ensure: [releaseHDC: hdc]
)
initFromBitmap: bitmap <Bitmap> = (
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipGetImageGraphicsContext
		unsignedValue: bitmap nativeImagePtr
		value: pointerBox address.
	lastResult = 0 ifFalse: 
		[pointerBox free.
		^reportError: 'Graphics creation failed with status: ', lastResult printString].
	nativeGraphicsPtr:: pointerBox asUnsignedLong.
	pointerBox free.
)
initFromHDC: hdc = (
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateFromHDC
		unsignedValue: hdc
		value: pointerBox address.
	lastResult = 0 ifFalse:
		[pointerBox free.
		^reportError: 'Graphics creation failed with status: ', lastResult printString].
	nativeGraphicsPtr:: pointerBox asUnsignedLong.
	pointerBox free.
)
polygon: vertices <Sequence[Points]> drawUsing: pen <Pen> fillUsing: brush <Brush> = (
	(* A combination of draw and fill, to translate the vertices only once. *)
	withPointArrayFrom: vertices do:
		[:pointBuffer |
		lastResult:: flatAPI GdipFillPolygonI
			unsignedValue: nativeGraphicsPtr
			value: brush nativeBrushPtr
			value: pointBuffer address
			value: vertices size
			value: 0. (* FillModeAlternate, the default in the C++ mapping *)
		lastResult:: flatAPI GdipDrawPolygonI
			unsignedValue: nativeGraphicsPtr
			value: pen nativePenPtr
			value: pointBuffer address
			value: vertices size].
	^lastResult
)
release = (
	nativeGraphicsPtr ~= 0 ifTrue:
		[flatAPI GdipDeleteGraphics value: nativeGraphicsPtr.
		nativeGraphicsPtr:: 0].
)
releaseHDC: hdc <Integer> = (
	lastResult:: flatAPI GdipReleaseDC
		unsignedValue: nativeGraphicsPtr
		value: hdc.
)
resetClip = (
	lastResult:: flatAPI GdipResetClip
		unsignedValue: nativeGraphicsPtr.
	^lastResult
)
setCompositingMode: mode <Integer> = (
	lastResult:: flatAPI GdipSetCompositingMode
		unsignedValue: nativeGraphicsPtr
		value: mode.
	^lastResult	
)
setCompositingQuality: mode <Integer> = (
	lastResult:: flatAPI GdipSetCompositingQuality
		unsignedValue: nativeGraphicsPtr
		value: mode.
	^lastResult	
)
setSmoothingMode: mode <Integer> = (
	lastResult:: flatAPI GdipSetSmoothingMode
		unsignedValue: nativeGraphicsPtr
		value: mode.
	^lastResult	
)
protected withPointArrayFrom: vertices <Sequence[Points]> do: action<[:Alien]> = (
	| buffer offset |
	buffer:: Alien rawNewC: vertices size * 8.
	offset:: 1.
	vertices keysAndValuesDo:
		[:index :each |
		buffer signedLongAt: offset put: each x.
		offset:: offset + 4.
		buffer signedLongAt: offset put: each y.
		offset:: offset + 4].
	^[action value: buffer] ensure: [buffer free]
)) : ('as yet unclassified'
forBitmap: bitmap <Bitmap> ^ <Graphics> = (
	(* Create a new Graphics instance on the specified bitmap instance. The creator must make arrangements to send #release to the instance when done using it. *)
	^self new initFromBitmap: bitmap
)
fromHDC: hdc <Integer> ^ <Graphics> = (
	(* Create a new Graphics instance on the specified device handle. The creator must make arrangements to send #release to the instance when done using it. *)
	^self new initFromHDC: hdc
))
class LinearGradientBrush = Brush (
(* Corresponds to (a subset of) the LinearGradientBrush class of the official API. *)|
|)
('as yet unclassified'
initFrom: from <Point> to: to <Point> fromColor: fromColor <Color> toColor: toColor <Color> = (
	| p1 p2 pointerBox |
	p1:: POINT newC initializeFromPoint: from.
	p2:: POINT newC initializeFromPoint: to.
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateLineBrushI
		unsignedValue: p1 address
		value: p2 address
		value: fromColor argb
		value: toColor argb
		value: 0 (* WrapModeTile *)
		value: pointerBox address.
	nativeBrushPtr:: pointerBox asUnsignedLong.
	lastResult = 0 ifFalse: 
		[reportError: 'LinearGradientBrush creation failed with status: ', 
			lastResult printString].
	pointerBox free.
	p2 free.
	p1 free.
)) : ('as yet unclassified'
from: p1 <Point> color: c1 <Color> to: p2 <Point> color: c2 <Color> = (
	^self new initFrom: p1 to: p2 fromColor: c1 toColor: c2
))
class PaintDCGraphics = Graphics (
(* Describe the class in this comment. *)|
	hdc
|)
('as yet unclassified'
getHDC = (
	^hdc
)
getHDCWhile: action = (
	^action value: hdc
)
initFromHDC: hdc_ = (
	super initFromHDC: hdc_.
	hdc:: hdc_
)
releaseHDC = (
)) : ('as yet unclassified'
fromHDC: hdc_ = (
	^self new initFromHDC: hdc_
))
class Pen = GDIplusObject (
(* Corresponds to the Pen class of the official GDI+ API. *)|
	nativePenPtr <Integer> ::= 0.
|)
('as yet unclassified'
initColor: color <Color> width: width <Float>= (
	| pointerBox widthFloat |
	pointerBox:: alienClass newC: 4.
	widthFloat:: alienClass new: 4.
	widthFloat floatAt: 1 put: width.
	lastResult:: flatAPI GdipCreatePen1
		unsignedValue: color argb
		value: widthFloat
		value: 0 (* UnitWorld *)
		value: pointerBox address.
	nativePenPtr:: pointerBox asUnsignedLong.
	lastResult = 0 ifFalse: [reportError: 'Pen creation failed with status: ', lastResult printString].
	pointerBox free.
)
release = (
	nativePenPtr ~= 0 ifTrue:
		[flatAPI GdipDeletePen value: nativePenPtr.
		nativePenPtr:: 0]
)) : ('as yet unclassified'
color: color <Color> width: width <Float> = (
	^self new initColor: color width: width
))
class SolidBrush = Brush (
(* Corresponds to (a subset of) the SolidBrush class of the official C++ GDI+ API. *)|
|)
('as yet unclassified'
initColor: color <Color> = (
	(* The last argument must be an alient pointing to a static buffer with the bitmap data. That buffer should stay around and be valid for the lifetime of the GDI+ bitmap object. The Bitmap will free it on receipt of #release. *)
	| pointerBox |
	pointerBox:: alienClass newC: 4.
	lastResult:: flatAPI GdipCreateSolidFill
		unsignedValue: color argb
		value: pointerBox address.
	nativeBrushPtr:: pointerBox asUnsignedLong.
	lastResult = 0 ifFalse: [reportError: 'Solid brush creation failed with status: ', lastResult printString].
	pointerBox free.
)) : ('as yet unclassified'
color: color <Color> = (
	^self new initColor: color
))'as yet unclassified'
alienClass = (
	^outer Win32API Alien
)
resetForNewImageSession = (
	token: nil
)
shutdown = (
	(* Shutdown GDI+ if started. *)
	token notNil ifTrue:
		[flatAPI GdiplusShutdown value: token asUnsignedLong.
		token: nil]
)
startup ^<Boolean> = (
	(* Attempt to start GDI+ and return a Boolean indicating success. *)
	| status |
	token:: alienClass newC: 4.
	withGdiplusStartupInputAndOutputDo:
		[:input :output |
		status:: flatAPI GdiplusStartup
			unsignedValue: token address
			value: input address
			value: output address].
	status = 0 (* ok *)
		ifFalse: [token free. token: nil].
	^token notNil
)
statusStringFor: statusCode = (
	^{'Ok'.
	'GenericError'.
	'InvalidParameter'.
	'OutOfMemory'.
	'ObjectBusy'.
	'InsufficientBuffer'.
	'NotImplemented'.
	'Win32Error'.
	'WrongState'.
	'Aborted'.
	'FileNotFound'.
	'ValueOverflow'.
	'AccessDenied'.
	'UnknownImageFormat'.
	'FontFamilyNotFound'.
	'FontStyleNotFound'.
	'NotTrueTypeFont'.
	'UnsupportedGdiplusVersion'.
	'GdiplusNotInitialized'.
	'PropertyNotFound'.
	'PropertyNotSupported'.
	'ProfileNotFound'.
	} at: statusCode + 1
)
withGdiplusStartupInputAndOutputDo: action = (
	(* For now we are skimping on having real definitions for GDI+ input and output structures and simply fake them here. *)
	| input output result |
	input:: alienClass newC: 16.
	input
		unsignedLongAt: 1 put: 1; (* version *)
		unsignedLongAt: 5 put: 0; (* debug callback *)
		unsignedLongAt: 9 put: 0; (* suppress background thread *)
		unsignedLongAt: 13 put: 0. (* suppress external codecs *)
	output:: alienClass newC: 8.
	result:: action value: input value: output.
	input free.
	output free.
	^result
)) : ()
class GDIplusLibrary = WinLibrary name: 'gdiplus' (
(* Provides access to functions of GDI+ flat API. See GDIplus class for a higher-level wrapper similar to Microsoft's C++ API. Note that the functions of this library are NOT imported into the containing Win32API instance. *)||)
('as yet unclassified'
GdipCreateBitmapFromGraphics = (
	(* GpStatus WINGDIPAPI GdipCreateBitmapFromGraphics(INT width, INT height, GpGraphics* target, GpBitmap** bitmap) *)
	^functionNamed: #GdipCreateBitmapFromGraphics argc: 4
)
GdipCreateBitmapFromScan0 = (
	(* GpStatus WINGDIPAPI GdipCreateBitmapFromScan0(INT width, INT height, INT stride, PixelFormat format, BYTE* scan0, GpBitmap** bitmap) *)
	^functionNamed: #GdipCreateBitmapFromScan0 argc: 6
)
GdipCreateCachedBitmap = (
	(* GpStatus WINGDIPAPI GdipCreateCachedBitmap( GpBitmap *bitmap, GpGraphics *graphics, GpCachedBitmap **cachedBitmap ) *)
	^functionNamed: #GdipCreateCachedBitmap argc: 3
)
GdipCreateFromHDC = (
	(* GpStatus WINGDIPAPI GdipCreateFromHDC(HDC hdc, GpGraphics **graphics) *)
	^functionNamed: #GdipCreateFromHDC argc: 2
)
GdipCreateFromHWND = (
	(* GpStatus WINGDIPAPI GdipCreateFromHWND(HWND hwnd, GpGraphics **graphics) *)
	^functionNamed: #GdipCreateFromHWND argc: 2
)
GdipCreateLineBrushI = (
	(* GpStatus WINGDIPAPI GdipCreateLineBrushI(GDIPCONST GpPoint* point1, GDIPCONST GpPoint* point2, ARGB color1, ARGB color2, GpWrapMode wrapMode, GpLineGradient **lineGradient) *)
	^functionNamed: #GdipCreateLineBrushI argc: 6
)
GdipCreatePen1 = (
	(* GpStatus WINGDIPAPI GdipCreatePen1(ARGB color, REAL width, GpUnit unit, GpPen **pen) *)
	^functionNamed: #GdipCreatePen1 argc: 4
)
GdipCreatePen2 = (
	(* GpStatus WINGDIPAPI GdipCreatePen2(GpBrush *brush, REAL width, GpUnit unit, GpPen **pen) *)
	^functionNamed: #GdipCreatePen2 argc: 4
)
GdipCreateSolidFill = (
	(* GpStatus WINGDIPAPI GdipCreateSolidFill(ARGB color, GpSolidFill **brush) *)
	^functionNamed: #GdipCreateSolidFill argc: 2
)
GdipDeleteBrush = (
	(* GpStatus WINGDIPAPI GdipDeleteBrush(GpBrush *brush) *)
	^functionNamed: #GdipDeleteBrush argc: 1
)
GdipDeleteCachedBitmap = (
	(* GpStatus WINGDIPAPI GdipDeleteCachedBitmap(GpCachedBitmap *cachedBitmap) *)
	^functionNamed: #GdipDeleteCachedBitmap argc: 1
)
GdipDeleteGraphics = (
	(* GpStatus WINGDIPAPI GdipDeleteGraphics(GpGraphics *graphics) *)
	^functionNamed: #GdipDeleteGraphics argc: 1
)
GdipDeletePen = (
	(* GpStatus WINGDIPAPI GdipDeletePen(GpPen *pen) *)
	^functionNamed: #GdipDeletePen argc: 1
)
GdipDisposeImage = (
	(* GpStatus WINGDIPAPI GdipDisposeImage(GpImage *image) *)
	^functionNamed: #GdipDisposeImage argc: 1
)
GdipDrawCachedBitmap = (
	(* GpStatus WINGDIPAPI GdipDrawCachedBitmap( GpGraphics *graphics, GpCachedBitmap *cachedBitmap, INT x, INT y ) *)
	^functionNamed: #GdipDrawCachedBitmap argc: 4
)
GdipDrawEllipseI = (
	(* GpStatus WINGDIPAPI GdipDrawEllipseI(GpGraphics *graphics, GpPen *pen, INT x, INT y, INT width, INT height) *)
	^functionNamed: #GdipDrawEllipseI argc: 6
)
GdipDrawImageI = (
	(* GpStatus WINGDIPAPI GdipDrawImageI(GpGraphics *graphics, GpImage *image, INT x, INT y); *)
	^functionNamed: #GdipDrawImageI argc: 4
)
GdipDrawLineI = (
	(* GpStatus WINGDIPAPI GdipDrawLineI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1, INT x2, INT y2) *)
	^functionNamed: #GdipDrawLineI argc: 6
)
GdipDrawPolygonI = (
	(* GpStatus WINGDIPAPI GdipDrawPolygonI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points, INT count) *)
	^functionNamed: #GdipDrawPolygonI argc: 4
)
GdipDrawRectangleI = (
	(* GpStatus WINGDIPAPI GdipDrawRectangleI(GpGraphics *graphics, GpPen *pen, INT x, INT y, INT width, INT height) *)
	^functionNamed: #GdipDrawRectangleI argc: 6
)
GdipFillEllipseI = (
	(* GpStatus WINGDIPAPI GdipFillEllipseI(GpGraphics *graphics, GpBrush *brush, INT x, INT y, INT width, INT height) *)
	^functionNamed: #GdipFillEllipseI argc: 6
)
GdipFillPolygonI = (
	(* GpStatus WINGDIPAPI GdipFillPolygonI(GpGraphics *graphics, GpBrush *brush, GDIPCONST GpPoint *points, INT count, GpFillMode fillMode) *)
	^functionNamed: #GdipFillPolygonI argc: 5
)
GdipFillRectangleI = (
	(* GpStatus WINGDIPAPI GdipFillRectangleI(GpGraphics *graphics, GpBrush *brush, INT x, INT y, INT width, INT height) *)
	^functionNamed: #GdipFillRectangleI argc: 6
)
GdipFlush = (
	(* GpStatus WINGDIPAPI GdipFlush(GpGraphics *graphics, GpFlushIntention intention) *)
	^functionNamed: #GdipFlush argc: 2
)
GdipGetDC = (
	(* GpStatus WINGDIPAPI GdipGetDC(GpGraphics* graphics, HDC * hdc) *)
	^functionNamed: #GdipGetDC argc: 2
)
GdipGetImageGraphicsContext = (
	(* GpStatus WINGDIPAPI GdipGetImageGraphicsContext(GpImage *image, GpGraphics **graphics) *)
	^functionNamed: #GdipGetImageGraphicsContext argc: 2
)
GdipGraphicsClear = (
	(* GpStatus WINGDIPAPI GdipGraphicsClear(GpGraphics *graphics, ARGB color) *)
	^functionNamed: #GdipGraphicsClear argc: 2
)
GdipReleaseDC = (
	(* GpStatus WINGDIPAPI GdipReleaseDC(GpGraphics* graphics, HDC hdc) *)
	^functionNamed: #GdipReleaseDC argc: 2
)
GdipResetClip = (
	(* GpStatus WINGDIPAPI GdipResetClip(GpGraphics *graphics) *)
	^functionNamed: #GdipResetClip argc: 1
)
GdipSetCompositingMode = (
	(* GpStatus WINGDIPAPI GdipSetCompositingMode(GpGraphics *graphics, CompositingMode compositingMode) *)
	^functionNamed: #GdipSetCompositingMode argc: 2
)
GdipSetCompositingQuality = (
	(* GpStatus WINGDIPAPI GdipSetCompositingQuality(GpGraphics *graphics, CompositingQuality compositingQuality) *)
	^functionNamed: #GdipSetCompositingQuality argc: 2
)
GdipSetSmoothingMode = (
	(* GpStatus WINGDIPAPI
	GdipSetSmoothingMode(GpGraphics *graphics, SmoothingMode smoothingMode); *)
	^functionNamed: #GdipSetSmoothingMode argc: 2
)
GdiplusShutdown = (
(* void GdiplusShutdown(      
    ULONG_PTR token
); *)
	^functionNamed: #GdiplusShutdown argc: 1
)
GdiplusStartup = (
(* Status GdiplusStartup(      
    ULONG_PTR token *token,
    const GdiplusStartupInput *input,
    GdiplusStartupOutput *output
); *)
	^functionNamed: #GdiplusStartup argc: 3
)
exportFunctionsTo: capi = (
	(* Please keep the list sorted alphabetically. *)
	capi
		exportFunction: GdipCreateBitmapFromGraphics;
		exportFunction: GdipCreateBitmapFromScan0;
		exportFunction: GdipCreateCachedBitmap;
		exportFunction: GdipCreateFromHDC;
		exportFunction: GdipCreateFromHWND;
		exportFunction: GdipCreateLineBrushI;
		exportFunction: GdipCreatePen1;
		exportFunction: GdipCreatePen2;
		exportFunction: GdipCreateSolidFill;
		exportFunction: GdipDeleteBrush;
		exportFunction: GdipDeleteCachedBitmap;
		exportFunction: GdipDeleteGraphics;
		exportFunction: GdipDeletePen;
		exportFunction: GdipDisposeImage;
		exportFunction: GdipDrawCachedBitmap;
		exportFunction: GdipDrawEllipseI;
		exportFunction: GdipDrawImageI;
		exportFunction: GdipDrawLineI;
		exportFunction: GdipDrawRectangleI;
		exportFunction: GdipFillEllipseI;
		exportFunction: GdipFillRectangleI;
		exportFunction: GdipFlush;
		exportFunction: GdipGetDC;
		exportFunction: GdipGetImageGraphicsContext;
		exportFunction: GdipReleaseDC;
		exportFunction: GdipSetCompositingMode;
		exportFunction: GdipSetCompositingQuality;
		exportFunction: GdipSetSmoothingMode;
		exportFunction: GdiplusShutdown;		
		exportFunction: GdiplusStartup
)) : ()
class KernelLibrary = WinLibrary name: 'Kernel' (
(* Contains functions from the Kernel Windows library. *)|
|)
('as yet unclassified'
CloseHandle ^ <Win32Function> = (
(*
BOOL WINAPI CloseHandle(
  __in  HANDLE hObject
);
*)
	^functionNamed: #CloseHandle argc: 1
)
CopyFileA ^ <Win32Function> = (
(* BOOL WINAPI CopyFile(
  __in  LPCTSTR lpExistingFileName,
  __in  LPCTSTR lpNewFileName,
  __in  BOOL bFailIfExists
);
*)
	^functionNamed: #CopyFileA argc: 3
)
CreateDirectoryA ^ <Win32Function> = (
(* BOOL WINAPI CreateDirectory(
  __in_opt  LPCTSTR lpPathName,
  __in      LPSECURITY_ATTRIBUTES lpSecurityAttributes
); *)
	^functionNamed: #CreateDirectoryA argc: 2
)
CreateFileA ^ <Win32Function> = (
(*
HANDLE WINAPI CreateFile(
  __in      LPCTSTR lpFileName,
  __in      DWORD dwDesiredAccess,
  __in      DWORD dwShareMode,
  __in_opt  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  __in      DWORD dwCreationDisposition,
  __in      DWORD dwFlagsAndAttributes,
  __in_opt  HANDLE hTemplateFile
);
*)
	^functionNamed: #CreateFileA argc:  7
)
CreatePipe ^ <Win32Function> = (
(*
BOOL WINAPI CreatePipe(
  __out     PHANDLE hReadPipe,
  __out     PHANDLE hWritePipe,
  __in_opt  LPSECURITY_ATTRIBUTES lpPipeAttributes,
  __in      DWORD nSize
);
*)
	^functionNamed: #CreatePipe argc: 4
)
CreateProcessA ^ <Win32Function> = (
(*
BOOL WINAPI CreateProcessA(
  __in_opt     LPCTSTR lpApplicationName,
  __inout_opt  LPTSTR lpCommandLine,
  __in_opt     LPSECURITY_ATTRIBUTES lpProcessAttributes,
  __in_opt     LPSECURITY_ATTRIBUTES lpThreadAttributes,
  __in         BOOL bInheritHandles,
  __in         DWORD dwCreationFlags,
  __in_opt     LPVOID lpEnvironment,
  __in_opt     LPCTSTR lpCurrentDirectory,
  __in         LPSTARTUPINFO lpStartupInfo,
  __out        LPPROCESS_INFORMATION lpProcessInformation
); *)
	^functionNamed: #CreateProcessA argc: 10
)
DeleteFileA ^ <Win32Function> = (
(*
BOOL WINAPI DeleteFile(
	_in LPCTSTR lpFileName
);
*)
	^functionNamed: #DeleteFileA argc: 1
)
FindClose ^ <Win32Function> = (
(*
BOOL WINAPI FindClose(
  __inout  HANDLE hFindFile
);
*)
	^functionNamed: #FindClose argc: 1
)
FindFirstFileA ^ <Win32Function> = (
(*
HANDLE WINAPI FindFirstFile(
  __in  LPCTSTR lpFileName,
  __out  LP_WIN32_FIND_DATA lpFindFileData
);
*)
	^functionNamed: #FindFirstFileA argc:  2
)
FindNextFileA ^ <Win32Function> = (
(*
BOOL WINAPI FindNextFile(
  __in  HANDLE  hFindFile,
  __out  LP_WIN32_FIND_DATA lpFindFileData
);
*)
	^functionNamed: #FindNextFileA argc:  2
)
FormatMessageA ^ <Win32Function> = (
(*
DWORD WINAPI FormatMessage(
  __in      DWORD dwFlags,
  __in_opt  LPCVOID lpSource,
  __in      DWORD dwMessageId,
  __in      DWORD dwLanguageId,
  __out     LPTSTR lpBuffer,
  __in      DWORD nSize,
  __in_opt  va_list *Arguments
);
*)
	^functionNamed: #FormatMessageA argc: 7
)
FreeEnvironmentStringsW ^ <Win32Function> = (
(*
BOOL WINAPI FreeEnvironmentStrings(
  __in  LPTCH lpszEnvironmentBlock
);
*)
	^functionNamed: #FreeEnvironmentStringsW argc: 1
)
GetACP ^ <Win32Function> = (
	(*
	Get ANSI Code Page
	UINT GetACP(VOID);
	*)
	^functionNamed: #GetACP argc: 0
)
GetCurrentDirectoryA = (
(* DWORD WINAPI GetCurrentDirectory(
  __in  LPCTSTR nBufferLength,
  __out  LPCTSTR lpBuffer,
);
*)
	^functionNamed: #GetCurrentDirectoryA argc: 2


)
GetCurrentThread ^ <Win32Function> = (
(*
HANDLE WINAPI GetCurrentThread(void);
*)
	^functionNamed: #GetCurrentThread argc: 0
)
GetDiskFreeSpaceA ^ <Win32Function> = (
(*
BOOL WINAPI GetDiskFreeSpaceA(
  __in     LPCTSTR lpRootPathName,
  __out   LPDWORD lpSectorsPerCluster,
  __out  LPDWORD lpBytesPerSector,
  __out  LPDWORD lpNumberOfFreeClusters,
  __out  LPDWORD lpTotalNumberOfClusters
);
*)
	^functionNamed: #GetDiskFreeSpaceA argc: 5
)
GetEnvironmentStringsW ^ <Win32Function> = (
(*
LPTCH WINAPI GetEnvironmentStrings(void);
*)
	^functionNamed: #GetEnvironmentStringsW argc: 0
)
GetExitCodeProcess ^ <Win32Function> = (
(*
BOOL WINAPI GetExitCodeProcess(
  __in   HANDLE hProcess,
  __out  LPDWORD lpExitCode
);
*)
	^functionNamed: #GetExitCodeProcess argc: 2
)
GetFileAttributesA ^ <Win32Function> = (
(*
DWORD WINAPI GetFileAttributes(
  __in  LPCTSTR lpFileName
);
*)
	^functionNamed: #GetFileAttributesA argc: 1
)
GetFileSize ^ <Win32Function> = (
(*
DWORD WINAPI GetFileSize(
  __in HANDLE hFile,
 __out_opt LPDWORD lpFileSizeHigh,
);
*)
	^functionNamed: #GetFileSize argc:  2
)
GetLastError ^ <Win32Function> = (
	(* DWORD WINAPI GetLastError(void); *)
	^functionNamed: #GetLastError argc: 0
)
GetModuleHandleA ^ <Win32Function> = (
	^functionNamed: #GetModuleHandleA argc: 1
)
GetStdHandle ^ <Win32Function> = (
(*
HANDLE WINAPI GetStdHandle(
  __in  DWORD nStdHandle
);
*)
	^functionNamed: #GetStdHandle argc: 1
)
GetTempFileNameA ^ <Win32Function> = (
(*
UINT WINAPI GetTempFileName(
  __in   LPCTSTR lpPathName,
  __in   LPCTSTR lpPrefixString,
  __in   UINT uUnique,
  __out  LPTSTR lpTempFileName
);
*)
	^functionNamed: #GetTempFileNameA argc: 4
)
GetTempPathA  ^ <Win32Function> = (
(*
DWORD WINAPI GetTempPath(
  __in   DWORD nBufferLength,
  __out  LPTSTR lpBuffer
);
*)
	^functionNamed: #GetTempPathA argc: 2
)
GetUserDefaultLangID ^ <Win32Function> = (
(*
LANGID GetUserDefaultLangID(void);
*)
	^functionNamed: #GetUserDefaultLangID argc: 0
)
LoadLibraryA ^ <Win32Function> = (
	^functionNamed: #LoadLibraryA argc: 1
)
MoveFileA ^ <Win32Function> = (
(*
BOOL WINAPI MoveFile(
  __in  LPCTSTR lpExistingFileName,
  __in  LPCTSTR lpNewFileName
);
*)
	^functionNamed: #MoveFileA argc:  2
)
MultiByteToWideChar ^ <Win32Function> = (
	(* int MultiByteToWideChar(
  UINT CodePage, 
  DWORD dwFlags,         
  LPCSTR lpMultiByteStr, 
  int cbMultiByte,       
  LPWSTR lpWideCharStr,  
  int cchWideChar        
); *)
	^functionNamed: #MultiByteToWideChar argc: 6
)
ReadFile ^ <Win32Function> = (
(*
BOOL WINAPI ReadFile(
  __in         HANDLE hFile,
  __out        LPVOID lpBuffer,
  __in         DWORD nNumberOfBytesToRead,
  __out_opt    LPDWORD lpNumberOfBytesRead,
  __inout_opt  LPOVERLAPPED lpOverlapped
);
*)
	^functionNamed: #ReadFile argc: 5
)
RemoveDirectoryA ^ <Win32Function> = (
(*
BOOL WINAPI RemoveDirectory(
	__in LPCTSTR lpPathName
);
*)
	^functionNamed: #RemoveDirectoryA argc: 1
)
SetFileApisToOEM ^ <Win32Function> = (
(*
	void WINAPI SetFileApisToOEM(void);
*)
	^functionNamed: #SetFileApisToOEM argc: 0
)
SetFilePointer ^ <Win32Function> = (
(*
BOOL WINAPI SetFilePointer(
  __in         		HANDLE hFile,
  __in         		LONG lDistanceToMove,
  __in out_opt    PLONG lpDistanceToMoveHigh,
  __in              	DWORD dwMoveMethod,
);
*)
	^functionNamed: #SetFilePointer argc: 4
)
SetHandleInformation ^ <Win32Function> = (
(*
BOOL WINAPI SetHandleInformation(
  __in  HANDLE hObject,
  __in  DWORD dwMask,
  __in  DWORD dwFlags
);
*)
	^functionNamed: #SetHandleInformation argc: 3
)
WaitForSingleObject ^ <Win32Function> = (
(*
DWORD WINAPI WaitForSingleObject(
  __in  HANDLE hHandle,
  __in  DWORD dwMilliseconds
);
*)
	^functionNamed: #WaitForSingleObject argc: 2
)
WideCharToMultiByte ^ <Win32Function> = (
	(* int WideCharToMultiByte(
  UINT CodePage, 
  DWORD dwFlags, 
  LPCWSTR lpWideCharStr,
  int cchWideChar, 
  LPSTR lpMultiByteStr, 
  int cbMultiByte,
  LPCSTR lpDefaultChar,    
  LPBOOL lpUsedDefaultChar
); *)
	^functionNamed: #WideCharToMultiByte argc: 8
)
WriteFile ^ <Win32Function> = (
(*
BOOL WINAPI WriteFile(
  __in HANDLE hFile,
 __in LPCVOID lpBuffer,
 __in DWORD nNumberOfBytesToWrite,
  __out_opt  LPDWORD lpNumberOfBytesWritten,
  __inout_opt  LPOVERLAPPED lpOverlapped
);
*)
	^functionNamed: #WriteFile argc:  5
)
exportFunctionsTo: capi = (
	capi
		exportFunction: CloseHandle;
		exportFunction: CopyFileA as: #CopyFile;
		exportFunction: CreateDirectoryA as: #CreateDirectory;
		exportFunction: CreateFileA as: #CreateFile;
		exportFunction: CreatePipe;
		exportFunction: CreateProcessA as: #CreateProcess;
		exportFunction: DeleteFileA as: #DeleteFile;
		exportFunction: FindClose;
		exportFunction: FindFirstFileA as: #FindFirstFile;
		exportFunction: FindNextFileA as: #FindNextFile;
		exportFunction: FormatMessageA as: #FormatMessage;
		exportFunction: FreeEnvironmentStringsW;
		exportFunction: GetCurrentDirectoryA as: #GetCurrentDirectory;
		exportFunction: GetCurrentThread;
		exportFunction: GetDiskFreeSpaceA as: #GetDiskFreeSpace;
		exportFunction: GetEnvironmentStringsW;
		exportFunction: GetExitCodeProcess;
		exportFunction: GetFileAttributesA as: #GetFileAttributes;
		exportFunction: GetFileSize;
		exportFunction: GetLastError;
		exportFunction: GetModuleHandleA as: #GetModuleHandle;
		exportFunction: GetStdHandle;
		exportFunction: GetTempFileNameA as: #GetTempFileName;
		exportFunction: GetTempPathA as: #GetTempPath;
		exportFunction: GetUserDefaultLangID;
		exportFunction: LoadLibraryA as: #LoadLibrary;
		exportFunction: MoveFileA as: #MoveFile;
		exportFunction: MultiByteToWideChar;
		exportFunction: ReadFile;
		exportFunction: RemoveDirectoryA as: #RemoveDirectory;
		exportFunction: SetFileApisToOEM;
		exportFunction: SetFilePointer;
		exportFunction: SetHandleInformation;
		exportFunction: WaitForSingleObject;
		exportFunction: WideCharToMultiByte;
		exportFunction: WriteFile
)) : ()
class MsimgLibrary = WinLibrary name: 'Msimg32' (
(* Describe the class in this comment. *)||)
('as yet unclassified'
GradientFill = (
(* BOOL GradientFill(
  HDC hdc,                   // handle to DC
  PTRIVERTEX pVertex,        // array of vertices
  ULONG dwNumVertex,         // number of vertices
  PVOID pMesh,               // array of gradients
  ULONG dwNumMesh,           // size of gradient array
  ULONG dwMode               // gradient fill mode
); *)
	^functionNamed: #GradientFill argc: 6
)
exportFunctionsTo: capi = (
	(* Please keep the list sorted alphabetically. *)
	capi
		exportFunction: GradientFill
)) : ()
class Pipe = (|
	myEnd
	otherEnd
|)
('as yet unclassified'
closeBothEnds = (
	closeMyEnd.
	closeOtherEnd.
)
closeMyEnd = (
	closeHandle: myEnd
)
closeOtherEnd = (
	closeHandle: otherEnd
)) : ()
class Process = (|
	lpProcessInformation
|)
('as yet unclassified'
waitForExitCode ^<Integer> = (
	^[ | lpExitCode delay |
		lpExitCode:: outer Win32API Alien newGC: 4.
		delay:: Delay forMilliseconds: 10.
		[ | rcode |
			rcode:: outer Win32API WaitForSingleObject
				unsignedValue: lpProcessInformation hProcess
				value: 0. (* dwMilliseconds *)
			16r00000102 = rcode (* WAIT_TIMEOUT *)] whileTrue: [delay wait].
		outer Win32API GetExitCodeProcess
			boolValue: lpProcessInformation hProcess
			value: lpExitCode pointer.
		lpExitCode signedLongAt: 1.
	] ensure: [lpProcessInformation closeHandles].
)) : ()
class UserLibrary = WinLibrary name: 'User' (
(* Describe the class in this comment. *)|
|)
('as yet unclassified'
AdjustWindowRect = (
(* BOOL AdjustWindowRect(      
    LPRECT lpRect,
    DWORD dwStyle,
    BOOL bMenu
); *)
	^functionNamed: #AdjustWindowRect argc: 3
)
AnimateWindow = (
(*
BOOL AnimateWindow(      
    HWND hwnd,
    DWORD dwTime,
    DWORD dwFlags
);
*)
	^functionNamed: #AnimateWindow argc: 3
)
AppendMenuA = (
	^functionNamed: #AppendMenuA argc: 4
)
BeginDeferWindowPos = (
	(* HDWP BeginDeferWindowPos(      
  		  int nNumWindows
	); *)
	^functionNamed: #BeginDeferWindowPos argc: 1
)
BeginPaint = (
	^functionNamed: #BeginPaint argc: 2
)
CreateMenu = (
	(* HMENU CreateMenu(VOID); *)
	^functionNamed: #CreateMenu argc: 0
)
CreatePopupMenu = (
	(* HMENU CreatePopupMenu(VOID); *)
	^functionNamed: #CreatePopupMenu argc: 0
)
CreateWindowExA = (
	^functionNamed: #CreateWindowExA argc: 12
)
DefWindowProcA = (
	^functionNamed: #DefWindowProcA argc: 4
)
DeferWindowPos = (
	(* HDWP DeferWindowPos(      
    		HDWP hWinPosInfo,
   		HWND hWnd,
    		HWND hWndInsertAfter,
    		int x,
    		int y,
    		int cx,
   		 int cy,
    		UINT uFlags
	); *)
	^functionNamed: #DeferWindowPos argc: 8
)
DestroyWindow = (
	^functionNamed: #DestroyWindow argc: 1
)
DispatchMessageA = (
	^functionNamed: #DispatchMessageA argc: 1
)
DrawMenuBar = (
	(* BOOL DrawMenuBar(HWND hWnd); *)
	^functionNamed: #DrawMenuBar argc: 1.
)
DrawTextA = (
	^functionNamed: #DrawTextA argc: 5
)
EnableWindow = (
	^functionNamed: #EnableWindow argc: 2
)
EndDeferWindowPos = (
	(* BOOL EndDeferWindowPos(      
    		HDWP hWinPosInfo
	); *)
	^functionNamed: #EndDeferWindowPos argc: 1
)
EndPaint = (
	^functionNamed: #EndPaint argc: 2
)
EnumThreadWindows = (
(*
BOOL EnumThreadWindows(      
    DWORD dwThreadId,
    WNDENUMPROC lpfn,
    LPARAM lParam
);
*)
	^functionNamed: #EnumThreadWindows argc: 3
)
FillRect = (
	^functionNamed: #FillRect argc: 3
)
FindWindowA = (
	(* HWND FindWindow(      
    LPCTSTR lpClassName,
    LPCTSTR lpWindowName
); *)
	^functionNamed: #FindWindowA argc: 2
)
FlashWindow = (
	(* BOOL WINAPI FlashWindow(HWND hWnd, BOOL bInvert); *)
	^functionNamed: #FlashWindow argc: 2
)
FlashWindowEx = (
	(* BOOL WINAPI FlashWindowEx(PFLASHWINFO pfwi); *)
	^functionNamed: #FlashWindowEx argc: 1
)
GetAncestor = (
	(* HWND GetAncestor(HWND hwnd, UINT gaFlags); *)
	^functionNamed: #GetAncestor argc: 2
)
GetClientRect = (
	(* BOOL GetClientRect(HWND hWnd, LPRECT lpRect); *)
	^functionNamed: #GetClientRect argc: 2
)
GetCursorPos = (
	(* BOOL GetCursorPos(LPPOINT lpPoint); *)
	^functionNamed: #GetCursorPos argc: 1
)
GetDC = (
	^functionNamed: #GetDC argc: 1
)
GetForegroundWindow = (
(* HWND GetForegroundWindow(VOID); *)
	^functionNamed: #GetForegroundWindow argc: 0
)
GetKeyState = (
	(* SHORT GetKeyState(int nVirtKey); *)
	^functionNamed: #GetKeyState argc: 1
)
GetMessageA = (
	^functionNamed: #GetMessageA argc: 4
)
GetScrollInfo = (
	(* BOOL GetScrollInfo(      
		HWND hwnd,
		int fnBar,
		LPSCROLLINFO lpsi
); *)
	^functionNamed: #GetScrollInfo argc: 3
)
GetSystemMetrics = (
	(* int WINAPI GetSystemMetrics(__in  int nIndex); *)
	^functionNamed: #GetSystemMetrics argc: 1
)
GetWindowLongA = (
	(* LONG GetWindowLongA(HWND hWnd, int nIndex); *)
	^functionNamed: #GetWindowLongA argc: 2
)
InvalidateRect = (
	^functionNamed: #InvalidateRect argc: 3
)
IsWindow = (
(*
BOOL IsWindow(      
    HWND hWnd
);
*)
	^functionNamed: #IsWindow argc: 1
)
IsWindowVisible = (
(*
BOOL IsWindowVisible(      
    HWND hWnd
);
*)
	^functionNamed: #IsWindowVisible argc: 1
)
LoadCursorA = (
	^functionNamed: #LoadCursorA argc: 2
)
LoadIconA = (
	^functionNamed: #LoadIconA argc: 2
)
MessageBeep = (
(*
BOOL WINAPI MessageBeep(
  __in  UINT uType
);
*)
	^functionNamed: #MessageBeep argc: 1
)
MoveWindow = (
	^functionNamed: #MoveWindow argc: 6
)
PeekMessageA = (
(*
BOOL PeekMessage(      
    LPMSG lpMsg,
    HWND hWnd,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg
);
*)
	^functionNamed: #PeekMessageA argc: 5
)
PostQuitMessage = (
	^functionNamed: #PostQuitMessage argc: 1
)
RegisterClassA = (
	^functionNamed: #RegisterClassA argc: 1
)
ReleaseCapture = (
	(* BOOL ReleaseCapture(VOID); *)
	^functionNamed: #ReleaseCapture argc: 0
)
ReleaseDC = (
	^functionNamed: #ReleaseDC argc: 2
)
SendMessageA = (
	^functionNamed: #SendMessageA argc: 4
)
SetActiveWindow = (
(*
HWND SetActiveWindow(      
    HWND hWnd
);
*)
	^functionNamed: #SetActiveWindow argc: 1
)
SetCapture = (
	(* HWND SetCapture(HWND); *)
	^functionNamed: #SetCapture argc: 1
)
SetCursorPos = (
	(* BOOL SetCursorPos(int X, int Y); *)
	^functionNamed: #SetCursorPos argc: 2
)
SetFocus = (
	(* HWND SetFocus(HWND hWnd); *)
	^functionNamed: #SetFocus argc: 1
)
SetForegroundWindow = (
(*
BOOL SetForegroundWindow(      
    HWND hWnd
);
*)
	^functionNamed: #SetForegroundWindow argc: 1
)
SetLayeredWindowAttributes = (
(* BOOL SetLayeredWindowAttributes(      
    HWND hwnd,
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags
); *)
	^functionNamed: #SetLayeredWindowAttributes argc: 4
)
SetMenu = (
	(* BOOL SetMenu(HWND hWnd, HMENU hMenu); *)
	^functionNamed: #SetMenu argc: 2
)
SetScrollInfo = (
	(* int SetScrollInfo(      
	    HWND hwnd,
	    int fnBar,
	    LPCSCROLLINFO lpsi,
	    BOOL fRedraw
	); *)
	^functionNamed: #SetScrollInfo argc: 4
)
SetWindowLongA = (
	(* LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong); *)
	^functionNamed: #SetWindowLongA argc: 3
)
SetWindowTextA = (
	^functionNamed: #SetWindowTextA argc: 2
)
ShowWindow = (
	^functionNamed: #ShowWindow argc: 2
)
SystemParametersInfoA = (
	(* BOOL WINAPI SystemParametersInfo(
		__in     UINT uiAction,
		__in     UINT uiParam,
		__inout  PVOID pvParam,
		__in     UINT fWinIni
	); *)
	^functionNamed: #SystemParametersInfoA argc: 4
)
TabbedTextOutA = (
	^functionNamed: #TabbedTextOutA argc: 8
)
TrackMouseEvent = (
	(* BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack); *)
	^functionNamed: #TrackMouseEvent argc: 1
)
TrackPopupMenu = (
	(* BOOL TrackPopupMenu(
	    HMENU hMenu,
	    UINT uFlags,
 	   int x,
	    int y,
	    int nReserved,
	    HWND hWnd,
	    CONST RECT *prcRect); *)
	^functionNamed: #TrackPopupMenu argc: 7
)
TranslateMessage = (
	^functionNamed: #TranslateMessage argc: 1
)
UnregisterClassA = (
	^functionNamed: #UnregisterClassA argc: 2
)
UpdateLayeredWindow = (
(* BOOL UpdateLayeredWindow(      
    HWND hwnd,
    HDC hdcDst,
    POINT *pptDst,
    SIZE *psize,
    HDC hdcSrc,
    POINT *pptSrc,
    COLORREF crKey,
    BLENDFUNCTION *pblend,
    DWORD dwFlags
); *)
	^functionNamed: #UpdateLayeredWindow argc: 9
)
UpdateWindow = (
	^functionNamed: #UpdateWindow argc: 1
)
WindowFromPoint = (
	(* HWND WindowFromPoint(POINT Point); *)
	^functionNamed: #WindowFromPoint argc: 1
)
exportFunctionsTo: capi = (
	(* Please keep the exports ordered alphabetically. *)
	capi
		exportFunction: AdjustWindowRect;
		exportFunction: AnimateWindow;
		exportFunction: AppendMenuA as: #AppendMenu;
		exportFunction: BeginDeferWindowPos;
		exportFunction: BeginPaint;
		exportFunction: CreateMenu;
		exportFunction: CreatePopupMenu;
		exportFunction: CreateWindowExA as: #CreateWindowEx;
		exportFunction: DefWindowProcA as: #DefWindowProc;
		exportFunction: DeferWindowPos;
		exportFunction: DestroyWindow;
		exportFunction: DispatchMessageA as: #DispatchMessage;
		exportFunction: DrawMenuBar;
		exportFunction: DrawTextA as: #DrawText;
		exportFunction: EnableWindow;
		exportFunction: EndDeferWindowPos;
		exportFunction: EndPaint;
		exportFunction: EnumThreadWindows;
		exportFunction: FillRect;
		exportFunction: FindWindowA as: #FindWindow;
		exportFunction: FlashWindow;
		exportFunction: FlashWindowEx;
		exportFunction: GetAncestor;
		exportFunction: GetClientRect;
		exportFunction: GetCursorPos;
		exportFunction: GetDC;
		exportFunction: GetForegroundWindow;
		exportFunction: GetKeyState;
		exportFunction: GetMessageA as: #GetMessage;
		exportFunction: GetScrollInfo;
		exportFunction: GetSystemMetrics;
		exportFunction: GetWindowLongA as: #GetWindowLong;
		exportFunction: InvalidateRect;
		exportFunction: IsWindow;
		exportFunction: IsWindowVisible;
		exportFunction: LoadCursorA as: #LoadCursor;
		exportFunction: LoadIconA as: #LoadIcon;
		exportFunction: MessageBeep;
		exportFunction: MoveWindow;
		exportFunction: PeekMessageA as: #PeekMessage;
		exportFunction: PostQuitMessage;
		exportFunction: RegisterClassA as: #RegisterClass;
		exportFunction: ReleaseCapture;
		exportFunction: ReleaseDC;
		exportFunction: SendMessageA as: #SendMessage;
		exportFunction: SetActiveWindow;
		exportFunction: SetCapture;
		exportFunction: SetCursorPos;
		exportFunction: SetFocus;
		exportFunction: SetForegroundWindow;
		exportFunction: SetLayeredWindowAttributes;
		exportFunction: SetMenu;
		exportFunction: SetScrollInfo;
		exportFunction: SetWindowLongA as: #SetWindowLong;
		exportFunction: SetWindowTextA as: #SetWindowText;
		exportFunction: ShowWindow;
		exportFunction: SystemParametersInfoA as: #SystemParametersInfo;
		exportFunction: TabbedTextOutA as: #TabbedTextOut;
		exportFunction: TrackMouseEvent;
		exportFunction: TrackPopupMenu;
		exportFunction: TranslateMessage;
		exportFunction: UpdateWindow;
		exportFunction: UpdateLayeredWindow;
		exportFunction: UnregisterClassA as: #UnregisterClass;
		exportFunction: WindowFromPoint
)) : ()
class Win32Function library: theLibrary <CLibrary> name: theName <Symbol> argc: numArgs <Integer> = CFunction library: theLibrary name: theName argc: numArgs (
(* A Windows function: same as CFunction but with some extra handy utilities. *)|
|)
('as yet unclassified'
boolValue ^<Boolean> = (
	(* Invoke the function with zero arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^unsignedValue ~= 0
)
boolValue: arg <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 1 argument and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg) ~= 0
)
boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 2 argument and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2) ~= 0
)
boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 3 argument and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3) ~= 0
)
boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 4 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4) ~= 0
)
boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 5 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5) ~= 0
)
boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 6 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6) ~= 0
)
boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 7 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7) ~= 0
)
boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> value: arg8 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 8 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8) ~= 0
)
boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> value: arg8 <Alien | Integer> value: arg9 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 9 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8 value: arg9) ~= 0
)
boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> value: arg8 <Alien | Integer> value: arg9 <Alien | Integer> value: arg10 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 10 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8 value: arg9 value: arg10) ~= 0
)
boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> value: arg8 <Alien | Integer> value: arg9 <Alien | Integer> value: arg10 <Alien | Integer> value: arg11 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 11 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8 value: arg9 value: arg10 value: arg11) ~= 0
)
boolValue: arg1 <Alien | Integer> value: arg2 <Alien | Integer> value: arg3 <Alien | Integer> value: arg4 <Alien | Integer> value: arg5 <Alien | Integer> value: arg6 <Alien | Integer> value: arg7 <Alien | Integer> value: arg8 <Alien | Integer> value: arg9 <Alien | Integer> value: arg10 <Alien | Integer> value: arg11 <Alien | Integer> value: arg12 <Alien | Integer> ^<Boolean> = (
	(* Invoke the function with 12 arguments and return a Boolean produced by interpreting the first four bytes of the result as false/true value. 0 is interpreted as false and anything else as true. Fail if the receiver expects a different number of arguments. *)
	^(unsignedValue: arg1 value: arg2 value: arg3 value: arg4 value: arg5 value: arg6 value: arg7 value: arg8 value: arg9 value: arg10 value: arg11 value: arg12) ~= 0
)) : ()
class WinLibrary name: theName <String> = CLibrary name: theName (
(* A Windows DLL. Mostly the same as CLibrary but uses different function instances. *)|
|)
('as yet unclassified'
functionClass ^<Class> = (
	(* The class of instances of functions managed by this library. *)
	^Win32Function
)) : ()'FontQuality'
ANTIALIASED_QUALITY = (
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^4
)
CLEARTYPE_QUALITY = (
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^5
)
DEFAULT_QUALITY =(
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^0
)
DRAFT_QUALITY =(
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^1
)
NONANTIALIASED_QUALITY = (
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^3
)
PROOF_QUALITY =(
	(* http://msdn.microsoft.com/en-us/library/cc250391.aspx *)
	^2
)'as yet unclassified'
ANSI_FIXED_FONT = (
	^11
)
ANSI_VAR_FONT = (
	^12
)
AW_ACTIVATE = (
	(* #define AW_ACTIVATE                 0x00020000 *)
	^16r00020000
)
AW_BLEND = (
	(* #define AW_BLEND                    0x00080000 *)
	^16r00080000
)
AW_CENTER = (
	(* #define AW_CENTER                   0x00000010 *)
	^16r00000010
)
AW_HIDE = (
	(* #define AW_HIDE                     0x00010000 *)
	^16r00010000
)
AW_HOR_NEGATIVE = (
	(* #define AW_HOR_NEGATIVE             0x00000002 *)
	^16r00000002
)
AW_HOR_POSITIVE = (
	(* #define AW_VER_POSITIVE             0x00000004 *)
	^16r00000004
)
AW_SLIDE = (
	(* #define AW_SLIDE                    0x00040000 *)
	^16r00040000
)
AW_VER_NEGATIVE = (
	(* #define AW_VER_NEGATIVE             0x00000008 *)
	^16r00000008
)
Alien = (
	(* Make the name lexically visible to everything nested here. *)
	^super Alien
)
BCM_GETIDEALSIZE = (
	^16r1601
)
BN_CLICKED = (
	^0
)
CFE_AUTOCOLOR = (
	^16r40000000
)
CFE_BOLD = (
	^16r1
)
CFE_ITALIC = (
	^16r2
)
CFE_UNDERLINE = (
	^16r4
)
CFM_BACKCOLOR = (
	^16r04000000
)
CFM_BOLD = (
	^16r1
)
CFM_COLOR = (
	^16r40000000
)
CFM_ITALIC = (
	^16r2
)
CFM_UNDERLINE = (
	^16r4
)
COLOR_BACKGROUND = (
	^1
)
COLOR_MENU = (
	^4
)
COLOR_WINDOW = (
	^5
)
CREATE_ALWAYS = (
(* http://msdn.microsoft.com/en-us/library/aa363858(VS.85).aspx
CREATE_ALWAYS
2
*)
	^2
)
CS_HREDRAW = (
	^2
)
CS_VREDRAW = (
	^1
)
CW_USEDEFAULT = (
	^2147483648
)
DC_BRUSH = (
	^18
)
DC_PEN = (
	^19
)
EM_EXGETSEL = (
	^WM_USER + 52
)
EM_EXSETSEL = (
	^WM_USER + 55
)
EM_GETCHARFORMAT = (
	^WM_USER + 58
)
EM_GETEVENTMASK = (
	^WM_USER + 59
)
EM_GETPARAFORMAT = (
	^WM_USER + 61
)
EM_HIDESELECTION = (
	^WM_USER + 63
)
EM_LINEFROMCHAR = (
	^16r00C9
)
EM_LINEINDEX = (
	^16r00BB
)
EM_LINELENGTH = (
	^16r00C1
)
EM_REQUESTRESIZE = (
	^WM_USER + 65
)
EM_SETCHARFORMAT = (
	^WM_USER + 68
)
EM_SETEVENTMASK = (
	^WM_USER + 69
)
EM_SETPARAFORMAT = (
	^WM_USER + 71
)
EM_SETSCROLLPOS = (
	^WM_USER + 222
)
EM_SHOWSCROLLBAR = (
	^WM_USER + 96
)
ENM_CHANGE = (
	^16r1
)
ENM_KEYEVENTS = (
	^16r10000
)
ENM_REQUESTRESIZE = (
	(* Richedit.h *)
	^16r40000
)
EN_CHANGE = (
	^16r300
)
EN_MSGFILTER = (
	^16r700
)
EN_REQUESTRESIZE = (
	(* Richedit.h *)
	^16r701
)
ERROR_ALREADY_EXISTS = (
	^16rB7
)
ERROR_NO_MORE_FILES = (
	^16r12
)
ERROR_SHARING_VIOLATION = (
	^16r20
)
ES_MULTILINE = (
	^4
)
ES_PASSWORD = (
	^16r20
)
ES_READONLY = (
	^16r800
)
ES_WANTRETURN = (
	^16r1000
)
FILE_ATTRIBUTE_DIRECTORY = (
	^16
)
FILE_ATTRIBUTE_NORMAL = (
(* http://msdn.microsoft.com/en-us/library/aa363858(VS.85).aspx
FILE_ATTRIBUTE_NORMAL
128
0x80
*)
	^128
)
FILE_ATTRIBUTE_READONLY = (
	^1
)
FILE_FLAG_SEQUENTIAL_SCAN = (
	^16r0800
)
FORMAT_MESSAGE_ALLOCATE_BUFFER = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_ALLOCATE_BUFFER
0x00000100
*)
	^16r00000100
)
FORMAT_MESSAGE_ARGUMENT_ARRAY = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_ARGUMENT_ARRAY
0x00002000
*)
	^16r00002000
)
FORMAT_MESSAGE_FROM_HMODULE = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_FROM_HMODULE
0x00000800
*)
	^16r00000800
)
FORMAT_MESSAGE_FROM_STRING = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_FROM_STRING
0x00000400
*)
	^16r00000400
)
FORMAT_MESSAGE_FROM_SYSTEM = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_FROM_SYSTEM
0x00001000
*)
	^16r00001000
)
FORMAT_MESSAGE_IGNORE_INSERTS = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_IGNORE_INSERTS
0x00000200
*)
	^16r00000200
)
FORMAT_MESSAGE_MAX_WIDTH_MASK = (
(*
http://msdn.microsoft.com/en-us/library/ms679351(VS.85).aspx
FORMAT_MESSAGE_MAX_WIDTH_MASK
0x000000FF
*)
	^16r000000FF
)
GA_PARENT = (
	^1
)
GA_ROOT = (
	^2
)
GA_ROOTOWNER = (
	^3
)
GENERIC_WRITE = (
	^16r40000000
)
GRADIENT_FILL_RECT_H = (
(* #define GRADIENT_FILL_RECT_H    0x00000000 *)
	^0
)
GRADIENT_FILL_RECT_V = (
(* #define GRADIENT_FILL_RECT_V    0x00000001 *)
	^1
)
GWL_EXSTYLE = (
	^-20
)
GWL_STYLE = (
	^-16
)
IDC_ARROW = (
	^32512
)
IDI_APPLICATION = (
	^32512
)
INVALID_FILE_SIZE ^ <Integer> = (
	^16rFFFFFFFF
)
INVALID_HANDLE_VALUE = (
	^16rFFFFFFFF
)
LBN_DBLCLK = (
	^2
)
LBN_ERRSPACE = (
	^-2
)
LBN_KILLFOCUS = (
	^5
)
LBN_SELCANCEL = (
	^3
)
LBN_SELCHANGE = (
	^1
)
LBN_SETFOCUS = (
	^4
)
LBS_DISABLENOSCROLL = (
	^16r1000
)
LBS_EXTENDEDSEL = (
	^16r800
)
LBS_HASSTRINGS = (
	^16r40
)
LBS_MULTIPLESEL = (
	^8
)
LBS_NOINTEGRALHEIGHT = (
	^16r100
)
LBS_NOTIFY = (
	^1
)
LB_ADDSTRING = (
	^16r180
)
LB_DELETESTRING = (
	^16r182
)
LB_GETCOUNT = (
	^16r18B
)
LB_GETCURSEL = (
	^16r188
)
LB_GETSEL = (
	^16r187
)
LB_INITSTORAGE = (
	^16r1A8
)
LB_INSERTSTRING = (
	^16r181
)
LB_RESETCONTENT = (
	^16r184
)
LB_SETCURSEL = (
	^16r186
)
LB_SETHORIZONTALEXTENT = (
	^16r194
)
LB_SETSEL = (
	^16r185
)
MF_CHECKED = (
	^16r8
)
MF_DISABLED = (
	^16r2
)
MF_ENABLED = (
	^16r0
)
MF_GRAYED = (
	^16r1
)
MF_POPUP = (
	^16r10
)
MF_SEPARATOR = (
	^16r800
)
MF_UNCHECKED = (
	^16r0
)
MK_CONTROL = (
	^8
)
MK_LBUTTON = (
	^1
)
MK_MBUTTON = (
	^16r10
)
MK_RBUTTON = (
	^2
)
MK_SHIFT = (
	^4
)
NULL = (
	^0
)
OUT_TT_PRECIS = (
	(* WinGDI.h:#define OUT_TT_PRECIS               4 *)
	^4
)
PFM_TABSTOPS = (
	^16r10
)
PM_REMOVE = (
	^1
)
PS_SOLID = (
	^0
)
SB_BOTH = (
	^2
)
SB_CTL = (
	^2
)
SB_HORZ = (
	^0
)
SB_VERT = (
	^1
)
SIF_ALL = (
	^16r1F
)
SM_CMONITORS = (
	^80
)
SM_CXSCREEN = (
	^0
)
SM_CXVIRTUALSCREEN = (
	^78
)
SM_CXVSCROLL = (
	^2
)
SM_CYHSCROLL = (
	^3
)
SM_CYSCREEN = (
	^1
)
SM_CYVIRTUALSCREEN = (
	^79
)
SM_XVIRTUALSCREEN = (
	^76
)
SM_YVIRTUALSCREEN = (
	^77
)
SPI_GETWORKAREA = (
	^16r30
)
STARTF_USESHOWWINDOW = (
	(* #define STARTF_USESHOWWINDOW    0x00000001 *)
	^16r00000001
)
STARTF_USESTDHANDLES = (
	^256
)
SWP_HIDEWINDOW = (
	^16r80
)
SWP_NOMOVE = (
	^16r2
)
SWP_NOREDRAW = (
	^16r8
)
SWP_NOSIZE = (
	^16r1
)
SWP_NOZORDER = (
	^16r4
)
SWP_SHOWWINDOW = (
	^16r40
)
SW_HIDE = (
	^0
)
SW_MINIMIZE = (
	(* #define SW_MINIMIZE         6 *)
	^6
)
SW_SHOW = (
	^5
)
SYSTEM_FONT = (
	^13
)
TPM_NONOTIFY = (
	^16r80
)
TPM_RETURNCMD = (
	^16r100
)
VK_CAPITAL = (
	^16r14
)
VK_CONTROL = (
	^16r11
)
VK_ESCAPE = (
	^16r1B
)
VK_LBUTTON = (
	^1
)
VK_MBUTTON = (
	^4
)
VK_MENU = (
	(* This means the Alt key. *)
	^16r12
)
VK_PAUSE = (
	^16r13
)
VK_RBUTTON = (
	^2
)
VK_SHIFT = (
	^16r10
)
WHITE_BRUSH = (
	^0
)
WM_CHAR = (
	^16r102
)
WM_CLOSE = (
	(* #define WM_CLOSE                        0x0010 *)
	^16r10
)
WM_COMMAND = (
	^273
)
WM_CREATE = (
	^1
)
WM_DESTROY = (
	^2
)
WM_ERASEBKGND = (
	^16r14
)
WM_GETFONT = (
	^16r31
)
WM_GETTEXT = (
	^16rD
)
WM_GETTEXTLENGTH = (
	^16rE
)
WM_HSCROLL = (
	^16r114
)
WM_KEYDOWN = (
	^16r100
)
WM_KEYUP = (
	^16r101
)
WM_LBUTTONDBLCLK = (
	^16r203
)
WM_LBUTTONDOWN = (
	^16r201
)
WM_LBUTTONUP = (
	^16r202
)
WM_MOUSELEAVE = (
	^16r2A3
)
WM_MOUSEMOVE = (
	^16r200
)
WM_MOUSEWHEEL = (
	^16r20A
)
WM_NCDESTROY = (
	^130
)
WM_NOTIFY = (
	^16r4E
)
WM_PAINT = (
	^15
)
WM_RBUTTONDBLCLK = (
	^16r206
)
WM_RBUTTONDOWN = (
	^16r204
)
WM_RBUTTONUP = (
	^16r205
)
WM_SETFONT = (
	^16r30
)
WM_SETREDRAW = (
	^16r0B
)
WM_SETTEXT = (
	^12
)
WM_SYSCHAR = (
	^16r106
)
WM_SYSCOMMAND = (
(* #define WM_SYSCOMMAND                   0x0112 *)
	^16r0112
)
WM_SYSKEYDOWN = (
	^16r104
)
WM_USER = (
	^16r400
)
WM_VSCROLL = (
	^16r115
)
WM_WINDOWPOSCHANGED = (
	^71
)
WS_BORDER = (
	^16r00800000
)
WS_CAPTION = (
	^16r00C00000
)
WS_CHILD = (
	^16r40000000
)
WS_CHILDWINDOW = (
	^WS_CHILD
)
WS_CLIPCHILDREN = (
	^16r02000000
)
WS_CLIPSIBLINGS = (
	^16r04000000
)
WS_DISABLED = (
	^16r08000000
)
WS_DLGFRAME = (
	^16r00400000
)
WS_EX_CLIENTEDGE = (
	^16r200
)
WS_EX_COMPOSITED = (
	^16r02000000
)
WS_EX_LAYERED = (
	^16r80000
)
WS_EX_NOACTIVATE = (
	^16r8000000
)
WS_EX_STATICEDGE = (
	^16r20000
)
WS_EX_TOPMOST = (
	^16r8
)
WS_EX_TRANSPARENT = (
	^16r20
)
WS_GROUP = (
	^16r00020000
)
WS_HSCROLL = (
	^16r00100000
)
WS_MAXIMIZE = (
	^16r01000000
)
WS_MAXIMIZEBOX = (
	^16r00010000
)
WS_MINIMIZE = (
	^16r20000000
)
WS_MINIMIZEBOX = (
	^16r00020000
)
WS_OVERLAPPED = (
	^0
)
WS_OVERLAPPEDWINDOW = (
	^bits: {#WS_OVERLAPPED. #WS_CAPTION. #WS_SYSMENU. #WS_THICKFRAME. #WS_MINIMIZEBOX. #WS_MAXIMIZEBOX}
)
WS_POPUP = (
	^16r80000000
)
WS_POPUPWINDOW = (
	^bits: {#WS_POPUP. #WS_BORDER. #WS_SYSMENU}
)
WS_SYSMENU = (
	^16r00080000
)
WS_TABSTOP = (
	^16r00010000
)
WS_THICKFRAME = (
	^16r00040000
)
WS_VISIBLE = (
	^16r10000000
)
WS_VSCROLL = (
	^16r00200000
)
closeHandle: handle <Integer | Alien> ^ <Boolean> = (
	(self CloseHandle boolValue: handle) ifFalse: [reportError]
)
createPipeForReading ^<Pipe> = (
	^Alien autoFreeAfter: [ :autofree | | readPipe writePipe |
		readPipe:: autofree value: (Alien newC: 4).
		writePipe:: autofree value: (Alien newC: 4).
		createPipeForReading: readPipe withChildPipe: writePipe.
		Pipe new myEnd: readPipe asUnsignedLong; otherEnd: writePipe asUnsignedLong
	]
)
createPipeForWriting ^<{Integer. Integer}> = (
	^Alien autoFreeAfter: [ :autofree | | readPipe writePipe |
		readPipe:: autofree value: (Alien newC: 4s).
		writePipe:: autofree value: (Alien newC: 4).
		createPipeForWriting: writePipe withChildPipe: readPipe.
		Pipe new myEnd: writePipe asUnsignedLong; otherEnd: readPipe asUnsignedLong
	]
)
createProcess: commandLine <String>
withCurrentDirectory: dir <FileDirectory>
withTitle: title <String>
withStdInput: stdInput <Alien | Integer>
withStdOutput: stdOutput <Alien | Integer>
withStdError: stdError <Alien | Integer>
^<Win32apiPROCESSINFORMATION> = (
	| lpProcessInformation lpStartupInfo result |
	lpProcessInformation:: PROCESS_INFORMATION newGC.
	lpStartupInfo:: STARTUPINFO newGC.

	Alien autoFreeAfter: [ :autoFree |
		lpStartupInfo dwFlags: STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW.
		lpStartupInfo wShowWindow: SW_HIDE.
		lpStartupInfo lpTitle: (autoFree value: (Alien newCString: title)) address.
		lpStartupInfo hStdInput: (stdInput isInteger ifTrue: [stdInput] ifFalse: [stdInput asUnsignedLong]).
		lpStartupInfo hStdOutput: (stdOutput isInteger ifTrue: [stdOutput] ifFalse: [stdOutput asUnsignedLong]).
		lpStartupInfo hStdError: (stdError isInteger ifTrue: [stdError] ifFalse: [stdError asUnsignedLong]).
		result:: self CreateProcess
			boolValue: 0 (* lpApplicationName *)
			value: (autoFree value: (Alien newCString: commandLine)) address
			value: 0 (* lpProcessAttributes *)
			value: 0 (* lpThreadAttributes *)
			value: 1 (* bInheritHandles *)
			value: 0 (* dwCreationFlags *)
			value: 0 (* lpEnvironment *)
			value: (autoFree value: (Alien newCString: dir fullName)) address
			value: lpStartupInfo address
			value: lpProcessInformation address.
		result ifFalse: [^reportError]].
	^Process new lpProcessInformation: lpProcessInformation
)
createTemporaryFile: inherit ^<{String. Alien}> = (
	|
	pathBuffer <Alien>
	tempName <Alien>
	result <Integer>
	hTempFile <Integer>
	lpSecurityAttributes <Alien>
	|
	lpSecurityAttributes:: SECURITY_ATTRIBUTES newGC bInheritHandle: inherit.
	Alien autoFreeAfter: [ :autoFree |
		pathBuffer:: Alien newGC: 512.
		result:: self GetTempPath unsignedValue: 512 value: pathBuffer address.
		(result > 512 or: [result = 0]) ifTrue: [^reportError].

		tempName:: Alien newGC: 512.
		result:: self GetTempFileName
			unsignedValue: pathBuffer address
			value: (autoFree value: (Alien newCString: 'NSP')) address
			value: 0
			value: tempName address.
		result = 0 ifTrue: [reportError]].
	
	hTempFile:: self CreateFile
		unsignedValue: tempName address
		value: GENERIC_WRITE
		value: 0
		value: lpSecurityAttributes address
		value: CREATE_ALWAYS
		value: FILE_ATTRIBUTE_NORMAL
		value: NULL.
	hTempFile = INVALID_HANDLE_VALUE ifTrue: [reportError].
	^File new name: tempName strcpy; handle: hTempFile
)
environmentVariables ^<Dictionary> = (
	| envp env string strings count a dict |
	envp:: self GetEnvironmentStringsW unsignedValue.
	env:: WCharAlien forPointer: envp.
	count:: 1.
	strings:: OrderedCollection new.
	[a:: Array streamContents: [ :s | | c |
		[c:: env unsignedShortAt: count.
		count:: count + 2.
		c = 0] whileFalse: [s nextPut: (Character value: c)]].
	string:: String newFrom: a.
	string isEmpty] whileFalse: [strings add: string].
	self FreeEnvironmentStringsW boolValue: envp.
	dict:: Dictionary new.
	strings do: [ :ea | | i k v |
		i:: ea indexOf: $=.
		k:: ea copyFrom: 1 to: i - 1.
		v:: ea allButFirst: i.
		dict at: k asUppercase asSymbol put: v].
	^dict
)
error: message = (
	^GiveUp signal: message
)
nullTerminatedCString: strings <SequenceableCollection[String]> = (
	| null |
	null:: Character value: 0.
	strings isEmpty ifTrue: [^Alien newCString: {null.null} asString].
	^Alien newCString: (String streamContents: [ :s |
		strings do: [ :string |
			s nextPutAll: string.
			s nextPut: null].
		s nextPut: null]).
)
reportError: message code: code = (
	^error: message, ' (', (getErrorMessage: code) , ')'
)'error codes'
getErrorMessage: errorCode <Integer> ^<String> = (
(*
http://msdn.microsoft.com/en-us/library/ms680582(VS.85).aspx
	FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dw,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) &lpMsgBuf,
        0, NULL );
*)
	(Alien newC: 4)	freeAfter: [ :lpMsgBuf | | result |
		result:: self FormatMessage
			unsignedValue:	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_IGNORE_INSERTS
			value: NULL
			value: errorCode
			value: self GetUserDefaultLangID unsignedValue
			value: lpMsgBuf address
			value: 0
			value: NULL.
		result = 0 ifTrue: [
			error:	'Could not retrieve error code: ', errorCode asString,
					' reason: ', getLastErrorCode asString].
		^((Alien forPointer: lpMsgBuf asUnsignedLong) strcpy copyWithout: Character lf) withBlanksTrimmed]
)
getLastErrorCode ^<Integer> = (
	^self GetLastError unsignedValue
)
getLastErrorMessage ^<String> = (
	^getErrorMessage: getLastErrorCode
)
reportError = (
	^error: getLastErrorMessage
)
reportError: message = (
	^error: message, ' (', getLastErrorMessage, ')'
)'pipes'
createPipeForReading: readPipe <Alien> withChildPipe: writePipe <Alien> = (
	| lpSecurityAttributes result |
	lpSecurityAttributes:: SECURITY_ATTRIBUTES newGC bInheritHandle: true.
	result:: self CreatePipe
		boolValue: readPipe address
		value: writePipe address
		value: lpSecurityAttributes address value: 0.
	result ifFalse: [^reportError].
	result:: self SetHandleInformation
		boolValue: readPipe
		value: 1
		value: 0.
	result ifFalse: [^reportError].
)
createPipeForWriting: writePipe <Alien> withChildPipe: readPipe <Alien> = (
	| lpSecurityAttributes result |
	lpSecurityAttributes:: SECURITY_ATTRIBUTES newGC bInheritHandle: true.
	result:: self CreatePipe
		boolValue: readPipe address
		value: writePipe address
		value: lpSecurityAttributes address value: 0.
	result ifFalse: [^reportError].
	result:: self SetHandleInformation
		boolValue: writePipe
		value: 1
		value: 0.
	result ifFalse: [^reportError].
)) : ('as yet unclassified'
usingPlatform: platform = (
	^self platform: platform
))