Newspeak3
'NS2JS'
class JavascriptGeneration usingPlatform: platform = (
(*Building blocks of Javascript syntax trees and a tree writer. The nodes are intended to represent Javascript code to be generated rather than the result of parsing an arbitrary Javascript program, so there is no provision for some ungood things such as the with statement.


   Copyright 2012 SAP AG.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0

*)|
	private List = platform collections OrderedCollection.
	private Dictionary = platform collections Dictionary.
	private WriteStream = platform streams CharacterReadWriteStream.

	syntax = Syntax new.
	factory = Factory new.
|)
(
class ASTComparator = ((*A tool to compare two JS syntax trees. The advantage over the #= operator is that the comparator is designed to retain the state of node traversal in case of a node mismatch. This makes it easy to see the nodes that caused the comparison to fail no matter how deep in the tree they were.

An instance is created using the #new factory method and can be reused to perform multiple comparisons. The comparison is then initiated by sending the #compare:and: message to the instance. The message returns true if the two trees are equal, false otherwise. After the #compare:and: message returned false, the instance can be inspected to see the nodes that caused the failure. The currentNode1 and currentNode2 slots contain the nodes found to be unequal. The path slot contains a path from the root of the first tree to currentNode1. The failureMessage slot contains a string with a description of the mismatch.*)|
	currentNode1 <Node>
	currentNode2 <Node>
	path = List new.
	failureMessage

	private failureBlock
|)
('accessing'
compare: node1 and: node2 ^<Boolean> = (
	failureBlock:: [^false].
	compareNode: node1 and: node2.
	^true.
)'as yet unclassified'
visitFunctionStatement: node = (
	visitFunctionExpression: node
)
visitTernaryOperatorExpression: node = (
	assertNodeIsExpected: node.
	compareNode: currentNode1 condition and: currentNode2 condition.
	compareNode: currentNode1 then and: currentNode2 then.
	compareNode: currentNode1 else and: currentNode2 else.
)
visitVerbatimNode: node = (
	assertNodeIsExpected: node.
	currentNode1 text = currentNode2 text ifFalse:
		[fail: 'verbatim text differs']
)'private'
assertNodeIsExpected: node = (
	assert: [node == currentNode1] message: 'internal ASTComparator error; node not tracked'.
)
compareList: list1 and: list2 sizeMismatchMessage: message <String>= (
	1 to: (list1 size min: list2 size) do:
		[:index | compareNode: (list1 at: index) and:  (list2 at: index)].
	list1 size = list2 size ifFalse: [fail: message]
)
compareNode: node1 <Node | nil> and: node2 <Node | nil> = (
	| oldCurrent1 oldCurrent2 |
	(node1 isNil and: [node2 isNil]) ifTrue: [^self].
	oldCurrent1:: currentNode1.
	currentNode1:: node1.
	oldCurrent2:: currentNode2.
	currentNode2:: node2.
	path addLast: node1.
	currentNode1 class = currentNode2 class ifFalse:
		[fail: 'nodes are instances of different classes'].
	node1 visitBy: self.
		(*The path and the current nodes are intentionally not restored in an ensure: block,
		to leave a record of the nodes that failed the comparison and the path leading up to them.*)
	path removeLast.
	currentNode1:: oldCurrent1.
	currentNode2:: oldCurrent2.
)
fail: message <String> = (
	failureMessage:: message.
	failureBlock value.
	error: 'the expression above is expected never to return'.
)'visiting'
visitArrayExpression: node = (
	assertNodeIsExpected: node.
	compareList: currentNode1 elements and: currentNode2 elements
		sizeMismatchMessage: 'number of array element differs'
)
visitAssignmentExpression: node = (
	assertNodeIsExpected: node.
	compareNode: currentNode1 leftHandSide and: currentNode2 leftHandSide.
	compareNode: currentNode2 rightHandSide and: currentNode2 rightHandSide.
)
visitBlock: node = (
	assertNodeIsExpected: node.
	compareList: currentNode1 statements and: currentNode2 statements
		sizeMismatchMessage: 'number of statements differs between the two blocks'
)
visitBooleanLiteral: node = (
	assertNodeIsExpected: node.
	currentNode1 value = currentNode2 value ifFalse:
		[fail: 'boolean literal values are different']
)
visitCallExpression: node = (
	assertNodeIsExpected: node.
	compareNode: currentNode1 function and: currentNode2 function.
	compareList: currentNode1 arguments and: currentNode2 arguments
		sizeMismatchMessage: 'argument list sizes do not match'.
)
visitForInStatement: node = (
	assertNodeIsExpected: node.
	currentNode1 varName = currentNode2 varName ifFalse:
		[fail: 'variable names are different'].
	compareNode: currentNode1 expression and: currentNode2 expression.
	compareNode: currentNode1 body and: currentNode2 body.
)
visitForStatement: node = (
	assertNodeIsExpected: node.
	compareNode: currentNode1 initExpression and: currentNode2 initExpression.
	compareNode: currentNode1 testExpression and: currentNode2 testExpression.
	compareNode: currentNode1 incrementExpression and: currentNode2 incrementExpression.
	compareNode: currentNode1 body and: currentNode2 body.
)
visitFunctionExpression: node = (
	assertNodeIsExpected: node.
	currentNode1 name = currentNode2 name ifFalse:
		[fail: 'function names are different'].
	currentNode2 parameters = currentNode2 parameters ifFalse:
		[fail: 'function parameters are different'].
	compareNode: currentNode1 body and: currentNode2 body
)
visitIdentifierExpression: node = (
	assertNodeIsExpected: node.
	currentNode1 name = currentNode2 name ifFalse:
		[fail: 'identifiers are different'].
)
visitIfStatement: node = (
	assertNodeIsExpected: node.
	compareNode: currentNode1 expression and: currentNode2 expression.
	compareNode: currentNode1 thenStatement and: currentNode2 thenStatement.
	compareNode: currentNode1 elseStatement and: currentNode2 elseStatement.	
)
visitIntegerLiteral: node = (
	assertNodeIsExpected: node.
	currentNode1 value = currentNode2 value ifFalse:
		[fail: 'integer literal values are different']
)
visitMemberExpression: node = (
	assertNodeIsExpected: node.
	compareNode: currentNode1 primary and: currentNode2 primary.
	compareNode: currentNode1 property and: currentNode2 property.
)
visitNewExpression: node = (
	assertNodeIsExpected: node.
	compareNode: currentNode1 expression and: currentNode2 expression.
	compareList: currentNode1 arguments and: currentNode2 arguments
		sizeMismatchMessage: 'argument list sizes do not match'.
)
visitObjectLiteral: node = (
	assertNodeIsExpected: node.
	currentNode1 slotNames = currentNode2 slotNames ifFalse:
		[fail: 'slot names are different in object literals'].
	compareList: currentNode1 slotValues and: currentNode2 slotValues
		sizeMismatchMessage: 'number of slot values differs between the object literals'
)
visitOperatorExpression: node = (
	assertNodeIsExpected: node.
	currentNode1 operatorName = currentNode2 operatorName ifFalse:
		[fail: 'operator names are different'].
	compareNode: currentNode1 left and: currentNode2 left.
	compareNode: currentNode1 right and: currentNode2 right.
)
visitReturnStatement: node = (
	assertNodeIsExpected: node.
	compareNode: currentNode1 expression and: currentNode2 expression.
)
visitScript: node = (
	assertNodeIsExpected: node.
	compareList: currentNode1 statements and: currentNode2 statements
		sizeMismatchMessage: 'number of statements differs between the two scripts'
)
visitStringLiteral: node = (
	assertNodeIsExpected: node.
	currentNode1 value = currentNode2 value ifFalse:
		[fail: 'string literals are different'].
)
visitThrowStatement: node = (
	assertNodeIsExpected: node.
	compareNode: currentNode1 expression and: currentNode2 expression.
)
visitTryStatement: node = (
	assertNodeIsExpected: node.
	compareNode: currentNode1 protectedBlock and: currentNode2 protectedBlock.
	currentNode1 catchVar = currentNode2 catchVar ifFalse:
		[fail: 'catch variable names are different'].
	compareNode: currentNode1 catchBlock and: currentNode2 catchBlock.
	compareNode: currentNode1 finallyBlock and: currentNode2 finallyBlock.
)
visitUnaryOperatorExpression: node = (
	assertNodeIsExpected: node.
	currentNode1 operatorName = currentNode2 operatorName ifFalse:
		[fail: 'operator names are different'].
	currentNode1 isPostfix = currentNode2 isPostfix ifFalse:
		[fail: 'one operator is prefix while the other is postfix'].
	compareNode: currentNode1 operand and: currentNode2 operand
)
visitVariableStatement: node = (
	assertNodeIsExpected: node.
	currentNode1 name = currentNode2 name ifFalse:
		[fail: 'variable names are different'].
	compareNode: currentNode1 initializer and: currentNode2 initializer
)) : ()
class Factory = ((*Provides a set of methods to build Javascript ASTs by writing expressions more readable than those that instantiate AST classes directly. An instance is held onto by the containing module as the slot named 'factory'. It's convenient to bind that instance in a user module to a slot with a short name such as 'js', to create Javascript ASTs with expressions like

js block: {js return: (js ident: 'self')}*)|
|)
('as yet unclassified'
array: elements <List[Node]> ^<ArrayExpression> = (
	elements do: [:each | assert: [each isJsNode] message: 'JS node expected'].
	^syntax ArrayExpression elements: elements
)
assign: lhs <Node> toBe: rhs <Node> ^<Node> = (
	assert: [lhs isJsNode] message: 'JS node expected on left'.
	assert: [rhs isJsNode] message: 'JS node expected on right'.
	^syntax AssignmentExpression leftHandSide: lhs rightHandSide: rhs
)
block: statements <List[Node]> ^<Node> = (
	statements do: [:each | assert: [each isJsNode] message:'Malformed statement tree'].
	^syntax Block statements: statements
)
call: expression <Node> with: arguments <List[Node]> = (
	^syntax CallExpression function: expression arguments: arguments
)
for: initExpr while: testExpr step: incExpr do: bodyStmt = (
	^syntax ForStatement
		initExpression: initExpr
		test: testExpr
		increment: incExpr
		body: bodyStmt
)
for: varName <String> in: expr <Node> do: bodyStmt <Node> = (
	| canonicalVarName |
	canonicalVarName:: varName isNil
		ifTrue: [varName]
		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].
	^syntax ForInStatement
		varName: canonicalVarName
		expression: expr
		body: bodyStmt
)
function: name <String> of: params body: body <Block> = (
	| canonicalName canonicalParams |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	canonicalParams:: params collect: [:each | each isString ifTrue: [ident: each]  ifFalse: [each]].
	^syntax FunctionStatement name: canonicalName parameters: canonicalParams body: body
)
functionOf: params body: body <Block> = (
	| paramIds |
	paramIds:: params collect: [:each | each isString ifTrue: [ident: each]  ifFalse: [each]].
	^syntax FunctionExpression name: nil parameters: paramIds body: body
)
ident: name <String> ^<Node> = (
	assert: [name isString] message: 'name must be a string'.
	^syntax IdentifierExpression name: name
)
if: expression <Node> then: then <Node> ^<Node> = (
	^syntax IfStatement expression: expression then: then else: nil
)
if: expression <Node> then: then <Node> else: else <Node> ^<Node> = (
	^syntax IfStatement expression: expression then: then else: else
)
literal: value <Boolean | Integer> ^<Node> = (
	value isString ifTrue: [^syntax StringLiteral value: value].
	value isNumber ifTrue: [^syntax IntegerLiteral value: value].
	(true = value or: [false = value]) ifTrue: [^syntax BooleanLiteral value: value].
	error: 'this value cannot be a Javascript literal'
)
new: expression <Node> with: args <List[Node]> ^<Node> = (
	^syntax NewExpression expression: expression arguments: args
)
objectLiteral = (
	^syntax ObjectLiteral new
)
objectLiteral: slots <List> = (
	slots keysAndValuesDo:
		[:index : element |
		assert: (index odd
			ifTrue: [[element isString]]
			ifFalse: [[element isJsNode]]) message: 'JS node or string expected'].
	^syntax ObjectLiteral slots: slots
)
objectLiteralSlotNames: names <List[String]> values: values <List[Node]>= (
	^syntax ObjectLiteral slotNames: names values: values
)
operator: name <String> with: left <Node> and: right <Node> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	assert: [left isJsNode] message: 'JS node expected on left'.
	assert: [right isJsNode] message: 'JS node expected on right'.
	^syntax OperatorExpression operator: canonicalName with: left and: right
)
postfixOperator: name <String> on: operand <Node> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax UnaryOperatorExpression operator: canonicalName postfix: true on: operand
)
prefixOperator: name <String> on: operand <Node> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax UnaryOperatorExpression operator: canonicalName postfix: false on: operand
)
propertyOf: expression <Node> at: indexExpr <Node> = (
	assert: [expression isJsNode] message: 'JS node expected'.
	assert: [indexExpr isJsNode] message: 'JS node expected for index expression'.
	^syntax MemberExpression primary: expression property: indexExpr
)
propertyOf: expression <Node> atPath: path <List[Node]> = (
	assert: [expression isJsNode] message: 'JS node expected'.
	^path isEmpty
		ifTrue: [expression]
		ifFalse:
			[propertyOf: (propertyOf: expression at: path first)
				atPath: (path copyFrom: 2 to: path size)]
)
return = (
	^syntax ReturnStatement expression: nil
)
return: expression <Node | nil> = (
	^syntax ReturnStatement expression: expression
)
script: statements <List[Node]> = (
	^syntax Script statements: statements
)
ternaryIf: condition then: then else: else = (
	^syntax TernaryOperatorExpression
		if: condition
		then: then
		else: else
)
throw: expression <Node> ^<Node> = (
	^syntax ThrowStatement expression: expression
)
try: block <Block> catch: varName <String> with: catchBlock <Block> = (
	| canonicalVarName |
	canonicalVarName:: varName isNil
		ifTrue: [varName]
		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].
	^syntax TryStatement block: block catch: canonicalVarName with: catchBlock finally: nil
)
try: block <Block> catch: varName <String> with: catchBlock <Block> finally: finallyBlock <Block>= (
	| canonicalVarName |
	canonicalVarName:: varName isNil
		ifTrue: [varName]
		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].
	^syntax TryStatement block: block catch: canonicalVarName with: catchBlock finally: finallyBlock
)
try: block <Block> finally: finallyBlock <Block>= (
	^syntax TryStatement block: block catch: nil with: nil finally: finallyBlock
)
var: name <String> ^<VariableStatement> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax VariableStatement name: canonicalName initializer: nil
)
var: name <String> value: expr <Node> ^<VariableStatement> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax VariableStatement name: canonicalName initializer: expr
)
verbatim: text <String> = (
	 assert:[text isString] message: 'String expected'.
	^syntax VerbatimNode text: text
)) : ()
class IdentifierRewriter replacing: id1 <String> with: id2 <String> = TreeRewriter (
(*Rewrites the tree replacing id1 with id2.*)|
	lookFor = id1.
	replaceWith = id2.
|)
('as yet unclassified'
visitIdentifierExpression: node = (
	^node name = lookFor
		ifTrue: [factory ident: replaceWith]
		ifFalse: [node]
)) : ()
class ReturnedExpressionExtractor = TreeRewriter (
(*Traverses the tree looking for a return statement. When found, returns its expression.*)|
	returnResultBlock
|)
('as yet unclassified'
rewrite: tree = (
	returnResultBlock: [:result | ^result].
	super rewrite: tree.
	^nil
)
visitReturnStatement: node = (
	returnResultBlock value: node expression
)) : ()
class Syntax = (
(*The AST nodes. The preferred way to construct instances is to use the factory object (an instance of Factory, a sibling of this class) held onto by the module.*)| |)
(
class ArrayExpression elements: elements = Node (
(*An array constructor expression.*)|
	protected elements_ = elements.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [elements = anotherNode elements]
)
elements = (
	^elements_
)
visitBy: visitor = (
	^visitor visitArrayExpression: self
)) : ()
class AssignmentExpression leftHandSide: lhs rightHandSide: rhs = Node (|
	leftHandSide <Expression> = lhs.
	rightHandSide <Expression> = rhs.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode 
		and: [leftHandSide = anotherNode leftHandSide
			and: [rightHandSide = anotherNode rightHandSide]]	
)
isOperatorExpression = (
	^true
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	leftHandSide printOn: stream.
	stream nextPutAll: ', '.
	rightHandSide printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitAssignmentExpression: self
)) : ('as yet unclassified'
var: name <String> to: expr <Expression> = (
	^AssignmentExpression
		leftHandSide: (IdentifierExpression name: name)
		rightHandSide: expr
))
class Block statements: s = Node (
(*Block; ECMA-262 p. 220.*)|
	statementsS <List[Statement | Expression]> = s.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [statements = anotherNode statements]
)
asBlock = (
	^self
)
isBlockStatement = (
	^true
)
statements = (
	^statementsS
)
visitBy: visitor = (
	^visitor visitBlock: self
)
visitStatementsBy: visitor = (
	| result |
	statements do: [:each | result:: each visitBy: visitor].
	^result
)) : ('as yet unclassified'
empty = (
	^Block statements: {}
))
class BooleanLiteral value: b <Boolean> = Node (|
	valueS = b.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [value = anotherNode value]
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	value printOn: stream.
	stream nextPutAll: ')'
)
value = (
	^valueS
)
visitBy: visitor = (
	^visitor visitBooleanLiteral: self
)) : ()
class CallExpression function: f arguments: args = Node (
(*expression ( arguments )*)|
	function <Expression> = f.
	arguments <List[Expression]> = args.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[function = anotherNode function and: [arguments = anotherNode arguments]]
)
isCallExpression = (
	^true
)
visitBy: visitor = (
	^visitor visitCallExpression: self
)) : ()
class ForInStatement varName: name <IdentifierExpression> expression: expr body: body = Node (|
	varName = name.
	expression = expr.
	body = body.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[varName = anotherNode varName and:
		[expression = anotherNode expression and:
		[body = anotherNode body]]]
)
visitBy: visitor = (
	^visitor visitForInStatement: self
)) : ()
class ForStatement initExpression: initExpr test: testExpr increment: incExpr body: body = Node (|
	initExpression = initExpr.
	testExpression = testExpr.
	incrementExpression = incExpr.
	body = body.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[initExpression = anotherNode initExpression and:
		[testExpression = anotherNode testExpression and:
		[incrementExpression = anotherNode incrementExpression and:
		[body = anotherNode body]]]]
)
visitBy: visitor = (
	^visitor visitForStatement: self
)) : ()
class FunctionExpression name: s <IdentifierExpression | nil> parameters: names <List[IdentifierExpression]> body: b = Node (
(*FunctionExpression. ECMA-262, p. 262.*)|
	name <IdentifierExpression | nil> = s.
	parameters <List[IdentifierExpression]> = names.
	body <Block> = b asBlock.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[name = anotherNode name and:
		[parameters = anotherNode parameters and:
		[body = anotherNode body]]]
)
visitBy: visitor = (
	^visitor visitFunctionExpression: self
)) : ('as yet unclassified'
parameters: names <List[IdentifierExpression]> body: b <Node> = (
	^FunctionExpression name: nil parameters: names body: b
))
class FunctionStatement name: s parameters: names body: b = FunctionExpression name: s parameters: names body: b (
(*A function statement. Essentially the same thing as a function expression, but needs to be written out differently. Note that unlike in a function expression, the name argument is not optional. TODO: should we move name up to this class and make function expressions anonymous? What does the standard say?*)|
|)
('as yet unclassified'
visitBy: visitor = (
	^visitor visitFunctionStatement: self
)) : ()
class IdentifierExpression name: s <String> = Node (
(*a case of PrimaryExpression*)|
	nameS = s.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [name = anotherNode name]
)
isIdentifier = (
	^true
)
name = (
	^nameS
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	stream nextPutAll: name.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitIdentifierExpression: self
)) : ()
class IfStatement expression: expr then: then else: else = Node (
(*if ( expression ) thenStatement else elseStatement*)|
	expression = expr.
	thenStatement = then.
	elseStatement = else.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[expression = anotherNode expression and:
		[thenStatement = anotherNode thenStatement and:
		[elseStatement = anotherNode elseStatement]]]
)
visitBy: visitor = (
	^visitor visitIfStatement: self
)) : ('as yet unclassified'
expression: expr then: then = (
	^IfStatement expression: expr then: then else: nil
))
class IntegerLiteral value: v <Integer> = Node (|
	valueS = v.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[value = anotherNode value]
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	value printOn: stream.
	stream nextPutAll: ')'
)
value = (
	^valueS
)
visitBy: visitor = (
	^visitor visitIntegerLiteral: self
)) : ()
class MemberExpression primary: expr <Expression> property: p <Node> = Node (
(*primary[property]*)|
	primary = expr.
	property = p.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[primary = anotherNode primary and:
		[property = anotherNode property]]
)
isMemberExpression = (
	^true
)
visitBy: visitor = (
	^visitor visitMemberExpression: self
)) : ()
class NewExpression expression: expr arguments: args = Node (
(*new expr ( arg, .... )*)|
	expression = expr.
	arguments = args.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[expression = anotherNode expression and:
		[arguments = anotherNode arguments]]
)
visitBy: visitor = (
	^visitor visitNewExpression: self
)) : ()
class Node = (
(*The superclass of all other nodes, both statements and expressions.*)|
	comment <String>
|)
('as yet unclassified'
= anotherNode = (
	^class = anotherNode class
)
asBlock = (
	^Block statements: {self}
)
isBlockStatement = (
	^false
)
isCallExpression = (
	^false
)
isIdentifier = (
	^false
)
isJsNode = (
	^true
)
isMemberExpression = (
	^false
)
isOperatorExpression = (
	^false
)) : ()
class ObjectLiteral = Node (
(*Object literal. ECMA-262, p. 216.*)|
	slotNames = List new.
	slotValues = List new.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[slotNames = anotherNode slotNames and:
		[slotValues = anotherNode slotValues]]
)
addSlot: name <String> value: object = (
	slotNames addLast: name.
	slotValues addLast: object
)
slotCount = (
	^slotNames size
)
slotsDo: aBlock = (
	(*Invoke a two-argument aBlock with the name and the value of each slot in this literal.*)
	^slotNames with: slotValues do: aBlock
)
slotsDo: aBlock betweenDo: betweenBlock = (
	(*Invoke a two-argument aBlock with the name and the value of each slot in this literal. Between the invocations (but not after the last one), invoke the betweenBlock.*)
	| lastIndex |
	lastIndex:: slotNames size.
	1 to: lastIndex do:
		[:index |
		aBlock value: (slotNames at: index) value: (slotValues at: index).
		index = lastIndex ifFalse: [betweenBlock value]]
)
visitBy: visitor = (
	^visitor visitObjectLiteral: self
)) : ('as yet unclassified'
slotNames: names values: values = (
	| instance |
	instance:: ObjectLiteral new.
	names with: values do:
		[:eachName :eachValue |
		instance addSlot: eachName value: eachValue].
	^instance
)
slots: namesAndValues = (
	| instance |
	namesAndValues size odd ifTrue: [error: 'invalid slot initialization data'].
	instance:: ObjectLiteral new.
	1 to: namesAndValues size by: 2 do:
		[:i |
		instance addSlot: (namesAndValues at: i) value: (namesAndValues at: i + 1)].
	^instance
))
class OperatorExpression operator: name <String> with: left <Node> and: right <Node> = Node (|
	operatorName = name.
	left = left.
	right = right.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[operatorName = anotherNode operatorName and:
		[left = anotherNode left and:
		[right = anotherNode right]]]
)
isOperatorExpression = (
	^true
)
visitBy: visitor = (
	^visitor visitOperatorExpression: self
)) : ()
class ReturnStatement expression: expr = Node (
(*return expression/opt.*)|
	expressionS = expr.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [expression = anotherNode expression]
)
expression = (
	^expressionS
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	expression printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitReturnStatement: self
)) : ('as yet unclassified'
noValue = (
	^ReturnStatement expression: nil
))
class Script statements: statements <List[Node]> = Node (
(*A series of statements, a top-level node to hold them together.*)|
	statements_ = statements.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [statements = anotherNode statements]
)
statements ^<List[Node]> = (
	^statements_
)
visitBy: visitor = (
	^visitor visitScript: self
)) : ()
class StringLiteral value: string <String> = Node (|
	valueS = string.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[value = anotherNode value]
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	value printOn: stream.
	stream nextPutAll: ')'
)
value = (
	^valueS
)
visitBy: visitor = (
	^visitor visitStringLiteral: self
)) : ()
class TernaryOperatorExpression if: condExpr then: thenExpr else: elseExpr = Node (|
	protected condition = condExpr.
	protected then = thenExpr.
	protected else = elseExpr.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[condition = anotherNode condition and:
		[then = anotherNode then and:
		[else = anotherNode else]]]
)
visitBy: visitor = (
	^visitor visitTernaryOperatorExpression: self
)) : ()
class ThrowStatement expression: expr = Node (|
	expressionS = expr.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [expression = anotherNode expression]
)
expression = (
	^expressionS
)
visitBy: visitor = (
	^visitor visitThrowStatement: self
)) : ()
class TryStatement block: pb <Block> catch: cvar <IdentifierExpression | nil> with: cb <Block | nil> finally: fb <Block | nil> = Node (
(*ECMA-262 p. 222*)|
	protectedBlock = pb.
	catchVar = cvar.
	catchBlock = cb.
	finallyBlock = fb.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[protectedBlock = anotherNode protectedBlock and:
		[catchVar = anotherNode catchVar and:
		[catchBlock = anotherNode catchBlock and:
		[finallyBlock = anotherNode finallyBlock]]]]
)
visitBy: visitor = (
	^visitor visitTryStatement: self
)) : ('as yet unclassified'
block: pb catch: cvar with: cb = (
	^TryStatement block: pb catch: cvar with: cb finally: nil
))
class UnaryOperatorExpression operator: name <String> postfix: postfix <Boolean> on: node <Node> = Node (
(*A unary operator application, either prefix or postfix.*)|
	operatorName <String> = name.
	isPostfix <Boolean> = postfix.
	operand <Node> = node.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[operatorName = anotherNode operatorName and:
		[isPostfix = anotherNode isPostfix and:
		[operand = anotherNode operand]]]
)
visitBy: visitor = (
	^visitor visitUnaryOperatorExpression: self
)) : ()
class VariableStatement name: n <IdentifierExpression> initializer: expr <Expression> = Node (
(*var name [= expression]*)|
	name = n.
	initializer = expr.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[name = anotherNode name and:
		[initializer = anotherNode initializer]]
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	name printOn: stream.
	stream nextPutAll: ', '.
	initializer printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitVariableStatement: self
)) : ('as yet unclassified'
name: s = (
	^VariableStatement name: s initializer: nil
))
class VerbatimNode text: s <String> = Node (
(*A node holding onto arbitrary text, to be emitted verbatim into the generated Javascript source. Nothing but the text is emitted, however the context may insert additional tokens before or after the text. For example if a verbatim node appears as a statement in a block, it will have a terminating semicolon.*)|
	text = s.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [text = anotherNode text]
)
visitBy: visitor = (
	^visitor visitVerbatimNode: self
)) : ()) : ()
class TreeRewriter = (
(*A tree visitor that accepts a JS syntax tree and rewrites it to another one. This class makes no rewriting as such other than reinstantiating all the nodes it visits. In other words, it is a tree copier.*)|
|)
('as yet unclassified'
rewrite: tree <Node> ^<Node> = (
(*The access point, use this to start rewriting.*)
	^tree visitBy: self
)
visitArrayExpression: node = (
	^factory array: (node elements collect: [:each | each visitBy: self])
)
visitAssignmentExpression: node = (
	^factory
		assign: (node leftHandSide visitBy: self)
		toBe: (node rightHandSide visitBy: self)
)
visitBlock: node = (
	^factory block: (node statements collect: [:each | each visitBy: self])
)
visitBooleanLiteral: node = (
	^factory literal: node value
)
visitCallExpression: node = (
	^factory call: (node function visitBy: self)
		with: (node arguments collect: [:each | each visitBy: self])
)
visitForInStatement: node = (
	^factory
		for: (node varName visitBy: self)
		in: (node expression visitBy: self)
		do: (node body visitBy: self)
)
visitForStatement: node = (
	^factory
		for: (node initExpression visitBy: self)
		while: (node testExpression visitBy: self)
		step: (node incrementExpression visitBy: self)
		do: (node body visitBy: self)
)
visitFunctionExpression: node = (
	^factory
		functionOf: node parameters
		body: (node body visitBy: self)
)
visitFunctionStatement: node = (
	^factory
		function: (node name visitBy: self)
		of: (node parameters collect: [:each | each visitBy: self])
		body: (node body visitBy: self)
)
visitIdentifierExpression: node = (
	^factory ident: node name
)
visitIfStatement: node = (
	^factory
		if: (node expression visitBy: self)
		then: (node thenStatement visitBy: self)
		else: (node elseStatement ifNotNil: [:it | it visitBy: self])
)
visitIntegerLiteral: node = (
	^factory literal: node value
)
visitMemberExpression: node = (
	^factory
		propertyOf: (node primary visitBy: self)
		at: (node property visitBy: self)
)
visitNewExpression: node = (
	^factory
		new: (node expression visitBy: self)
		with: (node arguments collect: [:each | each visitBy: self])
)
visitObjectLiteral: node = (
	^factory
		objectLiteralSlotNames: node slotNames
		values: (node slotValues collect: [:each | each visitBy: self])
)
visitOperatorExpression: node = (
	^factory operator: (node operatorName visitBy: self)
		with: (node left visitBy: self)
		and: (node right visitBy: self)
)
visitReturnStatement: node = (
	^factory return: (node expression ifNotNil: [:it | it visitBy: self])
)
visitScript: node = (
	^factory script: (node statements collect: [:each | each visitBy: self])
)
visitStringLiteral: node = (
	^factory literal: node value
)
visitTernaryOperatorExpression: node = (
	^factory
		ternaryIf: (node condition visitBy: self)
		then: (node then visitBy: self)
		else: (node else visitBy: self)
)
visitThrowStatement: node = (
	^factory throw: (node expression visitBy: self)
)
visitTryStatement: node = (
	^factory
		try: (node protectedBlock visitBy: self)
		catch: (node catchVar visitBy: self)
		with: (node catchBlock ifNotNil: [:it | it visitBy: self])
		finally: (node finallyBlock ifNotNil: [:it | it visitBy: self])
)
visitUnaryOperatorExpression: node = (
	^node isPostfix
		ifTrue:
			[factory postfixOperator: (node operatorName visitBy: self)
				on: (node operand visitBy: self)]
		ifFalse:
			[factory prefixOperator: (node operatorName visitBy: self)
				on: (node operand visitBy: self)]			
)
visitVariableStatement: node = (
	^factory var: (node name visitBy: self) value: (node initializer ifNotNil: [:it | it visitBy: self])
)
visitVerbatimNode: node = (
	^factory verbatim: node text
)) : ()
class Writer = (
(*Writes out a tree of Javascript syntax elements.*)|
	private output <WriteStream>
	private tabLevel <Integer>
	private stringTranslation = Dictionary new.
|stringTranslation at: $\ put: '\\'.
	stringTranslation at: Character cr put: '\r'.
	stringTranslation at: Character lf put: '\n'.
	stringTranslation at:  $" put: '\"')
('accessing'
contents ^<String> = (
	(*Answer the Javascript source generated last.*)
	^output contents
)
generateSourceFor: node <Node> ^<String> = (
	(*Generate and answer Javascript source to represent node. Any previously generated output is lost.*)
	generateSourceFor: node on: (WriteStream on: (String new: 100)).
	^contents
)'as yet unclassified'
generateSourceFor: node <Node> on: stream <WriteStream> = (
	(*Generate Javascript source to represent the node, writing it out to the stream.*)
	beginNewWriteCycleUsing: stream.
	node visitBy: self.
)
visitArrayExpression: node <ArrayExpression> = (
	| elements |
	elements: node elements.
	elements isEmpty ifTrue:
		[^write: '[]'].
	elements size = 1 ifTrue:
		[write: '['.
		elements first visitBy: self.
		^write: ']'].
	write: '['.
	indentCr.
	elements
		do:
			[:each | each visitBy: self]
		separatedBy:
			[write: ','.
			cr].
	unindentCr.
	write: ']'
)
visitForInStatement: node = (
	write: 'for ('.
	node varName visitBy: self.
	write: ' in '.
	node expression visitBy: self.
	write: ') '.
	node body asBlock visitBy: self.
)
visitForStatement: node = (
	write: 'for ('.
	node initExpression visitBy: self.
	write: '; '.
	node testExpression visitBy: self.
	write: '; '.
	node incrementExpression visitBy: self.
	write: ') '.
	node body asBlock visitBy: self.
)
visitFunctionStatement: node <FunctionStatement> = (
	write: 'function '.
	node name ifNotNil:
		[:name | 
		name visitBy: self.
		write: ' '].
	write: '('.
	node parameters
		do: [:each | each visitBy: self]
		separatedBy: [write: ', '].
	write: ') '.
	writeBlock: node body.
)
visitOperatorExpression: node <OperatorExpression> = (
	| parenthesizeLeft parenthesizeRight |
	parenthesizeLeft:: node left isOperatorExpression.
	parenthesizeRight:: node right isOperatorExpression.
	parenthesizeLeft ifTrue: [write: '('].
	node left visitBy: self.
	parenthesizeLeft ifTrue: [write: ') '] ifFalse: [write: ' '].
	node operatorName visitBy: self.
	parenthesizeRight ifTrue: [write: ' ('] ifFalse: [write: ' '].
	node right visitBy: self.
	parenthesizeRight ifTrue: [write: ')']
)
visitScript: node <Script> = (
	node statements
		do:
			[:each |
			each visitBy: self.
			write: ';']
		separatedBy:
			[cr.
			cr].
)
visitStringLiteral: node <StringLiteral> = (

	write: '"'.
	node value do:
		[:each | | s |
		s:: stringTranslation
			at: each
			ifAbsent: [{each}].
		write: s].
	write: '"'
)
visitTernaryOperatorExpression: node = (
	write: '('.
	node condition visitBy: self.
	write: ' ? '.
	node then visitBy: self.
	write: ' : '.
	node else visitBy: self.
	write: ')'
)
visitThrowStatement: node <ThrowStatement> = (
	write: 'throw '.
	node expression visitBy: self
)
visitUnaryOperatorExpression: node <UnaryOperatorExpression> = (
	| isPostfix isOnOperator |
	isPostfix:: node isPostfix.
	isOnOperator:: node operand isOperatorExpression.
	isPostfix ifFalse: [node operatorName visitBy: self].
	isOnOperator ifTrue: [write: '(']. (*not always necessary, but safer*)
	node operand visitBy: self.
	isOnOperator ifTrue: [write: ')'].
	isPostfix ifTrue: [node operatorName visitBy: self].
)
visitVerbatimNode: node = (
	write: node text
)'double dispatch'
visitAssignmentExpression: node <AssignmentExpression> = (
	node leftHandSide visitBy: self.
	write: ' = '.
	node rightHandSide visitBy: self.
)
visitBlock: node <Block> = (
	| statements |
	statements: node statements.
	statements isEmpty ifTrue:
		[^write: '{}'].
	write: '{'.
	indentCr.
	statements
		do:
			[:each |
			each visitBy: self.
			write: ';']
		separatedBy:
			[cr].
	unindentCr.
	write: '}'
)
visitBooleanLiteral: node <BooleanLiteral> = (
	write:: node value ifTrue: ['true'] ifFalse: ['false']
)
visitCallExpression: node <CallExpression> = (
	node function visitBy: self.
	write: '('.
	node arguments
		do:
			[:arg |
			arg visitBy: self]
		separatedBy:
			[write: ', '].
	write: ')'
)
visitFunctionExpression: node <FunctionExpression> = (
	write: '('.
	visitFunctionStatement: node.
	write: ')'
)
visitIdentifierExpression: node <IdentifierExpression> = (
	write: node name
)
visitIfStatement: node <IfStatement> = (
	write: 'if ('.
	node expression visitBy: self.
	write: ') '.
	writeBlock: node thenStatement asBlock.
	node elseStatement ifNotNil:
		[:else |
		write: ' else '.
		writeBlock: node elseStatement asBlock]
)
visitIntegerLiteral: node <IntegerLiteral> = (
	write: node value printString
)
visitMemberExpression: node <MemberExpression> = (
	| parenthesize |
	parenthesize::
		(node primary isIdentifier 
		or: [node primary isMemberExpression
		or: [node primary isCallExpression]]) not.
	parenthesize ifTrue: [write: '('].
	node primary visitBy: self.
	parenthesize ifTrue: [write: ')'].
	write: '['.
	node property visitBy: self.
	write: ']'
)
visitNewExpression: node <NewExpression> = (
	write: 'new '.
	node expression visitBy: self.
	write: '('.
	node arguments
		do:
			[:arg |
			arg visitBy: self]
		separatedBy:
			[write: ', '].
	write: ')'
)
visitObjectLiteral: node <ObjectLiteral> = (
	node slotCount = 0 ifTrue: 
		[write: '{}'.
		^self].
	write: '{'.
	indentCr.
	node
		slotsDo:
			[:name :value |
			| nameIsQuoted |
			(*Fancy slot names can be pre-quoted.*)
			nameIsQuoted:: name first = $'.
			nameIsQuoted ifFalse: [write: ''''].
			write: name.
			nameIsQuoted ifFalse: [write: ''''].
			write: ': '.
			value visitBy: self]
		betweenDo:
			[write: ','.
			cr].
	unindentCr.
	write: '}'
)
visitReturnStatement: node <ReturnStatement> = (
	write: 'return'.
	node expression ifNotNil:
		[:expr |
		write: ' '.
		expr visitBy: self]
)
visitTryStatement: node <TryStatement> = (
	write: 'try '.
	writeBlock: node protectedBlock.
	node catchBlock ifNotNil:
		[:catch |
		write: ' catch ('.
		node catchVar visitBy: self.
		write: ') '.
		writeBlock: catch].
	node finallyBlock ifNotNil:
		[:finally |
		write: ' finally '.
		writeBlock: finally]
)
visitVariableStatement: node <VariableStatement> = (
	write: 'var '.
	node name visitBy: self.
	node initializer ifNotNil:
		[:expr |
		write: ' = '.
		expr visitBy: self].
)'private'
beginNewWriteCycleUsing: stream <WriteStream> = (
	output:: stream.
	tabLevel:: 0.
)
cr = (
	(*Write a newline and the next line's indentation.*)
	output cr.
	tabLevel timesRepeat: [output tab]
)
inIndentedBlock: closure = (
	write: '{'.
	indentCr.
	^closure ensure: 
		[unindentCr.
		write: '}']
)
indentCr = (
	tabLevel: tabLevel + 1.
	cr
)
isJsIdentifier: name <String> = (
	^(name allSatisfy: [:c | c isLetter or: [c isDigit or: [c = $_]]])
		and: [name first isLetter or: [name first = $_]]
)
unindentCr = (
	tabLevel:: 0 max: tabLevel - 1.
	cr
)
write: text <String> = (
	output nextPutAll: text
)
writeBlock: block = (
	| statements |
	statements: block statements.
	statements isEmpty
		ifTrue: [write: '{}']
		ifFalse:
			[inIndentedBlock:
				[statements
					do: 
						[:each |
						each visitBy: self.
						write: ';']
					separatedBy:
						[cr]]]
)) : ()) : ()