Newspeak3
'HopscotchIDE'
class NewspeakBrowsing usingPlatform: p ide: ide = ((*
Class browsing for NS3 using new mirrors.

It would be nice to additionally support:
	
	editing a class header to a different name makes a copy a la the classic browser
	pull a nested class up as a sibling of its parent
	push a nested class down into one of its siblings
	
	auto-initialization of new slots in existing instances
	(but if it depends on a factory argument, what can we do?)
	
	senders/implementors restricted to the same module?
*)|
	private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	private ObjectMirror = p mirrors ObjectMirror.
	private Color = p hopscotch Color.
	private Duct = p ducts Duct.
	private EditableLinePresenter = p hopscotch fragments EditableLinePresenter.
	private HopscotchImages = p hopscotch HopscotchImages.
	private MixinBuilder = p mirrors MixinBuilder.
	private OrderedCollection = p collections OrderedCollection.
	private Set = p collections Set.
	private Subject = p hopscotch core Subject.

	private cachedPlatform = p.

	ide = ide.
        systemScope = ide systemScope.
	private AssortedMethodsPresenter = ide browsing AssortedMethodsPresenter.
	private AssortedMethodsSubject = ide browsing AssortedMethodsSubject.
	private ClassCommentPresenter = ide browsingMisc ClassCommentPresenter.
	private CodeEditorFragment = ide tools CodeEditorFragment.
	private DefinitionListPresenter = ide tools DefinitionListPresenter.
	private DefinitionTemplate = ide tools DefinitionTemplate.
	private DeletedClassSubject = ide browsingMisc DeletedClassSubject.
	private EditableNSClassNamePresenter = ide browsing EditableNSClassNamePresenter.
	private ExpandableMethodPresenter = ide browsing ExpandableMethodPresenter.
	private NS3Colorizer = ide newspeakColorization NS3BrowserColorizer.
	private ProgrammingPresenter = ide tools ProgrammingPresenter.
	private SelectorSubject = ide browsing SelectorSubject.
	private MethodSubject = ide browsing MethodSubject.
	private ClassSubject = ide browsing ClassSubject.
	private MethodInheritanceSubject = ide browsingST MethodInheritanceSubject.

	private languageUiDescriptionRegistry = ide languageUiDescriptionRegistry.
	private minitestUI = ide minitestUI.
	private minitest = ide minitest.
	private finalizer = ide finalizer.
	private Root = ide namespacing Root.
	
	private Deployment = p squeak Deployment.
	private ExternalLauncher = p squeak ExternalLauncher.
	private FileStream = p squeak FileStream.
	private Language = p squeak Language.
	private MethodContext = p squeak MethodContext.
	private OSProcess = p squeak OSProcess.
	private PackageOrganizer = p squeak PackageOrganizer.
	private Smalltalk = p squeak Smalltalk.
	private SystemOrganization = p squeak SystemOrganization.
	private UIManager = p squeak UIManager.
	private VMMirror = p squeak VMMirror.
|) (
class AbstractClassPresenter onSubject: s = ProgrammingPresenter onSubject: s ((* Common behavior for presenting a Newspeak class. *)|
	classNamePresenter
	descriptionOrSourceSwitchHolder
	descriptionOrSourceSwitcherHolder
	descriptionOrSourceHolder
	summaryOrEditor
|) (
'accessing'
extraInformationMetapresenter = (
	| enclosingClasses |
	enclosingClasses:: subject enclosingClasses.
	^enclosingClasses isEmpty
		ifTrue: [nothing]
		ifFalse:
			[ | labelStream |
			labelStream:: (String new: 50) writeStream.
			enclosingClasses do:
				[:each |
				labelStream
					nextPutAll: ' in ';
					nextPutAll: each simpleName].
			(label: labelStream contents) color: (Color gray: 0.5)]
)
icon = (
	^subject classUiDescription classIcon
)
nestingInformationLine = (
	| enclosingClasses |
	enclosingClasses:: subject enclosingClasses.
	^enclosingClasses isEmpty
		ifTrue: [label: 'top level class']
		ifFalse:
			[ | rowElements |
			rowElements:: OrderedCollection new.

			enclosingClasses do:
				[:each |
				rowElements add: (label: ' in ').
				rowElements add: (linkToBrowseEnclosingClass: each)].
			row: rowElements asArray]
)
'actions'
acceptClassDefinition: editor = (
	(* This class's definition has been changed in the definition editor. *)

	^majorUpdate:
		[[subject acceptClassDefinition: editor textBeingAccepted] 
			on: Error
			do: [:ex | editor showMessage: ex description. false]]
)
classActionsMenu = (

	^menuWithLabelsAndActions: {
		'Save to File' -> [respondToSave].
		#separator.
		'Inspect Mixin' -> [inspect: subject implementationClass].
		'Inspect Mirror' -> [inspect: subject classMirror].
		#separator.
		'Inspect Instances' -> [enterSubject: subject instancesSubject].
		'Inspect Subinstances' -> [enterSubject: subject subInstancesSubject].
		#separator.
		'Copy' -> [respondToCopy].
		'Move up' -> [respondToMoveUp].
		'Move down' -> [respondToMoveDown].
		#separator.
		'Delete' -> [respondToDelete].
		#separator.
		'Inspect Presenter' -> [respondToInspectPresenter]}
)
respondToDelete = (
	| deletedName |
	deletedName:: subject deleteClass.
	requestPresentationChange: 
		(DeletedClassSubject onModel: deletedName) presenter.
)
respondToMoveDown = (
(* Refactoring: move class to a nested class of its enclosing class *)
halt. (* Not yet implemented *)
)
respondToSave = (

	subject implementationClass
		ifNotNil: [:iclass | iclass printClass]
		ifNil: [error: 'no class; is this reasonable?']
)
'as yet unclassified'
accessModifierLabel = (
	^ (label: subject accessModifier) tinyFont
)
addOutlineItemsTo: parentItem = (
| selfItem |
selfItem:: (OutlineItem onModel: self)
	text: subject className;
	image: icon.
substance addOutlineItemsTo: selfItem.
parentItem addChild: selfItem
)
browseClassCategory: categoryName <Symbol> = (
	ide defaultPopularityRecord
		rememberCategoryVisit: categoryName.

	enterSubject:: ide browsingMisc NamespaceSubject
		onModel: (ide namespacing categoryNamespace: categoryName)
		key: categoryName.
)
browseNSClassReferences: className = (

	sendUp navigatorDo:
		[:shell | shell enterSubject: (ClassReferencesSubject onModel: className)]
)
classDescriptionDefinition = (
	^subclassResponsibility
)
classSourceDefinition = (
(*  ^InitializerMethodPresenter onSubject: subject initializer*)
	| editor init <InitializerMethodSubject> |
	(* init:: subject initializer.
	init isNil ifFalse:[
		(init methodMirror reflectee properties includesKey:#debugInfo) 
		ifFalse:[subject acceptClassDefinition: init source]. 
		(* temp hack until all are recompiled *)
		^init createPresenter expand; yourself.
		(*^(InitializerMethodPresenter onSubject: subject initializer) expand; yourself*)
	].*)
	^column: {	
		editor:: CodeEditorFragment new
			text: subject classHeaderSource;
			colorizerBlock: [ :text | subject colorizeSource: text, '()'];
			acceptResponse: 
					[(acceptClassDefinition: editor)	
						ifTrue: [editor defaultAcceptResponse]].
	}
)
collapsedHeadingDefinition = (
	(* Second level of the class header block, contained inside #headingDefinition. *)
	^column: {
		smallBlank.
		row:
			{image: icon.
			smallBlank.
			link: subject className asText allBold
				action: [browseClassMirror: subject classMirror].
			filler.
			itemReferencesButtonWithAction:
				[browseNSClassReferences: subject className].
			smallBlank.
			dropDownMenu: [classActionsMenu].
			}.
			smallBlank
		}
)
expandedHeadingDefinition = (
	(* Second level of the class header block, contained inside #headingDefinition. Defines the floating header block including the class name, containing classes, category and package, and the description/source switcher. *)
	^(column: {
		smallBlank.
		classNameAndContainmentDefinition.
		blank: 15.
		descriptionOrSourceSwitcherHolder:: holder: (switcherShowingSource: false).
		(row: {}) width: 1; color: (Color gray: 0.8).
		mediumBlank.
		descriptionOrSourceHolder:: holder: classDescriptionDefinition
	})
)
expandedHeadingDefinitionWithFloatingHeader = (
	(* UNUSED, but saving it for the time being as an experiment. *)
	(* Second level of the class header block, contained inside #headingDefinition. Defines the floating header block including the class name, containing classes, category and package, and the description/source switcher. *)
	^floatingHeader:	
		((column: {
			smallBlank.
			classNameAndContainmentDefinition.
			blank: 15.
			descriptionOrSourceSwitcherHolder::
				holder: (switcherShowingSource: false).	
			(row: {}) width: 1; color: (Color h: 240 s: 0.05 v: 0.8).
		}) color: (Color h: 240 s: 0.05 v: 0.9))
	body:
		(column: {
			smallBlank.
			descriptionOrSourceHolder:: holder: classDescriptionDefinition
		})
)
linkToBrowseEnclosingClass: mirror <ClassDeclarationMirror> = (
	^link: mirror simpleName asText allBold
		action: [enterSubject:: NormalClassSubject onModel: mirror]
)
public parentClassSubjectDo: action = (
	^action value: subject
)
requestPresentationChange: newPresenter = (
	parent
		replaceChild: self
		with: newPresenter
)
respondToBrowseSuperclass = (

	browseClass: subject superclass
)
respondToCopy = (
	| copyName |
	copyName:: UIManager default
			request: 'Copy as...'
			initialAnswer: subject className, '2'.
	copyName isEmpty ifTrue: [^self (* User cancelled *)].
	browseClass:: subject copyAs: copyName.
)
respondToMoveUp = (
(* Refactoring: move class to enclosing class of its enclosing class *)
notYetImplemented
)
respondToRename = (

	classNamePresenter enterEditState
)
public showHeaderEditor = (
      switchToSource
)
switchToDescription = (
	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: false).
	descriptionOrSourceHolder content: classDescriptionDefinition.
)
switchToSource = (
	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: true).
	descriptionOrSourceHolder content: classSourceDefinition
)
switcherShowingSource: showingSourceNow <Boolean> = (
	^showingSourceNow
		ifTrue:	
			[row: {
				(link: 'Description' action: [switchToDescription]) smallFont.
				mediumBlank.
				(label: 'Source' asText allBold) smallFont.			
			}]
		ifFalse:	
			[row: {
				(label: 'Description' asText allBold) smallFont.
				mediumBlank.
				(link: 'Source' action: [switchToSource]) smallFont.	
			}]
)
'definition'
classCategoryLink = (
	^(subject classCategoryName
		ifNil: [label: '(uncategorized)']
		ifNotNil:
			[:cat | 
			link: cat action: [browseClassCategory: cat]])
				tinyFont
)
classNameAndContainmentDefinition = (
	^row: {
		draggableImage: icon forSubject: subject.
		smallBlank.
		elastic:: column: {
			row: {
				classNamePresenter:: EditableNSClassNamePresenter onSubject: subject.
				smallBlank.
				linkImage: HopscotchImages default editImage action: [respondToRename].
				smallBlank.
				(nestingInformationLine) compressibility: 1.
				filler compressibility: 0.
				(* right hand side begins *)
				ClassActionsPresenter onSubject: subject.
				smallBlank.
				itemReferencesButtonWithAction:
					[browseNSClassReferences: subject className].
				smallBlank.
				dropDownMenu: [classActionsMenu].
				}.
			row: {
				(label: 'Access Modifier: ') tinyFont.
				accessModifierLabel.
				mediumBlank.
				(label: 'Category: ') tinyFont.
				classCategoryLink.
				mediumBlank.
				(label: ' Package: ') tinyFont.
				classPackageLink.
				}
			}
		}.
)
classPackageLink = (

	^(subject classPackageName
		ifNil: [label: '(no package)']
		ifNotNil:
			[:packageName | 
			link: packageName action: [browsePackage: packageName]])
				tinyFont
)
classSummaryDefinition = (
^
	column: {
		smallBlank.
		classNameAndContainmentDefinition.
		mediumBlank.
		preambleLine.
		mediumBlank.
		ClassCommentPresenter onSubject: subject.
		mediumBlank.
		row: {
			label: 'Slots' asText allBold.
			largeBlank.
			addButtonWithAction: [slotsPresenter addNewItemTemplate].
			}.
		mediumBlank.
		slotsPresenter:: subject slotsSubject presenter.
		mediumBlank.
		initializerDefinition.
		}
)
headingDefinition = (
	(* Top level of the class header block, the one that provides the expand/collapse button in the top left corner. *)
	^(row: {
		elastic:	
			(expanded: expandedHeadingDefinition
			collapsed: collapsedHeadingDefinition).
		smallBlank
	}) color: (Color h: 240 s: 0.05 v: 0.9)
)
initializerDefinition = (
	| editor fragment success |
	
	^subclassResponsibility
)
'private'
sectionLabelled: title <String> presenting: groupSubject <MirrorGroupSubject> = (

	| groupPresenter |
^
	column: {
		minorClassHeadingBlock: (
			row: {
				label: title.
				largeBlank.
				addButtonWithAction: [groupPresenter addNewItemTemplate].
				filler.
				expandButtonWithAction: [groupPresenter expandAll].
				blank: 3.
				collapseButtonWithAction: [groupPresenter collapseAll].
				blank: 3.
				reorderButtonWithAction: [groupPresenter switchSortOrder].
				}
			).
		groupPresenter:: groupSubject presenter.
		}
)
sectionLabelled: title <String> presenting: groupSubject <MirrorGroupSubject> allowSwitch: allowSwitch = (

	| groupPresenter |
^
	column: {
		minorClassHeadingBlock: (
			row: {
				label: title.
				largeBlank.
				addButtonWithAction: [groupPresenter addNewItemTemplate].
				filler.
				expandButtonWithAction: [groupPresenter expandAll].
				blank: 3.
				collapseButtonWithAction: [groupPresenter collapseAll].
				blank: 3.
				allowSwitch 
					ifTrue: [reorderButtonWithAction: [groupPresenter switchSortOrder]]
					ifFalse: [nothing]
				}
			).
		groupPresenter:: groupSubject presenter.
		}
)
) : (
)
class AbstractClassSubject onModel: m = ClassSubject onModel: m ((*Represents common behavior of NS class subjects. These include both class declarations which provide their own slots, methods and nested classes, and mixin applications.*)|  guessedSuperclass guessedSubclasses |) (
'accessing'
public classCategoryName ^<Symbol | nil> = (
	^classMirror reflectee category
)
public classMirror = (
	(* A synonym of #model, for readability. *)
	^model
)
public className = (

	^classMirror simpleName
)
public classPackageName ^<String | nil> = (
	(* Answer the name of the package the class belongs to. *)

	^[(PackageOrganizer default packageOfClass: implementationClass ifNone: [^nil])
		packageName]
			on: Error
			do: [:ex | ex return: nil]
					
)
enclosingClass ^ <NS2ClassStencilMirror> = (
	^classMirror enclosingClass
)
public enclosingClasses ^<List[NSClassMirror]> = (
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
	| classes currentClass |
	classes:: OrderedCollection new.
	currentClass:: classMirror enclosingClass.
	[currentClass notNil] whileTrue:
		[classes add: currentClass.
		currentClass:: currentClass enclosingClass].
	^classes
)
public implementationClass = (
(* The Smalltalk class behind the scenes. *)
^model reflectee definingClass
)
subclasses = (
(* guessedSubclasses ifNotNil: [ :sc | ^sc].
flag: #BOGUS. 
guessedSubclasses:: model guessSubclassesIfFail: [^NewspeakObject].
^guessedSubclasses *)
	^Object
)
public superclassName = (

	^classMirror superclassName
)
public title = (
	^className asString
)
'actions'
public acceptClassDefinition: aString = (

	| builder |
	builder:: ClassDeclarationBuilder reflecting: model reflectee.
	builder headerFromSource: aString.
	builder install.
	^true
)
'as yet unclassified'
public accessModifier = (
	^ classMirror accessModifier
)
public classHeaderSource = (
	^ classMirror header source
)
classLanguage = (
	^Language newspeak3
)
public colorizeSource: sourceText <String | Text> ^<Text> = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: model reflectee definingClass
		usingSelector: #classDecl
)
public copyAs: newName <String> = (	
	#BOGUS. (* Does not check if this will clobber an existing class. Should this case be an error or a warning? *)
	isTopLevel 
		ifTrue:
			[ | builder mixin klass |
			builder:: ClassDeclarationBuilder fromSource: classMirror source.
			builder header name: newName.	
			mixin:: builder install reflectee.
			klass:: mixin apply: Object withName: builder simpleName.
			Root at: klass name put: klass.
			klass mixin category: classCategoryName.
			SystemOrganization classify: klass name under: classCategoryName.
			^mixin]
		ifFalse:
			[ | builder newSource nestedBuilder |
			builder:: ClassDeclarationBuilder fromSource: classMirror source.
			builder header name: newName.
			newSource:: builder source.
			builder:: ClassDeclarationBuilder reflecting: classMirror enclosingClass reflectee.
			nestedBuilder:: builder instanceSide nestedClasses addFromSource: newSource.			
			builder install.
			^nestedBuilder reflectee].
)
public deleteClass = (
	nil = model enclosingClass ifTrue: [
		
		(* This will remove the class from the system dictionary, remove it from its category, and send a system change notification that will be noticed by MemoryHole. *)
		[Smalltalk forgetClass: (Smalltalk at: model simpleName) logged: true] ifError: [].
		Root removeKey: model simpleName ifAbsent: [].
	] ifFalse: [
	
		| builder |
		builder:: ClassDeclarationBuilder reflecting: model enclosingClass reflectee.
		builder instanceSide nestedClasses removeMirrorNamed: model simpleName.
		builder install.
	].

	^ model simpleName
)
public deployAsChromeApp = (
	| packager path |
	packager:: ide jsPackaging ChromeAppPackager usingPlatform: cachedPlatform.
	path:: packager
		packageApplicationConfiguration: (Root at: model simpleName)
		usingNamespace: ide namespacing Root.
	
	(* Only works if Chrome isn't already running :( *)
	(ExternalLauncher for: 'open')
		runWith: {'-a'. 'Google Chrome.app'. '--args'. '--load-and-launch-app=',path} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | ].
)
public deployAsDart = (
	| packager path |
	packager:: ide dartPackaging ApplicationPackager usingPlatform: cachedPlatform.
	path:: packager
		packageApplicationConfiguration: (Root at: model simpleName)
		usingNamespace: ide namespacing Root.
	
	(* Open the file browser? Run in a terminal? *)
)
public deployAsNof = (
	| appDef app |
	appDef:: Root at: model simpleName.
	app:: appDef packageUsing: ide namespacing manifestForSqueak.
	Deployment appToNof: app.
)
public deployAsPackagedImage = (
	| appDef app |
	appDef:: Root at: model simpleName.
	app:: appDef packageUsing: ide namespacing manifestForSqueak.
	Deployment makeDeploymentImageFor: app.
)
public deployAsWebPage = (
	ide webPackager isNil ifTrue:
		[ide webPackager: (ide jsPackaging WebPagePackager usingPlatform: cachedPlatform)].

	open:: ide webPackager
		packageApplicationConfiguration: (Root at: model simpleName)
		usingNamespace: ide namespacing Root.
)
public instancesSubject ^<ObjectSubject> = (
	| instances = OrderedCollection new. |
	#BOGUS. (* Put allInstancesDo: on ClassMirror? *)
	model reflectee applications do:
		[:application |
		application allInstancesDo:
			[:instance | instances add: instance]].
	^presenter objectSubjectFor: instances
)
public isApplicationConfiguration = (
	^isTopLevel and: [model classSide canUnderstand: #packageUsing:]
)
public isTestConfiguration = (
	^isTopLevel and: [model classSide canUnderstand: #packageTestsUsing:]
)
public isTopLevel = (
	^model enclosingClass == nil
)
public methodCount ^<Integer> = (
	^subclassResponsibility
)
open: path = (
	OSProcess isUnixMac ifTrue: [
		^(ExternalLauncher for: 'open')
			runWith: {path} 
			ifSuccess: [:stdout :stderr | ] 
			ifFailure: [:stdout :stderr | ]].

	OSProcess isUnix ifTrue: [
		^(ExternalLauncher for: 'xdg-open')
			runWith: {path} 
			ifSuccess: [:stdout :stderr | ] 
			ifFailure: [:stdout :stderr | ]].
	
	OSProcess isWindows ifTrue: [
	 	^(ExternalLauncher for: 'cmd')
			runWith: {'/c'. 'start'. path} 
			ifSuccess: [:stdout :stderr | ] 
			ifFailure: [:stdout :stderr | ]].
)
public runApp = (
	| appDef app |
	appDef:: Root at: model simpleName.
	app:: appDef packageUsing: ide namespacing manifestForSqueak.
	[app main: cachedPlatform args: {}] forkNamed: app printString.
)
public subInstancesSubject ^<ObjectSubject> = (
	| instances = OrderedCollection new. |
	#BOGUS. (* Put allInstancesDo: on ClassMirror? *)
	model reflectee applications do:
		[:application |
		application allInstancesDo:
			[:instance | instances add: instance].
		application allSubclassesDo:
			[:subclass | subclass allInstancesDo:
				[:instance | instances add: instance]]].
	^presenter objectSubjectFor: instances
)
public superclass = (
	| applications |
	applications:: model instanceSide applications.
	applications 
		detect: [:any <ClassMirror> | ^any superclass mixin reflectee definingClass]
		ifNone: [^Object]
)
public testingSubject = (
	^minitestUI TestingInProgressSubject
		onConfiguration: (Root at: model simpleName)
		platform: cachedPlatform
		minitest: minitest
)
public totalSubclassCount = (

	(* flag: #BOGUS.
	^(classMirror guessSubclassesIfFail: [Array new]) size *)
	^0
)
) : (
)
class BodylessClassPresenter onSubject: s = AbstractClassPresenter onSubject: s ((* Presents a mixin application class. The subject is an MixinApplicationClassSubject. *)|
|) (
'accessing'
preambleLine = (
	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)

	| preamble equalIndex prefix suffix |
	preamble:: subject model header source.
	equalIndex:: preamble indexOf: "=".
	equalIndex = 0
		ifTrue:
			[prefix:: preamble withBlanksTrimmed.
			suffix:: '']
		ifFalse:
			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1)
				withBlanksTrimmed.
			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)
				withBlanksTrimmed]. 
	^row: {
			label: prefix, ' = '.
			link: suffix action: [respondToBrowseSuperclass]
			}
)
'as yet unclassified'
classDescriptionDefinition = (
	^column: {
		preambleLine.
		}
)
'definition'
definition = (
	| classesPresenter |
^
	column: {
		headingDefinition.
	}
)
) : (
)
class BodylessClassSubject onModel: m = AbstractClassSubject onModel: m (
(* WIP. Represents a mixin application class rather than a class declaration.  *)) (
'as yet unclassified'
public createPresenter = (
	^BodylessClassPresenter onSubject: self
)
public methodCount ^<Integer> = (
	^0
)
) : (
)
public class ClassActionsPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
'as yet unclassified'
applicationActions = (
	subject isApplicationConfiguration ifFalse: [^nothing].
	^row: {
		smallBlank.
		(link: '[deploy]' action: [
			openMenu:: menuWithLabelsAndActions: {
				'as NOF' -> [recordVisit. subject deployAsNof].
				'as Packaged Image (warning: closes this image)' -> [recordVisit. subject deployAsPackagedImage].
				'as Dart' -> [recordVisit. subject deployAsDart].
				'as Web Page' -> [recordVisit. subject deployAsWebPage].
				'as Chrome Packaged App' -> [recordVisit. subject deployAsChromeApp].
			}					
		]) tinyFont.
		smallBlank.
		(link: '[run]' action: [subject runApp]) tinyFont.
	}
)
benchmarkActions = (
	^nothing
)
definition = (
	^row: {testActions. benchmarkActions. applicationActions}
)
recordVisit = (
	ide defaultPopularityRecord rememberClassVisit: subject implementationClass.
)
testActions = (
	subject isTestConfiguration ifFalse: [^nothing].
	^(link: '[run tests]' action: [recordVisit. enterSubject:: subject testingSubject]) tinyFont
)
) : (
)
class ClassReferencesPresenter onSubject: s = ProgrammingPresenter onSubject: s ((* The subject is an NSClassReferencesSubject. Displays the list of methods provided by the subject, which are those that seem to reference an NS class. *)|  |) (
'as yet unclassified'
definition = (

	| references |
	^column: {
		minorHeadingBlock: (
			row: {
				label: subject className asText allBold.
				label: ' references'.
				filler.
				expandButtonWithAction: [references expandAll].
				blank: 3.
				collapseButtonWithAction: [references collapseAll]
				}
			).
		blank: 10.
		row: {
			blank: 10.
			elastic:
				(references::
				(AssortedMethodsSubject onModel: subject referencesSubjects) presenter).
			}.
		blank: 10
		}
)
) : (
)
class ClassReferencesSubject onModel: m = Subject onModel: m ((* The model is the class name. Provides access to methods that are likely to reference the class because they are sending that name as a message. *)| nameSelectorSubject |nameSelectorSubject:: SelectorSubject onModel: className) (
'as yet unclassified'
public = anotherSubject = (
	^(anotherSubject class = self class)
		and: [anotherSubject className = className]
)
public className = (

	^model
)
public createPresenter = (

	^ClassReferencesPresenter onSubject: self
)
public hash = (
	^model hash
)
public referencesSubjects = (

	^nameSelectorSubject senderSubjects
)
public title = (
	^className, ' References'
)
) : (
)
public class ExemplarMethodGroupSubject onModel: m = MethodGroupSubject onModel: m ((* Describe the class in this comment. *)) (
'as yet unclassified'
elementSubjectClass = (
	^ExemplarMethodSubject
)
) : (
)
public class ExemplarMethodPresenter onSubject: s = ExpandableMethodPresenter onSubject: s ((* Describe the class in this comment. *)) (
'as yet unclassified'
methodDetails ^ <Fragment> = ( 
	^(finalizer subjectForContext: subject exemplar) createPresenter.
)
methodHeading = (
	inspectionHolder:: holder: [nothing].
	headingAfterLeftHolder:: holder: [nothing].
	^row: {
		accessModifierIcon.
		smallBlank.
		(selectorAndContainment) compressibility: 1.
		mediumBlank.
		deferred: [overrideIcon].
		blank: 2.
		deferred: 
			[subject isSubclassResponsibility 
				ifTrue: 
					[image: HopscotchImages default tinySubclassResponsibilityImage]
				ifFalse: [nothing]].
		smallBlank.
		deferred: 
			[sendersOfSubjectPresenter].
		smallBlank.
		headingAfterLeftHolder.
		filler compressibility: 0.
		categoryLink.
		largeBlank.
		inspectionHolder.
		smallBlank.
		itemReferencesMenuButtonWithAction: [goToMessages].
		smallBlank.
		dropDownMenu: [methodActionsMenu].
	}
)
) : (
)
class ExemplarMethodSubject onModel: m = NSMethodSubject onModel: m ((* Describe the class in this comment. *)) (
'as yet unclassified'
public createPresenter = (
	^ExemplarMethodPresenter onSubject: self
)
) : (
)
class ExpandableClassPresenter onSubject: s = ProgrammingPresenter onSubject: s ((* Presents the subject (an NSClassSubject) as a line displaying the class name and expandable into a full-blown class view. *)|  |) (
'as yet unclassified'
public collapse = (

	substance collapse
)
definition = (

	| toggle |
	toggle::
		collapsed: (NestedClassPresenter onSubject: subject)
		expanded: [subject classSubject createPresenter].
	toggle onUserToggled: [requestVisibility].
	^toggle
)
public expand = (

	substance expand
)
) : (
)
class InitializerMethodPresenter onSubject: s = ExpandableMethodPresenter onSubject: s ((* A specialized presenter for instance initializers. These present the initializer as a method, with a signature and sent messages information etc.. *)) (
'as yet unclassified'
acceptClassDefinition: classEditor = (
	(* This class's definition has been changed in the definition editor. *)

	^majorUpdate:
		[[subject classSubject acceptClassDefinition: classEditor textBeingAccepted] 
			on: Error
			do: [:ex | classEditor showMessage: ex description. false]]
)
categoryLink ^ <Fragment> = (
  (* don't display a category at all *)
	^(label: '<instance initializer>') tinyFont
)
classSourceDefinition = (
	^column: {	
		editor:: CodeEditorFragment new
			text: subject classSubject classHeaderSource;
			colorizerBlock: [ :text | subject classSubject colorizeSource: text, '()'];
			acceptResponse: 
					[(acceptClassDefinition: editor)	
						ifTrue: [editor defaultAcceptResponse]].
	}
)
methodDetails = (
	^classSourceDefinition
)
) : (
)
public class InitializerMethodSubject onModel: m <MethodMirror> = NSMethodSubject onModel: m ((* WIP: Designed to handle synthetic initializer methods, including the primary  class factory, the instance initializer and its subparts *)|
_classSubject  <ClassSubject | ClassHeaderSubject> 
|) (
'as yet unclassified'
public changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
   failureBlock value
)
public classSubject ^ <ClassSubject> = (
	_classSubject isNil ifTrue:[_classSubject:: (classSubjectOn: methodMirror definingMixin declaration)].
	^_classSubject
)
public createPresenter ^ <Presenter> = (
	| presenterClass |
	presenterClass:: ide settings useExemplarPresenters 
	    	ifTrue: [ExemplarMethodPresenter] 		
		ifFalse: [InitializerMethodPresenter].
	
	^(presenterClass onSubject: self)
)
public deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (
  (* do nothing for now. Should report an error, or better yet,
   not have the option in the menu *)
)
public isAnOverride = (
(* True if one of the superclasses has a method with the same selector. *)
 ^false
)
public isAnOverrideIn: classSubj <NSClassSubject | nil> = (
	^false
)
public isOverriden = (
	(* True if one of the subclasses has a method with the same selector. *)
	^false
)
public isValid ^ <Boolean> = (
	^true
)
public messages ^ <List[Symbol]> = (
	(* This is missing messages in the inheritance clause. *)
	|  accumulator <Set[Symbol]> = Set new. |
	allInitializers do:[: i |
		i  messages do:[:each | accumulator add: each]].
	^accumulator asMutableArrayList select:[:n | (n includes: "`") not]
)
public methodCategory ^<String> = (
	^'<instance initializer>'
)
public selector = (
	^methodMirror definingMixin declaration header primaryFactoryName
)
public source ^ <String> = (
	^classSubject classHeaderSource
)
public variableBindingKeys ^ <List[Symbol]> = (
	| accumulator <Set[Symbol]> = Set new. |

	allInitializers do:[: i |
		i  literalsDo:[:each |
			(each isVariableBinding and:[each key notNil]) ifTrue:
			[accumulator add: each key]]].
	^accumulator asMutableArrayList
)
'private'
allInitializers ^ <Collection[CompiledMethod]> = (
	(* get all the methods that represent instance initializer code.
	A principled way of doing this is needed, so that we don't rely on the
	conventions of the compiler here. Perhaps mirrors should support this?
	*)
	^classSubject model reflectee methodDict values select:[:m | m properties includesKey: #isSubinitializer ]
)
) : (
)
class MethodGroupPresenter onSubject: s = MirrorGroupPresenter onSubject: s ((* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)| groupedByCategory::=false. |) (
'actions'
switchSortOrder = (

	groupedByCategory: groupedByCategory not.
	refresh
)
'as yet unclassified'
addMethodIn: cls proposedSource: src = (
subject model enclosingMixin reflectee == cls ifTrue:
	[| template |
	template:: addNewItemTemplate: src.
	turnOnTemplateEditorMode: src in: template]
)
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	addNewItemTemplate: subject methodTemplateText
)
addNewItemTemplate: src = (
	(* Handle a user's request to create a new method by displaying a new method template. *)

	| template |
	template:: DefinitionTemplate new
		caption: 'Adding new method:';
		initialText: src;
		colorizerBlock: [ :text | subject colorizeSource: text];
		acceptResponse:
			[createNewMethodFromTemplate: template];
		cancelResponse:
			[prefixes remove: template].
	prefixes add: template.
	^template
)
public compileMethod: source <String> inPresenter: requestor <Presenter> ifCompiledAsSame: successResponse <Block> ifCompiledAsNew: successNewResponse <Block> ifFailed: failureResponse <Block> = (

	majorUpdate:
		[subject
			compileSource: source
			ifSuccess: 
				[:newSelector |
				newSelector = requestor subject selector
					ifTrue: [successResponse value]
					ifFalse: [successNewResponse value].
				content refresh.
				(content detectPresenter: [:some | some subject selector = newSelector]) 
					expand]
			ifFailure: failureResponse]
)
createNewMethodFromTemplate: template <DefinitionTemplate> = (

	subject 
		compileSource: template text
		ifSuccess:
			[:newSelector |
			prefixes remove: template.
			(content detectPresenter: [:some | some subject selector = newSelector]) expand]
		ifFailure:[:message | template editor showMessage: message]
)
deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (

	subject deleteMethodWithSubject: presenter subject.
	successResponse value
)
recategorizeMethodIn: presenter <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (

	| newName |
	newName:: newCategoryName withBlanksTrimmed.
	newName isEmpty ifTrue: [^failureResponse value].
	presenter subject
		changeCategoryTo: newName asSymbol
		ifSuccess:
			[refresh. (* so the methods are reshuffled according to categories *)
			successResponse value]
		ifFailure: failureResponse
)
repondToEnter: template defaultAction: defaultAction = (
| src index indexType range pos end |
range:: template editor editor selectionInterval.
pos:: range isEmpty ifTrue: [range first] ifFalse: [range last].
src:: (template editor editedText ifNil: [template editor text]) asString.
index:: src asString findString: 'argument' startingAt: pos.
indexType:: src indexOf: "<" startingAt: pos.
(index ~= 0 and: [indexType ~= 0]) ifTrue:
	[index:: index min: indexType].
index = 0 ifTrue:
	[index:: indexType].
index = 0 ifTrue:
	[template editor enterKeyResponse: nil.
	index:: src indexOf: Character tab startingAt: pos.
	index ~= 0 ifTrue:
		[template editor editor
			selectFrom: index + 1
			to: index].
	^self].
end:: index = indexType
	ifTrue:
		[index:: index + 1.
		(src indexOf: ">" startingAt: pos) - 1]
	ifFalse: ['argument' size + index].
template editor editor
	selectFrom: index
	to: end
)
turnOnTemplateEditorMode: src in: template = (
| indexOfFirstArg |
indexOfFirstArg:: src findString: 'argument1'.
indexOfFirstArg > 0 ifTrue:
	[template editor enterKeyResponse:
		[:defaultAction |
		repondToEnter: template defaultAction: defaultAction].
	template editor editor
		selectFrom: indexOfFirstArg
		to: 'argument1' size + indexOfFirstArg - 1]
)
'private'
contentPresenters = (

	| subjects |
	subjects:: groupedByCategory
		ifTrue: [subject sortedCategories]
		ifFalse: [subject elements].
	^subjects collect: 
		[:each | createPresenterForSubject: each]
)
) : (
)
public class MethodGroupSubject onModel: m = MirrorGroupSubject onModel: m ((* Represents the collection of methods of a Newspeak class. Holds onto the mirror group for the methods. *)|  |) (
'actions'
public methodTemplateText = (
^
'messageSelector = (
	
)'
)
'as yet unclassified'
public colorizeSource: sourceText <String | Text> ^<Text> = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: model enclosingMixin declaration reflectee definingClass
		usingSelector: #methodDecl
)
public compileSource: aString ifSuccess: successBlock ifFailure: failureBlock = (
	
	[ | builder newMirror |
	builder:: MixinBuilder reflecting: model enclosingMixin reflectee.
	newMirror:: builder methods addFromSource: aString.
	builder declaration install.
	successBlock value: newMirror simpleName]
		on: Error
		do: [:ex | failureBlock value: ex description].
)
public createPresenter = (
	^MethodGroupPresenter onSubject: self
)
public deleteMethodWithSubject: methodSubject = (

	| builder |
	builder:: MixinBuilder reflecting: model enclosingMixin reflectee.
	builder methods removeMirrorNamed: methodSubject selector.
	builder declaration install.
)
elementSubjectClass = (

	^NSMethodSubject
)
public methodSubjectsInCategory: categoryName <Symbol> ^<Collection[MethodSubject]> = (

	| matches |
	matches:: (modelMirrorCollection select: [:each | each category = categoryName]).
	^matches collect: [:mirrorMethod | elementSubjectClass onModel: mirrorMethod].
)
modelMirrorCollection = (
	^super modelMirrorCollection asSortedList: [:a :b | a simpleName < b simpleName]
)
public sortedCategories = (
(* Answer a collection of method subjects sorted by their category names found in the class, sorted with initialization first and private categories last. *)

| categories init privateCategories unclassified lineup |
categories:: modelMirrorCollection inject: Set new into: [:s :m | s add: m category. s].
init:: categories select: [:each | 'init*' match: each].
categories:: categories reject: [:each | init includes: each].
privateCategories:: categories select: [:each | 'private*' match: each].
categories:: categories reject: [:each | privateCategories includes: each].
(categories includes: #'as yet unclassified')
	ifTrue:
		[unclassified:: {#'as yet unclassified'}.
		categories remove: #'as yet unclassified']
	ifFalse:
		[unclassified:: {}].
lineup:: OrderedCollection new: categories size.
lineup 
	addAll: unclassified;
	addAll: init asSortedList;
	addAll: categories asSortedList;
	addAll: privateCategories asSortedList.
^lineup 
	inject: OrderedCollection new
	into: 
		[:collection :each |
		collection addAll: (methodSubjectsInCategory: each).
		collection]
)
) : (
)
class MirrorGroupPresenter onSubject: s = DefinitionListPresenter onSubject: s ((*  *)| elementPresenterClass |) (
'actions'
public addNewItemTemplate = (
	(* A subclass must redefine this to show a template for the user to fill out to create a new item in the group. *)

	subclassResponsibility
)
'initialize-release'
subject: aMirrorGroupSubject = (

	super subject: aMirrorGroupSubject.
	subject changedChannel => [:whatever | content refresh]
)
'private'
contentPresenters = (

	^subject elements collect: 
		[:each | createPresenterForSubject: each]
)
createPresenterForSubject: aSubject = (
	(* Let the subject create its default unless elementPresenterClass is set to specify our preference. *)

	^elementPresenterClass
		ifNil: [aSubject presenter]
		ifNotNil: [:pclass | pclass onSubject: aSubject]
)
) : (
)
class MirrorGroupSubject onModel: m = Subject onModel: m ((* An abstract superclass of subjects on mirror groups. Registers to receive update events from the mirror group and broadcasts its own update events through its 'changedChannel' when that happens. The presenter will listen to those and update itself when needed. *)| 
mirrorGroupChangesOutlet
public changedChannel ::= Duct owner: self.
|self model: m) (
'as yet unclassified'
elementSubjectClass = (
	(* Answer the class of the subjects we create on individual elements of our subject group. *)

	subclassResponsibility
)
public elements ^<Collection[Subject]> = (
	(* Answer a collection of subjects on individual elements of the group which is our subject. *)

	^modelMirrorCollection collect: [:each | elementSubjectClass onModel: each]
)
modelMirrorCollection ^<Collection[Mirror]> = (

	^(model collect: [:x|x]) asMutableArrayList
)
'initialize-release'
model: mirrorGroup = (

	super model: mirrorGroup.
	(* We expect the mirror group changes channel to be weak so we are retaining the outlet and expect that the old one, if any, will get garbage-collected. *)
	
	mirrorGroupChangesOutlet::
		model channelForChanges => [:x | changedChannel send: true].
)
) : (
)
public class NSMethodInheritanceSubject onModel: m = MethodInheritanceSubject onModel: m ((*  *)|  |) (
'as yet unclassified'
public implementingClass = (

	self halt
)
public methodTitle = (

	^model enclosingClassStencil name, '>>', selector
)
selector = (

	^model selector
)
) : (
)
public class NSMethodSubject onModel: m = MethodSubject onModel: m (|
       exemplar_slot <MethodContext>
|) (
'accessing'
public messages = (

	^compiledMethod messages
)
public methodCategory = (
	^methodMirror category
)
public methodMirror = (

	^model
)
public selector = (
	^methodMirror name
)
public source = (

	^methodMirror source
)
public variableBindingKeys  ^ <List[Symbol]> = (

	| result  <List[Symbol]> |
	result:: OrderedCollection new.
	compiledMethod literalsDo:
		[:each |
		(each isVariableBinding and:[each key notNil]) ifTrue:
			[result add: each key]].
	^result
)
'as yet unclassified'
public =  other <Object> ^<Boolean> = (

	^self class = other class and: [methodMirror = other methodMirror]
)
public allMethodCategories ^<Collection[Symbol]> = (
	(* Answer a collection of all category names used in the implementor class, plus some common names. *)
	| names |
	names:: super allMethodCategories.
	names addAll: (methodMirror definingMixin methods collect: [:ea | ea category]).
	^names
)
asMethodInheritanceSubject = (
^NSMethodInheritanceSubject onModel: methodMirror
)
public changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (

	| builder |
	builder:: MixinBuilder reflecting: methodMirror definingMixin reflectee.
	(builder methods findMirrorNamed: methodMirror simpleName) category: newName.
	builder declaration install.
	#BOGUS. (* Do this non atomically? *)

	successBlock value
)
classExemplar ^ <Class> = (
	^systemScope exemplarClassFor: methodMirror definingMixin reflectee
)
public className = (

	^methodMirror definingMixin name 
)
public colorizeMethodSource: sourceText = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: implementingClass
		usingSelector: #methodDecl
)
public compileNewSource: newSource <String> ifSuccess: successBlock ifNewMethod: newBlock1arg ifFailure: failureBlock = (

	| builder newMirror |
	builder:: MixinBuilder reflecting: methodMirror definingMixin reflectee.
	newMirror:: builder methods addFromSource: newSource.
	builder declaration install.
	newMirror simpleName = methodMirror simpleName
		ifTrue: [(* same *) successBlock value]
		ifFalse: [(* new *) newBlock1arg value: newMirror simpleName].
)
compiledMethod = (

	^methodMirror reflectee
)
public createPresenter = (
	| presenterClass |
	presenterClass:: 
	  (ide settings useExemplarPresenters 
		and: [implementingClass language isNewspeakLanguage3 
		and: [isSynthetic not]])
	    		ifTrue: [ExemplarMethodPresenter] 		
			ifFalse: [ExpandableMethodPresenter].
	
	^(presenterClass onSubject: self)	
)
public deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (
	| builder |
	builder:: MixinBuilder reflecting: methodMirror definingMixin reflectee.
	builder methods removeMirrorNamed: selector.
	builder declaration install.
	successBlock value (* always succeed? *)
)
public enclosingClasses ^<List[Mixin]> = (
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
	| classes currentClass |
	classes:: OrderedCollection new.
	currentClass:: methodMirror definingMixin.
	[classes add: currentClass reflectee.
	currentClass:: currentClass declaration enclosingClass.
	currentClass isNil]
		whileFalse: [currentClass:: currentClass instanceSide].
	^classes
)
public exemplar ^ <MethodContext> = (
   exemplar_slot ifNil:[
	exemplar_slot:: 
		(MethodContext newForMethod: methodMirror reflectee) 		
				setSender: nil 
				receiver: instanceExemplar 
				method:  methodMirror reflectee arguments: exemplarArgs.
	].
  ^exemplar_slot
)
exemplarArgs ^ <Array> = (
	^ Array new: methodMirror reflectee numArgs
)
public hash ^<SmallInteger> = (

	^self class hash bitXor: model hash
)
public implementingClass = (

	^methodMirror reflectee methodClass
)
instanceExemplar = (
	^systemScope exemplarInstanceFor: classExemplar
)
public isAnOverride = (

	^superclass canUnderstand: self selector
)
public isAnOverrideIn: classSubject <NSClassSubject | nil> = (
	^(classSubject ifNil: [^isAnOverride]) superclass canUnderstand: self selector
)
public isOverridden = (

	flag: #BOGUS. 
	^false.
)
public isOverriddenIn: classSubject <NSClassSubject | nil> = (
(* (classSubject ifNil: [^isOverridden]) subclasses do: [ :ea |
	(ea mixin methods includesMirrorNamed: selector)
		ifTrue: [^true]]. *)
^false
)
public isValid = (
	^true
)
superclass = (
	#BOGUS.
	^Object
)
) : (
)
class NestedClassGroupPresenter onSubject: s = MirrorGroupPresenter onSubject: s ((* Presents nested classes of an NS class and takes care of their creation and deletion. *)|  |) (
'as yet unclassified'
acceptNewClassDefinitionFrom: aTemplate = (

	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
addClassIn:  receiverClass <Mixin> proposedSource: src  <String> = (
	subject classObject == receiverClass ifTrue:
	[addNewItemTemplate: src]
)
public addNewItemTemplate = (

	| template |
	template:: DefinitionTemplate new
		caption: 'Adding new class:';
		initialText: subject classDefinitionHeaderPartTemplate;
		colorizerBlock: [ :text | subject colorizeSource: text];
		acceptResponse:
			[acceptNewClassDefinitionFrom: template];
		cancelResponse:
			[prefixes remove: template].
	prefixes add: template
)
addNewItemTemplate: src <String>  = (

	| template |
	template:: DefinitionTemplate new
		caption: 'Adding new class:';
		initialText: src;
		colorizerBlock: [ :text | subject colorizeSource: text];
		acceptResponse:
			[acceptNewClassDefinitionFrom: template];
		cancelResponse:
			[prefixes remove: template].
	prefixes add: template
)
) : (
)
class NestedClassGroupSubject onModel: m = MirrorGroupSubject onModel: m ((* Represents the collection of classes nested in a Newspeak class. Holds onto the mirror group for the classes.
*)|  |) (
'as yet unclassified'
public addClassFromDefinition: aString ifSuccess: successBlock ifFailure: failureBlock = (

	| builder newMirror |
	[builder:: MixinBuilder reflecting: model enclosingMixin reflectee.
	builder nestedClasses addFromSource: aString.
	builder declaration install]
		on: Error
		do: [:e <Error> | ^failureBlock value: e description].
			
	successBlock value
)
classObject = (
	^ model enclosingMixin reflectee
)
public colorizeSource: sourceText <Text | String> ^<Text> = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: model enclosingMixin declaration reflectee definingClass
		usingSelector: #classDecl
)
public createPresenter = (
	^NestedClassGroupPresenter onSubject: self
)
modelMirrorCollection = (
	^super modelMirrorCollection asSortedList: [:a :b | a simpleName < b simpleName]
)
'private'
public classDefinitionHeaderPartTemplate = (
^
'class ClassNameHere = (
(* Describe the class in this comment. *)
|
	slot1
	slot2
|
) ()'
)
elementSubjectClass = (

	^NestedClassSubject
)
) : (
)
class NestedClassPresenter onSubject: s = ProgrammingPresenter onSubject: s ((* Presents an NSClassSubject as link that browses the class. *)|  |) (
'as yet unclassified'
accessModifierIcon = (
	^ image: (iconForAccessModifier: subject accessModifier)
)
definition = (
^row: {
	accessModifierIcon.
	smallBlank.
	link: subject classMirror simpleName action: [	browseClassMirror: subject classMirror]
	}
)
) : (
)
class NestedClassSubject onModel: m = Subject onModel: m ((* Represents a class nested inside another class. The default presenter renders this as a link that enters the class definition when clicked. *)|  |) (
'accessing'
public classMirror = (
	^model
)
'as yet unclassified'
public accessModifier = (
	^ classMirror accessModifier
)
public classSubject = (

	^classSubjectOn: classMirror
)
'private'
public createPresenter = (

	^ExpandableClassPresenter onSubject: self
)
) : (
)
class NormalClassPresenter onSubject: s = AbstractClassPresenter onSubject: s ((* Presents a Newspeak class, as a full view that includes slots, nested classes, methods, etc. The subject is a ClassDeclarationSubject. *)|
	slotsSubject
	slotsPresenterX
|) (
'accessing'
preambleLine = (
	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)

	| preamble equalIndex prefix suffix |
	preamble:: subject classMirror header preamble.
	equalIndex:: preamble indexOf: "=".
	equalIndex = 0
		ifTrue:
			[prefix:: preamble withBlanksTrimmed.
			suffix:: '']
		ifFalse:
			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1)
				withBlanksTrimmed.
			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)
				withBlanksTrimmed].
	^suffix isEmpty 
		ifTrue: 
			[label: prefix]
		ifFalse:
			[row: {
				label: prefix, ' = '.
				link: suffix action: [respondToBrowseSuperclass]
				}]
)
slotsPresenter = (
	^slotsPresenterX
)
slotsPresenter: aPresenter = (
	(* Users of this expect that we answer the presenter rather than the receiver. *)
	slotsPresenterX:: aPresenter.
	^aPresenter
)
'as yet unclassified'
classDescriptionDefinition = (
	^column: {
		preambleLine.
		mediumBlank.
		ClassCommentPresenter onSubject: subject.
		mediumBlank.
		row: {
			label: 'Slots' asText allBold.
			largeBlank.
			addButtonWithAction: [slotsPresenter addNewItemTemplate].
			}.
		mediumBlank.
		slotsPresenter:: subject slotsSubject presenter.
		mediumBlank.
		initializerDefinition.
		}
)
'definition'
definition = (
	| classesPresenter |
^
	column: {
		headingDefinition.
		sectionLabelled: 'Classes' presenting: subject nestedClassesSubject allowSwitch: false.
		sectionLabelled: 'Methods' presenting: subject methodsSubject allowSwitch: true.
		sectionLabelled: 'Class Methods' presenting: subject classMethodsSubject allowSwitch: true.
	}
)
initializerDefinition = (
	| editor fragment success |
	
	^nothing
(*	
	editor:: CodeEditorFragment new
		text: subject initExprs;
		colorizerBlock: [ :text | NS2BrowserColorizer new
			parseText: text asString
			fromClass: subject classMirror
			usingSelector: #initExprs];
		acceptResponse: [[
			success:: true.
			subject initExprs: editor textBeingAccepted]
				ifError: [:err |
					success:: false.
					editor showMessage: err].
			success ifTrue: [
				editor defaultAcceptResponse.
				fragment refresh]].
	
	^fragment:: column: {
		holder: [ |additionalText|
			additionalText:: subject hasInitExprs ifTrue: [''] ifFalse:[' (empty)'].
			heading: (row: {
				label: 'Initializer ' asText allBold.
				label: additionalText.
				})
			details: editor.]	
		} *)
)
) : (
)
class NormalClassSubject onModel: m = AbstractClassSubject onModel: m ((* Represents the ''normal'' perspective of looking at a full class declaration, so that its details such as slots, nested classes, and methods are visible. The model is the mirror on the class. By default presented by NormalClassPresenter. *)| commentPresenter nestedClassesPresenter methodsPresenter |) (
'accessing'
public classCommentText ^<String> = (
	^model header classComment ifNil: ['']
)
public classCommentText: newComment <String> = (

	| builder |
	builder:: ClassDeclarationBuilder reflecting: model reflectee.
	builder header classComment: newComment.
	builder install.
)
public classMethodsSubject = (
	ide settings useExemplarPresenters ifTrue:
		[^ExemplarMethodGroupSubject onModel: classMirror classSide methods].
	^MethodGroupSubject onModel: classMirror classSide methods
)
initExprs = (
	^classMirror initExprs
)
initExprs: newInitExprs = (
	^classMirror initExprs: newInitExprs
)
public methodsSubject = (
	(ide settings useExemplarPresenters) ifTrue:
		[^ExemplarMethodGroupSubject onModel: model instanceSide methods].
	^MethodGroupSubject onModel: model instanceSide methods
)
public nestedClassesSubject = (

	^NestedClassGroupSubject onModel: model instanceSide nestedClasses
)
public slotsSubject = (

	^SlotGroupSubject onModel: classMirror instanceSide slots
)
public subclasses = (
(* guessedSubclasses ifNotNil: [ :sc | ^sc].
flag: #BOGUS. 
guessedSubclasses:: model guessSubclassesIfFail: [^NewspeakObject].
^guessedSubclasses *)
	^Object
)
'actions'
public acceptClassDefinition: aString = (

	| builder |
	builder:: ClassDeclarationBuilder reflecting: model reflectee.
	builder headerFromSource: aString.
	builder install.
	^true
)
'as yet unclassified'
public classHeaderSource = (
	^ classMirror header source
)
initializer ^ <MethodMirror> = (
	classMirror instanceSide initializer isNil ifTrue:[^nil].
	(* temporary measure until all classes have been recompiled *)
	^InitializerMethodSubject onModel: classMirror instanceSide initializer 
)
public methodCount ^<Integer> = (
	| instanceCount classCount |
	instanceCount:: model instanceSide methods size.
	classCount:: model classSide methods size.
	^instanceCount + classCount
)
'private'
public createPresenter = (

	^NormalClassPresenter onSubject: self
)
) : (
)
class SlotGroupPresenter onSubject: s = MirrorGroupPresenter onSubject: s ((* Displays the slots of a Newspeak class and handles their definiting, editing and removal. The subject is an NSSlotGroupSubject. *)|  |) (
'as yet unclassified'
acceptNewSlotDefinitionFrom: aTemplate = (

	majorUpdate:
		[subject
			acceptSlotDefinition: aTemplate text
			ifSuccess:
				[prefixes remove: aTemplate]
			ifFailure: 
				[:message |
				error: message]]
)
public addNewItemTemplate = (

	sendUp showHeaderEditor
)
defineSlot: definition <String> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (

	majorUpdate:
		[subject
			acceptSlotDefinition: definition
			ifSuccess: successResponse
			ifFailure: failureResponse]
)
deleteSlotInPresenter: presenter <NSSlotPresenter> = (

	|  slotSubject residue |
	slotSubject:: presenter subject.
	residue:: DefinitionResidue new
		caption: 'Deleted slot ', slotSubject slotName;
		definitionText: slotSubject definitionText;
		restoreResponse: [error: 'unimplemented'];
		forgetResponse: [suffixes remove: residue].
	subject deleteSlotSubject: slotSubject.
	suffixes add: residue
)
) : (
)
public class SlotGroupSubject onModel: m = MirrorGroupSubject onModel: m ((*  *)|  |) (
'as yet unclassified'
acceptSlotDefinition: definitionString ifSuccess: successBlock0 ifFailure: failureBlock1 = (

	self unimplemented.  (* Does it make sense to edit slots in isolation? *)
)
colorizeSource: sourceText <Text | String> ^<Text> = (
^NS2BrowserColorizer new
	parseText: sourceText asString
	fromClass: model declaringMixin
	usingSelector: #slotDef
)
public createPresenter = (
	^SlotGroupPresenter onSubject: self
)
deleteSlotSubject: aSlotSubject = (

	model removeMirrorNamed: aSlotSubject slotName
)
elementSubjectClass = (

	^SlotSubject
)
) : (
)
class SlotPresenter onSubject: s = ProgrammingPresenter onSubject: s ((* The subject is an NSSlotSubject. Presents the slot as a link expandable into a full definition. *)| editor |) (
'as yet unclassified'
goToMessages = (

	| messagesAndActions messageItems classItems |
	messagesAndActions:: OrderedCollection new.
	messagesAndActions 
		add: subject slotName -> [browseSelector: subject slotName];
		add: (subject slotName, ':') -> [browseSelector: subject slotName, ':'].
	(* messageItems:: referencesMenuMessageItems.
	classItems:: referencesMenuClassItems.
	messageItems notEmpty ifTrue:
		[messagesAndActions 
			add: #separator;
			addAll: messageItems].
	classItems notEmpty ifTrue:
		[messagesAndActions 
			add: #separator;
			addAll: classItems]. *)
	openMenuWithLabelsAndActions: messagesAndActions
)
'definition'
definition = (
	^row: {
		image: (iconForAccessModifier: subject slotAccessModifier).
		smallBlank.
		link: subject slotNameAndInitializerString action: [sendUp showHeaderEditor].
		filler.
		itemReferencesMenuButtonWithAction: [goToMessages].
		}
)
'private'
definitionText = (

	^subject slotDefinitionString
)
) : (
)
class SlotSubject onModel: m = Subject onModel: m ((*  *)| deleteResponse |) (
'accessing'
public acceptSlotDefinition: definitionString ifSuccess: successBlock0 ifFailure: failureBlock1 = (

	flag:: #BOGUS. (* do something! *)
	failureBlock1 value: 'Sorry, saving is not implemented yet'
)
definitionText = (

	^slotDefinitionString
)
slotDefinitionString = (

	^slotMirror source copy
)
slotInitializer = (

	^slotMirror initializer
)
slotMirror = (
(* A synonym of #model, for readability. *)

^model
)
public slotName = (
	^slotMirror name
)
public slotNameAndInitializerString ^<String> = (
	(* Answer a string that includes the name of the slot and some information from its initializer. The initializer information does not have to be complete; rather it should be formatted so as to look nice as a single line. *)

	| stream initializer |
	stream:: (String new: 30) writeStream.
	stream nextPutAll: slotMirror name.
	(* initializer:: slotMirror initializer.
	initializer notEmpty ifTrue:
		[stream nextPutAll: ' = ', (shorten: initializer toFirstCROrCharacters: 40)]. *)
	^stream contents
)
'as yet unclassified'
public slotAccessModifier = (

	^slotMirror accessModifier
)
'colorization'
colorizeSource: sourceText <Text | String> ^<Text> = (
^NS2BrowserColorizer new
	parseText: sourceText asString
	fromClass: model enclosingMixin
	usingSelector: #slotDef
)
'private'
public createPresenter = (

	^SlotPresenter onSubject: self
)
) : (
)
'as yet unclassified'
public classSubjectOn: cm <ClassDeclarationMirror> = (
	^cm hasBody
		ifTrue: [NormalClassSubject onModel: cm]
		ifFalse: [BodylessClassSubject onModel: cm]
)
) : (
)
