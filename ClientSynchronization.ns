Newspeak3
'OrthogonalSynchronization'
class ClientSynchronization usingPlatform: platform clientServer: clientServerModule = (
|
	private Smalltalk = 	platform squeak Smalltalk.
	WeakIdentityKeyMap = platform squeak WeakIdentityKeyDictionary.
	Map = platform collections Map.
	Set = platform collections Set.
	ObjectMirror = platform mirrors ObjectMirror.
	clientServerSync = clientServerModule.
|
) (
class ChangeAnalyzerResult newIds: newIdsMap changeLog: aChangeLogForServer = (
|
	public newObjectToLocalIds = newIdsMap.
	public changeLog = aChangeLogForServer.
	
|
) (
) : (
)
public class ChangeTrackingContext = (
|
	guidByObject = WeakIdentityKeyMap new.
	stateByObject = WeakIdentityKeyMap new.
	root

|
) (
class ChangeAnalyzer = (
|
	newObjectsIds
|
) (
changesForExistingObjects = (
	^ Array streamContents: [:stm |
		existingObjectAndStateDo: [:object :state |
			createChangeRecordFor: object
			 withState: state
			 ifNeeded:  [:changeRecord | stm nextPut: changeRecord] .
		].
	].	
)
computeNewObjectDefinitionsDo: definitionsAndIdsMapBlock  = (
	| objectToLocalIdMap newDefinitions |
	objectToLocalIdMap:: Map new.

	newDefinitions:: Array streamContents: [:stm |
		newObjectsIds keys do: [ :newObject  |

			| definitionWithId |
			definitionWithId::  (createObjectDefinitionWithIdFor: newObject).
			objectToLocalIdMap at: newObject put: definitionWithId id.
			stm nextPut: definitionWithId.
		].
	].	

	definitionsAndIdsMapBlock value: newDefinitions value: objectToLocalIdMap.
)
context  = (
	^ (ObjectMirror reflecting: self) getClass enclosingObject reflectee
)
createChangeRecordFor: anObject withState: initialState ifNeeded: newChangeRecordBlock = (	
	|  changesMap  |
	changesMap:: anObject isArray 
					ifTrue:  [ createChangesMapForArray: anObject withState: initialState]
					ifFalse: [ createChangesMapForRegularObject: anObject withState: initialState ].
	
	changesMap isEmpty 
		ifFalse:  [ 	newChangeRecordBlock value: (ObjectChangeRecord 
											for: (toExistingObjectReference: anObject) 
											withChanges: changesMap). 					].
)
createChangesMapForArray: anObject withState: initialState  = (
	| changesByIndex  |

	changesByIndex:: Map new.
	1 to: anObject size do:  [ :index |
		| content reference |
		content:: anObject at: index.
		reference:: initialState at: index.
		(reference refersTo: content inContext: context) ifFalse: 
			[ changesByIndex at: index put:  (toObjectReference: content)   ].
	].

	^ changesByIndex 
)
createChangesMapForRegularObject: anObject withState: initialState  = (
	| changesBySlot mirror |
	mirror:: ObjectMirror reflecting: anObject.	
	changesBySlot:: Map new.
	initialState keysAndValuesDo: [ :selector :val |
		| slotContent |
		slotContent:: (mirror getSlot: selector) reflectee. 
		(val refersTo: slotContent inContext:  context) ifFalse: [ 
			changesBySlot at: selector put:  (toObjectReference: slotContent)  
		].
	].

	^ changesBySlot 
)
createObjectDefinitionWithIdFor: anObject   = (	
	|  enclosingObject valuesBySlot definition newId   |
	valuesBySlot:: createObjectStateFor: anObject.
	enclosingObject:: enclosingObjectForClassOf: anObject.
	newId:: newObjectsIds at: anObject.

	definition:: ObjectDefinition 
		classNamed: (classNameFor: anObject) 
		enclosingObjectReference:  (toObjectReference: enclosingObject) 
		withContents: valuesBySlot.
		
	^ ObjectDefinitionWithIdentification id: newId definition: definition.  
)
createObjectStateFor: anObject  = (
	^ createObjectState: anObject newObjectFrom: [ :obj | newObjectReferenceFor: obj ]
)
discoverNewObjects = (
	traverseObjectsGraph: newObjectsIds keys visited: (Set withAll:  existingObjects)  do: [ :each |
		(isNew: each) ifTrue: [
			registerIdForNewObjectIfNeeded: each.
		].
	].
)
idForNewObject: anObject  = (
	registerIdForNewObjectIfNeeded: anObject.
	^ newObjectsIds at: anObject.
)
newObjectReferenceFor: anObject = (
	^ toNewObjectReferenceIdentifiedWith: (idForNewObject: anObject).
)
registerIdForNewObjectIfNeeded: anObject  = (
	| newId  existingIds |
	newId:: 1.
	existingIds:: newObjectsIds values.
	existingIds isEmpty ifFalse: [
		newId:: existingIds max + 1.
	].	
	
	^ newObjectsIds at: anObject ifAbsentPut: [ newId ].
)
toObjectReference: anObject = (
	^ toObjectReference: anObject newObjectFrom: [ :obj | newObjectReferenceFor: obj ] .	
)
traverseObjectsGraph: elements do: aBlock = (	
	traverseObjectsGraph: elements visited: Set new do: aBlock. 
)
traverseObjectsGraph: elements visited: visitedObjects do: aBlock = (
	(elements select: [:x | isIdentifiable: x]) do: [ :each |
		(visitedObjects includes: each) ifFalse: [
			visitedObjects add: each.
			aBlock value:  each. 
			slotsIn: each do: [:selector :content | 	
				(* discovered: content.  *)
	 			traverseObjectsGraph: {content} visited: visitedObjects do: aBlock.		
			].
			
		].	
	].
)
public value = (
	| detectedChanges  changeLog   |
	
	newObjectsIds:: Map new.

	detectedChanges:: changesForExistingObjects.
	discoverNewObjects. 
	computeNewObjectDefinitionsDo:
	 [ 
		:newObjectDefinitions :newObjectToLocalMap |
		changeLog:: ClientToServerChangeLog 
						withChanges: detectedChanges 
						withNewObjects: newObjectDefinitions.
						
		^ ChangeAnalyzerResult newIds: newObjectToLocalMap changeLog: changeLog. ].
)
) : (
)
class NewObjectReference toObjectIdentifiedWith: anIdentifier  = (
|
	public identifier = anIdentifier.
|
) (
public isKindOfNewObjectReference = (
	^ true
)
public referencedObjectFrom: anObjectStore = (
	^ anObjectStore objectWithLocalId: identifier.
)
) : (
)
classNameFor: anObject = (
	| mirror  |
	mirror:: ObjectMirror reflecting: anObject.
	^ mirror getClass  mixin name

)
createArrayState: anArray = (
	^ (anArray collect: 
		 [ :each |  toExistingObjectReference: each  ]) asArray.
)
createObjectState: anObject  = (
	^ createObjectState: anObject newObjectFrom: nil.
)
createObjectState: anObject newObjectFrom: newObjectBlock  = (
	
	anObject isArray ifTrue: 
		[ ^ createArrayState: anObject ].
	
	^ createRegularObjectState: anObject newObjectFrom: newObjectBlock
)
createRegularObjectState: anObject newObjectFrom: newObjectBlock = (
	|  valuesBySelector |
	valuesBySelector:: Map new.
	
	slotsIn: anObject do:  [ :selector :content |
		| objectReference |
		objectReference:: toObjectReference: content newObjectFrom: newObjectBlock .
		valuesBySelector at: selector put: objectReference.
	].
	^ valuesBySelector.
)
public detectChanges = (
	garbageCollect.
	^ ChangeAnalyzer new value.
)
enclosingObjectForClassOf: anObject = (
	| mirror  |
	mirror:: ObjectMirror reflecting: anObject.
	^ mirror getClass enclosingObject reflectee

)
existingObjectAndStateDo: aBlock = (
	stateByObject keysAndValuesDo: aBlock.
)
public existingObjects  = (
	^ guidByObject keys	
)
guidFor: anObject  = (
	^ guidByObject at: anObject.
)
public idForObject: anObject  = (
	^ guidByObject at: anObject.
)
public installNewObjectsFromIObjectToIdsMap: anIdsMap = (
	| allObjects |
		
	allObjects:: anIdsMap keys. 	
	allObjects do: [:each | guidByObject at: each put: (anIdsMap at: each) ].
	allObjects do: [:each | saveObjectState: each. ].
)
public installNewRoot: anObject identifiedBy: anIdsMap = (
	root:: anObject.
	installNewObjectsFromIObjectToIdsMap: anIdsMap.
)
public isIdentifiable: anObject  = (
	^ ({ #isKindOfInteger . #isKindOfString  . #isNil  } 
		anySatisfy:  [:selector | anObject perform:  selector ] ) not

)
isNew: anObject = (
	^ (isIdentifiable: anObject) and:
		[ (guidByObject includesKey: anObject) not ].
)
public isTracked: anObject = (
	^ guidByObject includesKey: anObject.
)
public objectById: anIdentifier = (
	^  objectById: anIdentifier ifNotFound: [ error].
)
public objectById: anIdentifier ifNotFound: notFoundBlock = (
	guidByObject keysAndValuesDo: [ :object :id | 
		(id = anIdentifier) ifTrue: [ ^ object].
	].

	^ notFoundBlock value.	
)
public objectWithGuid: anIdentifier = (
	^  objectById: anIdentifier.
)
saveObjectState: anObject  = (
	stateByObject at: anObject put: (createObjectState: anObject).
)
slotsIn: anObject do: selectorAndContentBlock = (
	| mirror valuesBySelector |
	mirror:: ObjectMirror reflecting: anObject.
	
	mirror getClass slots do:  [ :each |
		| selector  object|
		selector:: each name.
		object:: (mirror getSlot: selector) reflectee.
		selectorAndContentBlock value: selector value: object.
	].
)
toExistingObjectReference: anObject = (
	^ toObjectReference: anObject newObjectFrom: [:x | error]. 
)
toNewObjectReferenceIdentifiedWith: id  = (
	^  NewObjectReference toObjectIdentifiedWith: id.
)
toObjectReference: anObject newObjectFrom: newObjectBlock = (
	^ (isIdentifiable:  anObject) 
		ifTrue: [ 
			(isNew: anObject) 
				ifTrue: [ newObjectBlock value: anObject ]
				ifFalse: [ ObjectReference toObjectIdentifiedWith: (guidFor: anObject) ].
		]
		ifFalse: [ UnidentifiableObject for: anObject ].
)
public valuesForObject: anObject  = (
	^ stateByObject at: anObject.
)
) : (
)
public class ClientUpdater forContext: cto = (
|
	changeTrackingContext = cto.
|
) (
changeObjectsFrom:  changeRecords = (
	changeRecords do: [ :each | each applyChangesInContext: changeTrackingContext usingMirror: ObjectMirror ].  
)
installNewObjectsFromClientSideWithGuidFrom: clientChangesResult to: serverToClientChangeLog  = (
	| objectToIdMap | 

	objectToIdMap:: Map new.
	clientChangesResult newObjectToLocalIds keysAndValuesDo: [ :object :localId |
		  (serverToClientChangeLog  localToGlobalIds includesKey: localId) 
			ifTrue:  [ objectToIdMap at: object put: (serverToClientChangeLog  localToGlobalIds at: localId)   ].
	].
	changeTrackingContext installNewObjectsFromIObjectToIdsMap: objectToIdMap.
)
installNewObjectsFromServerFrom:  objectDefinitionsWithId  = (
	| materializer store |
	store:: TransientObjectStore forContext: changeTrackingContext.

	materializer:: ObjectsMaterializer objectStore: store. 
	materializer materializeObjectsFrom: objectDefinitionsWithId.
	store registerNewObjects.
	
)
public updateFrom: clientChangesResult to: serverToClientChangeLog  = (
	installNewObjectsFromClientSideWithGuidFrom: clientChangesResult to: serverToClientChangeLog .
	installNewObjectsFromServerFrom: serverToClientChangeLog newObjects. 
	changeObjectsFrom:  serverToClientChangeLog changeRecords. 
)
) : (
)
class ObjectsMaterializer objectStore: anObjectStore = (
|
	objectStore = anObjectStore.
|
) (
public materializeObjectsFrom: definitionsWithId = (
	|   newInstances |

	(* ensure every new object  gets instantiated (empty) but with an id *)
	definitionsWithId do: [:each | registerIfNeededObjectWithId: each id usingDefinitions: definitionsWithId ].
	
	newInstances::	definitionsWithId collect: [:each | 
			| newInstance newInstanceMirror |
			newInstance:: objectStore objectWithGuid: each id .
			newInstanceMirror:: ObjectMirror reflecting: newInstance.
			each definition fill: newInstanceMirror resolvingReferencesWith: objectStore.
	].

	^ newInstances.	
)
registerIfNeededObjectWithId: anId usingDefinitions: definitions = (

	(objectStore containsObjectWithId: anId) ifFalse: [
		| definitionWithId definition enclosingObjectMirror newInstance |
		definitionWithId:: definitions detect: [:each | each id = anId].
		definition:: definitionWithId definition.
		registerIfNeededObjectWithId: definition enclosingObjectReference identifier usingDefinitions: definitions.

		enclosingObjectMirror:: ObjectMirror reflecting:  (objectStore objectWithGuid: definition enclosingObjectReference identifier).		
		newInstance:: definitionWithId definition createEmptyInstanceUsingEnclosingObjectMirror: enclosingObjectMirror.
		objectStore registerObject: newInstance identifiedWith: definitionWithId id.
	].

	^ objectStore objectWithGuid: anId.

)
) : (
)
public class ServerUpdater forContext: cto = (
|
	changeTrackingContext = cto.|
) (
) : (
)
class TransientObjectStore forContext: aTrackingContext = (
|
	changeTrackingContext = aTrackingContext.
	newObjectsByGuid = Map new.
|
) (
public containsObjectWithId: anIdentifier = (
	changeTrackingContext objectById: anIdentifier ifNotFound: [
		^newObjectsByGuid includesKey: anIdentifier.
	].
	^true 
)
public objectWithGuid: anIdentifier = (
	^ changeTrackingContext objectById: anIdentifier ifNotFound: [
		newObjectsByGuid at: anIdentifier.
	]. 
)
public objectWithLocalId: anIdentifier = (
	subclassResponsibility
)
public registerNewObjects = (
	changeTrackingContext installNewObjectsFromIObjectToIdsMap: (reverseLookup: newObjectsByGuid). 
)
public registerObject: anObject identifiedWith: id = (
	newObjectsByGuid at: id put: anObject.
)
reverseLookup: aMap = (
	| newMap |
	newMap:: Map new.
	
	aMap keysAndValuesDo: [ :k :v | newMap at: v put: k].
	^newMap
)
) : (
)
ClientToServerChangeLog = (
	^ clientServerSync ClientToServerChangeLog.
)
ObjectChangeRecord = (
	^ clientServerSync ObjectChangeRecord.
)
ObjectDefinition = (
	^ clientServerSync ObjectDefinition.
)
ObjectDefinitionWithIdentification = (
	^ clientServerSync ObjectDefinitionWithIdentification.
)
ObjectReference = (
	^ clientServerSync ObjectReference.
)
UnidentifiableObject = (
	^ clientServerSync UnidentifiableObject.
)
garbageCollect  = (
	Smalltalk garbageCollect. 
)
) : (
)
