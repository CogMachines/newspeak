Newspeak3
'OrthogonalSynchronization'
class ClientSynchronization usingPlatform: platform clientServer: clientServerModule = (
|
	private Smalltalk = 	platform squeak Smalltalk.
	WeakIdentityKeyMap = platform squeak WeakIdentityKeyDictionary.
	Map = platform collections Map.
	Set = platform collections Set.
	ObjectMirror = platform mirrors ObjectMirror.
	clientServerSync = clientServerModule.
|
) (
public class ChangeTrackingContext = (
|
	guidByObject = WeakIdentityKeyMap new.
	stateByObject = WeakIdentityKeyMap new.
	root

|
) (
class ChangeAnalyzer = (
|
	newObjectsIds
|
) (
changesForExistingObjects = (
	^ Array streamContents: [:stm |
		existingObjectAndStateDo: [:object :state |
			createChangeRecordFor: object
			 withState: state
			 ifNeeded:  [:changeRecord | stm nextPut: changeRecord] .
		].
	].	
)
computeNewObjectsRecords = (
	^ Array streamContents: [:stm |
		newObjectsIds keys do: [:newObject |
			stm nextPut: (createChangeRecordForNewObject: newObject). 
		].
	].	
)
createChangeRecordFor: anObject withState: initialState ifNeeded: newChangeRecordBlock = (	
	|  changesMap  |
	changesMap:: anObject isArray 
					ifTrue:  [ createChangesMapForArray: anObject withState: initialState]
					ifFalse: [ createChangesMapForRegularObject: anObject withState: initialState ].
	
	changesMap isEmpty 
		ifFalse:  [ 	newChangeRecordBlock value: (ObjectChangeRecord 
											for: (toExistingObjectReference: anObject) 
											withChanges: changesMap). 					].
)
createChangeRecordForNewObject: anObject   = (	
	|  valuesBySlot newIdBlock |
	newIdBlock:: [:obj | idForNewObject: obj].
	valuesBySlot:: createObjectStateFor: anObject.
	^ (ObjectChangeRecord 
						for: (newObjectReferenceFor: anObject)  
						withChanges: valuesBySlot). 	 
)
createChangesMapForArray: anObject withState: initialState  = (
	| changesByIndex  |

	changesByIndex:: Map new.
	1 to: anObject size do:  [ :index |
		| content reference |
		content:: anObject at: index.
		reference:: initialState at: index.
		(reference refersTo: content) ifFalse: 
			[ changesByIndex at: index put:  (toObjectReference: content)   ].
	].

	^ changesByIndex 
)
createChangesMapForRegularObject: anObject withState: initialState  = (
	| changesBySlot mirror |
	mirror:: ObjectMirror reflecting: anObject.	
	changesBySlot:: Map new.
	initialState keysAndValuesDo: [ :selector :val |
		| slotContent |
		slotContent:: (mirror getSlot: selector) reflectee. 
		(val refersTo: slotContent) ifFalse: [ 
			changesBySlot at: selector put:  (toObjectReference: slotContent)  
		].
	].

	^ changesBySlot 
)
createObjectStateFor: anObject  = (
	^ createObjectState: anObject newObjectFrom: [ :obj | newObjectReferenceFor: obj ]
)
discoverNewObjects = (
	traverseObjectsGraph: newObjectsIds keys visited: (Set withAll:  existingObjects)  do: [ :each |
		(isNew: each) ifTrue: [
			registerIdForNewObjectIfNeeded: each.
		].
	].
)
idForNewObject: anObject  = (
	registerIdForNewObjectIfNeeded: anObject.
	^ newObjectsIds at: anObject.
)
newObjectReferenceFor: anObject = (
	^ toNewObjectReferenceIdentifiedWith: (idForNewObject: anObject).
)
registerIdForNewObjectIfNeeded: anObject  = (
	| newId  existingIds |
	newId:: 1.
	existingIds:: newObjectsIds values.
	existingIds isEmpty ifFalse: [
		newId:: existingIds max + 1.
	].	
	
	^ newObjectsIds at: anObject ifAbsentPut: [ newId ].
)
toObjectReference: anObject = (
	^ toObjectReference: anObject newObjectFrom: [ :obj | newObjectReferenceFor: obj ] .	
)
traverseObjectsGraph: elements do: aBlock = (	
	traverseObjectsGraph: elements visited: Set new do: aBlock. 
)
traverseObjectsGraph: elements visited: visitedObjects do: aBlock = (
	(elements select: [:x | isIdentifiable: x]) do: [ :each |
		(visitedObjects includes: each) ifFalse: [
			visitedObjects add: each.
			aBlock value:  each. 
			slotsIn: each do: [:selector :content | 	
				(* discovered: content.  *)
	 			traverseObjectsGraph: {content} visited: visitedObjects do: aBlock.		
			].
			
		].	
	].
)
public value = (
	| detectedChanges newObjectRecords   |
	
	newObjectsIds:: Map new.

	detectedChanges:: changesForExistingObjects.
	discoverNewObjects. 
	newObjectRecords:: computeNewObjectsRecords.

	^ ClientToServerChangeLog withChanges: detectedChanges withNewObjects: newObjectRecords.
)
) : (
)
class NewObjectReference toObjectIdentifiedWith: anIdentifier  = (
|
	identifier = anIdentifier.
|
) (
) : (
)
class ObjectChangeRecord for: anObjectReference withChanges: valuesBySlot  = (
|
	public objectReference =anObjectReference.
	public changes = valuesBySlot.
|) (
public refersTo: anObject = (
	^ objectReference refersTo: anObject.
)
) : (
)
class ObjectReference toObjectIdentifiedWith: anIdentifier = (
|
	identifier = anIdentifier.
|
) (
public isKindOfObjectReference = (
	^ true
)
public refersTo: anObject = (
	^( isIdentifiable: anObject) and: 
		  [ (isTracked: anObject) and:		
			[identifier = (idForObject: anObject)] ]. 
)
) : (
)
class UnidentifiableObject for: aValue = (
|
	value = aValue.
|
) (
public refersTo: anObject = (
	^ value = anObject.
)
) : (
)
createArrayState: anArray = (
	^ (anArray collect: 
		 [ :each |  toExistingObjectReference: each  ]) asArray.
)
createObjectState: anObject  = (
	^ createObjectState: anObject newObjectFrom: nil.
)
createObjectState: anObject newObjectFrom: newObjectBlock  = (
	
	anObject isArray ifTrue: 
		[ ^ createArrayState: anObject ].
	
	^ createRegularObjectState: anObject newObjectFrom: newObjectBlock
)
createRegularObjectState: anObject newObjectFrom: newObjectBlock = (
	|  valuesBySelector |
	valuesBySelector:: Map new.
	
	slotsIn: anObject do:  [ :selector :content |
		| objectReference |
		objectReference:: toObjectReference: content newObjectFrom: newObjectBlock .
		valuesBySelector at: selector put: objectReference.
	].
	^ valuesBySelector.
)
public detectChanges = (
	garbageCollect.
	^ ChangeAnalyzer new value.
)
existingObjectAndStateDo: aBlock = (
	stateByObject keysAndValuesDo: aBlock.
)
public existingObjects  = (
	^ guidByObject keys	
)
guidFor: anObject  = (
	^ guidByObject at: anObject.
)
public idForObject: anObject  = (
	^ guidByObject at: anObject.
)
public installNewRoot: anObject identifiedBy: anIdsMap = (
	| allObjects |
	root:: anObject.
	
	allObjects:: anIdsMap keys. 	
	allObjects do: [:each | guidByObject at: each put: (anIdsMap at: each) ].
	allObjects do: [:each | saveObjectState: each. ].
)
isIdentifiable: anObject  = (
	^ ({ #isKindOfInteger . #isKindOfString  . #isNil  } 
		anySatisfy:  [:selector | anObject perform:  selector ] ) not

)
isNew: anObject = (
	^ (isIdentifiable: anObject) and:
		[ (guidByObject includesKey: anObject) not ].
)
public isTracked: anObject = (
	^ guidByObject includesKey: anObject.
)
saveObjectState: anObject  = (
	stateByObject at: anObject put: (createObjectState: anObject).
)
slotsIn: anObject do: selectorAndContentBlock = (
	| mirror valuesBySelector |
	mirror:: ObjectMirror reflecting: anObject.
	
	mirror getClass slots do:  [ :each |
		| selector  object|
		selector:: each name.
		object:: (mirror getSlot: selector) reflectee.
		selectorAndContentBlock value: selector value: object.
	].
)
toExistingObjectReference: anObject = (
	^ toObjectReference: anObject newObjectFrom: [:x | error]. 
)
toNewObjectReferenceIdentifiedWith: id  = (
	^  NewObjectReference toObjectIdentifiedWith: id.
)
toObjectReference: anObject newObjectFrom: newObjectBlock = (
	^ (isIdentifiable:  anObject) 
		ifTrue: [ 
			(isNew: anObject) 
				ifTrue: [ newObjectBlock value: anObject ]
				ifFalse: [ ObjectReference toObjectIdentifiedWith: (guidFor: anObject) ].
		]
		ifFalse: [ UnidentifiableObject for: anObject ].
)
public valuesForObject: anObject  = (
	^ stateByObject at: anObject.
)
) : (
)
ClientToServerChangeLog = (
	^ clientServerSync ClientToServerChangeLog.
)
garbageCollect  = (
	Smalltalk garbageCollect. 
)
) : (
)
