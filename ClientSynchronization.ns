Newspeak3
'OrthogonalSynchronization'
class ClientSynchronization usingPlatform: platform clientServer: clientServerModule = (
|
	private Smalltalk = 	platform squeak Smalltalk.
	WeakIdentityKeyMap = platform squeak WeakIdentityKeyDictionary.
	Map = platform collections Map.
	Set = platform collections Set.
	ObjectMirror = platform mirrors ObjectMirror.
	clientServerSync = clientServerModule.
|
) (
class ChangeAnalyzerResult newIds: newIdsMap changeLog: aChangeLogForServer = (
|
	public newObjectToLocalIds = newIdsMap.
	public changeLog = aChangeLogForServer.
	
|
) (
) : (
)
public class ChangeTrackingContext = (
|
	guidByObject = WeakIdentityKeyMap new.
	stateByObject = WeakIdentityKeyMap new.
	root

|
) (
class ChangeAnalyzer = (
|
	newObjectsIds
|
) (
changesForExistingObjects = (
	^ Array streamContents: [:stm |
		existingObjectAndStateDo: [:object :state |
			createChangeRecordFor: object
			 withState: state
			 ifNeeded:  [:changeRecord | stm nextPut: changeRecord] .
		].
	].	
)
computeNewObjectDefinitionsDo: definitionsAndIdsMapBlock  = (
	| objectToLocalIdMap newDefinitions |
	objectToLocalIdMap:: Map new.

	newDefinitions:: Array streamContents: [:stm |
		newObjectsIds keys do: [ :newObject  |

			| definitionWithId |
			definitionWithId::  (createObjectDefinitionWithIdFor: newObject).
			objectToLocalIdMap at: newObject put: definitionWithId id.
			stm nextPut: definitionWithId.
		].
	].	

	definitionsAndIdsMapBlock value: newDefinitions value: objectToLocalIdMap.
)
context  = (
	^ (ObjectMirror reflecting: self) getClass enclosingObject reflectee
)
createChangeRecordFor: anObject withState: initialState ifNeeded: newChangeRecordBlock = (	
	|  changesMap  |
	changesMap:: anObject isArray 
					ifTrue:  [ createChangesMapForArray: anObject withState: initialState]
					ifFalse: [ createChangesMapForRegularObject: anObject withState: initialState ].
	
	changesMap isEmpty 
		ifFalse:  [ 	newChangeRecordBlock value: (ObjectChangeRecord 
											for: (toExistingObjectReference: anObject) 
											withChanges: changesMap). 					].
)
createChangesMapForArray: anObject withState: initialState  = (
	| changesByIndex  |

	changesByIndex:: Map new.
	1 to: anObject size do:  [ :index |
		| content reference |
		content:: anObject at: index.
		reference:: initialState at: index.
		(reference refersTo: content inContext: context) ifFalse: 
			[ changesByIndex at: index put:  (toObjectReference: content)   ].
	].

	^ changesByIndex 
)
createChangesMapForRegularObject: anObject withState: initialState  = (
	| changesBySlot mirror |
	mirror:: ObjectMirror reflecting: anObject.	
	changesBySlot:: Map new.
	initialState keysAndValuesDo: [ :selector :val |
		| slotContent |
		slotContent:: (mirror getSlot: selector) reflectee. 
		(val refersTo: slotContent inContext:  context) ifFalse: [ 
			changesBySlot at: selector put:  (toObjectReference: slotContent)  
		].
	].

	^ changesBySlot 
)
createObjectDefinitionWithIdFor: anObject   = (	
	|  enclosingObject valuesBySlot definition newId   |
	valuesBySlot:: createObjectStateFor: anObject.
	enclosingObject:: enclosingObjectForClassOf: anObject.
	newId:: newObjectsIds at: anObject.

	definition:: ObjectDefinition 
		classNamed: (classNameFor: anObject) 
		enclosingObjectReference:  (toObjectReference: enclosingObject) 
		withContents: valuesBySlot.
		
	^ ObjectDefinitionWithIdentification id: newId definition: definition.  
)
createObjectStateFor: anObject  = (
	^ createObjectState: anObject newObjectFrom: [ :obj | newObjectReferenceFor: obj ]
)
discoverNewObjects = (
	traverseObjectsGraph: newObjectsIds keys visited: (Set withAll:  existingObjects)  do: [ :each |
		(isNew: each) ifTrue: [
			registerIdForNewObjectIfNeeded: each.
		].
	].
)
idForNewObject: anObject  = (
	registerIdForNewObjectIfNeeded: anObject.
	^ newObjectsIds at: anObject.
)
newObjectReferenceFor: anObject = (
	^ toNewObjectReferenceIdentifiedWith: (idForNewObject: anObject).
)
registerIdForNewObjectIfNeeded: anObject  = (
	| newId  existingIds |
	newId:: 1.
	existingIds:: newObjectsIds values.
	existingIds isEmpty ifFalse: [
		newId:: existingIds max + 1.
	].	
	
	^ newObjectsIds at: anObject ifAbsentPut: [ newId ].
)
toObjectReference: anObject = (
	^ toObjectReference: anObject newObjectFrom: [ :obj | newObjectReferenceFor: obj ] .	
)
traverseObjectsGraph: elements do: aBlock = (	
	traverseObjectsGraph: elements visited: Set new do: aBlock. 
)
traverseObjectsGraph: elements visited: visitedObjects do: aBlock = (
	(elements select: [:x | isIdentifiable: x]) do: [ :each |
		(visitedObjects includes: each) ifFalse: [
			visitedObjects add: each.
			aBlock value:  each. 
			slotsIn: each do: [:selector :content | 	
				(* discovered: content.  *)
	 			traverseObjectsGraph: {content} visited: visitedObjects do: aBlock.		
			].
			
		].	
	].
)
public value  = (
	| detectedChanges  changeLog   |
	
	newObjectsIds:: Map new.

	detectedChanges:: changesForExistingObjects.
	discoverNewObjects. 
	computeNewObjectDefinitionsDo:
	 [ 
		:newObjectDefinitions :newObjectToLocalMap |
		changeLog:: ClientToServerChangeLog 
						withChanges: detectedChanges 
						withNewObjects: newObjectDefinitions.
						
		^ ChangeAnalyzerResult newIds: newObjectToLocalMap changeLog: changeLog. ].
)
) : (
)
classNameFor: anObject = (
	| mirror  |
	mirror:: ObjectMirror reflecting: anObject.
	^ mirror getClass  mixin name

)
createArrayState: anArray = (
	^ (anArray collect: 
		 [ :each |  toExistingObjectReference: each  ]) asArray.
)
public createObjectDefinitionWithIdForExisting: anObject   = (	
	|  enclosingObject valuesBySlot definition id   |
	valuesBySlot:: stateByObject at: anObject.
	enclosingObject:: enclosingObjectForClassOf: anObject.
	id:: idForObject: anObject.

	definition:: ObjectDefinition 
		classNamed: (classNameFor: anObject) 
		enclosingObjectReference:  (toExistingObjectReference: enclosingObject) 
		withContents: valuesBySlot.
		
	^ ObjectDefinitionWithIdentification id: id definition: definition.  
)
createObjectState: anObject  = (
	^ createObjectState: anObject newObjectFrom: nil.
)
createObjectState: anObject newObjectFrom: newObjectBlock  = (
	
	anObject isArray ifTrue: 
		[ ^ createArrayState: anObject ].
	
	^ createRegularObjectState: anObject newObjectFrom: newObjectBlock
)
createRegularObjectState: anObject newObjectFrom: newObjectBlock = (
	|  valuesBySelector |
	valuesBySelector:: Map new.
	
	slotsIn: anObject do:  [ :selector :content |
		| objectReference |
		objectReference:: toObjectReference: content newObjectFrom: newObjectBlock .
		valuesBySelector at: selector put: objectReference.
	].
	^ valuesBySelector.
)
public detectChanges = (
	garbageCollect.
	^ ChangeAnalyzer new value.
)
enclosingObjectForClassOf: anObject = (
	| mirror  |
	mirror:: ObjectMirror reflecting: anObject.
	^ mirror getClass enclosingObject reflectee

)
existingObjectAndStateDo: aBlock = (
	stateByObject keysAndValuesDo: aBlock.
)
public existingObjects  = (
	^ guidByObject keys	
)
guidFor: anObject  = (
	^ guidByObject at: anObject.
)
public idForObject: anObject  = (
	^ guidByObject at: anObject.
)
public installNewObjectsFromIObjectToIdsMap: anIdsMap = (
	| allObjects |
		
	allObjects:: anIdsMap keys. 	
	allObjects do: [:each | guidByObject at: each put: (anIdsMap at: each) ].
	allObjects do: [:each | saveObjectState: each. ].
)
public installNewRoot: anObject identifiedBy: anIdsMap = (
	root:: anObject.
	installNewObjectsFromIObjectToIdsMap: anIdsMap.
)
public isIdentifiable: anObject  = (
	^ ({ #isKindOfInteger . #isKindOfString  . #isNil  } 
		anySatisfy:  [:selector | anObject perform:  selector ] ) not

)
isNew: anObject = (
	^ (isIdentifiable: anObject) and:
		[ (guidByObject includesKey: anObject) not ].
)
public isTracked: anObject = (
	^ guidByObject includesKey: anObject.
)
public isTrackingObjectWithId: anId  = (
	objectById: anId ifNotFound: [ ^ false].
	^ true.
)
public objectById: anIdentifier = (
	^  objectById: anIdentifier ifNotFound: [ error].
)
public objectById: anIdentifier ifNotFound: notFoundBlock = (
	guidByObject keysAndValuesDo: [ :object :id | 
		(id = anIdentifier) ifTrue: [ ^ object].
	].

	^ notFoundBlock value.	
)
public objectWithGuid: anIdentifier = (
	^  objectById: anIdentifier.
)
saveObjectState: anObject  = (
	stateByObject at: anObject put: (createObjectState: anObject).
)
slotsIn: anObject do: selectorAndContentBlock = (
	| mirror valuesBySelector |
	mirror:: ObjectMirror reflecting: anObject.
	
	mirror getClass slots do:  [ :each |
		| selector  object|
		selector:: each name.
		object:: (mirror getSlot: selector) reflectee.
		selectorAndContentBlock value: selector value: object.
	].
)
toExistingObjectReference: anObject = (
	^ toObjectReference: anObject newObjectFrom: [:x | error]. 
)
toNewObjectReferenceIdentifiedWith: id  = (
	^  NewObjectReference toObjectIdentifiedWith: id.
)
toObjectReference: anObject newObjectFrom: newObjectBlock = (
	^ (isIdentifiable:  anObject) 
		ifTrue: [ 
			(isNew: anObject) 
				ifTrue: [ newObjectBlock value: anObject ]
				ifFalse: [ ObjectReference toObjectIdentifiedWith: (guidFor: anObject) ].
		]
		ifFalse: [ UnidentifiableObject for: anObject ].
)
public valuesForObject: anObject  = (
	^ stateByObject at: anObject.
)
) : (
)
public class ClientUpdater materializingObjectsWith: aMaterializerFactory forContext: cto endPoint: anEndPoint= (
|
	changeTrackingContext = cto.
	endPoint = anEndPoint.
	materializerFactory = aMaterializerFactory.
|
) (
applyChangesFrom:  changeRecords in: aStore = (
	changeRecords do: [ :each | each applyChangesIn: aStore usingMirror: ObjectMirror ].   
)
applyClientChangesFrom:  changeRecords in: aStore = (
	
	| storeVersion |
	storeVersion:: changeTrackingContext. 
	
	changeRecords do: [ :each | 
		| globalChangeRecord  previousVersion   |
		
		globalChangeRecord:: each asGlobalReferenceUsing: aStore. 
		previousVersion:: storeVersion parentVersion versionById: globalChangeRecord objectReference identifier.
		 storeVersion addObjectVersionWithParent: previousVersion versionedData: globalChangeRecord.

	].   
)
createStoreForGlobalNewObjects = (
	^ ObjectStoreWithGlobalNewObjects forContext: changeTrackingContext.
)
createStoreForLocalNewObjects = (
	^ ObjectStoreWithLocalNewObjects forStoreVersion: changeTrackingContext newGuidBlock: [ endPoint generateNextGuid ].
)
installLocalObjectsWithGuidUsing: clientChangesResult mappingGlobalsWith: serverToClientChangeLog  = (
	| objectToIdMap | 

	objectToIdMap:: Map new.
	clientChangesResult newObjectToLocalIds keysAndValuesDo: [ :object :localId |
		  (serverToClientChangeLog  localToGlobalIds includesKey: localId) 
			ifTrue:  [ objectToIdMap at: object put: (serverToClientChangeLog  localToGlobalIds at: localId)   ].
	].
	changeTrackingContext installNewObjectsFromIObjectToIdsMap: objectToIdMap.
)
installNewObjectsFromDefinitions:  objectDefinitionsWithId usingStore: aStore  = (
	| materializer |
	materializer:: materializerFactory value: aStore. 
	materializer materializeObjectsFrom: objectDefinitionsWithId.
	aStore registerNewObjects.
)
public updateFrom: clientChangesResult to: serverToClientChangeLog  = (
	| store |

	installLocalObjectsWithGuidUsing: clientChangesResult mappingGlobalsWith: serverToClientChangeLog.

	store:: createStoreForGlobalNewObjects.
	installNewObjectsFromDefinitions: serverToClientChangeLog newObjects usingStore: store. 
	applyChangesFrom:  serverToClientChangeLog changeRecords in: changeTrackingContext.  
)
public updateServerFrom: clientToServerChangeLog = (
	| store  |

	store:: createStoreForLocalNewObjects.
	installNewObjectsFromDefinitions: clientToServerChangeLog newObjectsDefinitions usingStore: store. 
	applyClientChangesFrom:  clientToServerChangeLog changeRecords in: store.  
	^ store localToGuidMap
	
)
) : (
)
class DefinitionsToObjectsMaterializer objectStore: aStore  = ObjectsMaterializer objectStore: aStore (
|

|
) (
createInstanceFrom: definitionWithId = (
	| newInstance enclosingObjectMirror |

	enclosingObjectMirror:: ObjectMirror reflecting:  (definitionWithId definition enclosingObjectReference  referencedObjectFrom: objectStore).		
	newInstance:: definitionWithId definition createEmptyInstanceUsingEnclosingObjectMirror: enclosingObjectMirror.
	 ^  newInstance
)
fillNewInstance: anInstance fromDefinition: aDefinition = (
	| newInstanceMirror |

	newInstanceMirror:: ObjectMirror reflecting: anInstance.
	aDefinition  fill: newInstanceMirror resolvingReferencesWith: objectStore.
)
) : (
)
class ObjectStoreWithGlobalNewObjects forContext: aTrackingContext  = TransientObjectStore  (
|
	changeTrackingContext = aTrackingContext.
	newObjectsByGuid = Map new.
|
) (
public containsNewObjectWithId: anId  = (
	^  newObjectsByGuid includesKey: anId.
)
public containsObjectWithGuid: anIdentifier = (
	changeTrackingContext objectById: anIdentifier ifNotFound: [
		^ newObjectsByGuid includesKey: anIdentifier.
	].

	^ true 
)
public newObjectWithId: anId  = (
	^  newObjectsByGuid at: anId.

)
public objectWithGuid: anIdentifier = (
	^ changeTrackingContext objectById: anIdentifier ifNotFound: [
		newObjectsByGuid at: anIdentifier.
	]. 
)
public registerNewObjects = (
	changeTrackingContext installNewObjectsFromIObjectToIdsMap: (reverseLookup: newObjectsByGuid). 
)
public registerObject: anObject identifiedWith: id = (
 	newObjectsByGuid at: id put: anObject.
)
) : (
)
class ObjectStoreWithLocalNewObjects forStoreVersion: aStoreVersion newGuidBlock: aNewGuidBlock = TransientObjectStore  (
|
	storeVersion = aStoreVersion.
	newObjectsByLocal = Map new.
	newGuidBlock = aNewGuidBlock.
|
) (
public containsNewObjectWithId: anId  = (
	^ newObjectsByLocal includesKey: anId.

)
public containsObjectWithGuid: anIdentifier = (
	changeTrackingContext objectById: anIdentifier ifNotFound: [
		^ false.
	].
	^true 
)
public guidForLocal: aLocalId = (
	^ localToGuidMap at: aLocalId.
)
public localToGuidMap = (
	| newMap |
	newMap:: Map new.
	newObjectsByLocal keysAndValuesDo: [ :localId :object | newMap at: localId put: object principalId   ].	

	^ newMap
)
public newGuid = (
	^ newGuidBlock value.
)
public newObjectWithId: anId  = (
	^  newObjectsByLocal at: anId.

)
public objectWithGuid: anIdentifier = (
	^ storeVersion versionById: anIdentifier .
)
public registerNewObjects = (

	newObjectsByLocal values do: [ :object  | storeVersion addObjectVersion:  object .  ].
	
)
public registerObject: anObject identifiedWith: id = (
 	newObjectsByLocal at: id put: anObject.
)
) : (
)
public class ObjectsMaterializer objectStore: anObjectStore = (
|
	objectStore = anObjectStore.
|
) (
createInstanceFrom:   definitionWithId = (
	subclassResponsibility.

)
fillNewInstance: anInstance fromDefinition: aDefinition = (
	subclassResponsibility.
)
public materializeObjectsFrom: definitionsWithId = (
	|  newInstances |

	(* ensure every new object  gets instantiated (empty) but with an id *)
	definitionsWithId do: [:each | registerIfNeededObjectWithId:  each id usingDefinitions: definitionsWithId ].
	
	newInstances::	definitionsWithId collect: [:each | 
			| newInstance  |
			newInstance:: objectStore newObjectWithId: each id .  
			fillNewInstance: newInstance fromDefinition: each definition.
	].

	^ newInstances.	
)
registerIfNeededObjectWithId: anId usingDefinitions: definitions = (

	(objectStore containsNewObjectWithId: anId) ifFalse: [
		| definitionWithId definition newInstance  |
		definitionWithId:: definitions detect: [:each | each id = anId  ].
		definition:: definitionWithId definition.
		definition enclosingObjectReference isKindOfNewObjectReference ifTrue: [
			registerIfNeededObjectWithId: definition enclosingObjectReference identifier  usingDefinitions: definitions.
		].
	
		newInstance:: createInstanceFrom: definitionWithId. 
		objectStore registerObject: newInstance identifiedWith: definitionWithId id.	
	
	].
)
) : (
)
public class StoreClient  = (
|
	public cto = ChangeTrackingContext new.
	public currentVersion
|
) (
createClientUpdater = (
	^ ClientUpdater materializingObjectsWith: [ :aStore |  DefinitionsToObjectsMaterializer objectStore: aStore  ] forContext: cto endPoint: nil.
)
public idForObject: anObject = (
	^ cto idForObject: anObject
)
public isTracked: anObject = (
	^ cto isTracked: anObject
)
public objectById: anId = (
	 ^ cto objectById: anId.
)
public synchronizeWithServer: aServer  = (
	| detectedChanges serverResponse clientUpdater |
	detectedChanges:: cto detectChanges.
	detectedChanges changeLog versionId: currentVersion.
	
	serverResponse:: aServer synchronize: detectedChanges changeLog.
	
	clientUpdater::  createClientUpdater.
	clientUpdater updateFrom: detectedChanges to: serverResponse.
	currentVersion:: serverResponse versionId.
)
) : (
)
class TransientObjectStore    = (
|
|	
) (
public containsNewObjectWithId: anId  = (
	subclassResponsibility
)
public containsObjectWithGuid: anIdentifier = (
	subclassResponsibility
)
public newObjectWithId: anId  = (
	subclassResponsibility
)
public objectWithGuid: anIdentifier = (
	subclassResponsibility
)
public registerNewObjects = (
	subclassResponsibility
)
public registerObject: anObject identifiedWith: id = (
	subclassResponsibility
				
)
reverseLookup: aMap = (
	| newMap |
	newMap:: Map new.
	
	aMap keysAndValuesDo: [ :k :v | newMap at: v put: k].
	^newMap
)
) : (
)
ClientToServerChangeLog = (
	^ clientServerSync ClientToServerChangeLog.
)
NewObjectReference = (
	^ clientServerSync NewObjectReference.
)
ObjectChangeRecord = (
	^ clientServerSync ObjectChangeRecord.
)
ObjectDefinition = (
	^ clientServerSync ObjectDefinition.
)
ObjectDefinitionWithIdentification = (
	^ clientServerSync ObjectDefinitionWithIdentification.
)
ObjectReference = (
	^ clientServerSync ObjectReference.
)
ServerToClientChangeLog = (
	^ clientServerSync ServerToClientChangeLog.
)
UnidentifiableObject = (
	^ clientServerSync UnidentifiableObject.
)
garbageCollect  = (
	Smalltalk garbageCollect. 
)
) : (
)
