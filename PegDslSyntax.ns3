Newspeak3
'NS2 Combinatorial Parsing'
class PegDslSyntax parserLib: parsers = (
"A grammar for an EBNF/PEG style notation."|
"imports"
  ExecutableGrammar = parsers ExecutableGrammar.
  CollectingCommentParser = parsers CollectingCommentParser.
 
  PredicateTokenParser = parsers PredicateTokenParser.
|)
(
class Grammar = ExecutableGrammar (|
"Lexical rules"

whitespace = super whitespace. "cache whitespace parser"
colon =  tokenFromChar: $:.
lparen = tokenFromChar: $(.
plus = tokenFromChar: $+.
questionMark = tokenFromChar: $?.
rparen = tokenFromChar: $).
semicolon = tokenFromChar: $;.
star = tokenFromChar: $*.
tilde = tokenFromChar: $~.
vbar = tokenFromChar: $|.
digit = charBetween: $0 and: $9.
letter = PredicateTokenParser new accept:[:c | c isLetter]
                                                      errorMsg: 'letter expected'.

id =  (letter | _),  ((letter | digit | _)) star
                 wrapper:[:fst   :snd  | fst asString, (String withAll: snd)].
                                           
identifier =  tokenFor: id.

str = (char: $' ),
           stringBody,
                   "[(character | [aWhitespaceChar] | (char: $" ") | twoQuotes) star],"
          (char: $')
              wrapper:[:oq :es :eq | es inject:'' into:[:s : e | s, e asString]].
 
string = tokenFor: str.

"Syntactic productions"

grammar = production star.

production = identifier, colon,  rhs, semicolon.

rhs = alternation | sequence.

alternation = rhs, vbar, rhs.

sequence = sequent plus.

sequent = negation | atom.

negation = tilde, atom.

atom = (parenthesizedProduction | productionName | string), modifier opt.

productionName = identifier.

modifier = plus | star | questionMark.

parenthesizedProduction = rparen, rhs, lparen.
|)
('as yet unclassified'
_ = (
	^char: $_
)
stringBody = (


"As an optimization, we process the body of a string with a dedicated scanning parser.
It should be equivalent to:

  ^(self character | self aWhitespaceChar | (self char: $"" ) | self twoQuotes) star"
^CollectingCommentParser new 
   termBlock:[: input | | c|
                c: input peek.
                c isNil 
                    ifTrue:[false] "let main routine handle end of input"
                    ifFalse:[c = $' 
                              ifFalse:[false]
                              ifTrue:[| pos | 
                                       pos: input position.
                                       input next.
                                       input peek = $' ifTrue:[false] ifFalse:[input position: pos. true]
                                     ]
                             ]
               ]
)) : ()) : ()