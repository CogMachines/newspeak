Newspeak3
'NS2V8'
class NS2V8ApplicationPackaging packageUsing: ns = ((* An app for the Newspeak-to-JavaScript compiler.

Derived from Newspeak2DartApplicationPackaging.

Copyright 2012 SAP AG.
Copyright 2012 Google Inc.
Copyright 2013 Ryan Macnak

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
	CombinatorialParsing = ns NS2CombinatorialParsing CombinatorialParsing.
	Grammar = ns NewspeakGrammar.
	ASTs = ns NewspeakASTs.
	Parsing = ns NewspeakParsing.
	Generation = ns JavascriptGeneration.
	Mirrors = ns CompilerMirrorsForDart.
	Compilation = ns Newspeak2V8Compilation mixinApply: ns NewspeakCompilation.
	
	Runtime = ns RuntimeForV8.
|)
(
class ApplicationPackager usingPlatform: p = (|
	private parserLib = CombinatorialParsing usingPlatform: p.
	private grammar = Grammar parserLib: parserLib.
	private asts = ASTs usingLib: p.
	private parsing = Parsing usingPlatform: p grammar: grammar asts: asts.
	private generation = Generation usingPlatform: p.
	private mirrors = Mirrors usingPlatform: p.
	private compilation = Compilation
		usingPlatform: p
		parsing: parsing
		generation: generation
		mirrors: mirrors. 
	
	private OrderedCollection = p collections OrderedCollection.
	private PNGReadWriter = p squeak PNGReadWriter.
	|)
(
class Association key: k value: v = (|
	key = k.
	value = v.
|)
() : ()
class FlatBlackMarket usingSmalltalk: st = (|
	Smalltalk = st.
|)
('as yet unclassified'
doesNotUnderstand: msg = (
	^Smalltalk at: msg selector ifAbsent: [super doesNotUnderstand: msg]
)) : ()
class ImportsRecorder usingNamespace: ns = (|
	namespace = ns.
	imports = OrderedCollection new.
|)
('as yet unclassified'
doesNotUnderstand: message = (
	imports add: message selector.
	^message sendTo: namespace
)) : ()'accessing'
public compileAppDefn: appDefn usingNamespace: ns to: output = (
	compileAppDefn: appDefn withRuntimeDefn: Runtime usingNamespace: ns to: output
)
public compileAppDefn: appDefn withRuntimeDefn: runtimeDefn usingNamespace: ns to: output = (
	compileAppSources: (extractSourcesFromAppDefn: appDefn usingNamespace: ns)
	withRuntimeSource: (extractSourcesFromAppDefn: runtimeDefn usingNamespace: ns)
	withResources: (extractResourcesFromAppDefn: appDefn usingNamespace: ns)
	to: output
)
public compileSource: appDefnSource usingNamespace: ns to: output = (
	compileAppSources: {appDefnSource}
	withRuntimeSource: (extractSourcesFromAppDefn: Runtime usingNamespace: ns)
	withResources: {}
	to: output
)'as yet unclassified'
public compileAppSources: appSources withRuntimeSource: runtimeSource withResources: rs to: output = (
	compilation Infrastructure 
		withAppSources: (appSources)
		withRuntimeSources: (runtimeSource)
		withResources: rs
		outputTo: output
)
private extractResourcesFromAppDefn: appDefn usingNamespace: ns = (
	(* Ordered is important: the app definition must come first *)
	|
	resources = OrderedCollection new. 
	importsRecorder = ImportsRecorder usingNamespace: ns.
	|

	appDefn packageUsing: importsRecorder.
	importsRecorder imports do: [:import <Symbol> |
		| resource |
		resource:: ns perform: import.
		resource isBehavior ifFalse: [resources add: (Association key: import value: resource)].
		resource isForm ifTrue: [PNGReadWriter putForm: resource onFileNamed: import,'.png']].

	^resources asArray
)'private'
private extractSourcesFromAppDefn: appDefn usingNamespace: ns = (
	(* Ordered is important: the app definition must come first *)
	|
	modules = OrderedCollection new. 
	importsRecorder = ImportsRecorder usingNamespace: ns.
	|
	modules add: (sourceOf: appDefn).

	appDefn packageUsing: importsRecorder.
	importsRecorder imports do: [:import <Symbol> |
		| resource |
		resource:: ns perform: import.
		resource isBehavior ifTrue: [modules include: (sourceOf: (resource))]].

	^modules asArray
)
private sourceOf: klass = (
	| stream |
	stream:: (String new: 1000) writeStream.
	klass mixin printTopClassOn: stream.
	^stream contents.
)) : ()
class ChromeAppPackager usingPlatform: p = ApplicationPackager usingPlatform: p (|
	FileDirectory = p blackMarket FileDirectory.
	CrLfFileStream = p blackMarket CrLfFileStream.
	Smalltalk = p blackMarket Smalltalk.
|)
('as yet unclassified'
packageApplicationConfiguration: config <Class> = (
	| name flatBlackMarket scriptStream pageStream backgroundStream manifestStream |

	name:: config name.
	flatBlackMarket:: FlatBlackMarket usingSmalltalk: Smalltalk.
	
	[FileDirectory default createDirectory: name] ifError: [(* Already exists? *)].
	
	(* Should not automatically create a window, but until we have UI bindings... *)
		
	scriptStream:: CrLfFileStream forceNewFileNamed: name , '/window.js'.
	[scriptStream nextPutAll: (String streamContents: [:bufferStream |
	self compileAppDefn: config usingNamespace: flatBlackMarket to: bufferStream])]
		ensure: [scriptStream close].
	
	pageStream:: CrLfFileStream forceNewFileNamed: name , '/window.html'.
	[pageStream nextPutAll: '<!DOCTYPE html><html><head><title>'.
	pageStream nextPutAll: name.
	pageStream nextPutAll: '</title></head><body><script type="text/javascript" src="'.
	pageStream nextPutAll: 'window'.
	pageStream nextPutAll: '.js"> </script></body></html>']
		ensure: [pageStream close].
		
	backgroundStream:: CrLfFileStream forceNewFileNamed: name , '/background.js'.
	[backgroundStream nextPutAll: 
'chrome.app.runtime.onLaunched.addListener(function() {
  chrome.app.window.create("window.html", {});
});'.
	]
		ensure: [backgroundStream close].
		
	manifestStream:: CrLfFileStream forceNewFileNamed: name , '/manifest.json'.
	[manifestStream nextPutAll: 
'{ "name": "', name, '", "version": "0.1", "app": {
    "background": { "scripts": ["background.js"] } } }'.
	]
		ensure: [manifestStream close].
		
	^(FileDirectory default / name) fullName
)) : ()
class WebPagePackager usingPlatform: p = ApplicationPackager usingPlatform: p (|
	CrLfFileStream = p blackMarket CrLfFileStream.
	Smalltalk = p blackMarket Smalltalk.
|)
('as yet unclassified'
packageApplicationConfiguration: config <Class> = (
	| name flatBlackMarket scriptStream pageStream |

	name:: config name.
	flatBlackMarket:: FlatBlackMarket usingSmalltalk: Smalltalk.
	
	scriptStream:: CrLfFileStream forceNewFileNamed: name , '.js'.
	[scriptStream nextPutAll: (String streamContents: [:bufferStream |
	self compileAppDefn: config usingNamespace: flatBlackMarket to: bufferStream])]
		ensure: [scriptStream close].
		
	pageStream:: CrLfFileStream forceNewFileNamed: name , '.html'.
	[pageStream nextPutAll: '<!DOCTYPE html><html><head><title>'.
	pageStream nextPutAll: name.
	pageStream nextPutAll: '</title></head><body><script type="text/javascript" src="'.
	pageStream nextPutAll: name.
	pageStream nextPutAll: '.js"> </script></body></html>']
		ensure: [pageStream close].
		
	^pageStream fullName
)) : ()) : ()