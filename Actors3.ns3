Newspeak3
'Actors'
class Actors3 usingPlatform: p vm: vm = (|
private SharedQueue2 = p squeak SharedQueue2.
private WeakMap = p squeak WeakKeyDictionary.
private List = p collections OrderedCollection.
private Transcript = p squeak Transcript.
private SqueakDelay = p squeak Delay.

private Processor <ProcessScheduler> = p squeak Processor.
private primitives <VMMirror> = vm.

private brazil = p brazil.
public (* bogus - temporary access to a default actor *) uiActor = UIActor new.

private internalRefs <WeakMap[FarReference, InternalFarReference]> = WeakMap new.
|p squeak Project uiProcess actor: uiActor.
p actors: self) (
public class Actor named: debugName <String> = (|
private (* N.B. Do not leak to subinstances. *) internalActor = (ProcessActor named: debugName) startEventLoop.
|) (
'as yet unclassified'
public interrupt = (
	unimplemented
)
public onError: onError <[:E]> = (
	unimplemented.
)
public seed: value <Value> ^<FarReference[Value]> = (
	(* Creating a far reference to a PassByCopy is questionable. It may be that this should be seed: receiver perform: selector with: argument. *)
	(isValueObject: value) ifFalse: [Error signal: 'Cannot seed an actor with a non-Value.'].
	^createFarReferenceTo: value in: internalActor for: currentActor.
)
public terminate = (
	unimplemented
)
) : (
)
protected class EventualSendReactor selector: s arguments: a resolver: r = (
(* An eventual-send to a promise.

Note that all slots contain objects that belong to the actor which performed the eventual send. *)|
protected selector <Symbol> = s.
protected arguments <Array> = a.
protected resolver <InternalResolver> = r.
|) (
'as yet unclassified'
public reactBroken: error = (
	(* Broken promise contagion. *)	
	resolver __owner == currentActor ifFalse: [halt].
	(* Should this be immediate? *)
	(* resolver internalBreak: error. ? *)
	currentActor enqueueMessage:
		(PendingDelivery
			receiver: resolver
			selector: #internalBreak:
			arguments: {error}
			resolver: nil)
)
public reactResolved: value = (
	resolver __owner == currentActor ifFalse: [halt].
	resolver internalResolve: 
		(currentActor
			eventualSendTo: value
			selector: selector
			arguments: arguments)
)
) : (
)
class InternalActor = () (
'as yet unclassified'
public currentActor = (
	(* BOGUS. Polymorphic with other actor system. *)
	^self
)
public eventualSendTo: receiver selector: selector arguments: arguments ^<Ref> = (
	(* Sent from the compilation of an eventual send, via the same method in ProcessScheduler. *)
	
	| targetFuture message |
	(isRef: receiver) ifTrue:
		[^(internalRefs at: receiver) eventualSend: selector arguments: arguments].
	
	(* Otherwise, a near reference. *)
	targetFuture:: InternalLocalPromise __owner: self.
	message:: PendingDelivery
		receiver: receiver
		selector: selector
		arguments: arguments
		resolver: targetFuture.
	enqueueMessage: message.
	^Ref wrapping: targetFuture __owner: self.
)
) : (
)
class InternalFarReference to: t inActor: a = (|
public target = t.
public targetActor = a.
|) (
'as yet unclassified'
public eventualSend: selector arguments: arguments = (
	| sourceActor resolverInTarget redirector message forked |
	
	sourceActor:: currentActor.
	sourceActor == targetActor ifTrue: [halt].
	
	resolverInTarget:: InternalLocalPromise __owner: targetActor.
	targetActor enqueueMessage: 
		(PendingDelivery
			receiver: target
			selector: selector
			arguments: (wrapArguments: arguments from: sourceActor to: targetActor)
			resolver: resolverInTarget).

	^createRemotePromiseOf: resolverInTarget in: targetActor for: sourceActor
)
public isInternalResolver = (
	^false
)
public refPrintOn: stream = (
	stream nextPutAll: '<far ref '.
	target printOn: stream.  (* very BOGUS *)
	stream nextPutAll: '>'.
)
public shortenResolution = (
	^self	
)
public whenResolved: onValue <[:V | V2 def]> whenBroken: onError <[:E | E2 def]> ^<Promise[V2, E2]> = (
	| resolver = InternalLocalPromise __owner: currentActor. |
	currentActor enqueueMessage:
		(PendingDelivery 
			receiver: onValue
			selector: #cull:
			arguments: {Ref wrapping: self __owner: currentActor}
			resolver: resolver).
	^Ref wrapping: resolver __owner: currentActor
)
public wrapFrom: wrapSourceActor to: wrapTargetActor = (
	targetActor == wrapTargetActor ifTrue: [^target].
	^Ref wrapping: self __owner: wrapTargetActor.
)
) : (
)
protected class InternalLocalPromise __owner: o = (|
	public __owner <Actor> = o. (* For assertions only. *)
	public resolution
	public state ::= #unresolved. (* unresolved, forwarded, resolved, smashed *)
	protected reactors <List[WhenReactor | EventualSendReactor | RedirectingReactor]> (* use linked list for randomizing scheduler? *)
	
	public _targetPromise
	public _targetActor
|) (
'as yet unclassified'
public addReactor: msg = (
	state == #resolved ifTrue:
		[^msg reactResolved: resolution].
	state == #broken ifTrue:
		[^msg reactBroken: resolution].
	state == #forwarded ifTrue: 
		[resolution:: resolution shortenResolution.
		^resolution addReactor: msg].
	state == #unresolved ifTrue:
		[nil == reactors ifTrue: [reactors:: List new].
		reactors add: msg.
		^self].
	state == #remote ifTrue:
		[nil == reactors ifTrue: [reactors:: List new].
		reactors add: msg.
		^self].
	halt.
)
doForwardingTo: sourceFuture = (
	state:: #forwarded.
	resolution:: sourceFuture shortenResolution.
	nil == reactors ifFalse:
		[reactors do: [:msg | resolution addReactor: msg].
		reactors:: nil].
)
public eventualSend: selector arguments: arguments ^<Promise> = (
	| resolver |
	__owner == currentActor ifFalse: [halt].
	
	resolver:: InternalLocalPromise __owner: __owner.
	self addReactor: (EventualSendReactor selector: selector arguments: arguments resolver: resolver).
	^Ref wrapping: resolver __owner: __owner.
)
public internalBreak: error = (
	(* assert: [state == #unresolved] message: 'State error'. *)

	resolution:: error.
	state:: #broken.
	
	nil == reactors ifFalse:
		[reactors do: [:msg | msg reactBroken: error].
		reactors:: nil].
)
public internalResolve: value = (
	(* assert: [state == #unresolved] message: 'State error'. *)


	(isRef: value) ifTrue: 
		[ | internalRef = (internalRefs at: value). |
		internalRef isInternalResolver ifTrue: [^doForwardingTo: internalRef]].

	resolution:: value.
	state:: #resolved.
	
	nil == reactors ifFalse:
		[reactors do: [:msg | msg reactResolved: value].
		reactors:: nil].
)
public isInternalResolver = (
	^true
)
public refPrintOn: stream = (
	state == #forwarded ifTrue: [^stream nextPutAll: '<local promise>'].
	state == #remote ifTrue: [^stream nextPutAll: '<remote promise>'].
	state == #unresolved ifTrue: [^resolution refPrintOn: stream].
	state == #broken ifTrue: [^stream nextPutAll: '<broken ref>'].
	state == #resolved ifTrue: 
		[^(isRef: resolution)
			ifTrue: [stream nextPutAll: '<???>'] 
			ifFalse: [stream nextPutAll: '<near ref>']].
	halt.
)
public shortenResolution = (
	state == #remote ifTrue: [^self].
	state == #unresolved ifTrue: [^self].
	state == #forwarded ifTrue: [^resolution shortenResolution].
	state == #resolved ifTrue: [^self].
	state == #broken ifTrue: [^self].
	halt.
)
public whenResolved: onValue <[:V | V2 def]> whenBroken: onError <[:E | E2 def]> ^<Promise[V2, E2]> = (
	| resolver = InternalLocalPromise __owner: __owner. |
	__owner == currentActor ifFalse: [halt].
	self addReactor: (WhenReactor onValue: onValue onError: onError resolver: resolver).
	^Ref wrapping: resolver __owner: __owner
)
public wrapFrom: sourceActor to: targetActor = (
	| resolverInTarget redirector msg |
	sourceActor == __owner ifFalse: [halt].
	sourceActor == currentActor ifFalse: [halt].

	state == #remote ifTrue: [
		targetActor == _targetActor ifTrue: [^Ref wrapping: _targetPromise __owner: targetActor].
		^createRemotePromiseOf: _targetPromise in: _targetActor for: targetActor].
	
	state == #forwarded ifTrue: [^resolution wrapFrom: sourceActor to: targetActor].
		
	state == #resolved ifTrue: 
		[(isRef: resolution) ifTrue: 
			[^(internalRefs at: resolution) wrapFrom: sourceActor to: targetActor]].
	
	resolverInTarget:: InternalLocalPromise __owner: targetActor.
	redirector:: RedirectReactor
		from: sourceActor
		to: targetActor
		resolver: resolverInTarget.
	self addReactor: redirector.	
	^Ref wrapping: resolverInTarget __owner: targetActor
)
) : (
)
class InternalRemotePromise __owner: o = InternalLocalPromise __owner: o (|
public targetPromise
public targetActor
|state: #remote) (
'as yet unclassified'
public addReactor: msg = (
	localPromise addReactor: msg
)
public eventualSend: selector arguments: arguments = (
	^localPromise eventualSend: selector arguments: arguments
)
public isInternalResolver = (
	^true
)
public shortenResolution = (
	^localPromise shortenResolution
)
public whenResolved: onValue <[:V | V2 def]> whenBroken: onError <[:E | E2 def]> = (
	^localPromise whenResolved: onValue whenBroken: onError
)
public wrapFrom: _sourceActor to: _targetActor = (
	{_sourceActor. _targetActor. targetPromise. localPromise} out.
	
	_targetActor == _sourceActor ifTrue: ['hiyo!' out. ^Ref wrapping: targetPromise __owner: _targetActor].
	
	(* WRONG *)
	^localPromise wrapFrom: _sourceActor to: _targetActor 
)
) : (
)
protected class PendingDelivery receiver: r selector: s arguments: a resolver: y = (
(* A message in an actor's event queue. Every turn starts by sending #deliverIn:.

Note that all slots contain objects that belong to the actor in which the message is queued, even the resolver. *)|
protected receiver <Object> = r.
protected selector <Symbol> = s.
protected arguments <Array> = a.
protected resolver <InternalResolver> = y.
|) (
'as yet unclassified'
public deliverIn: fastCurrentActor = (
	| resolution type msg |
	
	(* Transcript print: fastCurrentActor; space; print: self; cr. *)

	[(* BOGUS: Don't rely on perform not being overridden. *)
	resolution:: receiver perform: selector withArguments: arguments.
	type:: #internalResolve:] 
		on: Error (* BOGUS: Exception? *) 
		do: [:error | 
			resolution:: error.
			type:: #internalBreak:].

	(* Transcript show: {resolver. type. resolution}; cr. *)

	nil == resolver ifTrue: [
		type == #internalBreak: ifTrue: [{'silent failure'. resolution} out].
		^self].
	type == #internalResolve:
		ifTrue: [resolver internalResolve: resolution]
		ifFalse: [resolver internalBreak: resolution].
)
public postedTo: actor = (
	check: receiver allowedIn: actor.
	arguments do: [:arg | check: arg allowedIn: actor].
	resolver == nil ifFalse: [resolver __owner == actor ifFalse: [halt]].
)
public printOn: stream = (
	receiver printOn: stream.
	stream nextPutAll: ' <-: '.
	stream nextPutAll: selector.
	stream space.
	arguments isEmpty ifFalse: [arguments printOn: stream].
)
) : (
)
protected class ProcessActor named: n = InternalActor (
(* An actor whose turns run in its own Process, allowing us to suspend it individually. *)|
	protected name <String> = n.
	protected process <Process>
	protected messageQueue <SharedQueue> = SharedQueue2 new.
|) (
'as yet unclassified'
doOneTurn = (
	messageQueue next deliverIn: self.
)
public enqueueMessage: actorMessage = (
	actorMessage postedTo: self.
	messageQueue nextPut: actorMessage
)
public printOn: stream = (
	stream nextPutAll: '[ProcessActor('.
	stream nextPutAll: name.
	stream nextPutAll: ')#'.
	identityHash printOn: stream.
	stream nextPutAll: ']'.
)
public startEventLoop = (
	process:: [[self doOneTurn] repeat] newProcess.
	process name: ('Event loop for ', name) asString.
	process priority: Processor userBackgroundPriority.
	process actor: self.
	process resume.
)
) : (
)
protected class RedirectReactor from: s to: d resolver: r = (
(* A bridge between InternalResolvers in different actors. *)|
protected sourceActor <Actor> = s.
protected destinationActor <Actor> = d.
protected resolver <InternalResolver>  = r.
|) (
'as yet unclassified'
public reactBroken: r = (
	| msg |
	currentActor == sourceActor ifFalse: [halt].
	msg:: PendingDelivery
		receiver: resolver
		selector: #internalBreak:
		arguments: {wrapArgument: r from: sourceActor to: destinationActor}
		resolver: nil.
	destinationActor enqueueMessage: msg.
)
public reactResolved: r = (
	| msg |
	currentActor == sourceActor ifFalse: [halt].
	msg:: PendingDelivery
		receiver: resolver
		selector: #internalResolve:
		arguments: {wrapArgument: r from: sourceActor to: destinationActor}
		resolver: nil.
	destinationActor enqueueMessage: msg.
)
) : (
)
class Ref wrapping: ref __owner: o = (|
protected internalRef = ref.
public __owner = o.
|internalRefs at: self put: ref) (
'as yet unclassified'
protected doesNotUnderstand: message <Message> = (
	(* For the debugger/inspector. Questionable. *)
	(* Should probably override public method of Object as well. *)
	0 = message arguments size ifTrue: [(message selector startsWith: 'is') ifTrue: [^false]].
	
	internalRef state == #resolved ifTrue:
		[^message sendTo: internalRef resolution].
	
	^Error signal: 'Cannot immediate-send to an eventual reference: ', message selector.
)
public isPromise = (
	^true
)
public printOn: stream = (
	(* BOGUS - debugging *)
	internalRef refPrintOn: stream.
)
public whenResolved: onValue <[:V | V2 def]> ^<Promise[V2, E]>= (
	^internalRef
		whenResolved: onValue
		whenBroken: [:e | e signal] (* Should we make this the behavior of a nil catch-clause instead? *)
)
public whenResolved: onValue <[:V | V2 def]> whenBroken: onError <[:E | E2 def]> ^<Promise[V2, E2]> = (
	^internalRef whenResolved: onValue whenBroken: onError
)
protected yourself = (
	^super yourself
)
) : (
)
public class Resolver = (
(*A Resolver represents the authority to resolve a Promise and is the control facet of the promise's eventual resolution.*)|
	private (* N.B. We must not leak access to an InternalResolver via subobjects. *) internalResolver = InternalLocalPromise __owner: currentActor.
	public promise <Promise[V, E]> = Ref wrapping: internalResolver __owner: currentActor.
|) (
'as yet unclassified'
public break: error <E> = (
	| msg |
	internalResolver __owner == currentActor ifFalse: [halt].
	#unresolved == internalResolver state 
		ifTrue: [internalResolver internalBreak: error]
		ifFalse: [Error signal: 'Already resolved'].
)
public isResolver ^<Boolean> = (
	^true
)
public resolve: value <V> = (
	| msg |
	internalResolver __owner == currentActor ifFalse: [halt].
	#unresolved == internalResolver state 
		ifTrue: [internalResolver internalResolve: value]
		ifFalse: [Error signal: 'Already resolved'].
)
) : (
)
public class Timer __duration: milliseconds callback: callback repeating: repeating = (|
	protected process
	protected actor = currentActor.
	protected cancelled ::= false.
|repeating
		ifTrue: [self schedule: callback every: milliseconds] 
		ifFalse: [self schedule: callback after: milliseconds]) (
'as yet unclassified'
public cancel = (
	cancelled:: true.
	nil == process ifFalse: [process terminate. process:: nil].
)
public isActive ^<Boolean> = (
	cancelled ifTrue: [^false].
	^nil ~= process
)
public isTimer ^<Boolean> = (
	^true
)
protected schedule: callback after: ms = (
	|
	delay = SqueakDelay forMilliseconds: ms.
	msg = PendingDelivery
		receiver: [cancelled ifFalse: [callback value]]
		selector: #value
		arguments: {}
		resolver: nil.
	|
	process:: [delay wait. actor enqueueMessage: msg. process:: nil] newProcess.
	process name: 'One-shot timer for ', callback printString.
	process priority: 41.
	process resume.
)
protected schedule: callback every: ms = (
	(* When should we start ticking down for the next callback? When we schedule the callback, when the callback starts, or if-and-when the callback completes without an error? *)
	|
	delay = SqueakDelay forMilliseconds: ms.
	msg = PendingDelivery
		receiver: [cancelled ifFalse: [callback value: self]]
		selector: #value
		arguments: {}
		resolver: nil.
	|
	process:: [[delay wait. actor enqueueMessage: msg] repeat] newProcess.
	process name: 'Repeating timer for ', callback printString.
	process priority: 41.
	process resume.
)
) : (
'as yet unclassified'
public after: duration do: callback <[]> ^<Timer> = (
	^self __duration: duration callback: callback repeating: false
)
public every: duration do: callback <[:Timer]> ^<Timer> = (
	^self __duration: duration callback: callback repeating: true
)
)
protected class UIActor = InternalActor (
(* An actor whose turns run in the Squeak UI Process. *)) (
'as yet unclassified'
public enqueueMessage: actorMessage = (
	actorMessage postedTo: self.
	
	(* bogus - should drain an explicit queue to allow for a randomizing scheduler *)
	brazil theDesktop scheduleUIAction: [actorMessage deliverIn: self].
)
public printOn: stream = (
	stream nextPutAll: '[UIActor#'.
	identityHash printOn: stream.
	stream nextPutAll: ']'.
)
) : (
)
protected class WhenReactor onValue: v onError: e resolver: r = (
(* A when-catch for a promise.

Note that all slots contain objects that belong to the actor which sent #whenResolved:. *)|
	protected onValue <[:V] | []> = v.
	protected onError <[:E] | []> = e.
	protected resolver <InternalResolver> = r.
|) (
'as yet unclassified'
public reactBroken: value = (
	resolver __owner == currentActor ifFalse: [halt].
	currentActor enqueueMessage:
		(PendingDelivery 
			receiver: onError
			selector: #cull:
			arguments: {value}
			resolver: resolver).
)
public reactResolved: value = (
	resolver __owner == currentActor ifFalse: [halt].
	currentActor enqueueMessage:
		(PendingDelivery 
			receiver: onValue
			selector: #cull:
			arguments: {value}
			resolver: resolver).
)
) : (
)
'as yet unclassified'
private check: object allowedIn: actor = (
	assert: [nil ~= actor] message: 'Invalid actor'.
	
	(isRef: object) ifTrue: [object __owner == actor ifFalse: [halt]].
	(* Otherwise near reference *)
)
private createFarReferenceTo: target in: targetActor for: sourceActor = (
	| internal external |
	internal:: InternalFarReference to: target inActor: targetActor.
	^Ref wrapping: internal __owner: sourceActor.
)
private createRemotePromiseOf: resolverInTarget in: targetActor for: sourceActor = (
	| sourceResolver redirector message remotePromise |
	sourceActor == targetActor ifTrue: [halt].
	
	sourceResolver:: InternalLocalPromise __owner: sourceActor.
	sourceResolver state: #remote.
	sourceResolver _targetPromise: resolverInTarget.
	sourceResolver _targetActor: targetActor.
	
	redirector:: RedirectReactor
		from: targetActor
		to: sourceActor
		resolver: sourceResolver.

	message:: PendingDelivery
		receiver: resolverInTarget
		selector: #addReactor:
		arguments: {redirector}
		resolver: nil.
	targetActor enqueueMessage: message.
	
	^Ref wrapping: sourceResolver __owner: sourceActor.
)
private currentActor = (
	^Processor activeProcess actor ifNil: [uiActor].
)
private isRef: object <Object> ^<Boolean> = (
	^Ref == (primitives classOf: object)
)
private isValueObject: object <Object> ^<Boolean> = (
	nil == object ifTrue: [^true].
	true == object ifTrue: [^true].
	false == object ifTrue: [^true].
	object isString ifTrue: [^true].
	object isNumber ifTrue: [^true].
	object isCharacter ifTrue: [^true].
	object isBehavior ifTrue: [^isValueObject: object enclosingClass].
	^false
)
private wrapArgument: argument from: sourceActor to: targetActor = (
	(* [argument] lives in [sourceActor], answer the corresponding proxy that lives in [targetActor] *)

	sourceActor == targetActor ifTrue: [halt. (* We can't tell which side a near reference belongs to here, so we must have decided this earlier. *) ].

	(isRef: argument) ifTrue: [^(internalRefs at: argument) wrapFrom: sourceActor to: targetActor.].
	
	(* Near ref *)
	^(isValueObject: argument)
		ifTrue: [argument (* Pass by copy *)]
		ifFalse: [createFarReferenceTo: argument in: sourceActor (* Pass by proxy *) for: targetActor].
)
private wrapArguments: arguments from: sourceActor to: targetActor = (
	^arguments collect: [:argument | wrapArgument: argument from: sourceActor to: targetActor].
)
) : (
)
