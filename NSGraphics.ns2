Newspeak3
'NSGraphics'
class NSGraphics usingPlatform: p = NewspeakObject (
"
Rectange, Point from Strongtalk
to add: Color, Form (much reduced) from Squeak; Font, Gradient from Brazil?

For the code derived from Strongtalk, the Sun Microsystems copyright and BSD license below applies.

Copyright (c) 1995-2006 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
Copyright 2010 Ryan Macnak and other contributors.
 
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, 
 this  list of conditions and the following disclaimer.

* Redistribution in binary form must reproduce the above copyright notice, 
this list of conditions and the following disclaimer in the documentation and/o other materials provided with the distribution.

Neither the name of Sun Microsystems or the names of contributors may 
be used to endorse or promote products derived from this software without 
specific prior written permission.

>>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS 
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGE.>>
"|
|)
(
class Circle center: c radius: r = (|
	public center = c.
	public radius = r.
|)
('as yet unclassified'
containsPoint: p = (
	|dx dy|
	dx:: center x - p x.
	dy:: center y - p y.
	^(dx*dx)+(dy*dy) < (radius * radius)
)
drawOn: gc = (
	
)
extent = (
	^(radius*2)@(radius*2)
))
class Color withRgb: rgb_ = (
"Color represented internally as 10 bits for each component r, g, and b (fits in a SmallInteger)

How many colors is it appropriate to provide named methods for? black/white? red/green/blue? cyan/magenta/yellow? purple mountain majesty?"|
	private rgb <SmallInteger> = rgb_.
|)
('accessing'
public alpha ^<Float> = (
	^1.0 "opaque"
)
public blue ^<Float> = (
	"Return the blue component as a float, 0 to 1 inclusive."
	^(rgb bitAnd: 2r000000000000000000001111111111) >> 00 / 1023.0
)
public brightness ^<Float> = (
	^(red max: green) max: blue
)
public green ^<Float> = (
	"Return the green component as a float, 0 to 1 inclusive."
	^(rgb bitAnd: 2r000000000011111111110000000000) >> 10 / 1023.0
)
public hue ^<Float> = (
	"Return the hue of this color, an angle in the range [0.0..360.0]."

	| r g b max min span h |
	r:: self red.
	g:: self green.
	b:: self blue. 

	max:: ((r max: g) max: b).
	min:: ((r min: g) min: b).
	span:: (max - min) asFloat.
	span = 0.0 ifTrue: [ ^ 0.0 ].

	r = max ifTrue: [
		h:: ((g - b) asFloat / span) * 60.0.
	] ifFalse: [
		g = max
			ifTrue: [ h:: 120.0 + (((b - r) asFloat / span) * 60.0). ]
			ifFalse: [ h:: 240.0 + (((r - g) asFloat / span) * 60.0). ].
	].

	h < 0.0 ifTrue: [ h:: 360.0 + h ].
	^ h
)
public red ^<Float> = (
	"Return the red component as a float, 0 to 1 inclusive."
	^(rgb bitAnd: 2r111111111100000000000000000000) >> 20 / 1023.0
)
public saturation ^<Float> = (
	"Return the saturation of this color, a value between 0.0 and 1.0."
	| r g b max min |
	r:: self red.
	g:: self green.
	b:: self blue. 

	max:: r. min:: r.
	g > max ifTrue: [max:: g].
	b > max ifTrue: [max:: b].
	g < min ifTrue: [min:: g].
	b < min ifTrue: [min:: b].

	max = 0
		ifTrue: [ ^ 0.0 ]
		ifFalse: [ ^ (max - min) asFloat / max asFloat ].
)'as yet unclassified'
public brighter ^<Color> = (
	^Color h: hue s: saturation v: (brightness + 0.1 min: 0)
)
public darker ^<Color> = (
	^Color h: hue s: saturation v: (brightness - 0.1 max: 0)
)'testing'
public = obj ^<Boolean> = (
	^obj isColor and: [obj rgb = self rgb]
)
public hash ^<Integer> = (
	^rgb
)
public isColor ^<Color> = (
	^true
)) : ('as yet unclassified'
public r: r <Number> g: g <Number> b: b <Number> a: a <Number> ^<Color> = (
	"Arguments should be 0 to 1 inclusive"
	^TranslucentColor withRgb:
		((r*1023)rounded << 20) |
		((g*1023)rounded << 10) |
		((b*1023)rounded << 00)
		alpha: a		
)'constants'
public black ^<Color> = (
	^self r: 0 g: 0 b: 0
)
public white ^<Color> = (
	^self r: 1 g: 1 b: 1
)'instance creation'
public gray: brightness <Number> ^<Color> = (
	"Return a gray shade with the given brightness in the range [0,1]."
	^self r: brightness g: brightness b: brightness
)
public h: hue <Number> s: saturation <Number> v: brightness <Number> ^<Color> = (
	"This method from Squeak"
	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 180 s: 1 v: 1) is pure red."
	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."

	| s v hf i f p q t | 
	s:: (saturation asFloat max: 0.0) min: 1.0.
	v:: (brightness asFloat max: 0.0) min: 1.0.

	"zero saturation yields gray with the given brightness"
	s = 0.0 ifTrue: [ ^ self r: v g: v b: v ].

	hf:: hue asFloat.
	(hf < 0.0 or: [hf >= 360.0])
		ifTrue: [hf:: hf - ((hf quo: 360.0) asFloat * 360.0)].
	hf:: hf / 60.0.
	i:: hf asInteger.  "integer part of hue"
	f:: hf fractionPart.         "fractional part of hue"
	p:: (1.0 - s) * v.
	q:: (1.0 - (s * f)) * v.
	t:: (1.0 - (s * (1.0 - f))) * v.

	0 = i ifTrue: [ ^ self r: v g: t b: p ].
	1 = i ifTrue: [ ^ self r: q g: v b: p ].
	2 = i ifTrue: [ ^ self r: p g: v b: t ].
	3 = i ifTrue: [ ^ self r: p g: q b: v ].
	4 = i ifTrue: [ ^ self r: t g: p b: v ].
	5 = i ifTrue: [ ^ self r: v g: p b: q ].

	self error: 'implementation error'.
)
public r: r <Number> g: g <Number> b: b <Number> ^<Color> = (
	"Arguments should be 0 to 1 inclusive"
	^withRgb:
		((r*1023)rounded << 20) |
		((g*1023)rounded << 10) |
		((b*1023)rounded << 00)
				
))
class GraphicsContext = (|
	source
	destination
|)
('actions'
fill = (
	
)
paint = (
	
)
stroke = (
	
)'as yet unclassified'
arcAt: center <Point> radius: radius <Number> from: startAngle <Number> to: stopAngle <Number> = (
	
)
lineTo: coord <Point> = (
	
)
moveTo: coord <Point> = (
	
)
rotate: angle <Number> = (
)
scale: scaleing <Point> = (
)
translate: delta <Point> = (
))
class Point x: xcoord y: ycoord = ("A two-dimensional point."|
	public x = xcoord.
	public y = ycoord.
|)
('accessing'
hash ^<Int> = (

	"2**10 = 1024 = approximate screen dimension"
	^(self x hash bitShift: 10) bitXor: (self x hash bitXor: self y hash)
)
r = (
	^((x * x) + (y * y)) sqrt
)
theta = (
	"From Squeak's Point"
	"Answer the angle the receiver makes with origin in radians. right is 0; 
	down is 90."

	| tan theta |
	x = 0
		ifTrue: [y >= 0
				ifTrue: [^ 1.570796326794897 "90.0 degreesToRadians"]
				ifFalse: [^ 4.71238898038469 "270.0 degreesToRadians"]]
		ifFalse: 
			[tan:: y asFloat / x asFloat.
			theta:: tan arcTan.
			x >= 0
				ifTrue: [y >= 0
						ifTrue: [^theta]
						ifFalse: [^"360.0 degreesToRadians" 6.283185307179586 + theta]]
				ifFalse: [^"180.0 degreesToRadians" 3.141592653589793 + theta]]
)'comparing'
< other <Point> ^<Boolean> = (

	^self x < other x and: [ self y < other y ]
)
<= other <Point> ^<Boolean> = (

	^self x <= other x and: [ self y <= other y ]
)
= other <Object>  ^<Boolean> = (

	^self == other
		or: [ other isPoint
					and: [	| p <Point> |
								p:: "guaranteed <Point>" other.
								self x = p x and: [ self y = other y ]		]]

	"%todo: use correct code below when coerce is implemented fast. (& remove isPoint implementation)"
"	^self == other
		or: [	| p <Pt> |
				p := Pt coerce: other else: [ ^false ].
				self x = p x and: [ self y = other y ]	]	]
				
"
)
> other <Point> ^<Boolean> = (

	^self x > other x and: [ self y > other y ]
)
>= other <Point> ^<Boolean> = (

	^self x >= other x and: [ self y >= other y ]
)
asPoint ^<Point> = (

	^self
)'operations'
* other <Point> ^<Point> = (

	^(self x * other x)@(self y * other y)
)
+ other <Point> ^<Point> = (

	^(self x + other x)@(self y + other y)
)
- other <Point> ^<Point> = (

	^(self x - other x)@(self y - other y)
)
/ other <Point> ^<Point> = (

	^(self x / other x)@(self y / other y)
)
// other <Point> ^<Point> = (

	^(self x // other x)@(self y // other y)
)
abs ^<Point> = (

	^self x abs @ self y abs
)
floor ^<Point> = (

	^self x floor @ self y floor
)
max: other <Point> ^<Point> = (

	^(self x max: other x) @ (self y max: other y)
)
min: other <Point> ^<Point> = (

	^(self x min: other x) @ (self y min: other y)
)
negated ^<Point> = (

	^self x negated @ self y negated
)
relativeTo: p <Point> ^<Point> = (

	^self - p
)
rounded ^<Point> = (

	^self x rounded @ self y rounded
)
translatedBy: p <Point> ^<Point> = (

	^self + p
)
truncateTo: grid <Number> = (

	^(self x truncateTo: grid)@(self y truncateTo: grid)
)
truncated ^<Point> = (

	^self x truncated @ self y truncated
)'printing'
printOn: strm <CharOutputStream> = (

	strm print: self x; putAll: ' @ '; print: self y
)'restricted-double dispatching'
expandRect: r <Rect> ^<Rect> = (

	^Rectangle
		left: r left - self x
		right: r right + self x
		top: r top - self y
		bottom: r bottom + self y
)
insetRect: r <Rect> ^<Rect> = (

	^Rectangle
		left: r left + self x
		right: r right - self x
		top: r top + self y
		bottom: r bottom - self y
)'testing'
isPoint ^<Boolean> = (

	^true
)'utility'
corner: other <Point> ^<Rect> = (

	^Rectangle origin: self  corner: other
)
extent: other <Point> ^<Rect> = (

	^Rectangle origin: self  extent: other
)) : ('instance creation'
r: r <Number> degrees: d <Number> ^<Point> = (
	"Answer an instance representing the polar coordinate (r,d) whose angle is given in degrees"
	^self
		r: r
		theta: d * 0.0174532925199433  "Float pi / 180"
)
r: r <Number> theta: theta <Number> ^<Point> = (
	"Answer an instance representing the polar coordinate (r,theta) whose angle is given in radians"
	^self
		x: r * theta cos
		y: r * theta sin
))
class Rectangle origin: o <Point> corner: c <Point> = (|
	public origin <Point> = o. "the top left point"
	public corner <Point> = c. "the bottom right point"
|)
('accessing'
bottom ^<Number> = (

	^self corner y
)
bottomCenter ^<Point> = (

	^self xCenter @ self bottom
)
bottomLeft ^<Point> = (

	^self left @ self bottom
)
bottomRight ^<Point> = (

	^self right @ self bottom
)
center ^<Point> = (

	^self xCenter @ self yCenter
)
extent ^<Point> = (

	^self width @ self height
)
height ^<Int> = (

	^self bottom - self top
)
left ^<Number> = (

	^self origin x
)
leftCenter ^<Point> = (

	^self left @ self yCenter
)
right ^<Number> = (

	^self corner x
)
top ^<Number> = (

	^self origin y
)
topCenter ^<Point> = (

	^self xCenter @ self top
)
topLeft ^<Point> = (

	^self origin
)
width ^<Int> = (

	^self right - self left
)
xCenter ^<Number> = (

	^(self left + self right) // 2
)
yCenter ^<Number> = (

	^(self top + self bottom) // 2
)'comparing'
= other <Object>  ^<Boolean> = (

	"%todo: use coerce here when is fast"
	^(Reflection classOf: other) == (Reflection classOf: self)
		and: [	| otherRect <Rect> |
					otherRect:: "guaranteed <Rectangle>" other.
					otherRect origin = self origin and: [ otherRect corner = self corner ]	]
)
hash ^<Int> = (

	^self origin hash bitXor: self corner hash
)'compatibility'
translateBy: p <Point> ^<Instance> = (
	"A synonym for #translatedBy: for bluebook compatiblity"
	^self translatedBy: p
)'operations'
enclosedRect ^<Rect> = (
	^self
)
enclosingRect ^<Rect> = (
	^self
)
expandBy: delta <Number | Point | Rect> ^<Rect> = (
	^delta expandRect: self
)
insetBy: delta <Number | Point | Rect> ^<Rect> = (
	^delta insetRect: self
)
intersect: other <Rect> ^<Rect> = (

	| t <Number> b <Number> l <Number> r <Number> |
	t:: self top max: other top.
	l:: self left max: other left.
	r:: self right min: other right.
	b:: self bottom min: other bottom.
	^Rectangle
		left: l
		right: (r max: l)
		top: t
		bottom: (b max: t)
)
merge: other <Rectangle> ^<Rect> = (
	^(self origin min: other origin)
		corner: (self corner max: other corner)
)
relativeTo: p <Point> ^<Rect> = (
	^Rectangle
		left: self left - p x
		right: self right - p x
		top: self top - p y
		bottom: self bottom - p y
)
translatedBy: p <Point> ^<Rect> = (
	^Rectangle
		left: self left + p x
		right: self right + p x
		top: self top + p y
		bottom: self bottom + p y
)'printing'
printOn: strm <CharOutputStream> = (

	strm put: $(; print: self origin; putAll: ' corner: '; print: self corner; put: $)
)'region testing'
translatedBy: p <Point> mightIntersect: r <Region>  ^<Boolean> = (
	^r relativeTo: p mightIntersectRect: self
)'restricted-double dispatching'
expandRect: r <Rect> ^<Rect> = (

	^Rectangle
		left: r left - self left
		right: r right + self right
		top: r top - self top
		bottom: r bottom + self bottom
)
insetRect: r <Rect> ^<Rect> = (

	^Rectangle
		left: r left + self left
		right: r right - self right
		top: r top + self top
		bottom: r bottom - self bottom
)
relativeTo: p <Point> mightIntersectRect: other <Rect> ^<Boolean> = (
	"A faster form of ((self relativeTo: p) mightIntersect: other)"

	| orig <Point> corn <Point> oorig <Point> ocorn <Point> x <Number> y <Number> |
	orig:: self origin.
	corn:: self corner.
	oorig:: other origin.
	ocorn:: other corner.
	x:: p x.
	y:: p y.
	^orig x - x < ocorn x and: [ orig y - y < ocorn y
		and: [ oorig x < (corn x - x) and: [ oorig y < (corn y - y) ]]  ]
)
translatedBy: p <Point> surelyContainedByRect: other <Rect> ^<Boolean> = (

	| orig <Point> corn <Point> oorig <Point> ocorn <Point> x <Number> y <Number> |
	orig:: self origin.
	corn:: self corner.
	oorig:: other origin.
	ocorn:: other corner.
	x:: p x.
	y:: p y.
	^oorig x <= (orig x + x) and: [ oorig y <= (orig y + y)
		and: [ ocorn x >= (corn x + x) and: [ ocorn y >= (corn y + y) ]]]
)'testing'
contains: other <Rect> ^<Boolean> = (
	^self origin <= other origin and: [ self corner >= other corner ]
)
containsPoint: p <Point> ^<Boolean> = (
	"Return true if the pixel at (i.e. unit rectangle whose origin is) p intersects the receiver."

	^p >= self origin and: [ p < self corner ]
)
intersects: other <Rect> ^<Boolean> = (

	^self origin < other corner and: [ other origin < self corner ]
)
relativeTo: orig <Point> containsPoint: p <Point> ^<Boolean> = (
	"Return true if the pixel at (i.e. unit rectangle whose origin is) p (which is relative to orig) intersects the receiver.
	  This is just a faster way to express (self containsPoint: p - orig)."

	| offx <Number> offy <Number> px <Number> py <Number> |
	offx:: orig x.
	offy:: orig y.
	px:: p x.
	py:: p y.
	^px - offx >= self origin x
		and: [ px - offx < self corner x
		and: [ py - offy >= self origin y
		and: [ py - offy < self corner y ]  ]]
)
relativeTo: p <Point> mightIntersect: r <Region>  ^<Boolean> = (

	^r translatedBy: p mightIntersect: self
)
relativeTo: p <Point> surelyContains: r <Region>  ^<Boolean> = (

	^r translatedBy: p surelyContainedByRect: self
)
xSameAs: other <Rect> ^<Boolean> = (
	"convenience function to see if the x components of the receiver are the same as other's"

	^self left = other left  and: [ self right = other right ]
)
ySameAs: other <Rect> ^<Boolean> = (
	"convenience function to see if the y components of the receiver are the same as other's"

	^self top = other top  and: [ self bottom = other bottom ]
)) : ('instance creation'
corner: p1 <Point> corner: p2 <Point> ^<Rect> = (
	"Create the rectangle defined by two of its diagonal corners.  The correct origin
	  and corner will be computed for you (i.e. this works for any two points)."

	| minX <Number> maxX <Number> minY <Number> maxY <Number> tmp <Number> |
	minX:: p1 x.
	maxX:: p2 x.
	minY:: p1 y.
	maxY:: p2 y.
	minX > maxX
		ifTrue: [ tmp:: minX.  minX:: maxX. maxX:: tmp ].
	minY > maxY
		ifTrue: [ tmp:: minY.  minY:: maxY. maxY:: tmp ].

	^self left: minX right: maxX top: minY bottom: maxY
)
left: l <Number> right: r <Number> top: t <Number> bottom: b <Number>  ^<Rect> = (
	"Create a rectangle given the location of the sides.  Left must be <= right, and
	 top must be <= bottom"

	^self origin: l @ t corner:  r @ b
)
origin: o <Point> extent: c <Point> ^<Rect> = (
	"Create a rectangle with the specified origin and corner.  origin must be <= corner.
	  If you cannot guarantee that, use #corner:corner:"

	^self origin: o corner: c + o
))
class TranslucentColor withRgb: rgb_ <SmallInteger> alpha: a <Float> = Color withRgb: rgb_ (|
	public alpha <Float> = a.
|)
())