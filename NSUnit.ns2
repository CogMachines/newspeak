Newspeak3
'NSUnit'
class NSUnit usingPlatform: platform = NewspeakObject (
"Copyright 2008-2009 David Pennell, Gilad Bracha and other contributors.

Derived from Squeak's SUnit code, translated to Newspeak and modified.  This code is licensed under the same terms as SUnit (the Squeak license)."|
	private Exception = platform Exceptions Exception.
	private UnhandledError = platform Exceptions UnhandledError.
	private OrderedCollection = platform Collections OrderedCollection.
	private Set = platform Collections Set.
	private Semaphore = platform Processes Semaphore.
	private FailureLog = platform Transcript.  "e.g. Transcript"
	private Delay = platform Processes Delay.
	private Processor = platform Processor.
	private Duration = platform Kernel Duration.
	private IdentitySet = platform Collections IdentitySet.
	private Error = platform Exceptions Error.
	private SyntaxErrorNotification = platform Exceptions SyntaxErrorNotification.
|)
(
class ResumableTestFailure = TestFailure (
"A ResumableTestFailure triggers a TestFailure, but lets execution of the TestCase continue. this is useful when iterating through collections, and #assert: ing on each element. in combination with methods like testcase>>#assert:description:, this lets you run through a whole collection and note which tests pass.

here''s an example:

	

	(1 to: 30) do: [ :each |
		self assert: each odd description: each printString, ' is even' resumable: true]

for each element where #odd returns <false>, the element will be printed to the Transcript. ")
('camp smalltalk'
isResumable ^ <Boolean> = (
	"Of course a ResumableTestFailure is resumable ;-)"

	^true
)
sunitExitWith: aValue = (
	resume: aValue
))
class TestCase selector: sel <Symbol> = (
"A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say ''assert: socket isOpen'' to test whether or not a socket is open at a point in a test."| protected selectorToTest <Symbol> = sel. |)
('accessing'
assert: aBooleanOrBlock = (
	aBooleanOrBlock value ifFalse: [signalFailureWith: 'Assertion failed']
)
assert: aBooleanOrBlock description: aString = (
	aBooleanOrBlock value ifFalse: [
		logFailure: aString.
		signalFailureWith: aString]			
)
assert: aBooleanOrBlock description: aString resumable: resumableBoolean = (
 	| exception |
	aBooleanOrBlock value
		ifFalse: 
			[logFailure: aString.
			exception:: resumableBoolean
							ifTrue: [ResumableTestFailure]
							ifFalse: [TestFailure].
			exception signal: aString]
)
deny: aBooleanOrBlock = (
	aBooleanOrBlock value ifTrue: [signalFailure: 'Assertion failed']
)
deny: aBooleanOrBlock description: aString = (
	assert: aBooleanOrBlock value not description: aString
)
deny: aBooleanOrBlock description: aString resumable: resumableBoolean = (
	assert: aBooleanOrBlock value not
	description: aString
	resumable: resumableBoolean
)
resources ^ <Collection[TestResource]> = (
	"answer a list of TestResource instances required by this TestCase"
	^{}
)
should: aBlock <[^Boolean]> = (
	assert: aBlock value
)
should: aBlock <[^Boolean]>  raise: anExceptionalEvent whoseDescriptionDoesNotInclude: subString <String> description: aString <String> = (
	^assert: (executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionNotContaining: subString)
		description: aString
)
should: aBlock <[^Boolean]> description: aString <String> = (
	assert: aBlock value description: aString
)
should: aBlock <[^Boolean]> raise: anExceptionalEvent = (
	^assert: (executeShould: aBlock inScopeOf: anExceptionalEvent)
)
should: aBlock <[^Boolean]> raise: anExceptionalEvent description: aString <String> = (
	^assert: (executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
)
should: aBlock <[^Boolean]> raise: anExceptionalEvent whoseDescriptionIncludes: subString <String> description: aString <String> = (
	^assert: (executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionContaining: subString)
		description: aString
)
shouldnt: aBlock <[^Boolean]> = (
	deny: aBlock value
)
shouldnt: aBlock <[^Boolean]> description: aString <String> = (
	deny: aBlock value description: aString
)
shouldnt: aBlock <[^Boolean]> raise: anExceptionalEvent = (
	^assert: (executeShould: aBlock inScopeOf: anExceptionalEvent) not
)
shouldnt: aBlock <[^Boolean]> raise: anExceptionalEvent description: aString <String> = (
	^assert: (executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
)
shouldnt: aBlock <[^Boolean]> raise: anExceptionalEvent whoseDescriptionDoesNotInclude: subString <String> description: aString <String> = (
	^assert: (executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionNotContaining: subString) not
		description: aString
)
shouldnt: aBlock <[^Boolean]> raise: anExceptionalEvent whoseDescriptionIncludes: subString <String> description: aString <String> = (
	^assert: (executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionContaining: subString) not
		description: aString
)'as yet unclassified'
newTest ^ <TestCase> = (
	^class on: selectorToTest
)
selector ^ <Symbol> = (
	^selectorToTest
)'dependencies'
addDependentToHierachy: anObject = (
	"an empty method. for Composite compability with TestSuite"
)
removeDependentFromHierachy: anObject = (
	"an empty method. for Composite compability with TestSuite"
)'extensions'
executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock = (
	^[aBlock value.
 	false] 
		on: anException
		do: [:exception | 
			anotherBlock value: exception.
			exception return: true]
)
fail = (
	^assert: false
)'printing'
printOn: aStream = (
	selectorToTest isNil ifTrue: [^super printOn: aStream].
	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: selectorToTest
)'private'
executeShould: aBlock 
		inScopeOf: anExceptionalEvent 
		withDescriptionContaining: aString <String> = (
	^[aBlock value.
 	false] on: anExceptionalEvent
		do: [:ex | ex return: (ex description includesSubString: aString) ]
)
executeShould: aBlock 
		inScopeOf: anExceptionalEvent 
		withDescriptionNotContaining: aString <String> = (
	^[aBlock value.
 	false] on: anExceptionalEvent
		do: [:ex | ex return: (ex description includesSubString: aString) not ]
)
executeShould: aBlock inScopeOf: anExceptionalEvent = (
	^[aBlock value.
 	false] on: anExceptionalEvent
		do: [:ex | ex return: true]
			
)
performTest = (
	perform: selectorToTest asSymbol
)'running'
debug = (
	resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[newTest runCase] 
		ensure: [resources do: [:each | each tearDown]]
)
debugAsFailure = (
	| semaphore |
	semaphore:: Semaphore new.
	resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait.
	resources do: [:each | each reset]] fork.
	newTest runCaseAsFailure: semaphore.
)
failureLog = (
	^FailureLog
)
isLogging = (
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^false
)
logFailure: aString = (
	isLogging ifTrue: [
		failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
)
openDebuggerOnFailingTestMethod = (
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

		halt
		performTest
)
run ^ <TestResult> = (
	| result |
	result:: TestResult new.
	run: result.
	^result
)
run: aResult <TestResult> = (
	aResult runCase: self
)
runCase = (
	[setUp.
	performTest] ensure: [tearDown]
)
runCaseAsFailure: aSemaphore = (
	[setUp.
	openDebuggerOnFailingTestMethod] ensure: [
		tearDown.
		aSemaphore signal]
)
setUp = (
			
)
tearDown = (
			
)'testing'
expectedFailures = (
	^ {}
)
should: aBlock <[^Boolean]> notTakeMoreThan: aDuration = (
    "Evaluate aBlock in a forked process and if it takes more than anInteger milliseconds
    to run we terminate the process and report a test failure.  It'' important to
    use the active process for the test failure so that the failure reporting works correctly
    in the context of the exception handlers."

    | evaluated evaluationProcess result delay testProcess |

    evaluated:: false.
    delay:: Delay forDuration: aDuration.
    testProcess:: Processor activeProcess.
    "Create a new process to evaluate aBlock"
    evaluationProcess:: [
        result:: aBlock value.
        evaluated:: true.
        delay unschedule.
        testProcess resume ] forkNamed: 'Process to evaluate should: notTakeMoreThanMilliseconds:'.

    "Wait the milliseconds they asked me to"
    delay wait.
    "After this point either aBlock was evaluated or not..."
    evaluated ifFalse: [
        evaluationProcess terminate.
       assert: false description: ('Block evaluation took more than the expected <1p>' expandMacrosWith: aDuration)].
   
    ^result
)
should: aBlock <[^Boolean]> notTakeMoreThanMilliseconds: anInteger <Integer> = (
    "For compatibility with other Smalltalks"

   should: aBlock notTakeMoreThan: (Duration milliSeconds: anInteger).
)
should: aBlock <[^Boolean]> raise: anException withExceptionDo: anotherBlock <[]> = (
	^assert: (executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock)
)
shouldFix: aBlock <[^Boolean]> = (
	^should: aBlock raise: Exception
)
shouldPass ^ <Boolean> = (
	"Unless the selector is in the list we get from #expectedFailures, we expect it to pass"
	^ (expectedFailures includes: selectorToTest) not
)) : ('testing'
isAbstract ^ <Boolean> = (
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self name = #TestCase
)
shouldInheritSelectors ^ <Booelan> = (
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^self superclass isAbstract
		or: [self testSelectors isEmpty]

"$QA Ignore:Sends system method(superclass)$"
))
class TestConfiguration = (
"Test configurations are used to determine how to instantiate the class under test. Each class under test should have at least one configuration in order for it to execute.  A configuration is represented by a nested class within the test case, that is declared to be a subclass of this class.

The class defines two virtual methods:

- testModuleName ^ <Symbol> - returning the name of the class under test
- configuration: ideNamespace <Namespace> ^ <Class> - returning a test case class that can be instantiated into a test case. "|
	protected testModule
|)
('as yet unclassified'
configure: platform <Platform> ^<TestCase> = (
	subclassResponsibility.
)
testModuleName ^<Symbol> = (
	subclassResponsibility.
)) : ('as yet unclassified'
configurationsFor: testClass <Symbol> ^ <Collection[TestConfiguration]> = (
	^ subclasses select: [:cls <Class> | cls new testModuleName = testClass]
))
class TestFailure = Exception (
"Signaled in case of a failed test (failure). The test framework distinguishes between failures and errors. A failure is anticipated and checked for with assertions. Errors are unanticipated problems like a division by 0 or an index out of bounds ...")
('camp smalltalk'
defaultAction = (
	UnhandledError signalForException: self
)
isResumable = (
	^ false
))
class TestResource setUp: sup <[^Object]> tearDown: tdown <[]> = (
"I represent a resource for TestCases.  My setUp method should return an object (resource) that may be used by multiple TestCases.   TestSuite will setup the resource before running a collection of test cases and tear it down afterwards "|
	setUpBlock = sup.				"create the actual resource"
	tearDownBlock = tdown.		"release the actual resource"
	private resource_private				"the actual resource"
|)
('as yet unclassified'
reset = (
	tearDown
)
resource ^ <Object> = (
	resource_private ifNil: [resource_private:: setUp].
	^resource_private
)'running'
setUp ^ <Object> = (
	resource_private:: setUpBlock value.
	^resource_private
)
signalInitializationError = (
	^class signalInitializationError
)
tearDown = (
	[tearDownBlock value] ensure: [resource_private:: nil]
)'testing'
isAvailable ^ <Boolean> = (
	"override to provide information on the
	readiness of the resource"

	^resource notNil
)
isUnavailable ^ <Boolean>  = (
	"override to provide information on the
	readiness of the resource"
	
	^isAvailable not
)) : ('as yet unclassified'
setUp: sup <[^Object]> ^<Instance> = (
	^setUp: sup tearDown: []
)'creation'
signalInitializationError = (
	^signalErrorWith: 'Resource ' , self name , ' could not be initialized'
))
class TestResult = Object (
"This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done."|
	passed =  OrderedCollection new.
	failures = Set new.
	allErrors = OrderedCollection new.
|)
('accessing'
defects = (

	^OrderedCollection new
		addAll: unexpectedErrors;
		addAll: failures; 
		yourself
			
)
expectedDefectCount = (

	^ self expectedDefects size
)
expectedDefects = (

	^ (errors, failures asOrderedCollection) select: [:each | each shouldPass not] 
)
expectedPassCount = (

	^ self expectedPasses size
)
expectedPasses = (

	^ passed select: [:each | each shouldPass] 
)
failureCount = (


	^self failures size
			
)
passedCount = (


	^self passed size
			
)
runCount = (

	^ passed size + failures size + errors size
)
tests = (

	^(OrderedCollection new: self runCount)
		addAll: passed;
		addAll: failures;
		addAll: errors;
		yourself
)
unexpectedErrorCount ^ <Integer> = (

	^ self unexpectedErrors size
)
unexpectedErrors = (

	^ allErrors select: [:each | each shouldPass] 
)
unexpectedFailureCount = (

	^ self unexpectedFailures size
)
unexpectedFailures = (

	^ failures select: [:each | each shouldPass] 
)
unexpectedPassCount = (

	^ self unexpectedPasses size
)
unexpectedPasses = (

	^ passed select: [:each | each shouldPass not] 
)'as yet unclassified'
errors = (
	^unexpectedErrors
)'printing'
printOn: aStream = (

	aStream
		nextPutAll: self runCount printString;
		nextPutAll: ' run, ';
		nextPutAll: self expectedPassCount printString;
		nextPutAll: ' passes, ';
		nextPutAll: self expectedDefectCount printString;
		nextPutAll:' expected failures, ';
		nextPutAll: self unexpectedFailureCount printString;
		nextPutAll: ' failures, ';
		nextPutAll: self unexpectedErrorCount printString;
		nextPutAll:' errors, ';
		nextPutAll: self unexpectedPassCount printString;
		nextPutAll:' unexpected passes'.
)'running'
runCase: aTestCase <TestCase> = (

	| testCasePassed <Boolean> |
	testCasePassed:: true.
	[[aTestCase runCase] 
		on: TestFailure "Exception"
		do: [:signal | 
			"(signal isKindOf: TestFailure) ifFalse:[signal resignalAs: signal]."
			failures add: aTestCase.
			testCasePassed:: false.
			signal return: false
			]
	]	on: Error, SyntaxErrorNotification
		do: [:signal |
			allErrors add: aTestCase.
			testCasePassed:: false.
			signal return: false
			].
	testCasePassed ifTrue: [passed add: aTestCase]
)'testing'
hasErrors = (


	^self errors size > 0
			
)
hasFailures ^ <Boolean> = (
	^self failures size > 0
			
)
hasPassed ^ <Boolean>= (
	^self runCount = (self passedCount + self expectedDefectCount)
)
isError: aTestCase = (


	^self errors includes: aTestCase
			
)
isFailure: aTestCase = (

	^self failures includes: aTestCase
			
)
isPassed: aTestCase = (


	^self passed includes: aTestCase
			
))
class TestSuite named: nm <String> tests: t <SeqCtn[TestCase | TestSuite]> = (
"This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol"| 
	name <String> = nm.
	tests <SeqCtn[TestCase | TestSuite]> = t ifNil: [OrderedCollection new].
 |)
('accessing'
addTest: aTest <TestCase | TestSuite> = (
	self tests add: aTest
)
addTests: aCollection <Colection[TestCase | TestSuite]> = (
	aCollection do: [:eachTest <TestCase>  | self addTest: eachTest]
)
defaultResources ^ <SeqCltn[TestResource]> = (
	^self tests 
		inject: OrderedCollection new
		into: [:coll <SeqCltn[TestResource]> :testCase <TestCase> | 
			coll
				addAll: testCase resources;
				yourself]
)
resources ^ <Set[TestResource]> = (
	^tests inject: IdentitySet new into: [:set :each | set addAll: each resources; yourself]
)'as yet unclassified'
addDependentToHierarchy: anObject = (
	self addDependent: anObject.
	self tests do: [ :each | each addDependentToHierarchy: anObject]
)'dependencies'
removeDependentFromHierachy: anObject = (
	self removeDependent: anObject.
	self tests do: [ :each <TestCase> | each removeDependentFromHierachy: anObject]
)'running'
run = (
	| result <TestResult> |
 	result:: TestResult new.
	resources do: [ :res |
		res isAvailable ifFalse: [^res signalInitializationError]].
	[run: result] ensure: [resources do: [:each | each reset]].
	^result
)
run: aResult <TestResult> = (
	tests do: [:each <TestCase | TestSuite> | 
		changed: each.
		each run: aResult]
)) : ('as yet unclassified'
on: testCaseClass <Class> ^ <Instance> = (
	^named: testCaseClass name asString 
	tests: (allTestsFromTestCase: testCaseClass).
))'as yet unclassified'
isTestClass: cls <Class> ^ <Boolean> = (
"someday, should use metadata"
	#BOGUS yourself. 	"%BOGUS use mirrors"
	^(cls inheritsFrom: TestCase) or: [(cls name endsWith: 'TestCase')]
)
isTestMethod: selector <String> ^ <Boolean> = (
	#BOGUS yourself. 	
	 ^selector first = $t and:[('test*' match: selector) and: [selector numArgs <= 0]]
	"%BOGUS: nasty Squeakism: strings can tell you how many arguments they have (assuming the string is a method name"
)
isTestMethod: selector <String> inClass: cls <Class> ^ <Boolean> = (
	^(isTestMethod: selector) and:[isTestClass: cls]
)
signalErrorWith: aString <String> = (
	Error new signal: aString		
)
signalFailureWith: aString <String> = (
	TestFailure new signal: aString		
)'private'
allTestSelectorsFromTestCase: testCaseClass <Class> ^  <Collection[Symbol]> = (
	| sels <Collection[Symbol]> |
	^(testSelectorsFromSelectors: testCaseClass allSelectors)
)
allTestsFromChildrenOfTestCase: testCaseClass <Class> ^ <SeqCltn[TestCase | TestSuite]> = (
	| tests <SeqCltn[TestCase | TestSuite]> |
	tests:: OrderedCollection new.
	testCaseClass allSubclasses 
		do: [: each <Class>  | 
			tests addAll: (allTestsFromTestCase: each)].
	^tests
)
allTestsFromTestCase: testCaseClass <Class> ^ <SeqCltn[TestCase | TestSuite]> = (
	| tests <SeqCltn[TestCase | TestSuite]> |
	tests:: OrderedCollection new.
	(isAbstractTestCase: testCaseClass)
		ifTrue: [tests addAll: (allTestsFromChildrenOfTestCase: testCaseClass)]
		ifFalse: [tests addAll: (
					(allTestSelectorsFromTestCase: testCaseClass)
						collect: [:each | testCaseClass on: each])].
	^tests
)
isAbstractTestCase: testCaseClass <Class> ^ <Boolean> = (
	^(testCaseClass respondsTo: #isAbstract)
		ifTrue: [testCaseClass isAbstract]
		ifFalse: [false]
)
shouldInheritSelectorsFromTestCase: testCaseClass <Class> ^ <Boolean> = (
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^testCaseClass superclass isAbstract
		or: [(testSelectorsFromTestCase: testCaseClass) isEmpty]
)
testSelectorsFromSelectors: sels <Collection[Symbol]> ^  <Collection[Symbol]> = (
	^sels select: [:each <Symbol>  |  isTestMethod: each]
)
testSelectorsFromTestCase: testCaseClass <Class> ^  <Collection[Symbol]> = (
	| sels <Collection[Symbol]> |
	^(testSelectorsFromSelectors: testCaseClass selectors)
))