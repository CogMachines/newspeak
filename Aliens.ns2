Newspeak3
'Aliens'
class Aliens usingPlatform: p vmMirror: vmm = NewspeakObject (
"Aliens are Newspeak's capabilities for FFI.  They represent C data and allow callouts and callbacks.
 
This module simply provides access to the Smalltalk classes.  The story for NS2/3 Aliens is not yet well-defined.

More documentuation is available at
http://wiki.squeak.org/squeak/uploads/6100/Alien%20FFI.2.pdf
http://wiki.squeak.org/squeak/uploads/6100/Alien%20FFI%20bowels.2.pdf

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Ryan Macnak
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
	public Alien = p blackMarket NsFFI Alien.
	public Callback = p blackMarket NsFFI Callback.
	public IllegalAlien = p blackMarket NsFFI IllegalAlien.
	public UnsafeAlien = p blackMarket NsFFI UnsafeAlien.
	public ObjectiveCAlien = p blackMarket NsFFI ObjectiveCAlien.
	
	private vmMirror = vmm.
	private ByteString = p blackMarket Collections ByteString.
	private ByteArray = p collections ByteArray.
	private Dictionary = p collections Dictionary.
	private loadedLibraries ::= Dictionary new.
|)
(
class Alien3 on: ba = (
"
Experimental.

Note that Alien indexing starts at 1 as in Smalltalk, not at 0 as in C or Strongtalk's FFI.
"|
	private bytearray = ba. "Note this is not an instance of ByteArray because the AlienFFI primitives sometimes check that their arguments are instances of the Squeak class Alien.  If these checks are removed, this should work with ByteArray directly."
|)
('HACK'
asInteger = (
	^bytearray
)'accessing'
address ^<Integer> = (
	^self sizeField <= 0
		ifTrue: [self addressField]
		ifFalse: [self error: 'One cannot take the address of direct Alien instances; they may move']
)
boolAt: index <Integer> ^<Boolean> = ( 
	^(self unsignedLongAt: index) ~~ 0
)
boolAt: index <Integer> put: newValue <Integer | Boolean> = (
	self unsignedLongAt: index
		put: (newValue isInteger ifTrue: [newValue] ifFalse: [newValue ifTrue: [1] ifFalse:[0]])
)
copyInto: aByteObject <Alien | indexableByteSubclass> from: start <Integer> to: stop <Integer> in: replacement <Alien | indexableByteSubclass> startingAt: repStart <Integer> ^<self> = (

	vmMirror 
	 alien: self bytearray
	 copyInto: (aByteObject class = self class ifTrue: [aByteObject bytearray] ifFalse: [aByteObject])
	 from: start
	 to: stop
	 in: replacement asInteger
	 startingAt: repStart
	 ifFail: [halt].
	^self
)
dataSize ^<Integer> = (
	^self sizeField abs
)
doubleAt: index <Integer> ^<Float> = (
	^vmMirror alien: bytearray doubleAt: index ifFail: [halt]
)
doubleAt: index <Integer> put: value <Float | Integer> ^<Float | Integer> = (
	^vmMirror alien: bytearray doubleAt: index put: value ifFail: [halt].
)
floatAt: index <Integer> ^<Float> = (
	^vmMirror alien: bytearray floatAt: index ifFail: [halt]
)
floatAt: index <Integer> put: value <Float | Integer> ^<Float | Integer> = (
	^vmMirror alien: bytearray floatAt: index put: value ifFail: [halt]
)
freeAfter: aBlock = (
	"The receiver must be a pointer to a previously allocated external C heap memory block. Invoke aBlock passing the receiver as the argument, then free the receiver. Allows automatic allocation and freeing of C artifacts using patters such as
	(Alien newCString: 'foo') freeAfter: [:cstring | ...use cstring here...]."
	
	^[aBlock value: self] ensure: [self free]
)
pointer ^<Alien> = (
	"Answer a pointer to the receiver in the form of an Alien.
	 This will fail if the receiver is not indirect."
	self isPointer ifTrue:
		[self error: 'One cannot take the address of pointer Alien instances; they may move, and are already pointers'].
	^self class forPointer: self address
)
replaceFrom: start <Integer> to: stop <Integer> with: replacement <Alien | indexableByteSubclass> startingAt: repStart <Integer> ^<self> = (

	vmMirror alien: bytearray replaceFrom: start to: stop with: replacement startingAt: repStart ifFail: [halt].
	^self
)
signedByteAt: index <Integer> ^<Integer> = (
	^vmMirror alien: bytearray signedByteAt: index ifFail: [halt]
)
signedByteAt: index <Integer> put: value <Integer> ^<Integer> = (
	^vmMirror alien: bytearray signedByteAt: index put: value ifFail: [halt]
)
signedLongAt: index <Integer> ^<Integer> = (
	^vmMirror alien: bytearray signedLongAt: index ifFail: [halt]
)
signedLongAt: index <Integer> put: value <Integer> ^<Integer> = (
	^vmMirror alien: bytearray signedLongAt: index put: value ifFail: [halt]
)
signedShortAt: index <Integer> ^<Integer> = (
	^vmMirror alien: bytearray signedShortAt: index ifFail: [halt]
)
signedShortAt: index <Integer> put: value <Integer> ^<Integer> = (
	^vmMirror alien: bytearray signedShortAt: index put: value ifFail: [halt]
)
strcpy ^<ByteString> = (
	^self strcpyFrom: 1
)
strcpyFrom: startIndex <Integer> ^<ByteString> = (
	| length string |
	length:: self strlenStartingAt: startIndex.
	string:: ByteString new: length.
	self copyInto: string
		from: 1 to: length
		in: self startingAt: startIndex.
	^string
)
strcpyUTF8 ^<String> = (
	^self strcpyUTF8From: 1
)
strcpyUTF8From: startIndex <Integer> ^<String> = (
	| length bytes |
	length:: self strlenStartingAt: startIndex.
	self copyInto: (bytes:: ByteArray new: length)
		from: 1 to: length
		in: self startingAt: 1.
	^bytes utf8ToIso
)
strlen = (
	^self strlenStartingAt: 1
)
strlenStartingAt: index <Integer> ^<Integer> = (
	^vmMirror alien: bytearray strlenStartingAt: index ifFail: [halt]
)
strlenThroughPointerAt: index <Integer> ^<Integer> = (
	^vmMirror alien: bytearray strlenThroughPointerAt: index
)
unsignedByteAt: index <Integer> ^<Integer> = (
	^vmMirror alien: bytearray unsignedByteAt: index ifFail: [halt]
)
unsignedByteAt: index <Integer> put: value <Integer> ^<Integer> = (
	^vmMirror alien: bytearray unsignedByteAt: index put: value ifFail: [halt]
)
unsignedLongAt: index <Integer> ^<Integer> = (
	^vmMirror alien: bytearray unsignedLongAt: index ifFail: [halt]
)
unsignedLongAt: index <Integer> put: value <Integer> ^<Integer> = (
	^vmMirror alien: bytearray unsignedLongAt: index put: value ifFail: [halt]
)
unsignedShortAt: index <Integer> ^<Integer> = (
	^vmMirror alien: bytearray unsignedShortAt: index ifFail: [halt]
)
unsignedShortAt: index <Integer> put: value <Integer> ^<Integer> = (
	^vmMirror alien: bytearray unsignedShortAt: index put: value ifFail: [halt]
)'as yet unclassified'
findSymbol: symbol <String> ^<Integer> = (
	^vmMirror inLibrary: self bytearray findSymbol: symbol ifFail: []
)'callouts'
callDoubleResult: result <Alien | nil> arguments: args <Array[Alien | Integer]> ^<Alien> = (	
	vmMirror
		callFunction: self bytearray 
		doubleResult: (result ifNotNil: [result bytearray])
		arguments: (args collect: [:ea | ea asInteger])
		ifFail: [halt].
	^result
)
callFloatResult: result <Alien | nil> arguments: args <Array[Alien | Integer]> ^<Alien> = (	
	vmMirror
		callFunction: self bytearray 
		floatResult: (result ifNotNil: [result bytearray])
		arguments: (args collect: [:ea | ea asInteger])
		ifFail: [halt].
	^result
)
callIntegralResult: result <Alien | nil> arguments: args <Array[Alien | Integer]> ^<Alien> = (	
	vmMirror
		callFunction: self bytearray 
		integralResult: (result ifNotNil: [result bytearray])
		arguments: (args collect: [:ea | ea asInteger])
		ifFail: [halt].
	^result
)'coercing'
asAlien ^<Alien> = (
	^self
)'converting'
asSignedByte ^<Integer> = (
	"Answer an Integer created from the first byte of the receiver interpreted as a signed value."
	
	^self signedByteAt: 1
)
asSignedLong ^<Integer> = (
	"Answer an Integer created from the first 4 bytes of the receiver interpreted as a signed value."
	
	^self signedLongAt: 1
)
asSignedShort ^<Integer> = (
	"Answer an Integer created from the first 2 bytes of the receiver interpreted as a signed value."
	
	^self signedShortAt: 1
)
asUnsignedByte ^<Integer> = (
	"Answer an Integer created from the first byte of the receiver interpreted as an unsigned value."
	
	^self unsignedByteAt: 1
)
asUnsignedLong ^<Integer> = (
	"Answer an Integer created from the first 4 bytes of the receiver interpreted as an unsigned value."
	
	^self unsignedLongAt: 1
)
asUnsignedShort ^<Integer> = (
	"Answer an Integer created from the first 2 bytes of the receiver interpreted as an unsigned value."
	
	^self unsignedShortAt: 1
)'memory management'
free = (
	"Free the memory referenced by the receiver, or fail if
	 the receiver is direct or the indirect pointer is invalid.
	 Note that if successful the address and size fields are
	 zero'ed, effectively preventing double-freeing hazards."
	vmMirror free: bytearray ifFail: [halt]
)'private'
addressField ^<Integer> = (
	^vmMirror alienAddressField: bytearray ifFail: [halt]
)
addressFieldPut: value <Integer> ^<Integer> = (
	^vmMirror alien: bytearray addressFieldPut: value ifFail: [halt]
)
sizeField ^<Integer> = (
	^vmMirror alienSizeField: bytearray ifFail: [halt]
)
sizeFieldPut: size <Integer> ^<Integer> = (
	^vmMirror alien: bytearray sizeFieldPut: size ifFail: [halt]
)'testing'
isPointer ^<Boolean> = (
	^self sizeField = 0
)) : ('as yet unclassified'
autoFreeAfter: action = (
	"Evaluate the action, which must be a 1-argument block. The argument passed to the action is a block the action can use to register Aliens created inside the action. Such aliens will be freed as soon as the action completes. Return the value returned from the action. See usage example at the bottom of the method. "
	
	| toFree |
	toFree:: OrderedCollection new.
	^[action value: [:alien | toFree add: alien]]
		ensure: [toFree do: [:each | each free]]
		
"
	Alien autoFreeAfter:
		[:autoFree | | foo bar |
		foo := autoFree value: (Alien newCString: 'foo').
		bar := autoFree value: (Alien newCString: 'bar').
		...]
"
)
ensureLoaded: aLibraryName <String> ^<Alien> = (
	^loadedLibraries at: aLibraryName ifAbsentPut: [
		(Alien basicNew: 4)
			unsignedLongAt: 1
			put: (vmMirror loadLibrary: aLibraryName ifFail: [halt]);
			yourself
	]
)
forPointer: address <Integer> = (
	
	^(self on: (Alien basicNew: 8)) 
		sizeFieldPut: 0;
		addressFieldPut: address;
		yourself
)
fromString: str = (
	| len |
	len:: str byteSize.
	^(self newC: len + 1)
		replaceFrom: 1 to: len with: str startingAt: 1
)
lookup: symbol  <String> inLibrary: libraryName <String> ^<Alien> = (
	^self forPointer: ((self ensureLoaded: libraryName) findSymbol: symbol)
)
new: byteSize = (
	
	"Answer an Alien of the given byte size whose data resides on the Smalltalk heap."
	
	^(self on: (Alien basicNew: byteSize + 4))
		sizeFieldPut: byteSize;
		yourself
)
newC: byteSize = (
	
	"Answer an Alien of the given byte size whose data resides on the external heap.  The memory is zero-filled."
	
	^(self on: (Alien basicNew: 8)) 
		sizeFieldPut: byteSize negated;
		addressFieldPut: (vmMirror calloc: byteSize ifFail: [callocFailed]);
		yourself
)
rawNewC: byteSize = (
	
	"Answer an Alien of the given byte size whose data resides on the external heap.  The memory is NOT zero-filled."
	
	^(self on: (Alien basicNew: 8)) 
		sizeFieldPut: byteSize negated;
		addressFieldPut: (vmMirror malloc: byteSize ifFail: [mallocFailed]);
		yourself
))'restricted'
resetForNewImageSession = (
	loadedLibraries:: Dictionary new: loadedLibraries size.
))