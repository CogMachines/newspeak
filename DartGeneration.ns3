Newspeak3
'NS2Dart'
class DartGeneration usingPlatform: platform = (
"Building blocks of Dart syntax trees and a tree writer. The nodes are intended to represent Dart code to be generated rather than the result of parsing an arbitrart Dart program, so these nodes may not provide for complete expression of Dart.

Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
	private List = platform collections OrderedCollection.
	private Dictionary = platform collections Dictionary.
	private WriteStream = platform streams CharacterReadWriteStream.

	syntax = Syntax new.
	factory = Factory new.
|)
(
class Factory = ()
('as yet unclassified'
assign: lhs <Node> toBe: rhs <Node> ^<Node> = (
	assert: [lhs isDartNode] message: 'Dart node expected on left'.
	assert: [rhs isDartNode] message: 'Dart node expected on right'.
	^syntax AssignmentExpression leftHandSide: lhs rightHandSide: rhs
)
block: statements <List[Node]> ^<Node> = (
	statements do: [:each | assert: [each isDartNode] message:'Malformed statement tree'].
	^syntax Block statements: statements
)
list: elements <List[Node]> ^<ListExpression> = (
	elements do: [:each | assert: [each isDartNode] message: 'Dart node expected'].
	^syntax ListExpression elements: elements
)) : ()
class Syntax = (
"The AST nodes. The preferred way to construct instances is to use the factory object (an instance of Factory, a sibling of this class) held onto by the module.")
(
class AssignmentExpression leftHandSide: lhs rightHandSide: rhs = Node (|
	leftHandSide <Expression> = lhs.
	rightHandSide <Expression> = rhs.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode 
		and: [leftHandSide = anotherNode leftHandSide
			and: [rightHandSide = anotherNode rightHandSide]]	
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	leftHandSide printOn: stream.
	stream nextPutAll: ', '.
	rightHandSide printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitAssignmentExpression: self
)) : ('as yet unclassified'
var: name <String> to: expr <Expression> = (
	^AssignmentExpression
		leftHandSide: (IdentifierExpression name: name)
		rightHandSide: expr
))
class Block statements: s = Node (|
	statements <List[Statement | Expression]> = s.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [statements = anotherNode statements]
)
asBlock = (
	^self
)
isBlockStatement = (
	^true
)
visitBy: visitor = (
	^visitor visitBlock: self
)
visitStatementsBy: visitor = (
	| result |
	statements do: [:each | result:: each visitBy: visitor].
	^result
)) : ('as yet unclassified'
empty = (
	^Block statements: {}
))
class ListExpression elements: elements_ = Node (
"A list expression, e.g. [1,2,3]."|
	elements = elements_.
|)
('as yet unclassified'
visitBy: visitor = (
	^visitor visitListExpression: self
)) : ()
class Node = (
"The superclass of all other nodes, both statements and expressions."|
	comment <String>
|)
('as yet unclassified'
= anotherNode = (
	^class = anotherNode class
)
isDartNode = (
	^true
)) : ()) : ()
class Writer = (
"Writes out a tree of Dart syntax elements."|
	private output <WriteStream>
	private tabLevel <Integer>
	private stringTranslation = Dictionary new.
|stringTranslation at: $\ put: '\\'.
	stringTranslation at: Character cr put: '\r'.
	stringTranslation at: Character lf put: '\n'.
	stringTranslation at:  $" put: '\"')
('as yet unclassified'
visitAssignmentExpression: node <AssignmentExpression> = (
	node leftHandSide visitBy: self.
	write: ' = '.
	node rightHandSide visitBy: self.
)
visitBlock: node <Block> = (
	| statements |
	statements: node statements.
	statements isEmpty ifTrue:
		[^write: '{}'].
	write: '{'.
	indentCr.
	statements
		do:
			[:each |
			each visitBy: self.
			write: ';']
		separatedBy:
			[cr].
	unindentCr.
	write: '}'
)
visitListExpression: node <ListExpression> = (
	| elements |
	elements: node elements.
	elements isEmpty ifTrue:
		[^write: '[]'].
	elements size = 1 ifTrue:
		[write: '['.
		elements first visitBy: self.
		^write: ']'].
	write: '['.
	indentCr.
	elements
		do:
			[:each | each visitBy: self]
		separatedBy:
			[write: ','.
			cr].
	unindentCr.
	write: ']'
)) : ()) : ()