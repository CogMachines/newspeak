Newspeak3
'NS2Dart'
class DartGeneration usingPlatform: platform = (
"Building blocks of Dart syntax trees and a tree writer. The nodes are intended to represent Dart code to be generated rather than the result of parsing an arbitrary Dart program, so these nodes may not provide for complete expression of Dart.

Derived from the JavascriptGeneration class in NS2JS, which is why the SAP copyright below applies.

Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
	private List = platform collections OrderedCollection.
	private Dictionary = platform collections Dictionary.
	private WriteStream = platform streams CharacterReadWriteStream.

	syntax = Syntax new.
	factory = Factory new.
|)
(
class Factory = ()
('as yet unclassified'
assign: lhs <Node> toBe: rhs <Node> ^<Node> = (
	assert: [lhs isDartNode] message: 'Dart node expected on left'.
	assert: [rhs isDartNode] message: 'Dart node expected on right'.
	^syntax AssignmentExpression leftHandSide: lhs rightHandSide: rhs
)
block: statements <List[Node]> ^<Node> = (
	statements do: [:each | assert: [each isDartNode] message:'Malformed statement tree'].
	^syntax Block statements: statements
)
class: name extends: supername fields: fields methods: methods = (
	^syntax ClassDeclaration 
		name: name
		superclassName: supername
		fields: fields
		methods: methods
)
for: initExpr while: testExpr step: incExpr do: bodyStmt = (
	^syntax ForStatement
		initExpression: initExpr
		test: testExpr
		increment: incExpr
		body: bodyStmt
)
for: varName <String> in: expr <Node> do: bodyStmt <Node> = (
	| canonicalVarName |
	canonicalVarName:: varName isNil
		ifTrue: [varName]
		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].
	^syntax ForInStatement
		varName: canonicalVarName
		expression: expr
		body: bodyStmt
)
functionOf: params body: body <Block> = (
	halt. "Block closures -> Anonymous functions"
)
ident: name <String> ^<Node> = (
	assert: [name isString] message: 'name must be a string'.
	^syntax IdentifierExpression name: name
)
if: expression <Node> then: then <Node> ^<Node> = (
	^syntax IfStatement expression: expression then: then else: nil
)
if: expression <Node> then: then <Node> else: else <Node> ^<Node> = (
	^syntax IfStatement expression: expression then: then else: else
)
library: name classes: classes = (
	^syntax LibraryDeclaration name: name classes: classes
)
list: elements <List[Node]> ^<ListExpression> = (
	elements do: [:each | assert: [each isDartNode] message: 'Dart node expected'].
	^syntax ListExpression elements: elements
)
literal: value <Boolean | Integer> ^<Node> = (
	value isString ifTrue: [^syntax StringLiteral value: value].
	value isNumber ifTrue: [^syntax IntegerLiteral value: value].
	(true = value or: [false = value]) ifTrue: [^syntax BooleanLiteral value: value].
	error: 'this value cannot be a Dart literal'
)
memberOf: expression <Node> at: memberName <Node> = (
	assert: [expression isDartNode] message: 'Dart node expected'.
	assert: [memberName isString] message: 'String expected for member name'.
	^syntax MemberExpression primary: expression property: memberName
)
method: name <String> params: params body: body <Block> = (
	| canonicalName canonicalParams |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	canonicalParams:: params collect: [:each | each isString ifTrue: [ident: each]  ifFalse: [each]].
	^syntax MethodDeclaration name: canonicalName parameters: canonicalParams body: body
)
new: expression <Node> with: args <List[Node]> ^<Node> = (
	^syntax NewExpression expression: expression arguments: args
)
on: target invoke: method with: arguments <List[Node]> = (
	^syntax MethodInvocation target: target method: method arguments: arguments
)
operator: name <String> with: left <Node> and: right <Node> = (
	assert: [left isDartNode] message: 'Dart node expected on left'.
	assert: [right isDartNode] message: 'Dart node expected on right'.
	^syntax OperatorExpression operator: name with: left and: right
)
postfixOperator: name <String> on: operand <Node> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax UnaryOperatorExpression operator: canonicalName postfix: true on: operand
)
prefixOperator: name <String> on: operand <Node> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax UnaryOperatorExpression operator: canonicalName postfix: false on: operand
)
return = (
	^syntax ReturnStatement expression: nil
)
return: expression <Node | nil> = (
	^syntax ReturnStatement expression: expression
)
ternaryIf: condition then: then else: else = (
	^syntax TernaryOperatorExpression
		if: condition
		then: then
		else: else
)
throw: expression <Node> ^<Node> = (
	^syntax ThrowStatement expression: expression
)
try: block <Block> catch: varName <String> with: catchBlock <Block> = (
	| canonicalVarName |
	canonicalVarName:: varName isNil
		ifTrue: [varName]
		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].
	^syntax TryStatement block: block catch: canonicalVarName with: catchBlock finally: nil
)
try: block <Block> catch: varName <String> with: catchBlock <Block> finally: finallyBlock <Block>= (
	| canonicalVarName |
	canonicalVarName:: varName isNil
		ifTrue: [varName]
		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].
	^syntax TryStatement block: block catch: canonicalVarName with: catchBlock finally: finallyBlock
)
var: name <String> ^<VariableStatement> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax VariableStatement name: canonicalName initializer: nil
)
var: name <String> value: expr <Node> ^<VariableStatement> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax VariableStatement name: canonicalName initializer: expr
)) : ()
class Syntax = (
"The AST nodes. The preferred way to construct instances is to use the factory object (an instance of Factory, a sibling of this class) held onto by the module.")
(
class AssignmentExpression leftHandSide: lhs rightHandSide: rhs = Node (|
	leftHandSide <Expression> = lhs.
	rightHandSide <Expression> = rhs.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode 
		and: [leftHandSide = anotherNode leftHandSide
			and: [rightHandSide = anotherNode rightHandSide]]	
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	leftHandSide printOn: stream.
	stream nextPutAll: ', '.
	rightHandSide printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitAssignmentExpression: self
)) : ('as yet unclassified'
var: name <String> to: expr <Expression> = (
	^AssignmentExpression
		leftHandSide: (IdentifierExpression name: name)
		rightHandSide: expr
))
class Block statements: s = Node (|
	statements <List[Statement | Expression]> = s.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [statements = anotherNode statements]
)
asBlock = (
	^self
)
isBlockStatement = (
	^true
)
visitBy: visitor = (
	^visitor visitBlock: self
)
visitStatementsBy: visitor = (
	| result |
	statements do: [:each | result:: each visitBy: visitor].
	^result
)) : ('as yet unclassified'
empty = (
	^Block statements: {}
))
class ClassDeclaration name: n superclassName: s fields: f methods: m = Node (|
name <String> = n.
superclassName <String> = s.
fields = f.
methods = m.
|)
('as yet unclassified'
visitBy: visitor = (
	^visitor visitClassDeclaration: self
)) : ()
class IdentifierExpression name: s <String> = Node (
"a case of PrimaryExpression"|
	name = s.
|assert: [isLegalIdentifier: s] message: 'Not a legal Dart identifier')
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [name = anotherNode name]
)
isIdentifier = (
	^true
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	stream nextPutAll: name.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitIdentifierExpression: self
)) : ()
class LibraryDeclaration name: n classes: c = Node (
"Describe the class in this comment."|
	name <String> = n.
	classes <List[ClassDeclaration]> = c.
|)
('as yet unclassified'
visitBy: visitor = (
	^visitor visitLibraryDeclaration: self
)) : ()
class ListExpression elements: elements_ = Node (
"A list expression, e.g. [1,2,3]."|
	elements = elements_.
|)
('as yet unclassified'
visitBy: visitor = (
	^visitor visitListExpression: self
)) : ()
class MemberExpression primary: expr <Expression> property: p <Node> = Node (
"primary.property"|
	primary = expr.
	property = p.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[primary = anotherNode primary and:
		[property = anotherNode property]]
)
isMemberExpression = (
	^true
)
visitBy: visitor = (
	^visitor visitMemberExpression: self
)) : ()
class MethodDeclaration name: n parameters: p body: b = Node (|
	name = n.
	parameters = p.
	body = b.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[name = anotherNode name and:
		[parameters = anotherNode parameters and:
		[body = anotherNode body]]]
)
visitBy: visitor = (
	^visitor visitMethodDeclaration: self
)) : ()
class MethodInvocation target: t method: m arguments: a = Node (
"target.method(a1, a2, ... aN)"|
	target <Expression> = t.
	method <String> = m.
	arguments <List[Expression]> = a.
|)
('as yet unclassified'
isMethodInvocation = (
	^true
)
visitBy: visitor = (
	^visitor visitMethodInvocation: self
)) : ()
class NewExpression expression: expr arguments: args = Node (
"new expr ( arg, .... )"|
	expression = expr.
	arguments = args.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[expression = anotherNode expression and:
		[arguments = anotherNode arguments]]
)
visitBy: visitor = (
	^visitor visitNewExpression: self
)) : ()
class Node = (
"The superclass of all other nodes, both statements and expressions."|
	comment <String>
|)
('as yet unclassified'
= anotherNode = (
	^class = anotherNode class
)
isDartNode = (
	^true
)) : ()
class OperatorExpression operator: name <String> with: left <Node> and: right <Node> = Node (|
	operatorName = name.
	left = left.
	right = right.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[operatorName = anotherNode operatorName and:
		[left = anotherNode left and:
		[right = anotherNode right]]]
)
isOperatorExpression = (
	^true
)
visitBy: visitor = (
	^visitor visitOperatorExpression: self
)) : ()
class ReturnStatement expression: expr = Node (
"return expression/opt."|
	expression <Expression | nil> = expr.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [expression = anotherNode expression]
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	expression printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitReturnStatement: self
)) : ('as yet unclassified'
noValue = (
	^ReturnStatement expression: nil
))
class StringLiteral value: string <String> = Node (|
	value = string.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[value = anotherNode value]
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	value printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitStringLiteral: self
)) : ()
class VariableStatement name: n <IdentifierExpression> initializer: expr <Expression> = Node (
"var name [= expression]"|
	name = n.
	initializer = expr.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[name = anotherNode name and:
		[initializer = anotherNode initializer]]
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	name printOn: stream.
	stream nextPutAll: ', '.
	initializer printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitVariableStatement: self
)) : ('as yet unclassified'
name: s = (
	^VariableStatement name: s initializer: nil
))'as yet unclassified'
isLegalIdentifier: id <String> ^<Boolean> = (
	id size > 0 ifFalse: [^false].
	id do: [:char | (char isAlphaNumeric or: [char = $_]) ifFalse: [^false]].
	^id first isNumber not
)) : ()
class Writer = (
"Writes out a tree of Dart syntax elements."|
	private output <WriteStream>
	private tabLevel <Integer>
	private stringTranslation = Dictionary new.
|stringTranslation at: $\ put: '\\'.
	stringTranslation at: Character cr put: '\r'.
	stringTranslation at: Character lf put: '\n'.
	stringTranslation at:  $" put: '\"')
('accessing'
generateSourceFor: node <Node> on: stream <WriteStream> = (
	"Generate Javascript source to represent the node, writing it out to the stream."
	beginNewWriteCycleUsing: stream.
	node visitBy: self.
)'as yet unclassified'
visitClassDeclaration: node <ClassDeclaration> = (
	write: 'class '.
	write: node name.
	write: ' extends '.
	write: node superclassName.
	cr.
	write: '{'.
	indentCr.
		node fields do: [:ea | ea visitBy: self. write: ';'. cr].
		cr.
		node methods do: [:ea | ea visitBy: self].
	unindentCr.
	write: '}'.
	cr.
)
visitMemberExpression: node <MemberExpression> = (
	node primary visitBy: self.
	write: '.'.
	write: node property.
)
visitMethodDeclaration: node <MethodDeclaration> = (
	node name visitBy: self.
	write: '('.
	node parameters do: [:ea | ea visitBy: self] separatedBy: [write: ', '].
	write: ')'.
	cr.
	node body visitBy: self.
	cr.
)
visitMethodInvocation: node <MethodInvocation> = (
	node target visitBy: self.
	write: '.'.
	node method visitBy: self.
	write: '('.
	node arguments do: [:ea | ea visitBy: self] separatedBy: [write: ', '].
	write: ')'.
)
visitNewExpression: node <NewExpression> = (
	write: 'new '.
	node expression visitBy: self.
	write: '('.
	node arguments do: [:ea | ea visitBy: self] separatedBy: [write: ', '].
	write: ')'.
)
visitOperatorExpression: node <OperatorExpression> = (
	| parenthesizeLeft parenthesizeRight |
	parenthesizeLeft:: node left isOperatorExpression.
	parenthesizeRight:: node right isOperatorExpression.
	parenthesizeLeft ifTrue: [write: '('].
	node left visitBy: self.
	parenthesizeLeft ifTrue: [write: ') '] ifFalse: [write: ' '].
	write: node operatorName.
	parenthesizeRight ifTrue: [write: ' ('] ifFalse: [write: ' '].
	node right visitBy: self.
	parenthesizeRight ifTrue: [write: ')']
)
visitReturnStatement: node <ReturnStatement> = (
	write: 'return '.
	node expression visitBy: self.
)
visitStringLiteral: node <StringLiteral> = (
	(node value includes: $") ifTrue: [halt "Implement escaping"].
	
	write: '"'.
	write: node value.
	write: '"'.
)'node traversal'
visitAssignmentExpression: node <AssignmentExpression> = (
	node leftHandSide visitBy: self.
	write: ' = '.
	node rightHandSide visitBy: self.
)
visitBlock: node <Block> = (
	| statements |
	statements: node statements.
	statements isEmpty ifTrue:
		[^write: '{}'].
	write: '{'.
	indentCr.
	statements
		do:
			[:each |
			each visitBy: self.
			write: ';']
		separatedBy:
			[cr].
	unindentCr.
	write: '}'
)
visitIdentifierExpression: node <IdentifierExpression> = (
	write: node name
)
visitLibraryDeclaration: lib <LibraryDeclaration> = (
	write: '#library('.
	write: lib name.
	write: ');'.
	cr. cr.
	lib classes do: [:ea | ea visitBy: self] separatedBy: [cr. cr].
)
visitListExpression: node <ListExpression> = (
	| elements |
	elements: node elements.
	elements isEmpty ifTrue:
		[^write: '[]'].
	elements size = 1 ifTrue:
		[write: '['.
		elements first visitBy: self.
		^write: ']'].
	write: '['.
	indentCr.
	elements
		do:
			[:each | each visitBy: self]
		separatedBy:
			[write: ','.
			cr].
	unindentCr.
	write: ']'
)
visitVariableStatement: node <VariableStatement> = (
	write: 'var '.
	node name visitBy: self.
)'private'
beginNewWriteCycleUsing: stream <WriteStream> = (
	output:: stream.
	tabLevel:: 0.
)
cr = (
	"Write a newline and the next line's indentation."
	output cr.
	tabLevel timesRepeat: [output tab]
)
indentCr = (
	tabLevel: tabLevel + 1.
	cr
)
unindentCr = (
	tabLevel:: 0 max: tabLevel - 1.
	cr
)
write: text <String> = (
	output nextPutAll: text
)) : ()) : ()