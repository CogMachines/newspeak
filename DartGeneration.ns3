Newspeak3
'NS2Dart'
class DartGeneration usingPlatform: platform = (
"Building blocks of Dart syntax trees and a tree writer. The nodes are intended to represent Dart code to be generated rather than the result of parsing an arbitrary Dart program, so these nodes may not provide for complete expression of Dart.

Derived from the JavascriptGeneration class in NS2JS, which is why the SAP copyright below applies.

Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
	private List = platform collections OrderedCollection.
	private Dictionary = platform collections Dictionary.
	private WriteStream = platform streams CharacterReadWriteStream.

	syntax = Syntax new.
	factory = Factory new.
|)
(
class Factory = ()
('as yet unclassified'
assign: lhs <Node> toBe: rhs <Node> ^<Node> = (
	assert: [lhs isDartNode] message: 'Dart node expected on left'.
	assert: [rhs isDartNode] message: 'Dart node expected on right'.
	^syntax AssignmentExpression leftHandSide: lhs rightHandSide: rhs
)
block: statements <List[Node]> ^<Node> = (
	statements do: [:each | assert: [each isDartNode] message:'Malformed statement tree'].
	^syntax Block statements: statements
)
class: name extends: supername fields: fields methods: methods = (
	halt.
)
for: initExpr while: testExpr step: incExpr do: bodyStmt = (
	^syntax ForStatement
		initExpression: initExpr
		test: testExpr
		increment: incExpr
		body: bodyStmt
)
for: varName <String> in: expr <Node> do: bodyStmt <Node> = (
	| canonicalVarName |
	canonicalVarName:: varName isNil
		ifTrue: [varName]
		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].
	^syntax ForInStatement
		varName: canonicalVarName
		expression: expr
		body: bodyStmt
)
functionOf: params body: body <Block> = (
	halt. "Block closures -> Anonymous functions"
)
ident: name <String> ^<Node> = (
	assert: [name isString] message: 'name must be a string'.
	^syntax IdentifierExpression name: name
)
if: expression <Node> then: then <Node> ^<Node> = (
	^syntax IfStatement expression: expression then: then else: nil
)
if: expression <Node> then: then <Node> else: else <Node> ^<Node> = (
	^syntax IfStatement expression: expression then: then else: else
)
list: elements <List[Node]> ^<ListExpression> = (
	elements do: [:each | assert: [each isDartNode] message: 'Dart node expected'].
	^syntax ListExpression elements: elements
)
literal: value <Boolean | Integer> ^<Node> = (
	value isString ifTrue: [^syntax StringLiteral value: value].
	value isNumber ifTrue: [^syntax IntegerLiteral value: value].
	(true = value or: [false = value]) ifTrue: [^syntax BooleanLiteral value: value].
	error: 'this value cannot be a Dart literal'
)
memberOf: expression <Node> at: indexExpr <Node> = (
	assert: [expression isDartNode] message: 'Dart node expected'.
	assert: [indexExpr isDartNode] message: 'Dart node expected for index expression'.
	^syntax MemberExpression primary: expression property: indexExpr
)
method: name <String> params: params body: body <Block> = (
	| canonicalName canonicalParams |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	canonicalParams:: params collect: [:each | each isString ifTrue: [ident: each]  ifFalse: [each]].
	^syntax MethodDeclaration name: canonicalName parameters: canonicalParams body: body
)
new: expression <Node> with: args <List[Node]> ^<Node> = (
	^syntax NewExpression expression: expression arguments: args
)
on: target invoke: method with: arguments <List[Node]> = (
	^syntax MethodInvocation target: target method: method arguments: arguments
)
operator: name <String> with: left <Node> and: right <Node> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	assert: [left isDartNode] message: 'Dart node expected on left'.
	assert: [right isDartNode] message: 'Dart node expected on right'.
	^syntax OperatorExpression operator: canonicalName with: left and: right
)
postfixOperator: name <String> on: operand <Node> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax UnaryOperatorExpression operator: canonicalName postfix: true on: operand
)
prefixOperator: name <String> on: operand <Node> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax UnaryOperatorExpression operator: canonicalName postfix: false on: operand
)
return = (
	^syntax ReturnStatement expression: nil
)
return: expression <Node | nil> = (
	^syntax ReturnStatement expression: expression
)
ternaryIf: condition then: then else: else = (
	^syntax TernaryOperatorExpression
		if: condition
		then: then
		else: else
)
throw: expression <Node> ^<Node> = (
	^syntax ThrowStatement expression: expression
)
try: block <Block> catch: varName <String> with: catchBlock <Block> = (
	| canonicalVarName |
	canonicalVarName:: varName isNil
		ifTrue: [varName]
		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].
	^syntax TryStatement block: block catch: canonicalVarName with: catchBlock finally: nil
)
try: block <Block> catch: varName <String> with: catchBlock <Block> finally: finallyBlock <Block>= (
	| canonicalVarName |
	canonicalVarName:: varName isNil
		ifTrue: [varName]
		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].
	^syntax TryStatement block: block catch: canonicalVarName with: catchBlock finally: finallyBlock
)
var: name <String> ^<VariableStatement> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax VariableStatement name: canonicalName initializer: nil
)
var: name <String> value: expr <Node> ^<VariableStatement> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax VariableStatement name: canonicalName initializer: expr
)) : ()
class Syntax = (
"The AST nodes. The preferred way to construct instances is to use the factory object (an instance of Factory, a sibling of this class) held onto by the module.")
(
class AssignmentExpression leftHandSide: lhs rightHandSide: rhs = Node (|
	leftHandSide <Expression> = lhs.
	rightHandSide <Expression> = rhs.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode 
		and: [leftHandSide = anotherNode leftHandSide
			and: [rightHandSide = anotherNode rightHandSide]]	
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	leftHandSide printOn: stream.
	stream nextPutAll: ', '.
	rightHandSide printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitAssignmentExpression: self
)) : ('as yet unclassified'
var: name <String> to: expr <Expression> = (
	^AssignmentExpression
		leftHandSide: (IdentifierExpression name: name)
		rightHandSide: expr
))
class Block statements: s = Node (|
	statements <List[Statement | Expression]> = s.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [statements = anotherNode statements]
)
asBlock = (
	^self
)
isBlockStatement = (
	^true
)
visitBy: visitor = (
	^visitor visitBlock: self
)
visitStatementsBy: visitor = (
	| result |
	statements do: [:each | result:: each visitBy: visitor].
	^result
)) : ('as yet unclassified'
empty = (
	^Block statements: {}
))
class IdentifierExpression name: s <String> = Node (
"a case of PrimaryExpression"|
	name = s.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [name = anotherNode name]
)
isIdentifier = (
	^true
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	stream nextPutAll: name.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitIdentifierExpression: self
)) : ()
class ListExpression elements: elements_ = Node (
"A list expression, e.g. [1,2,3]."|
	elements = elements_.
|)
('as yet unclassified'
visitBy: visitor = (
	^visitor visitListExpression: self
)) : ()
class MemberExpression primary: expr <Expression> property: p <Node> = Node (
"primary.property"|
	primary = expr.
	property = p.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[primary = anotherNode primary and:
		[property = anotherNode property]]
)
isMemberExpression = (
	^true
)
visitBy: visitor = (
	^visitor visitMemberExpression: self
)) : ()
class MethodDeclaration name: n parameters: p body: b = Node (|
	name = n.
	parameters = p.
	body = b.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[name = anotherNode name and:
		[parameters = anotherNode parameters and:
		[body = anotherNode body]]]
)
visitBy: visitor = (
	^visitor visitMethodDeclaration: self
)) : ()
class MethodInvocation target: t method: m arguments: a = Node (
"target.method(a1, a2, ... aN)"|
	target <Expression> = t.
	method <String> = m.
	arguments <List[Expression]> = a.
|)
('as yet unclassified'
visitBy: visitor = (
	^visitor visitMethodInvocation: self
)) : ()
class NewExpression expression: expr arguments: args = Node (
"new expr ( arg, .... )"|
	expression = expr.
	arguments = args.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[expression = anotherNode expression and:
		[arguments = anotherNode arguments]]
)
visitBy: visitor = (
	^visitor visitNewExpression: self
)) : ()
class Node = (
"The superclass of all other nodes, both statements and expressions."|
	comment <String>
|)
('as yet unclassified'
= anotherNode = (
	^class = anotherNode class
)
isDartNode = (
	^true
)) : ()
class ReturnStatement expression: expr = Node (
"return expression/opt."|
	expression <Expression | nil> = expr.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [expression = anotherNode expression]
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	expression printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitReturnStatement: self
)) : ('as yet unclassified'
noValue = (
	^ReturnStatement expression: nil
))
class StringLiteral value: string <String> = Node (|
	value = string.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[value = anotherNode value]
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	value printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitStringLiteral: self
)) : ()
class VariableStatement name: n <IdentifierExpression> initializer: expr <Expression> = Node (
"var name [= expression]"|
	name = n.
	initializer = expr.
|)
('as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[name = anotherNode name and:
		[initializer = anotherNode initializer]]
)
printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	name printOn: stream.
	stream nextPutAll: ', '.
	initializer printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitVariableStatement: self
)) : ('as yet unclassified'
name: s = (
	^VariableStatement name: s initializer: nil
))) : ()
class Writer = (
"Writes out a tree of Dart syntax elements."|
	private output <WriteStream>
	private tabLevel <Integer>
	private stringTranslation = Dictionary new.
|stringTranslation at: $\ put: '\\'.
	stringTranslation at: Character cr put: '\r'.
	stringTranslation at: Character lf put: '\n'.
	stringTranslation at:  $" put: '\"')
('as yet unclassified'
visitAssignmentExpression: node <AssignmentExpression> = (
	node leftHandSide visitBy: self.
	write: ' = '.
	node rightHandSide visitBy: self.
)
visitBlock: node <Block> = (
	| statements |
	statements: node statements.
	statements isEmpty ifTrue:
		[^write: '{}'].
	write: '{'.
	indentCr.
	statements
		do:
			[:each |
			each visitBy: self.
			write: ';']
		separatedBy:
			[cr].
	unindentCr.
	write: '}'
)
visitListExpression: node <ListExpression> = (
	| elements |
	elements: node elements.
	elements isEmpty ifTrue:
		[^write: '[]'].
	elements size = 1 ifTrue:
		[write: '['.
		elements first visitBy: self.
		^write: ']'].
	write: '['.
	indentCr.
	elements
		do:
			[:each | each visitBy: self]
		separatedBy:
			[write: ','.
			cr].
	unindentCr.
	write: ']'
)) : ()) : ()