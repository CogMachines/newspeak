Newspeak3
'Newspeak'
class NSCompilerTesting usingPlatform: platform testingStrategy: strategy minitest: minitest = (
(* A replacement of NSCompilerTests, relying on a separate testing strategy object to actually run the tests in some target environment. See the class comment of InImageNSCompilerTestingStrategy for a description of the testing strategy protocol.

Copyright 2011 Vassili Bykov
Copyright 2012 Google Inc

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
	private TestContext = minitest TestContext.
	
	private testingStrategy = strategy.
	private Exception = platform blackMarket Exception.
	private Error = platform blackMarket Error.
|)
(
class CompilerTests = TestContext (|
|)
('as yet unclassified'
IMPLEMENT = (
	(* look for senders in this class to find the tests that still need to be converted *)
)
assertCompilationErrorIn: classSource <String> = (

	[
		testingStrategy
			test: classSource
			with: 'class SampleTest test: sampleClass = ()(''foo''test = ())'
			ifFailure: [:message | ^ self]
			ifError: [:message | ^ self]]
		on: Error (* not Exception, which catches InMidstOfFileinNotifications *)
		do: [^ self].
	failWithMessage: 'Expected a compilation error, but succeeded'
)
assertNoCompilationErrorIn: classSource <String> = (

	[
		testingStrategy
			test: classSource
			with: 'class SampleTest test: sampleClass = ()(''foo''test = ())'
			ifFailure: [:message | ^ self]
			ifError: [:message | ^ self]]
		on: Error (* not Exception, which catches InMidstOfFileinNotifications *)
		do: [^ failWithMessage: 'Unexpected compilation error'].
)
testAssignBooleanLiteral = (
	testSampleMethod: 'run = (| t | t:: false)'
	with: 'assert: [sample = sample run]'
)
testAssignCharacterLiteral = (
	testSampleMethod: 'run = (| t | t:: $c)'
	with: 'assert: [sample = sample run]'
)
testAssignFloatLiteral = (
	testSampleMethod: 'run = (| t | t:: 3.14159)'
	with: 'assert: [sample = sample run]'
)
testAssignIntLiteral = (
	testSampleMethod: 'run = (| t | t:: 42)'
	with: 'assert: [sample = sample run]'
)
testAssignNil = (
	testSampleMethod: 'run = (| t | t:: nil)'
	with: 'assert: [sample = sample run]'
)
testAssignParam = (
	testSampleMethod: 'assignParam: x = (| t | t:: x)'
	with: 'assert: [sample = (sample assignParam: 91)]'
)
testAssignStringLiteral = (
	testSampleMethod: 'run = (| t | t:: ''abc'')'
	with: 'assert: [sample = sample run]'
)
testAssignSymbolLiteral = (
	testSampleMethod: 'run = (| t | t:: #abc)'
	with: 'assert: [sample = sample run]'
)
testAssignTemps = (
	testSampleMethod: 'run = (| t1 t2 | t1:: t2)'
	with: 'assert: [sample = sample run]'
)
testBooleanLiteral = (
	testSampleMethod: 'run = (true)'
	with: 'assert: [sample = sample run]'
)
testCascadeGuardedSend = (
	testSampleMethod: 'cascadeGuardedSend = (
		^[:x | x] value: 3; value: 4
	)'
	with: 'assert: [sample cascadeGuardedSend = 4]'
)
testCharacterLiteral = (
	testSampleMethod: 'run = ($c)'
	with: 'assert: [sample = sample run]'
)
testClassMethodScope15 = (
	test:
		'class Sample = () (
			class Inner = () () : (
				''class methods''
				static = (^Inner new)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''accessing''
			test = (
				| innerClass |
				innerClass:: sample Inner.
				assert: [innerClass static class = innerClass]
			)
		)'
)
testClassMethodsNotBlockingOuterMethods = (
	test:
		'class Sample  = (
		) (
			class Inner = () (
				''cat''
				bar = (^ foo)
	       	) : (
				''cat''
				foo = (^ 91))
			''access''
			 foo = (^42)
		)'
	with:
		'class SampleTest test: sampleClass = ( | klass = sampleClass. | ) (
			''test''
			test = (
				assert: [klass new Inner new bar = 42].
			)
		)'
)
testClosureInTempInitializer = (
	(* Regression test against bug in scope building. *)
	testSampleMethod: 
'closureInInitializer = (
	| value ::= 9. closure = [value: value + 1]. |
	^closure
)'
	with:
'
	| closure |
	closure:: sample closureInInitializer.
	assert: [closure value = 10].
	assert: [closure value = 11].
	assert: [closure value = 12].
'
)
testClosureNLR = (
	testSampleMethod: 'nlr: x = ( [^x] value. ^2 )'
	with: 'assert: [(sample nlr: 42) = 42]'
)
testClosureNLR2 = (
	testSampleMethod: 'closureNLR2 = (
	| block |
	block:: [:n | n < 10 ifTrue: [^true] ifFalse: [block value: n-1]].
	block value: 20.
	^false
	)'
	with: 'assert: [sample closureNLR2 = true]'
)
testClosureNestCounters = (
	testSampleMethod: '
counterGenerator: param = (
	| totalCount ::= 9. |
	^[
		| count ::= 0. |
		[
			count:: count+1.
			totalCount:: totalCount + 1.
			count @ totalCount
		]
	].
)'
	with:
'
	| gen c1 c2 |
	gen:: sample counterGenerator: #ignored.
	c1:: gen value.
	c2:: gen value.
	
	assert: [c1 value = (1@10)] description: ''Assertion 1 failed''.
	assert: [c1 value = (2@11)] description: ''Assertion 2 failed''.
	assert: [c2 value = (1@12)] description: ''Assertion 3 failed''.
	assert: [c1 value = (3@13)] description: ''Assertion 4 failed''.
	assert: [c2 value = (2@14)] description: ''Assertion 5 failed''.
	c1:: gen value.
	assert: [c1 value = (1@15)] description: ''Assertion 6 failed''.
	assert: [c1 value = (2@16)] description: ''Assertion 7 failed''.
	assert: [c2 value = (3@17)] description: ''Assertion 8 failed''.
'
)
testClosureReentrancy = (
	testSampleMethod: '
closureFactorial = (
	| factorial |
        factorial:: [:n| n = 1 ifTrue: [1] ifFalse: [(factorial value: n - 1) * n]].
       ^(1 to: 10) collect: factorial
)'
	with:
'
	assert: [sample closureFactorial = {1. 2. 6. 24. 120. 720. 5040. 40320. 362880. 3628800}].
'
)
testClosureTempFrame = (
	testSampleMethod: '
insideInlinedBlock = (
	| a b c|
	a: 10.
	b: 20.
	c: 40.
	a < 200 ifTrue: [
		^(b < 1000) and: [c > 0]
	]
) '
	with:
'
	assert: [sample insideInlinedBlock = true].
'
)
testCompilePseudoVariables = (
	test:
		'class Sample = (
			| slot slot2 slot3 |
		) (
			''misc''
			foo: param314159 = (^param314159 + 7)
			bar = (^self foo: 5)
			snafu: x = (	^x foo: 84)
			baz = (^snafu:: self	)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''test''
			test = (
				assert: [(sample foo: 3) = 10] description: ''Assertion failed: (sample foo: 3) = 10''.
				assert: [sample bar = 12] description: ''Assertion failed: sample bar = 12''.
				assert: [sample baz = sample] description: ''Assertion failed: sample baz = sample''.
			)
		)'
)
testControlMessageValues = (
	testSampleMethod: ''
	with: '
assert: [nil == (false ifTrue: [7])].
assert: [nil == (true ifFalse: [7])].

assert: [nil == (nil ifNotNil: [7])].
assert: [7 == (7 ifNil: [9])].

assert: [7 == (7 timesRepeat: [9])].
assert: [3 == (3 to: 7 do: [:ignore|])].
assert: [3 == (3 to: 7 by: 2 do: [:ignore|])].

assert: [nil == ([false] whileTrue: [7])].
assert: [nil == ([true] whileFalse: [7])].
assert: [nil == ([false] whileTrue)].
assert: [nil == ([true] whileFalse)].
'
)
testDivisionTowardNegInfinity = (
	testSampleMethod: ''
	with: '
assert: [(13 // 5) = 2].
assert: [(-13 // 5) = -3].
assert: [(13 // -5) = -3].
assert: [(-13 // -5) = 2].

assert: [(5 // 13) = 0].
assert: [(-5 // 13) = -1].
assert: [(5 // -13) = -1].
assert: [(-5 // -13) = 0].

assert: [(16 // 8) = 2].
assert: [(-16 // 8) = -2].
assert: [(16 // -8) = -2].
assert: [(-16 // -8) = 2].'
)
testDivisionTowardZero = (
	testSampleMethod: ''
	with: '
assert: [(13 quo: 5) = 2].
assert: [(-13 quo: 5) = -2].
assert: [(13 quo: -5) = -2].
assert: [(-13 quo: -5) = 2].

assert: [(5 quo: 13) = 0].
assert: [(-5 quo: 13) = 0].
assert: [(5 quo: -13) = 0].
assert: [(-5 quo: -13) = 0].

assert: [(16 quo: 8) = 2].
assert: [(-16 quo: 8) = -2].
assert: [(16 quo: -8) = -2].
assert: [(-16 quo: -8) = 2].'
)
testDoublyNestedIWhileInIf = (
	testSampleMethod: 'doublyNestedWhileInIf = (| tf tg |  
     	tf:: 1 + 1 * 2.
	tg:: 2*2*2*2.
	tg <1000 
		ifTrue:[
			[tg < 10000]
				whileTrue:[
					tg < 5000
						ifTrue:[tg:: tg *2]
						ifFalse:[
							tg:: tg + 1000.
							[tf > 10] whileFalse:[tf:: tf+ 1].
							]
				]
			]
		ifFalse:[].
	^tg + tf
	)'
	with:
'
   assert: [10203 = sample doublyNestedWhileInIf].
'
)
testDuplicateNames = (

	assertCompilationErrorIn: 'class Sample = (| foo |) (class foo = ()() ''cat'' foo = ())'.
	
	assertCompilationErrorIn: 'class Sample = (| foo |) (''cat'' foo = ())'.
	assertCompilationErrorIn: 'class Sample = () (class foo = ()() ''cat'' foo = ())'.
	assertCompilationErrorIn: 'class Sample = (| foo |) (class foo = ()())'.
	
	assertCompilationErrorIn: 'class Sample = () (''cat'' foo = () foo = ())'.
	assertCompilationErrorIn: 'class Sample = (| foo foo |) ()'.
	assertCompilationErrorIn: 'class Sample = () (class foo = ()() class foo = ()())'.
	
	assertCompilationErrorIn: 'class Sample = ( | foo ::= 42.| ) (''cat'' foo: x = ())'.
	assertNoCompilationErrorIn: 'class Sample = ( | foo = 42.| ) (''cat'' foo: x = ())'.
)
testDynamicSuper = (
	test:
'class Sample = () (
	class Super1 = () (
		''accessing''
		m = (^1984)
	)
	class Super2 = () (
		''accessing''
		m = (^1948)
	)
	class DynamicSuperSample sup: Sup = (
		| App = Inner mixin |> Sup. |
	) (
		class Inner = () (
			''accessing''
			foo = (^super m)
		)
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (
		| klass instance1 instance2 |
		klass: sample DynamicSuperSample.
		instance1:: klass sup: sample Super1.
		instance2:: klass sup: sample Super2.
		assert: [instance1 App new foo = 1984].
		assert: [instance2 App new foo = 1948].
	)
)'.
)
testDynamicSuperInitialization = (
(* The assert: clase of this test is expected to fail in a correct implementation because the mixin application in the App slot initializer does not supply the primary factory of Super with the argument it expects. *)
	test:
'class Sample = () (
	class Super arg: a = ( | superSlot = a. | ) (
	)
	class DynamicSuperSample sup: Sup = (
		| App = Inner mixin |> Sup. |
	) (
		class Inner = ( | innerSlot = 1984. | ) ()
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (
		| dssClass superClass instance species |
		dssClass:: sample DynamicSuperSample.
		superClass:: sample Super.
		instance:: dssClass sup: superClass.
		assert: [instance App new] signals: Error.
	)
)'
)
testEmptyNoParamBlock = (
	testSampleMethod: 'emptyNoParamBlock = (^[]) '
	with:
'
   assert: [sample emptyNoParamBlock isBlock].
   assert: [nil = sample emptyNoParamBlock value].
'
)
testEmptyOneParam = (
	testSampleMethod: 'emptyOneParam: aParam = () '
	with: 'assert: [sample = (sample emptyOneParam: 3)]'
)
testEmptyOneParamBlock = (
	testSampleMethod: 'emptyOneParamBlock = (^[:x | ])'
	with:
'
	assert: [sample emptyOneParamBlock isBlock].
	assert: [nil = (sample emptyOneParamBlock value: 91)]
'
)
testEmptyTwoParamBlock = (
	testSampleMethod: 'emptyTwoParamBlock = (^[:x :y | ])'
	with:
'
	assert: [sample emptyTwoParamBlock isBlock].
	assert: [nil = (sample emptyTwoParamBlock value: 91 value: 42)]
'
)
testEmptyTwoParams = (
	testSampleMethod: 'emptyParam1: x param2: y = ()'
	with: 'assert: [sample = (sample emptyParam1: 42 param2: 91)]'
)
testEmptyZeroParams = (
	testSampleMethod: 'emptyZeroParams = ()'
	with: 'assert: [sample = sample emptyZeroParams]'
)
testExplicitOuterInInitializer = (
	test:
'class Sample = () (
	class Inner = (
		| f = 2 * outer Sample m. |
	) (
	)
	''accessing''
	m = (^91)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (
		assert: [182 = sample Inner new f].
	)
)'
)
testFloatLiteral = (
	testSampleMethod: 'floatLiteral = (5.2)'
	with: 'assert: [sample = sample floatLiteral]'
)
testIfCascade = (
(* Regression for bitbucket issue 85 *)
	test:
		'class Sample = ( | slot1 slot2 | ) (
			''unclassified''
			fail = (
				| x | 
				x: class new.
				x
					slot1: (true ifTrue: [3] ifFalse: [4]);
					slot2: 8.
				^x 
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''test''
			test = (
				assert: [sample fail slot1 = 3] description: ''Assertion failed: slot1 = 3''.
				assert: [sample fail slot2 = 8] description: ''Assertion failed: slot2 = 8''.
			)
		)'
)
testIfFalse1 = (
(* the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods *)
	testSampleMethod: 'testIfFalse1 = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf < 32 ifFalse:[tf:: 96]. )'
	with: 'assert: [96 = sample testIfFalse1]'
)
testIfFalse2 = (
(* the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods *)
	testSampleMethod: 'testIfFalse2 = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf > 32 ifFalse:[tf:: 96].)'
	with: 'assert: [nil = sample testIfFalse2]'
)
testIfTrue1 = (
(* the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods *)
	testSampleMethod: 'testIfTrue1 = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf > 32 ifTrue:[tf:: 64]. ) '
	with: 'assert: [64 = sample testIfTrue1]'
)
testIfTrue2 = (
(* the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods *)
	testSampleMethod: 'testIfTrue2 = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf < 32 ifTrue:[tf:: 64]. ) '
	with: 'assert: [nil = sample testIfTrue2]'
)
testIfTrueIfFalseElse = (
(* the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods *)
	testSampleMethod: 'testIfTrueIfFalse = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf < 32 ifTrue:[tf:: 64] ifFalse:[tf:: 96]. ) '
	with: 'assert: [96 = sample testIfTrueIfFalse]'
)
testIfTrueIfFalseThen = (
(* the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods *)
	testSampleMethod: 'testIfTrueIfFalse = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf > 32 ifTrue:[tf:: 64] ifFalse:[tf:: 96]. ) '
	with: 'assert: [64 = sample testIfTrueIfFalse]'
)
testImmutableInstVar = (

	test:
		'class Sample = (
			| slot = 9. |
		)()'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''test''
			test = (
				assert: [sample slot = 9] description: ''Slot not properly initialized''.
				assert: [sample slot: 10] signals: Error description: ''Assignment did not raise error''.
				assert: [sample slot = 9] description: ''Slot did not retain value''.
			)
		)'
)
testImmutableTempEnforced = (
	testSampleMethod: 'immutableTemp = ( | a = 9. | a:: 10. )'
	with: 'assert: [sample immutableTemp] signals: Error.'
)
testImmutableTempInitialized = (
	testSampleMethod: 'immutableTemp = ( | a = 9. | ^a )'
	with: 'assert: [sample immutableTemp = 9].'
)
testImplicitOuterInInitializer = (
	test:
'class Sample = () (
	class Inner = (
		| f = 2 * m. |
	) (
	)
	''accessing''
	m = (^91)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (
		assert: [182 = sample Inner new f].
	)
)'
)
testImplicitSend = (
(* Regression: test will fail if implict sends do not handle popping of nested expressions off the operand stack correctly *)
	test:
'class Sample = () (
	''samples''
	brokenMethod: stream = (
		[[stream atEnd] whileFalse: [stream next]] value
	)
	bar = (
	   | s |
	   brokenMethod: (s: ''abc'' readStream)
      )
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (sample bar = sample)
)'
)
testIncestuousSiblings16 = (
	test:
		'class Sample = () (
			class ISup = () (
				''cat sup''
				ketchup = (^16)
			)
			class ISub = ISup () (
				''cat soup''
				nekojiru = (^ketchup + 1)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''accessing''
			test = (
				| innerSup innerSub anInnerSub |
				innerSup:: sample ISup.
				innerSub:: sample ISub.
				assert: [innerSub superclass = innerSup] description: ''innerSub superclass is not equal to innerSup''.
				anInnerSub:: innerSub new.
				assert: [anInnerSub ketchup = 16].
				assert: [anInnerSub nekojiru = 17].
				(*...*)
			)
		)'.
	TODO (* modifying the nested class declaration? *)
)
testInit17 = (
	test:
'class Sample = () (
	class Test17 x: i y: j z: k = (
		(*Test initializers.*)
		|
			x ::= i.
			y ::= j.
			z
			rho
			theta
		|
			z: x + y + k.
			rho: 1000 * z.
			theta:: rho + y
	) (
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (
		| anInstance |
		anInstance:: sample Test17 x: 42 y: 91 z: 19.
		assert: [anInstance z = (anInstance x + anInstance y + 19)].
		assert: [anInstance rho = 152000].
		assert: [anInstance theta = 152091].
	)
)'
)
testInlinedSetters = (
(* Regression for bitbucket issue 91 *)
	test:
		'class Sample = ( | slot1 slot2 field0 field1 field2 field3 field4  | ) (
			''unclassified''
			expr1 = (^23)
			expr2 = (^36)
			expr3 = (^52)
			expr4 = (^69)

			y = (
			 	| a b |
				field0: (slot1:: 0). (*Correct: uses method''s setter temp*)
				[
					field1: (slot2:: self expr1).(*Correct: uses closures''s setter temp*)
					field2: (true ifTrue: [slot2:: self expr2]). (*WRONG: uses method''s setter temp*)
					field3: ([true] value ifTrue: [slot2:: self expr3]). (*WRONG: uses method''s setter temp*)
					field4:(slot2:: self expr4). (*Correct: uses closures''s setter temp*)
				] value.
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''test''
			test = (
				sample y.
				assert: [sample slot1 = 0].
				assert: [sample field1 = sample expr1].
				assert: [sample field2 = sample expr2].	
				assert: [sample field3 = sample expr3].	
				assert: [sample field4 = sample expr4].	
				assert: [sample slot2 = sample expr4].	
			)
		)'
)
testInlinedTempReadBeforeWritten = (
	testSampleMethod: 'run = ( 
		1 to: 10 do: [:ignore | | temp tempIsNil | 
			tempIsNil: temp isNil.
			assert: [tempIsNil]. (*Do not access temp from a closure to avoid effects of indirection.*)
			temp: 7.
		])'
	with: 'assert: [sample = sample run]'
)
testInner12 = (
	test:
'class Sample = () (
	class NS2Test12 s: aClass =  (
		(*Test for n-levels of nesting*)
		| Sup = aClass. |
	) (
		class Inner1 = Sup () ( 
			class Inner11 = Sup () (
				class Inner111 = Sup () ( 
					''tests'' 
					baz = (^outer Inner11 bar + outer Inner1 foo + outer NS2Test12 m)
				)
				''tests''
		    		bar = (^outer NS2Test12 m + outer Inner1 foo)
			)
			'' tests''
			foo = (
				^outer NS2Test12 m
			)

		)
		''access''
		(*(NS2Test12 s: Object) Inner1 new Inner11 new Inner111 new bar = 364*)
		m = (^91)
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (
		| klass innerKlass innerInnerKlass innerInnerInnerKlass anInstance anInnerInstance anInnerInnerInstance |
		klass:: sample NS2Test12.
		anInstance:: klass s: Object.
		assert: [anInstance Inner1 = anInstance Inner1].
		assert: [anInstance Inner1 new foo = 91].

		innerKlass::  anInstance Inner1.
		anInnerInstance:: innerKlass new.
		assert: [anInnerInstance Inner11 = anInnerInstance Inner11].
		assert: [anInnerInstance  Inner11 new bar = 182].

		innerInnerKlass:: anInnerInstance Inner11.
		anInnerInnerInstance::  innerInnerKlass  new.
		innerInnerInnerKlass::  anInnerInnerInstance Inner111.
		assert: [anInnerInnerInstance Inner111 = anInnerInnerInstance Inner111].
		assert: [anInnerInnerInstance  Inner111 new baz = 364].
	)
)'
)
testInner14 = (
	test:
'class Sample = () (
	class NS2Test14a  = (
		(*A nested test case*)
	) (
		class Inner1 create =  () (
			''nested calls''
		 	foo = (^m)
		)
		''access''
		m = (^91)
	)
	class NS2Test14b s: aClass = (
		(*A nested test case*)
		|
		Sup = aClass.
		|
	) (
		class Inner2  = Sup create ( ) (
			''nested calls''
			bar = (^foo)
		)
		''access''
		(*(NS2Test14b s: NS2Test14a new Inner1) Inner2 new bar = 91*)
		m = (^42)
	)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (
		| klassA klassB innerKlass innerInnerKlass innerInnerInnerKlass anInstance anInnerInstance anInnerInnerInstance  |
		klassA:: sample NS2Test14a.
		klassB:: sample NS2Test14b.
		anInstance:: klassB s: klassA new Inner1.
		assert: [anInstance Inner2 = anInstance Inner2].
		assert: [anInstance m = 42].

		innerKlass::  anInstance Inner2.
		anInnerInstance:: innerKlass new.
		assert: [anInnerInstance bar = 91].
	)
)'
)
testInner18 = (
(* This test creates a situation where the an object's enclosing instance with respect to its class (Inner2) is an instance of the same class (Sample) as its enclosing instance with respect to its superclass (Inner1). *)

	test:
		'class Sample s: Sup = (
			| SuperClass = Sup. |
		) (
			class Inner1 = () (
				''misc''
				i1 = (^Inner1)
			)
			class Inner2 = SuperClass () (
				''misc''
				i1 = (^Inner1)
				supI1 = (^super i1)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | klass = sampleClass. |) (
			''misc''
			test = (
				| o1 o2 o1i1 o1i2 o2i1 o2i2 innerKlass11 innerKlass12 innerKlass21 innerKlass22 |
				o1:: klass s: Object.
				o2:: klass s: o1 Inner1.
				o1i1:: o1 Inner1 new.
				o1i2:: o1 Inner2 new.
				o2i1:: o2 Inner1 new.
				o2i2:: o2 Inner2 new.
				innerKlass11:: o1 Inner1.
				innerKlass12:: o1 Inner2.
				innerKlass21:: o2 Inner1.
				innerKlass22:: o2 Inner2.
				
				assert: [o2 Inner2 superclass = o1 Inner1] description: ''Assertion failed: o2 Inner2 superclass = o1 Inner1''.
				assert: [o1 Inner1 = o1i1 i1] description: ''Assertion failed: o1 Inner1 = o1i1 i1''.
				assert: [o1 Inner1 = o1i2 i1] description: ''Assertion failed: o1 Inner1 = o1i2 i1''.
				assert: [o2 Inner1 = o2i1 i1] description: ''Assertion failed: o2 Inner1 = o2i1 i1''.
				assert: [o2 Inner1 = o2i2 i1] description: ''Assertion failed: o2 Inner1 = o2i2 i1''.
				assert: [o1 Inner1 = o1i2 i1] description: ''Assertion failed: o1 Inner1 = o1i2 i1''.
				assert: [o1 Inner1 = o2i2 supI1] description: ''Assertion failed: o1 Inner1 = o2i2 supI1''.
				assert: [(o1 Inner1 = o2 Inner1) not] description: ''Assertion failed: o1 Inner1 ~= o2 Inner1''.

			)
		)'
)
testInner20 = (
	test:
		'class Sample = () (
			class Outer = () (
				class Inner = () (
					''misc''
					foo = (^m + y)
				)
				''misc''
				m = (^91)
				y = (^8)
			)
			class OuterSub = Outer () (
				''misc''
				m = (^77)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''misc''
			test = (
				| innerKlass innerInnerKlass anInnerInstance |
				innerKlass:: sample OuterSub.
				anInnerInstance:: innerKlass new.
				innerInnerKlass:: anInnerInstance Inner.
				assert: [innerInnerKlass new foo = 85].
			)
		)'
)
testInner21 = (
	test:
		'class Sample = () (
			class A = () ()
			class B = A () (
				class B1 = () ( 
					class B1a = A () () 
				) 
			) 
			class C = B () ()
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''testing''
			test = (
				| anInnerInstance anInnerInnerInstance innerKlass innerInnerKlass innerInnerInnerKlass |
				innerKlass: sample C.
				anInnerInstance::  innerKlass new.
				innerInnerKlass:: anInnerInstance B1.
				anInnerInnerInstance:: innerInnerKlass new.
				innerInnerInnerKlass:: anInnerInnerInstance B1a.
				innerInnerInnerKlass new.
			)
		)'
)
testInner3 = (
	test:
		'class Sample s: aClass = (
			| Sup = aClass. |
		) (
			class Inner create = Sup () (
				''nested calls''
				foo = (^m)
			)
			''access''
			m = (^91)
		)'
	with:
		'class SampleTest test: sampleClass = ( | klass = sampleClass. | ) (
			''test''
			test = (
				| anInstance |
				anInstance:: klass s: Object.
				assert: [anInstance Inner = anInstance Inner] description: ''Assertion failed: anInstance Inner = anInstance Inner''.
				assert: [anInstance Inner create foo = 91] description: ''Assertion failed: anInstance Inner create foo = 91''.
			)
		)'
)
testInner7 = (
	test:
		'class Sample s: aClass = (
			(*A perverse nested test case. This example only works if nested classes
			are created lazily (as they are right now). An eager semantics would
			cause an infinite regress of nested classes being created.

			Is even the eager case actually a problem? One can always write an 
			infinite loop in an initializer. How is this different?*)
			| Sup = aClass. |
		) (
			class Inner = Sup s: Sup (
				(*Under comb semantics the argument refers to Inner''s Sup, which is not yet initialized. A real puzzler.
				Under new semantics, lexically evident Sup will be used rather than inherited one - which is what we expect.
				Arguably, both should work, but Squeak dies if the superclass is nil.*)
			) (
				''nested calls''
				foo = (^m)
	       	)
			''access''
			 m = (^91)
		)'
	with:
		'class SampleTest test: sampleClass = ( | klass = sampleClass. | ) (
			''test''
			test = (
				| anInstance anInnerInstance anInnerInnerInstance |
				anInstance:: klass s: klass.
				assert: [anInstance Inner = anInstance Inner]
					description: ''Assertion failed: anInstance Inner = anInstance Inner''.
				assert: [anInstance Inner new foo = 91]
					description: ''Assertion failed: anInstance Inner new foo = 91''.

				anInnerInstance:: anInstance Inner new.
				assert: [anInnerInstance Inner new foo = 91]
					description: ''Assertion failed: anInnerInstance Inner new foo = 91''.
				assert: [anInnerInstance Inner = anInnerInstance Inner]
					description: ''Assertion failed: anInnerInstance Inner = anInnerInstance Inner''.

				anInnerInnerInstance:: anInstance Inner new Inner new.
				assert: [anInnerInnerInstance Inner new foo = 91]
					description: ''Assertion failed: anInnerInnerInstance Inner new foo = 91''.
				assert: [anInnerInnerInstance Inner = anInnerInnerInstance Inner]
					description: ''Assertion failed: anInnerInnerInstance Inner = anInnerInnerInstance Inner''.
			)
		)'
)
testInner8 = (
	test:
		'class Sample s: aClass =  (
			(*Test for n-levels of nesting*)
			| Sup = aClass. |
		) (
			class Inner1 = Sup () (
				class Inner11 = Sup () (
					class Inner111 = Sup () ( 
						''tests'' 
						baz = (^bar + foo + m)
					)
					''tests''
					bar = (^m + foo)
				)
				''tests''
				foo = (^m)
			)
			''access''
			(*(NS2Test8 s: Object) Inner1 new Inner11 new Inner111 new bar = 364*)
			m = (^91)
		)'
	with:
		'class SampleTest test: sampleClass = ( | klass = sampleClass. | ) (
			''test''
			test = (
				| innerKlass innerInnerKlass innerInnerInnerKlass anInstance anInnerInstance anInnerInnerInstance |
				anInstance:: klass s: Object.

				assert: [anInstance Inner1 = anInstance Inner1]
					description: ''Assertion failed: anInstance Inner1 = anInstance Inner1''.
				assert: [anInstance Inner1 new foo = 91]
					description: ''Assertion failed: anInstance Inner1 new foo = 91''.

				innerKlass:: anInstance Inner1.
				anInnerInstance:: innerKlass new.

				assert: [anInnerInstance Inner11 = anInnerInstance Inner11]
					description: ''Assertion failed: anInnerInstance Inner11 = anInnerInstance Inner11''.
				assert: [anInnerInstance  Inner11 new bar = 182]
					description: ''Assertion failed: anInnerInstance  Inner11 new bar = 182''.

				innerInnerKlass:: anInnerInstance Inner11.
				anInnerInnerInstance::  innerInnerKlass  new.

				innerInnerInnerKlass::  anInnerInnerInstance Inner111.
				assert: [anInnerInnerInstance Inner111 = anInnerInnerInstance Inner111]
					description: ''Assertion failed: anInnerInnerInstance Inner111 = anInnerInnerInstance Inner111''.
				assert: [anInnerInnerInstance  Inner111 new baz = 364]
					description: ''Assertion failed: anInnerInnerInstance  Inner111 new baz = 364''.
			)
		)'
)
testInner9 = (
	test:
		'class Sample = ((*Test mutually referential nested classes (and implicit use of Object).*)) (
			class Inner1 = ()
			(''nested calls''
				foo = (^Inner2 new val)
			)
			(* (NS2Test9 new Inner1 new foo = 91 *)
			class Inner2 = ()
			(''nested calls''
				val = (^91)
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''test''
			test = (
				| innerKlass anInnerInstance |
				assert: [sample Inner1 = sample Inner1] description: ''Assertion failed: sample Inner1 = sample Inner1''.
				assert: [sample Inner1 new foo = 91] description: ''Assertion failed: sample Inner1 new foo = 91''.
				innerKlass::  sample Inner1.
				anInnerInstance:: innerKlass new.
			)
		)'.
	TODO (* Do we want to do anything with innerKlass and anInnerInstance? *)
)
testIntLiteral = (
	testSampleMethod: 'intLiteral = (5)'
	with: 'assert: [sample = sample intLiteral]'
)
testMetaRelationships = (
	test:
		'class Sample = () (
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''accessing''
			test = ( | Class Metaclass |
				Class:: self class class superclass.
				Metaclass:: self class class class.
				assert: [Class superclass = Object or: [Class superclass superclass = Object]]
					description: ''Class superclass [superclass] = Object''.
				assert: [Class class class = Metaclass]
					description: ''Class class class = Metaclass''.
				assert: [Class class superclass = Class]
					description: ''Class class superclass = Class''.
				assert: [SampleTest class class = Metaclass]
					description: ''SampleTest class class = Metaclass''.
				assert: [Metaclass class class = Metaclass]
					description: ''Metaclass class class = Metaclass''.
				assert: [Object class class = Metaclass]
					description: ''Object class class = Metaclass''.
			)
		)'.
)
testModifyInitWithSchemaChange = (
	IMPLEMENT.
	TODO. (* To be able to implement this, need to extend test strategy API with source recompilation support. *)
)
testMultipleSetters = (
	testSampleMethod: 'testMultipleSetters = (
	| x y z |
	
	^x::  (y:: 42) + (z:: 49).
)'
	with: 'assert: [sample testMultipleSetters = 91]'
)
testMultipleSetters22 = (
	test:
		'class Sample = () (
			''uncategorized''
			a: alpha = ()
			b: beta = ()
			invokeMultipleSetters = (
				| x |
				^x::  (a:: 42) + (b:: 49).
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''test''
			test = (
				assert: [sample invokeMultipleSetters = 91].
			)
		)'
)
testMultipleSetters23 = (
	test:
		'class Sample = () (
			''uncategorized''
			a: alpha = ()
			b: beta = ()
			c: gamma = ()
			invokeMultipleSetters = (
				^a:: 42 + (b:: 49) + (c:: 44).
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''test''
			test = (
				assert: [sample invokeMultipleSetters = 135].
			)
		)'
)
testNLR0 = (
	testSampleMethod: 'NLR0: x = ( [^x] value. ^2) '
	with:
		'assert: [1 = (sample NLR0: 1)].
	 	assert: [3 = (sample NLR0: 3)].'
)
testNLR1 = (
	testSampleMethod: 'NLR1: x = ( x > 2 ifTrue:[^x]. ^2) '
	with:
		'assert:[2 = (sample NLR1: 1)].
	 	assert:[3 = (sample NLR1: 3)].'
)
testNLR2 = (
	testSampleMethod: 'NLR2: x = ( x > 2 ifTrue:[^x+1]. ^2) '
	with:
		'assert: [2 = (sample NLR2: 1)].
	 	assert: [4 = (sample NLR2: 3)].'
)
testNLR3 = (
	testSampleMethod: 'NLR3: x = ( [^x + 2] value. ^2) '
	with:
		'assert:[3 = (sample NLR3: 1)].
	 	assert:[5= (sample NLR3: 3)].'
)
testNLRInIf1 = (
	testSampleMethod: 'depth: arg = (^arg ifTrue: [1] ifFalse: [^0].)'
	with:
		'assert: [true]. (*Mostly just checking for no error during compilation*)
		assert: [(sample depth: true) = 1].
		assert: [(sample depth: false) = 0].'
)
testNLRInIf2 = (
	testSampleMethod: 'depth: arg = (^arg ifTrue: [^1] ifFalse: [0].)'
	with:
		'assert: [true]. (*Mostly just checking for no error during compilation*)
		assert: [(sample depth: true) = 1].
		assert: [(sample depth: false) = 0].'
)
testNLRInIf3 = (
	testSampleMethod: 'depth: arg = (^arg ifTrue: [^1] ifFalse: [^0].)'
	with:
		'assert: [true]. (*Mostly just checking for no error during compilation*)
		assert: [(sample depth: true) = 1].
		assert: [(sample depth: false) = 0].'
)
testNestedIWhileInIf = (
	testSampleMethod: 'nestedWhileInIf = (| tf tg |  
	tg:: 2*2*2*2.
	tg <1000 
		ifTrue:[[tg < 10000] whileTrue:[tg:: tg *2]]
		ifFalse:[tg:: tg +200].
	^tg
	)'
	with:
		'assert: [16384 = sample nestedWhileInIf]'
)
testNestedIfFalse = (
	testSampleMethod: 'nestedIfFalse = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
tf < 32 ifTrue:[tf:: 64] ifFalse:[tf*tf > 100 ifTrue:[tf:: 96]]. ^tg + tf) '
	with:
		'assert: [170 = sample nestedIfFalse]'
)
testNestedIfInWhile = (
	testSampleMethod: 'nestedIfInWhile = (| tf tg |  
	tf:: 50. 
	tg:: tf *2. 
	[tg < 10000] whileTrue:[
		tg > 1000 ifTrue:[
			tg:: tg *2
			] ifFalse:[
				tg:: tg +200.
			]
		].
	^tg)
	'
	with:
		'assert: [17600 = sample nestedIfInWhile]'
)
testNestedIfTrue = (
	testSampleMethod: 'nestedIfTrue = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
tf > 32 ifTrue:[tf*tf > 100 ifTrue:[tf:: 64] ifFalse:[tf:: 96]]. ^tg + tf) '
	with:
		'assert: [138 = sample nestedIfTrue]'
)
testNilLiteral = (
	testSampleMethod: 'nilLiteral = (nil)'
	with: 'assert: [sample = sample nilLiteral]'
)
testOneParamBlock = (
	testSampleMethod: 'oneParamBlock = (^[:x | x + 32] value:59) '
	with: 'assert: [91 = sample oneParamBlock]'
)
testOperandStackDepth1 = (
(* Regression - flushes out bug in operand stack depth required for closures *)
	testSampleMethod: 'testOperandStackDepth1 = (
	100 timesRepeat: [
		{1. 2. 3}  doWithIndex: [:x :i | 
			x = x ifTrue: []]].
)'
	with: 'assert: [sample testOperandStackDepth1 = sample]'
)
testOuterSendToSibling = (
	assertCompilationErrorIn: 
'class Sample = () (
 class Sibling = ()()
 class Nested = ()(''cat'' method=(^outer Sibling yourself))
)'.	
)
testParameterImmutabilityEnforced = (
	testSampleMethod: 'immutableParem: x = ( x:: 10. )'
	with: 'assert: [sample immutableParem: 9] signals: Error.'
)
testParseAccessors = (
	test:
		'class Sample =  () ( 
			''access''
			private wintergreen = (^true)
			protected schweik = (^true)
			public enemy = (^true)
			privateFirstClass = (^true)
			protectedSpeech = (^true)
			publicServant = (^true)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''test''
			test = (
				assert: [sample wintergreen].
				assert: [sample schweik].
				assert: [sample enemy].
				assert: [sample privateFirstClass].
				assert: [sample protectedSpeech].
				assert: [sample publicServant].
			)
		)'
)
testRemainderTowardNegInfinity = (
	testSampleMethod: ''
	with: '
assert: [(13 \\ 5) = 3].
assert: [(-13 \\ 5) = 2].
assert: [(13 \\ -5) = -2].
assert: [(-13 \\ -5) = -3].

assert: [(5 \\ 13) = 5].
assert: [(-5 \\ 13) = 8].
assert: [(5 \\ -13) = -8].
assert: [(-5 \\ -13) = -5].

assert: [(16 \\ 8) = 0].
assert: [(-16 \\ 8) = 0].
assert: [(16 \\ -8) = 0].
assert: [(-16 \\ -8) = 0].'
)
testRemainderTowardZero = (
	testSampleMethod: ''
	with: '
assert: [(13 rem: 5) = 3].
assert: [(-13 rem: 5) = -3].
assert: [(13 rem: -5) = 3].
assert: [(-13 rem: -5) = -3].

assert: [(5 rem: 13) = 5].
assert: [(-5 rem: 13) = -5].
assert: [(5 rem: -13) = 5].
assert: [(-5 rem: -13) = -5].

assert: [(16 rem: 8) = 0].
assert: [(-16 rem: 8) = 0].
assert: [(16 rem: -8) = 0].
assert: [(-16 rem: -8) = 0].'
)
testRepeatingWhile = (
	testSampleMethod: 'brokenMethod: stream = (
		[[stream atEnd] whileFalse: [stream next]] value
	)'
	with: 'assert: [(sample  brokenMethod:  ''1234567890123456789'' readStream) isNil not]'
)
testReservedWords = (
	(* To stress the name mangler, try to define slots/temps with identifiers that are often reserved words in target languages. The temporaries are split across two methods to avoid hitting the Squeak limit of 63.*)
	
	assertNoCompilationErrorIn: 'class Sample = ( 

	| abstract as assert boolean break byte case catch class const continue debugger default delete do double Dynamic else enum export extends factory final finally float for function get goto if in implements import is int instanceof interface long native negate new null operator package private protected public return set short static switch synchronized this throw throws transient try typedef typeof use var void volatile while with |
	
	)(
	''cat'' foo = (
		| abstract as assert boolean break byte case catch class const continue debugger default delete do double Dynamic else enum export extends factory final finally float for function get goto if in implements import |
	)
	bar = (
		| is int instanceof interface long native negate new null operator package private protected public return set short static switch synchronized this throw throws transient try typedef typeof use var void volatile while with |
	))'
)
testReservedWordsAsMessageSends = (
	(* For effect *)
	assertCompilationErrorIn: 'class Sample = () (''cat'' foo = (super))'.
	assertCompilationErrorIn: 'class Sample = () (''cat'' foo = (outer))'.
	(* For value *)
	assertCompilationErrorIn: 'class Sample = () (''cat'' foo = (^super))'.
	assertCompilationErrorIn: 'class Sample = () (''cat'' foo = (^outer))'.
)
testReturnAssignBooleanLiteral = (
	testSampleMethod: 'returnAssignBooleanLiteral = (| t |  ^t:: false) '
	with: 'assert: [false = sample returnAssignBooleanLiteral]'
)
testReturnAssignCharacterLiteral = (
	testSampleMethod: 'returnAssignCharacterLiteral = (| t |  ^t:: $c) '
	with: 'assert: [$c = sample returnAssignCharacterLiteral]'
)
testReturnAssignFloatLiteral = (
	testSampleMethod: 'returnAssignIntLiteral = (| t |  ^t:: 3.14159) '
	with: 'assert: [3.14159 = sample returnAssignIntLiteral]'
)
testReturnAssignIntLiteral = (
	testSampleMethod: 'returnAssignIntLiteral = (| t |  ^t:: 42) '
	with: 'assert: [42 = sample returnAssignIntLiteral]'
)
testReturnAssignNil = (
	testSampleMethod: 'returnAssignNil = (| t |  ^t:: nil) '
	with: 'assert: [nil = sample returnAssignNil]'
)
testReturnAssignParam = (
	testSampleMethod: 'returnAssignParam: x = (| t |  ^t:: x) '
	with: 'assert: [91 = (sample returnAssignParam: 91)]'
)
testReturnAssignStringLiteral = (
	testSampleMethod: 'assignReturnStringLiteral = (| t |  ^t:: ''abc'') '
	with: 'assert: [''abc'' = sample assignReturnStringLiteral]'
)
testReturnAssignSymbolLiteral = (
	testSampleMethod: 'assignReturnSymbolLiteral = (| t |  ^t:: #abc) '
	with: 'assert: [#abc = sample assignReturnSymbolLiteral]'
)
testReturnAssignTemps = (
	testSampleMethod: 'returnAssignTemps = (| t1 t2  | ^t1:: t2) '
	with: 'assert: [nil = sample returnAssignTemps ]'
)
testReturnBooleanLiteral = (
	testSampleMethod: 'returnBooleanLiteral = (^false) '
	with: 'assert: [false = sample returnBooleanLiteral]'
)
testReturnCharacterLiteral = (
	testSampleMethod: 'returnCharacterLiteral = (^$c) '
	with: 'assert: [$c = sample returnCharacterLiteral]'
)
testReturnClosure = (
	testSampleMethod: 'returnClosure = (| t | t::1. ^[t:: t + 1]) '
	with: 
	'| closure1 closure2 |
	closure1:: sample returnClosure.
	closure2:: sample returnClosure.
 	assert: [2 = closure1 value].
 	assert: [3 = closure1 value].
 	assert: [2 = closure2 value].
 	assert: [4 = closure1 value].
 	assert: [3 = closure2 value].'
)
testReturnConditionalClosure = (
	testSampleMethod:
		'returnConditionalClosure = (| t | t::1. 
		^[t > 1 ifFalse:[t::t * 2. t] ifTrue:[t:: t + 1]]) '
	with: 
	'| closure1 closure2 |
	closure1:: sample returnConditionalClosure.
	closure2:: sample returnConditionalClosure.
 	assert: [2 = closure1 value].
 	assert: [3 = closure1 value].
 	assert: [2 = closure2 value].
 	assert: [4 = closure1 value].
 	assert: [3 = closure2 value].'
)
testReturnConditionalClosure2 = (
	testSampleMethod:
		'returnConditionalClosure2 = (
	| t | 
	t::1. 
	^[ | x | 
		x:: t > 1 
			ifFalse:[t::t * 2. t] 
			ifTrue:[t:: t + 1]. 
		x = t ifTrue:[| y z | y:: x -1.  z:: y + 1. z]
		]
	) '
	with: 
	'| closure1 closure2 |
	closure1:: sample returnConditionalClosure2.
	closure2:: sample returnConditionalClosure2.
 	assert: [2 = closure1 value].
 	assert: [3 = closure1 value].
 	assert: [2 = closure2 value].
 	assert: [4 = closure1 value].
 	assert: [3 = closure2 value].'
)
testReturnFinalClosure = (
	testSampleMethod: 'returnFinalClosure = (| t | t::1. ^[t ]) '
	with: 
	'| closure1 closure2 |
	closure1:: sample returnFinalClosure.
	closure2:: sample returnFinalClosure.	
	assert: [1 =closure1 value].
	assert: [1 =closure1 value].
 	assert: [1 =closure2 value].
	assert: [1 =closure2 value].'
)
testReturnFloatLiteral = (
	testSampleMethod: 'returnFloatLiteral = (^3.14159) '
	with: 'assert: [3.14159 = sample returnFloatLiteral].'
)
testReturnIntLiteral = (
	testSampleMethod: 'returnIntLiteral = (^42) '
	with: 'assert: [42 = sample returnIntLiteral].'
)
testReturnNestedClosure = (
	testSampleMethod: 'returnNestedClosure = (| t | t::1. ^[[t:: t + 1]]) '
	with:
	'| closure1 closure2 |
	closure1:: sample returnNestedClosure.
	closure2:: sample returnNestedClosure.
 	assert: [2 = closure1 value value].
 	assert: [3 = closure1 value value].
 	assert: [2 = closure2 value value].
 	assert: [4 = closure1 value value].
 	assert: [3 = closure2 value value].'
)
testReturnNil = (
	testSampleMethod: 'returnNil = (^nil)'
	with: 'assert: [nil = sample returnNil].'
)
testReturnNoParamBlock = (
	testSampleMethod: 'returnNoParamBlock = (^[false]) '
	with: 'assert: [false = sample returnNoParamBlock value].'
)
testReturnOneParamBlock = (
	testSampleMethod: 'returnOneParamBlock = (^[:x | x ])'
	with: 'assert: [3 = (sample returnOneParamBlock value: 3)].'
)
testReturnOneParamBlockIncrement = (
	testSampleMethod: 'returnOneParamBlockIncrement = (^[:x | x + 1]) '
	with: 'assert: [4 = (sample returnOneParamBlockIncrement value: 3)].'
)
testReturnOneParamBlockWithTemp = (
	testSampleMethod: 'returnOneParamBlockWithTemp = (^[:x | | y |  y:: x ]) '
	with: 'assert: [3 = (sample returnOneParamBlockWithTemp value: 3)].'
)
testReturnOneParamBlockWithTempIncrement = (
	testSampleMethod: 'returnOneParamBlockWithTempIncrement = (^[:x | | y |  y:: x. y + 1]) '
	with: 'assert: [4 = (sample returnOneParamBlockWithTempIncrement value: 3)].'
)
testReturnParam = (
	testSampleMethod: 'returnParam: x = (^x) '
	with: 'assert: [91 = (sample returnParam: 91) ].'
)
testReturnStringLiteral = (
	testSampleMethod: 'returnStringLiteral = (^''abc'')'
	with: 'assert: [''abc'' = sample returnStringLiteral].'
)
testReturnSymbolLiteral = (
	testSampleMethod: 'returnSymbolLiteral = (^#abc) '
	with: 'assert: [#abc = sample returnSymbolLiteral].'
)
testReturnTupleLiteral0 = (
	testSampleMethod: 'returnTupleLiteral0 = (^{}) '
	with: 'assert: [{} = sample returnTupleLiteral0].'
)
testReturnTupleLiteral1 = (
	testSampleMethod: 'returnTupleLiteral1 = (^{ 1 }) '
	with: 'assert: [{1} = sample returnTupleLiteral1].'
)
testReturnTupleLiteral16 = (
	testSampleMethod: 'returnTupleLiteral16 = (^{ #abc.  0. $z.  ''def''. true. false. nil. self.  1. 2. 3. 4. 5. 6. 7. 8.}) '
	with: 'assert: [{ #abc.  0. $z.  ''def''. true. false. nil. sample.  1. 2. 3. 4. 5. 6. 7. 8.} = sample returnTupleLiteral16].'
)
testReturnTupleLiteral2 = (
	testSampleMethod: 'returnTupleLiteral2 = (^{ #abc.  1 }) '
	with: 'assert: [{ #abc.  1 } = sample returnTupleLiteral2].'
)
testReturnTupleLiteral8 = (
	testSampleMethod: 'returnTupleLiteral8 = (^{ #abc.  1. $z.  ''def''. true. false. nil. self }) '
	with: 'assert: [{ #abc.  1. $z.  ''def''. true. false. nil. sample } = sample returnTupleLiteral8].'
)
testReturnUnarySend = (
	test:
'class Sample = ( | testSlot = 42. | ) (
	''samples''
	returnUnarySend = (^testSlot)
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (sample returnUnarySend = sample testSlot)
)')
testSetter = (
	test:
		'class Sample = (
			| slot slot2 slot3 |
		) (
			''category''
			method = (
				| local |
				local:: local:: 1.
				assert: [local = 1] description: ''Assertion failed: 1''.

				slot:: slot:: slot:: 2.
				assert: [slot = 2] description: ''Assertion failed: 2''.
	
				local:: slot:: 3.
				assert: [local = 3] description: ''Assertion failed: l3''.
				assert: [slot = 3] description: ''Assertion failed: s3''.
	
				local:: 4.
				^slot:: slot2:: slot3:: local
			)
		)'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''test''
			test = (
				assert: [sample slot = nil] description: ''Assertion failed: slot = nil''.
				assert: [sample method = 4] description: ''Assertion failed: method = 4''.
				assert: [sample slot = 4] description: ''Assertion failed: slot = 4''.
				assert: [sample slot2 = 4] description: ''Assertion failed: slot2 = 4''.
				assert: [sample slot3 = 4] description: ''Assertion failed: slot3 = 4''.
			)
		)'
)
testSimultaneousSlotsInClass = (	
	test:
		'class Sample = (
			|| a = {b}. b = {a}. ||
		)()'
	with:
		'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
			''test''
			test = (
				assert: [sample a first = sample b].
				assert: [sample b first = sample a].
			)
		)'
)
testSimultaneousSlotsInMethod = (
	testSampleMethod: 'simulSlot = ( || a = {b}. b = {a}. || ^{a. b} )'
	with: 
	' | ab a b | 
	ab:: sample simulSlot.
	a:: ab first.
	b:: ab last.
	assert: [a first yourself= b yourself].
	assert: [b first yourself = a yourself]'
)
testSlotDeclarationInInlinedLoop = (
(* Regression test for NS2Dart inlining. When the condition sequence was split, the slot declaration was duplicated, appearing both in the prologue and after the loop body. The variable in the loop body shadowed the one in the prologue, so the condition expression only ever sees the first value. *)
	testSampleMethod: 
'run = (
  | w ::= 0. |
  [ | t | t: w. t = w ifFalse: [assert: [false]] ifTrue: [w < 2]]
    whileTrue: [w: w+1]
)'
	with: 'assert: [sample = sample run]'
)
testSlotNamedSameAsFactory = (

(* Testing issue 108:
	If a slot with the name of the factory method exists, other slots are not initialized *)
	test:
'class Sample platform: p = (
|
	foo = 42.
	platform
|) ()'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass platform: 23. | ) (
	''accessing''
	test = (assert: [sample foo = 42])
)'
)
testStackDepthTracking2 = (
	testSampleMethod:
'createProcess: commandLine <String>
withCurrentDirectory: dir <FileDirectory>
withTitle: title <String>
withStdInput: stdInput <Alien | Integer>
withStdOutput: stdOutput <Alien | Integer>
withStdError: stdError <Alien | Integer>
^<Win32apiPROCESSINFORMATION> = (
	| lpProcessInformation lpStartupInfo result |
	lpProcessInformation:: PROCESS_INFORMATION newGC.
	lpStartupInfo:: STARTUPINFO newGC.
	Alien autoFreeAfter: [ :autoFree |
		lpStartupInfo
			dwFlags: STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			wShowWindow: SW_HIDE;
			lpTitle: (autoFree value: (Alien newCString: title)) address;
			hStdInput: (stdInput isInteger ifTrue: [stdInput] ifFalse: [stdInput asUnsignedLong]);
			hStdOutput: (stdOutput isInteger ifTrue: [stdOutput] ifFalse: [stdOutput asUnsignedLong]);
			hStdError: (stdError isInteger ifTrue: [stdError] ifFalse: [stdError asUnsignedLong]).
		result:: self CreateProcess
			boolValue: 0 (*lpApplicationName*)
			value: (autoFree value: (Alien newCString: commandLine)) address
			value: 0 (*lpProcessAttributes*)
			value: 0 (*lpThreadAttributes*)
			value: 1 (*bInheritHandles*)
			value: 0 (*dwCreationFlags*)
			value: 0 (*lpEnvironment*)
			value: (autoFree value: (Alien newCString: dir fullName)) address
			value: lpStartupInfo address
			value: lpProcessInformation address.
		result ifFalse: [^reportError]].
	^Process new lpProcessInformation: lpProcessInformation
)'
	with: 'assert: [true].' (* Just checking no error during compilation.  Error is avoided by removing the cascaded sends. *)
)
testStackDepthTracking3 = (
	testSampleMethod:
'createProcess: commandLine <String>
withCurrentDirectory: dir <FileDirectory>
withTitle: title <String>
withStdInput: stdInput <Alien | Integer>
withStdOutput: stdOutput <Alien | Integer>
withStdError: stdError <Alien | Integer>
^<Win32apiPROCESSINFORMATION> = (
	| lpProcessInformation lpStartupInfo result |
	lpProcessInformation:: PROCESS_INFORMATION newGC.
	lpStartupInfo:: STARTUPINFO newGC.
	Alien autoFreeAfter: [ :autoFree |
		lpStartupInfo
			dwFlags: STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			wShowWindow: SW_HIDE;
			lpTitle: (autoFree value: (Alien newCString: title)) address;
			hStdInput: (stdInput isInteger ifTrue: [stdInput] ifFalse: [stdInput asUnsignedLong]);
			hStdOutput: (stdOutput isInteger ifTrue: [stdOutput] ifFalse: [stdOutput asUnsignedLong]);
			hStdError: (stdError isInteger ifTrue: [stdError] ifFalse: [stdError asUnsignedLong]).
		result:: self CreateProcess
			boolValue: 0 (*lpApplicationName*)
			value: (autoFree value: (Alien newCString: commandLine)) address
			value: 0 (*lpProcessAttributes*)
			value: 0 (*lpThreadAttributes*)
			value: 1 (*bInheritHandles*)
			value: 0 (*dwCreationFlags*)
			value: 0 (*lpEnvironment*)
			value: (autoFree value: (Alien newCString: dir fullName)) address
			value: lpStartupInfo address
			value: lpProcessInformation address.
		result ifFalse: [^reportError]].
	^Process new lpProcessInformation: lpProcessInformation
)'
	with: 'assert: [true].' (* Just checking no error during compilation.  Error is avoided by removing the cascaded sends. *)
)
testStackDepthTracking4 = (
	testSampleMethod:
'createProcess: commandLine <String>
withCurrentDirectory: dir <FileDirectory>
withTitle: title <String>
withStdInput: stdInput <Alien | Integer>
withStdOutput: stdOutput <Alien | Integer>
withStdError: stdError <Alien | Integer>
^<Win32apiPROCESSINFORMATION> = (
	|  lpStartupInfo  |

	Alien autoFreeAfter: [ :autoFree |
		lpStartupInfo
			dwFlags: STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			wShowWindow: SW_HIDE;
			lpTitle: (autoFree value: (Alien newCString: title)) address;
			hStdInput: (stdInput isInteger ifTrue: [stdInput] ifFalse: [stdInput asUnsignedLong]);
			hStdOutput: (stdOutput isInteger ifTrue: [stdOutput] ifFalse: [stdOutput asUnsignedLong]);
			hStdError: (stdError isInteger ifTrue: [stdError] ifFalse: [stdError asUnsignedLong]).
			^3
		].
)'
	with: 'assert: [true].' (* Just checking no error during compilation.  Error is avoided by removing the cascaded sends. *)
)
testStringLiteral = (
	testSampleMethod: 'stringLiteral = (''abc'')'
	with: 'assert: [sample = sample stringLiteral].'
)
testSuperClassClause1 = (
	test:
'class Sample = () (
	class SuperHierarchy =  (
	) (
		class Inner1 new: x =  ( | v = x. |) ( 
			'' tests''
			foo = (
				^v + 42
			)
		)
		''access''
       makeInnerInstance = (^(Inner1 new: 1) foo)
	)
	
	class SubHierarchy = SuperHierarchy (
	) (
		class Inner1 new: x =  super Inner1 new: x () ( 
			'' tests''
			foo = (
				^v * super foo
			)		
		)
	)	
	
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (
		| subklass superklass subInstance superInstance |
		superklass:: sample SuperHierarchy.
		superInstance:: superklass new.
		assert: [superInstance Inner1 = superInstance Inner1].
		assert: [(superInstance Inner1 new: 2) foo = 44].
		
		subklass:: sample SubHierarchy.
		subInstance:: subklass new.
		assert: [subInstance Inner1 = subInstance Inner1].
		assert: [(subInstance Inner1 new: 2) foo = 88].
	)
)'
)
testSuperClassClause2 = (
	test:
'class Sample = () (
	class InnerHierarchy =  (
	) (	
		class Inner1 new: x =  ( | v = x. |) ( 
			''tests''
			foo = (
				^v + 42
			)
		)
		
		class InnerInnerHierarchy = () (
			class Inner1 new: x =  outer InnerHierarchy Inner1 new: x () ( 
				''tests''
				foo = (
					^v * super foo
				)
			)		
		)
	)	
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (
		| innerInnerklass innerklass innerInnerInstance innerInstance |
		innerklass:: sample InnerHierarchy.
		innerInstance:: innerklass new.
		assert: [innerInstance Inner1 = innerInstance Inner1].
		assert: [(innerInstance Inner1 new: 2) foo = 44].
		
		innerInnerklass:: innerInstance InnerInnerHierarchy.
		innerInnerInstance:: innerInnerklass new.
		assert: [innerInnerInstance Inner1 = innerInnerInstance Inner1].
		assert: [(innerInnerInstance Inner1 new: 2) foo = 88].
	)
)'
)
testSuperClassClause3 = (
	test:
'class Sample = () (
	class Inner0 new: x =  ( | v = x. |) ( 
		'' tests''
		foo = (
			^v + 42
		)
	)
		
	class Inner1 new: x =  outer Sample Inner0 new: x () ( 
		'' tests''
		foo = (
			^v * super foo
		)		
	   )	
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (
		| innerklass0 innerklass1 innerInstance0 innerInstance1 |
		innerklass0:: sample Inner0.
		assert: [(innerklass0 new: 2) foo = 44].
		
		innerklass1:: sample Inner1.
		assert: [(innerklass1 new: 2) foo = 88].
	)
)'
)
testSuperClassClause4 = (
	test:
'class Sample = () (
	class Inner0 new: x =  ( | v = x. |) ( 
		'' tests''
		foo = (
			^v + 42
		)
	)
		
	class Inner1 new: x =  self Inner0 new: x () ( 
		'' tests''
		foo = (
			^v * super foo
		)		
	   )	
)'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (
		| innerklass0 innerklass1 innerInstance0 innerInstance1 |
		innerklass0:: sample Inner0.
		assert: [(innerklass0 new: 2) foo = 44].
		
		innerklass1:: sample Inner1.
		assert: [(innerklass1 new: 2) foo = 88].
	)
)'
)
testSymbolLiteral = (
	testSampleMethod: 'symbolLiteral = (#abc)'
	with: 'assert: [sample = sample symbolLiteral].'
)
testSymbolLiteralBlock = (
	testSampleMethod: 'symbolLiteralBlock = (^[#xx])'
	with: 'assert: [#xx = sample symbolLiteralBlock value].'
)
testTimesRepeat = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'testTimesRepeat = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf timesRepeat:[tf:: tf +1].
	^tf
	 ) '
	with: 'assert: [74 = sample testTimesRepeat].'
)
testToByDo1 = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'testToByDo1 = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf to: 74 by: 1 do:[:i <integer> |  tf:: tf +1].
	^tf
	 ) '
	with: 'assert: [75 = sample testToByDo1].'
)
testToByDo2 = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'testToByDo2 = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf to: 74 by: 36 do:[:i <integer> |  tf:: tf +1].
	^tf
	 ) '
	with: 'assert: [39 = sample testToByDo2].'
)
testToDo1 = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'testToDo1 = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf to: 74  do:[:i <integer> |  tf:: tf +1].
	^tf
	 ) '
	with: 'assert: [75 = sample testToDo1].'
)
testToDo2 = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'testToDo2 = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf to: tf*2  do:[:i <integer> |  tf:: tf +1].
	^tf
	 ) '
	with: 'assert: [75 = sample testToDo2].'
)
testToDo3 = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'testToDo3 = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf to: tf*2  do:[:i <integer> |  tf:: i].
	^tf
	 ) '
	with: 'assert: [74 = sample testToDo3].'
)
testTupleLiteral0 = (
	testSampleMethod: 'tupleLiteral0 = ({})'
	with: 'assert: [sample = sample tupleLiteral0].'
)
testTupleLiteral1 = (
	testSampleMethod: 'tupleLiteral1 = ({ 1 }) '
	with: 'assert: [sample = sample tupleLiteral1].'
)
testTupleLiteral16 = (
	testSampleMethod: 'tupleLiteral16 = ({ #abc.  0. $z.  ''def''. true. false. nil. self.  1. 2. 3. 4. 5. 6. 7. 8.}) '
	with: 'assert: [sample = sample tupleLiteral16].'
)
testTupleLiteral2 = (
	testSampleMethod: 'tupleLiteral2 = ({ #abc.  1 }) '
	with: 'assert: [sample = sample tupleLiteral2].'
)
testTupleLiteral8 = (
	testSampleMethod: 'tupleLiteral8 = ({ #abc.  1. $z.  ''def''. true. false. nil. self }) '
	with: 'assert: [sample = sample tupleLiteral8].'
)
testTuplesAreShallowlyImmutable = (
	testSampleMethod: ''
	with: '
assert: [{1. 9. 8. 4} at: 2 put: 8] signals: Error.
'
)
testTwoParamBlock = (
	testSampleMethod: 'twoParamBlock = (^[:x :y | x -y] value: 91 value: 49) '
	with: 'assert: [42 = sample twoParamBlock].'
)
testWhileFalse = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'testWhileFalse = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
[tg:: tg *2. tg > 10000] whileFalse.
^tg)'
	with: 'assert: [18944 = sample testWhileFalse].'
)
testWhileFalseColon = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'testWhileFalseColon = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
[tg >= 10000] whileFalse:[tg:: tg *2].
^tg)'
	with: 'assert: [18944 = sample testWhileFalseColon].'
)
testWhileInBlock = (
(* Regression: check that loops leave something on the operand stack *)
	testSampleMethod:
	'testWhileInBlock = (	| copied |
	copied::  ''abc'' readStream.
	^ Array streamContents: [:resultStream |
		[copied atEnd] whileFalse: [
			resultStream nextPut: copied next]].
      )'
	with: 'assert: [{$a. $b. $c} = sample testWhileInBlock].'
)
testWhileTrue = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'testWhileTrue = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
[tg:: tg *2. tg < 10000] whileTrue.
^tg)'
	with: 'assert: [18944 = sample testWhileTrue].'
)
testWhileTrueColon = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'testWhileTrueColon = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
[tg < 10000] whileTrue:[tg:: tg *2].
^tg)'
	with: 'assert: [18944 = sample testWhileTrueColon].'
)
testWhileWithScope = (
(* The convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods. *)
	testSampleMethod: 'testWhileWithScope = ( | i n |
i:: 5. 
n:: 1. 
[ | j | j:: 0. i > j] whileTrue:[i:: i -1. n:: n*2].
^n
) '
	with: 'assert: [32 = sample testWhileWithScope].'
)'private'
test: sampleClassSource <String> with: testClassSource <String> = (
	testingStrategy
		test: sampleClassSource
		with: testClassSource
		ifFailure: [:message | failWithMessage: message]
		ifError: [:message | Error new signal: message]
)
testSampleMethod: sampleMethod <String> with: testMethodBody <String> = (
	test:
'class Sample = () (
	''samples''
',
	sampleMethod,
')'
	with:
'class SampleTest test: sampleClass = ( | sample = sampleClass new. | ) (
	''accessing''
	test = (',
	testMethodBody,
	')
)'
)) : ('as yet unclassified'
TEST_CONTEXT = (
))'as yet unclassified'
TODO = (
	(* A marker method. Look for senders to find methods that still need work. *)
)
test: sampleClassSource <String> with: testClassSource <String> = (
	testingStrategy test: sampleClassSource with: testClassSource
)) : ()