Newspeak3
'Actors'
class ActorSystemTests usingPlatform: p = (
(*Various example and test actors.*)|
	private platform = p.
	private actors = p actors.
	private Transcript = p blackMarket Transcript.
|)
(
class FactorialDriver = (
(*Needs class methods since Promise chaining and pipelining does not work outside of the context of an actor at this time.*)|
|)
() : ('as yet unclassified'
testFactorialOf: n <Integer> on: mathClass <FarReference[Factorial class]> usingPlatform: p = (
	| math result result2 |
	math: mathClass ESEND new.
	result:: math ESEND factorial: n. (*pipelining test*)
	result2:: result whenResolved: [ :r | (*chaining test*)
		p blackMarket Transcript show: 'Factorial of ', n, ' is ', r; cr. r + 1.
	].
	result2 whenResolved: [ :r2 | 
		p blackMarket Transcript show: 'Result of chaining is ', r2; cr.
	]
))
class Failure = (
(*Signals an exception.*)|
|)
('as yet unclassified'
fail = (
	halt.
	1 / 0.
)) : ()
class Math = (
(*Simplest possible factorial without an accumulator for tail recursion.*)|
|)
('as yet unclassified'
factorial: n <Integer> ^ <Integer> = (
	(n <= 1) 
		ifTrue: [ ^1 ] 
		ifFalse: [ ^(self ESEND factorial: (n - 1)) ESEND * n ].
)) : ()'as yet unclassified'
flipCoin ^ <Boolean> = (
	(*Flips a coin and returns true if head, false if tail.*)
	^true.
)
testAll = (
	testFactorial: 5.
	testFactorialDirect: 12.
	^testPromiseGroup.
)
testCoinFlip = (
	| booleanPromise |
	booleanPromise:: self ESEND flipCoin.
	booleanPromise ESEND ifTrue: [ Transcript cr; show: 'Coin landed heads-up'; cr. 1 ] ifFalse: [ Transcript cr; show: 'Coin landed tails-up'; cr. 2 ].
	booleanPromise whenResolved: [ :b | Transcript cr; show: 'Fulfilled with ', b; cr ] catch: [ :e | Transcript cr; show: 'Failed with error ', e; cr ].
	^booleanPromise
)
testFactorial: n <Integer> = (
	| mathClass = actors createActor: Math mixin. driver = actors createActor: FactorialDriver mixin. |
	driver ESEND testFactorialOf: n on: mathClass usingPlatform: platform.
)
testFactorialDirect: n = (
	| mathClass = actors createActor: Math mixin. math result |
	math:: mathClass ESEND new.
	result:: math ESEND factorial: n.
	^result whenResolved: [ :r |
		Transcript show: 'Factorial of ', n, ' is ', result, ' (on gui actor)'; cr.
		42.
	].
)
testFailure = (
	| failureClass = actors createActor: Failure mixin. failure = failureClass ESEND new. |
	failure ESEND fail.
)
testPromiseGroup = (
	| mathClass = actors createActor: Math mixin. math r2 r3 r4 |
	math:: mathClass ESEND new.
	r2:: math ESEND factorial: 2.
	r3:: math ESEND factorial: 3.
	r2, r3 whenResolved: [ Transcript show: 'done ', (r2 + r3); cr. ].
	r4:: math ESEND factorial: 4.
	^r2, r3, r4 whenResolved: [
		| sum = r2 + r3 + r4. |
		Transcript show: 'done all three of them ', sum; cr.
		sum
	].
)) : ()