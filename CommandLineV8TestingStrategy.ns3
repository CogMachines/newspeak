Newspeak3
'NS2JS Tests'
class CommandLineV8TestingStrategy platform: platform compilerModule: compilerModule v8path: v8path <String> temporaryDirectoryPath: temporaryDirectoryPath <String> = (
(*A compiler testing strategy [1] that compiles classes to be tested to a Javascript script using a supplied compiler, writes out the source to a temporary file, runs a v8 command on the script and examines the script output to determine if any tests failed.

[1] See InImageNSCompilerTestingStrategy in the NS2 package for details about strategies.


   Copyright 2012 SAP AG.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0

*)|
	private FileStream = platform blackMarket Files CrLfFileStream.

	private newShell = platform blackMarket ExternalProcess NewShell usingPlatform: platform.
	private CommandError = newShell CommandError.

	compilerModule = compilerModule.
	v8path = v8path.
	temporaryDirectoryPath = temporaryDirectoryPath.
	infrastructureFunctions = compilerModule InfrastructureFunctions new.
	phase1Platform = compilerModule Phase1Platform new.
	
	CombinatorialParsing = platform blackMarket NS2CombinatorialParsing CombinatorialParsing.
	BlocklessCombinatorialParsing = platform blackMarket NS2CombinatorialParsing BlocklessCombinatorialParsing.
	NewspeakGrammar = platform blackMarket NewspeakGrammar.
	NewspeakASTs = platform blackMarket NewspeakASTs.
	NewspeakParsing = platform blackMarket NewspeakParsing.

	
	private cachedInfrastructureScript
|)
(
class ModuleSourceGenerator sampleClassSource: sampleClassSource testClassSource: testClassSource = (
(*Combines the sample and the test class sources into a top-level class module containing the two, plus any necessary infrastructure.*)|
	sampleClassSource = sampleClassSource.
	testClassSource = testClassSource.
|)
('as yet unclassified'
assertionMethodsSource ^<String> = (
	^'''assertions''
	assert: aBlock = (
		aBlock value ifFalse:
			[print: ''[ASSERTION FAILED]''.
			quit]
	)
	assert: aBlock description: descriptionText = (
		aBlock value ifFalse:
			[print: ''[ASSERTION FAILED] '', descriptionText.
			quit]
	)
	assert: aBlock descriptionBlock: descriptionBlock = (
		aBlock value ifFalse:
			[print: ''[ASSERTION FAILED] '', descriptionBlock value.
			quit]
	)
	assert: aBlock signals: errorClass = (
		assert: aBlock signals: errorClass description: ''Exception expected but not signaled''.
	)
	assert: aBlock signals: errorClass description: descriptionText = (
		aBlock on: errorClass do: [:ex | ^self].
		print: ''[ASSERTION FAILED] '', descriptionText.
		quit.
	)
	deny: aBlock = (assert: [aBlock value not])
	'
)
moduleSource ^<String> = (
(*Returns a string with the Newspeak source of a top-level class containing everything necessary to assemble and run the tests.*)
	| source |
	source:: (String new: 400) writeStream.
	source
		nextPutAll: 'Newsqueak2'; cr;
		nextPutAll: '''InImageNSCompilerTesting-tmp'''; cr;
		nextPutAll: 'class TestModule platform: platform = ( "| private Error = platform Exceptions Error. |" ) ('; cr;
		nextPutAll: sampleClassSource; cr;
		nextPutAll: testClassSource; cr;
		nextPutAll: assertionMethodsSource; cr;
		nextPutAll: runMethodSource; cr;
		nextPutAll: ')'.
	^source contents
)
runMethodSource ^<String> = (
	^'''running''
	run = (
		(SampleTest test: Sample) test
"should eventually run it like this:"
"	[(SampleTest test: Sample) test]
		on: Error do:
			[:ex |
			print: ''[ERROR]''.
			quit]"
	)'
)) : ()
class TestScriptGenerator moduleSource: moduleSource = (
(*Generates the source of Javascript script containing the translation of the given module plus the code necessary to assemble and invoke the tests.*)|
	topLevelClassSource = moduleSource.
	protected compiler = compilerModule Compiler2 new.
|)
('as yet unclassified'
infrastructureScript = (

	nil = cachedInfrastructureScript ifTrue: [
		| output |
		output:: (String new: 2000) writeStream.
		writeInfrastructureTo: output.
		writeSectionDividerTo: output.
		writePhase1PlatformTo: output.
		writeSectionDividerTo: output.
		writeClass: CombinatorialParsing To: output.
		writeClass: BlocklessCombinatorialParsing To: output.
		writeClass: NewspeakGrammar To: output.
		writeClass: NewspeakASTs To: output.
		writeClass: NewspeakParsing To: output.
		cachedInfrastructureScript:: output contents].
	^ cachedInfrastructureScript
)
scriptSource = (
	| output |
	output:: (String new: 2000) writeStream.
	
	output nextPutAll: infrastructureScript.
	
	writeTopLevelClassTo: output.
	
	writeSectionDividerTo: output.
	writeLaunchCodeTo: output.
	writeSectionDividerTo: output.
	writeSuccessMarkerPrintCodeTo: output.
	^output contents
)
writeClass: aClass To: stream = (

	| source rep |
	source:: (String new: 1000) writeStream.
	aClass mixin printTopClassOn: source.
		rep:: compiler compileClassSource: topLevelClassSource readStream within: nil.
	compiler outputTopLevelClass: rep to: stream.
	stream nextPutAll: ';'
)
writeInfrastructureTo: stream = (
	infrastructureFunctions outputTo: stream.
)
writeLaunchCodeTo: stream = (
	stream
		nextPutAll: 'TestModule["#platform:"](newspeakUndefinedObject)["#run"]();'
)
writePhase1PlatformTo: stream = (
	phase1Platform outputTo: stream.
)
writeSectionDividerTo: stream = (
	stream cr; cr
)
writeSuccessMarkerPrintCodeTo: stream = (
	stream nextPutAll: 'print("[SUCCESS]");'
)
writeTopLevelClassTo: stream = (
	| rep |
	rep:: compiler compileClassSource: topLevelClassSource readStream within: nil.
	stream
		nextPutAll: 'var TestModule = '.
	compiler outputTopLevelClass: rep to: stream.
	stream nextPutAll: ';'
)) : ()'accessing'
test: sampleClassSource <String> with: testClassSource <String> ifFailure: failureBlock <[:String]> ifError: errorBlock <[:String]> = (
	| moduleGenerator scriptGenerator scriptOutput |
	
	moduleGenerator:: ModuleSourceGenerator
		sampleClassSource: sampleClassSource
		testClassSource: testClassSource.
	scriptGenerator:: TestScriptGenerator
		moduleSource: moduleGenerator moduleSource.
	write: scriptGenerator scriptSource toFile: scriptPath.
	scriptOutput:: executeScript: scriptPath ifError: errorBlock.
	if: scriptOutput hasErrorsInvoke: errorBlock else:
		[if: scriptOutput hasFailuresInvoke: failureBlock else:
			[(hasSuccess: scriptOutput) ifFalse:
				[errorBlock value: 'Test script has not run to completion']]].
)'as yet unclassified'
TODO = (
	(*Marker*)
)
executeScript: scriptPath <String> ifError: errorBlock ^<String> = (
(*Run the Javascript script and return the contents of its stdout.*)

	| command |
	command:: newShell perform: v8path asSymbol.
	^[command value: scriptPath]
		on: CommandError do:
			[:ex |
			(*v8 prints the error message to stdout instead of stderr*)
			errorBlock value: (ex stdoutContents upTo: Character cr)]
)
hasSuccess: scriptOutput = (
	^(scriptOutput indexOfSubCollection: '[SUCCESS]') ~= 0
)
if: scriptOutput hasErrorsInvoke: errorBlock else: elseBlock = (
	| errorIndex |
	errorIndex:: scriptOutput indexOfSubCollection: '[ERROR]'.
	errorIndex = 0
		ifTrue:
			[elseBlock value]
		ifFalse:
			[errorBlock value: scriptOutput. TODO. (*extract the message and invoke error block here*)]
)
if: scriptOutput hasFailuresInvoke: failureBlock else: elseBlock = (
	| errorIndex |
	errorIndex:: scriptOutput indexOfSubCollection: '[ASSERTION FAILED]'.
	errorIndex = 0
		ifTrue: elseBlock
		ifFalse: [failureBlock value: scriptOutput. TODO. (*extract the message and invoke error block here*)]
)
scriptPath ^<String> = (
	^temporaryDirectoryPath, '/ns2jsTestScript.js'
)
write: text <String> toFile: filePath <String> = (
	| stream |
	stream:: FileStream forceNewFileNamed: filePath.
	[stream nextPutAll: text]
		ensure: [stream close]
)) : ()