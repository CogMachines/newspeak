Newspeak3'HopscotchIDE'class SqueakMethodVersioning usingPlatform: platform ide: ide sourceControlBrowser: sourceControlBrowser_ = NewspeakObject ("An ugly expedient to provide a Hopscotch GUI for Squeak's method versions facility.This should evolve into, or be replaced by, a real method history facility.The basic approach is to use Squeak's existing VersionsBrowser to provide alist of versions of a method. This means that this code is dependent on Squeak; indeed it is in principle still dependent on Morphic, as the VersionsBrowser does not properly separate logic and UI. However, we use VersionsBrowser only as computing tool, and never require it to display anything. It can run in this capacity without actually running Morphic,  indeed without Morphic even being present (provided the globals it and its superclasses reference are nil).  Should this fail, one could copy some of the ugly logic from VersionsBrowser. At a minimum, we should be able to display the version info in Hopscotch with Morphic dormant.Obviously, in the longer term we shoud eliminate the use of VersionsBrowser and do the right thing, using a source manager. It may be that the overall structure of the presentation need not change much - just the fact that we will have an accurate and complete version history.See the comments on the nested classes for more details, including their own flaws."|	Subject = platform hopscotch core Subject.	AssortedMethodsPresenter = ide browsing AssortedMethodsPresenter.	ExpandableMethodPresenter = ide browsing ExpandableMethodPresenter.	MethodSubject = ide browsing MethodSubject.	CodeEditorFragment = ide tools CodeEditorFragment.	OrderedCollection = platform collections OrderedCollection.	SortedCollection = platform collections SortedCollection.	"ungood imports"	VersionsBrowser = platform blackMarket Tools VersionsBrowser. 	MCModification = platform blackMarket Monticello MCModification.	HopscotchImages = platform hopscotch HopscotchImages. "a cheap import"	Color = platform blackMarket Graphics Color.	MethodReference = platform blackMarket System MethodReference.	messageCollector <MessageCollector Collector> = 		platform blackMarket NewspeakUtilities "SourceMirrors" MessageCollector usingPlatform: platform blackMarket.	sourceControlBrowser = sourceControlBrowser_.|)(class MethodVersionPresenter onSubject: s = ExpandableMethodPresenter onSubject: s("By overriding the methodHeading method, we change how a method version isdisplayed. We add a timestamp, and menus that allow us to revert to a version, but not to do illogical things like deleting it.The presenter does not show the category, as the data from the change record is unreliable. "|	isComparing ::= false.	comparisonPresenter	toggle|)('as yet unclassified'methodActionsMenu ^ <Menu> = (	^menuWithLabelsAndActions: {		'Revert to this version' -> [respondToRevert].		#separator.		'Inspect Presenter' -> [respondToInspectPresenter].		})methodHeading ^ <Presenter> = (	^row:{		(link: [subject selector]			action: [substance userToggle]			dragSubject: subject			withImage: HopscotchImages default hsExpandImage) color: actionLinkColor.		largeBlank.		label: subject timeStamp. 		mediumBlank.		(link: [isComparing ifTrue: ['hide comparison'] ifFalse: ['show comparison']] action: [respondToCompare]) tinyFont.		mediumBlank.		deferred: 			[sendersOfSubjectPresenter].		filler.		smallBlank.		itemReferencesButtonWithAction: [goToMessages].		smallBlank.				dropDownMenu: [methodActionsMenu].		})'definition'definition = (	createComparisonPresenter.	createCodeEditor.	toggle::		collapsed: methodHeading		expanded:			[column: {				methodHeading color: methodHeadingColor.				holder: 					[isComparing						ifTrue: [comparisonPresenter]						ifFalse: [editor]]				}].	toggle onUserToggled: [toggle isExpanded ifTrue: [requestVisibility]].	^toggle)'actions'respondToAccept = (	^editor showMessage: 'This is an old version of the method! You cannot change it!')respondToCompare = (	toggle isExpanded ifFalse: [toggle userToggle].	isComparing 		ifTrue: [hideComparison]		ifFalse: [showComparison])respondToRevert = (	subject revert.	sendUp refresh)'private'hideComparison = (	isComparing:: false.	refresh)showComparison = (	isComparing:: true.	refresh)'initialize-release'createCodeEditor = (	editor:: CodeEditorFragment new		text: subject source;		acceptResponse: 			[respondToAccept];		cancelResponse:			[editor text: subject source.			editor leaveEditState]. 	editor colorizerBlock: [:text | subject colorizeMethodSource: text].	^editor)createComparisonPresenter = (	| current diffSubject |	"mcMod:: MCModification of: subject currentVersion asMethodDefinition to: subject mcMethod."	current:: subject currentVersion asMethodDefinition.	diffSubject:: 		sourceControlBrowser differences SideBySideDiffSubject 			a: current source 			b: subject mcMethod source.	diffSubject titleA: current timeStamp.	diffSubject titleB: subject timeStamp.	comparisonPresenter: diffSubject presenter.))class MethodVersionSubject fromChangeRecord: cr <ChangeRecord> = MethodSubject onModel: {cr. cr asMethodDefinition} ("This class implements the complete protocol of its abstract superclass, based on the information given in a ChangeRecord, which is what the VersionsBrowser gives us for a given method version.It would be cleaner to use a source mirror on the sources provided by the change record. Maybe we have such code somewhere.  Since I don't understand how source mirrors are to be used in the current mirror library, I decided not to pursue this option right now.However,  it is the right thing to do longer term, when the next generation mirror API is available.  We will need a read only source mirror. The model for this subject would then be a pair - the mirror and timestamp. Presumably, once the entire tool uses a source manager, Squeak ChangeRecords will not be involved at all, eliminating one more nasty dependency."|	currentVersion|)('as yet unclassified'changeCategoryTo: newName <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[]> = (	^failureBlock value)changeRecord ^ <ChangeRecord> = (	^model first)compileNewSource: src <String> ifSuccess: successBlock <[]> ifNewMethod: nblk <[Object]>  ifFailure: failureBlock <[]> = (	^failureBlock value)createPresenter ^ <Presennter> = (	^MethodVersionPresenter onSubject: self)implementingClass ^ <Class> = (	^mcMethod actualClass)isAnOverride ^ <Boolean> = (	^false)isValid ^ <Boolean> = (	^true)mcMethod ^ <MCMethodDefinition> = (	^model second)messages ^ <Collection[Symbol]> = (	^messageCollector selectorsIn: source inLanguage: implementingClass language)methodCategory ^ <String> = ("apparently not the category of the changed method"	^mcMethod category)revert = (	"make class accept the source of this version"	mcMethod load)selector ^ <Symbol> = (	^changeRecord methodSelector)source ^ <String> = (	^mcMethod source)timeStamp ^ <String> = (	^changeRecord stamp)variableBindingKeys ^ <Collection[Symbol]> = (	^messages select:[: sym <Symbol>  | sym first isUppercase])) : ('as yet unclassified'onModel: model <Tuple[ChangeRecord,  MCMethodDefinition]> ^ <Instance> = (	^self fromChangeRecord: model first))class MethodHistorySubject onSelector: s <Symbol> ofClass: kls <Class> = 	Subject onModel: {s. kls} ("A subject for a list of versions of a method. Its sole purpose is to extract the list of versions from a Squeak VersionsBrowser"	|	public versions <ChangeList> = 		(VersionsBrowser new			scanVersionsOf: (kls compiledMethodAt: s ifAbsent: []) 			class: kls 			meta: kls isMeta			category: nil 			selector: s) changeList. 		 |)('as yet unclassified'createPresenter ^ <Presenter> = (	^MethodHistoryPresenter onSubject: self)currentVersion = (	"The first item in versions should be the "	^versions first)klass ^ <Class> = (	^model at: 2)previousVersions = (	^versions copy removeFirst; yourself)selector ^ <Symbol> = (	^model at: 1)) : ('as yet unclassified'onModel: model <Tuple[Symbol, Class]> ^ <Instance> = (	^self onSelector: model first ofClass: model second))class MethodHistoryPresenter onSubject: s = AssortedMethodsPresenter onSubject: s ("Present the history of a method.  Shows the current version, and a list of prior definitions with a suitable header, where the prior definitions are MethodVersionPresentersWhen we have a diff tool, we will integrate it into here as well.")('as yet unclassified'collapseAll = (	"Ugh. Copied down from DefinitionListPresenter, to override override in AssortedMethodsPresenter."	majorUpdate:		[content presenters do: [:each | each collapse]])compileMethod: source <String> inPresenter: requestor <Presenter> ifCompiledAsSame: successResponse <[]> ifCompiledAsNew: successNewResponse <[]> ifFailed: failureResponse <[String]> = (	super 		compileMethod: source 		inPresenter: requestor  		ifCompiledAsSame: successResponse  		ifCompiledAsNew: successNewResponse 		ifFailed: failureResponse.	refresh)contentPresenters ^ <Collection[Presenter]> = (	^subject previousVersions collect:[:cr <ChangeRecord>  | versionsRowFor: cr])currentVersion ^ <Presenter> = (	^column: {		minorHeadingBlock: 			(row: {				label: 'Current version' asText allBold. 				mediumBlank.  				(label: subject currentVersion stamp)			}).		(MethodSubject 			on: (MethodReference class: subject klass selector: subject selector) 			) presenter		})definition = (^	column: {		headingDefinition.		mediumBlank.		currentVersion.		mediumBlank.		olderVersions.		mediumBlank.		}	)expandAll = (	"See comment in collapseAll."	majorUpdate:		[content presenters do: [:each | each expand]])headingDefinition ^ <Presenter> = (		^minorHeadingBlock: (			row:{				label: 'Versions of '   asText allBold.				link: subject klass name  asText allBold 				action:[browseClass: subject klass].				label: ( '>>', subject selector) asText allBold.				}		).)olderVersions ^ <Presenter> = (	^column: {		minorHeadingBlock:(			row: {(label: 'Older versions' asText allBold).				filler.				expandButtonWithAction: [expandAll].				blank: 3.				collapseButtonWithAction: [collapseAll].				blank: 3.				}			).		super definition.		})title ^ <String> = (	^'Versions of ', subject klass name, '>>', subject selector)versionsRowFor: cr <ChangeRecord> ^ <Presenter> = (	^(MethodVersionSubject fromChangeRecord: cr)		currentVersion: subject currentVersion;		presenter)))