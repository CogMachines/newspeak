Newspeak3
'Mirrors'
class MirrorsForV8 usingPlatform: p runtime: r vmMirror: vmm = (
(* The reflection library for the Javascript-based implementation of Newspeak. 

Copyright Google Inc. 2014 - 2017
*)|
private List = p collections List.
private Map = p collections Map.
private Mixin = p kernel Mixin.
private StringBuilder = p kernel StringBuilder.
private ImmutableMirrorGroup = (r MirrorGroups usingLib: p) ImmutableMirrorGroup.
private vmmirror = vmm.

public parserLib = Future computing: [r CombinatorialParsing usingPlatform: p].
public grammar = Future computing: [r NewspeakGrammar usingPlatform: p parsers: parserLib].
private asts = Future computing: [r NewspeakASTs usingLib: p].
private parsing = Future computing: [r NewspeakParsing usingPlatform: p grammar: grammar asts: asts].
private generation = Future computing: [r JavascriptGeneration usingPlatform: p].
private compilation = Future computing: [r Compilation usingPlatform: p parsing: parsing generation: generation mirrors: nil].
private compiler = Future computing: [compilation Compiler new].
|) (
public class ClassDeclarationBuilder fromIR: ir forExistingMixin: m within: enclosing = (|
private prvtExistingMixin <Mixin> ::= m.
private prvtClassDeclIR <IntermediateClassDeclaration> ::= ir.

public enclosingClass = enclosing.
public instanceSide = MixinBuilder forClassDeclaration: self ir: ir instanceSide em: m.
public classSide = MixinBuilder forClassDeclaration: self ir: ir classSide em: m.
deletedInstanceMethods <List[Symbol]>
deletedClassMethods <List[Symbol]>
|) (
public accessModifier = (
	^prvtClassDeclIR accessModifier
)
public canUnderstand: selector <Symbol> ^ <Boolean> = (
	^instanceSide canUnderstand: selector
)
public install ^<ClassDeclarationMirror> = (
	| writer sb <StringBuilder> src <String> runtimeMixin <JRM> |
	(* assert: [prvtExistingMixin isNil] message: 'Modifying existing code as-yet-unimplemented'. *)
	writer:: generation Writer new.
	sb:: StringBuilder new.
	writer generateSourceFor: prvtClassDeclIR runtimeMixin on: sb.
	src:: sb asString.
	src out.
	runtimeMixin:: js call: (js ident: 'eval') with: {src}.
	prvtExistingMixin isNil
		ifTrue: [prvtExistingMixin:: Mixin fromRuntimeMixin: runtimeMixin] (* source indices will be BOGUS here *)
		ifFalse: [updateMixinFrom: runtimeMixin].
	^ClassDeclarationMirror reflecting: prvtExistingMixin.
)
public name ^<Symbol> = (
	^compilation names fullyQualifiedNameToSimple: prvtClassDeclIR qualifiedName
)
public qualifiedName = (
	#BOGUS. (* Remove when currentMixinUID uses a proper token. *)
	^prvtClassDeclIR qualifiedName
)
public simpleName ^<Symbol> = (
	^name
)
updateApplicationsOf: oldRuntimeMixin <JRM> from: newRuntimeMixin <JRM> by: classDeclIR <IntermediateClassDeclaration> = (
	|
	newRuntimeMetamixin <MJRM> = js propertyOf: newRuntimeMixin at: (js literal: 'meta').
	applications <Array[JRC]> = js propertyOf: oldRuntimeMixin at: (js literal: 'applications').
	|
	(* TODO: handle deletes *)	
	(* TODO: copy nested classes also? *)
	(* TODO: copy new metadata *)
	applications do: [:runtimeClass <JRC> |
		|
		runtimeMetaclass <MJRC> = js propertyOf: runtimeClass at: (js literal: 'meta').
		|
		(*runtimeClass out.*)
		(* Cf. IntermediateClassDeclaration copyMethods: *)
		classDeclIR instanceSide methods do: [:ea <IntermediateMethod> |
			| jsProName <String> jsPubName <String> |
			jsPubName:: compilation names manglePublic: ea name.
			jsProName:: compilation names mangleProtected: ea name.
			ea isProtected ifTrue: [
				js assign: (js propertyOf: runtimeClass at: jsProName) toBe: (js propertyOf: newRuntimeMixin at: jsPubName).
				js assign: (js propertyOf: runtimeClass at: jsPubName) toBe: (js call: (js ident: 'dnuCatcher') with: {jsPubName}).
			].
			ea isPublic ifTrue: [
				js assign: (js propertyOf: runtimeClass at: jsProName) toBe: (js propertyOf: newRuntimeMixin at: jsPubName).
				js assign: (js propertyOf: runtimeClass at: jsPubName) toBe: (js propertyOf: newRuntimeMixin at: jsPubName).
			].
		].
		classDeclIR classSide methods do: [:ea <IntermediateMethod> |
			| jsProName <String>  jsPubName <String> |
			jsPubName:: compilation names manglePublic: ea name.
			jsProName:: compilation names mangleProtected: ea name.
			ea isProtected ifTrue: [
				js assign: (js propertyOf: runtimeMetaclass at: jsProName) toBe: (js propertyOf: newRuntimeMetamixin at: jsPubName).
				js assign: (js propertyOf: runtimeMetaclass at: jsPubName) toBe: (js call: (js ident: 'dnuCatcher') with: {jsPubName}).
			].
			ea isPublic ifTrue: [
				js assign: (js propertyOf: runtimeMetaclass at: jsProName) toBe: (js propertyOf: newRuntimeMetamixin at: jsPubName).
				js assign: (js propertyOf: runtimeMetaclass at: jsPubName) toBe: (js propertyOf: newRuntimeMetamixin at: jsPubName).
			].
		].
	].
)
updateInstanceMixin: oldRuntimeMixin <JRM> from: newRuntimeMixin <JRM> by: classDeclIR <IntermediateClassDeclaration> ^  <List[Symbol]> = (
	(* TODO: handle deletes 
	go thru old methods and see if they exist in new methods, if not add them to deleted list? and remove from old.
	*)
	| newMethods <List[IntermediateMethod]> = classDeclIR instanceSide methods. |
	
	deletedInstanceMethods:: List new.
	
	(* (js propertyOf: oldRuntimeMixin at: #methods) forEach: [:m <MM> | 
		(newMethods anySatisfy: [: im <IntermediateMethod> | 
			im name = (compilation names manglePublic: (js propertyOf: m at: #name))
			])
		   ifFalse: [
			deletedInstanceMethods add: im name.
			(* remove from old; need to add delete support to JavascriptGeneration; not critical *)
			].
		].*)
	(* TODO: copy nested classes also? *)
	(* TODO: copy new metadata *)
	newMethods do: [:ea <IntermediateMethod> | (* insert modified or new instance methods into mixin *)
		| jsName <String> |
		jsName:: compilation names manglePublic: ea name.
		js assign: (js propertyOf: oldRuntimeMixin at: jsName) toBe: (js propertyOf: newRuntimeMixin at: jsName).
	].
	{#name. #header. #slots. #methods. #nestedClasses} do: [:jsName |
		js assign: (js propertyOf: oldRuntimeMixin at: jsName) toBe: (js propertyOf: newRuntimeMixin at: jsName).
	].
)
updateMetaMixin: oldRuntimeMetamixin <MJRM> from: newRuntimeMetamixin <MJRM> by: classDeclIR <IntermediateClassDeclaration> ^  <List[Symbol]> = (
	| newMethods <List[IntermediateMethod]> = classDeclIR classSide methods. |

	(* TODO: handle deletes *)
	deletedClassMethods:: List new.
	(* TODO: copy nested classes also? *)
	(* TODO: copy new metadata *)
	newMethods do: [:ea <IntermediateMethod> | (* insert modified or new class methods into mixin *)
		| jsName <String> |
		jsName:: compilation names manglePublic: ea name.
		js assign: (js propertyOf: oldRuntimeMetamixin at: jsName) toBe: (js propertyOf: newRuntimeMetamixin at: jsName).
	].
	{#slots. #methods. #nestedClasses} do: [:jsName <Symbol>  |
		js assign: (js propertyOf: oldRuntimeMetamixin at: jsName) toBe: (js propertyOf: newRuntimeMetamixin at: jsName).
	].
)
updateMixin: oldMixin <Mixin> from: newRuntimeMixin <JRM> by: classDeclIR <IntermediateClassDeclaration> = (
	|
	deletedInstanceMethods <List[Symbol]> 
	deletedClassMethods <List[Symbol]>
	oldRuntimeMixin <JRM> = js propertyOf: oldMixin at: (js literal: 'runtimeMixin').
	oldRuntimeMetamixin <MJRM> = js propertyOf: oldRuntimeMixin at: (js literal: 'meta').
	newRuntimeMetamixin <MJRM> = js propertyOf: newRuntimeMixin at: (js literal: 'meta').
	|
	(* TODO: handle deletes *)
	(* TODO: copy nested classes also? *)
	(* TODO: copy new metadata *)
      deletedInstanceMethods:: updateInstanceMixin: oldRuntimeMixin from: newRuntimeMixin  by: classDeclIR.
      deletedClassMethods:: updateMetaMixin: oldRuntimeMetamixin from: newRuntimeMetamixin by: classDeclIR.
      updateApplicationsOf: oldRuntimeMixin from: newRuntimeMixin by: classDeclIR.
)
updateMixinFrom: runtimeMixin <JRM> = (
  |
  instanceMethodSourceIndices <Map[String, Integer]> = Map new.
  classMethodSourceIndices <Map[String, Integer]> = Map new.
  runtimeMetamixin <MJRM> = js propertyOf: runtimeMixin at: (js literal: 'meta').
  existingMixin <JRM> = js propertyOf: prvtExistingMixin at: (js literal: 'runtimeMixin').
  existingMetamixin <MJRM> = js propertyOf: existingMixin at: (js literal: 'meta').
  newSourceIndex <Integer> ::= js propertyOf: (js ident: 'sources') at: (js literal: 'length').
  | 
(* TODO: Also update source indices for header. *)
(* TODO: update access modifiers if they have changed? *)
       (* collect existing mixin's source indices into a map keyed by name *)
      (js propertyOf: existingMixin at: (js literal: 'methods'))  do: [:ea <MM> | 
	   instanceMethodSourceIndices at: (js propertyOf: ea at: (js literal: 'name')) put: (js propertyOf: ea at: (js literal: 'source'))
	].
      (js propertyOf: existingMetamixin at: (js literal: 'methods')) do: [:ea <MM> | 
	  classMethodSourceIndices at: (js propertyOf: ea at: (js literal: 'name')) put: (js propertyOf: ea at: (js literal: 'source'))
	].
      (* Augment maps of source indices with entries for any new methods *)
      (js propertyOf: runtimeMixin at: (js literal: 'methods')) do:
		[:e <MM> | | selector |
		   selector:: (js propertyOf: e at: (js literal: 'name')).
		   instanceMethodSourceIndices at: selector ifAbsent: [instanceMethodSourceIndices at: selector put: newSourceIndex].
		   newSourceIndex:: newSourceIndex + 1.
		 ]. 
	(js propertyOf: runtimeMetamixin at: (js literal: 'methods')) do:
		[:e <MM> | | selector |
		   selector:: (js propertyOf: e at: (js literal: 'name')).
		   classMethodSourceIndices at: selector ifAbsent: [classMethodSourceIndices at: selector put: newSourceIndex].
	         newSourceIndex:: newSourceIndex + 1.
		 ].

	  (* Update global sources array with any changed or new source code *)
	instanceSide methods do: [:m <MethodBuilder> | | sourceIndex <Integer> |
		  sourceIndex:: instanceMethodSourceIndices at:  m name.
		  m source ~= nil ifTrue: [js assign: (js propertyOf: (js ident: 'sources') at: sourceIndex) toBe: m source].
		].
	classSide methods do: [:m <MethodBuilder> | | sourceIndex <Integer> |
		  sourceIndex:: classMethodSourceIndices at: m name.
		  m source ~= nil ifTrue: [js assign: (js propertyOf: (js ident: 'sources') at: sourceIndex) toBe: m source].
		].
	  (* Ensure new runtime structure has correct source indices in its metadata*)
	  (* what about the name itself? And the access modifier *)
	(js propertyOf: runtimeMixin at: (js literal: 'methods')) do: [:mm <MM> | 
			js assign: (js propertyOf: mm at: (js literal: 'source')) 
			    toBe: (instanceMethodSourceIndices at: (js propertyOf: mm at: (js literal: 'name'))).
	].
	(js propertyOf: runtimeMetamixin at: (js literal: 'methods')) do: [:mm <MM> | 
		    js assign: (js propertyOf: mm at: (js literal: 'source')) 
		       toBe: (classMethodSourceIndices at: (js propertyOf: mm at: (js literal: 'name'))).
		].
		  (* Update class header source index *)
	js assign: (js propertyOf:  runtimeMixin at: (js literal: 'header')) toBe: (js propertyOf: existingMixin at: (js literal: 'header')).

      (* Update the  existing runtime based on the new one *)
	updateMixin: prvtExistingMixin from: runtimeMixin by: prvtClassDeclIR
)
) : (
public fromSource: src <String> ^<ClassDeclarationBuilder> = (
	^self fromUnitSource: 'Newspeak3 ''Uncategorized'' ', src
)
public fromUnitSource: src <String> ^<ClassDeclarationBuilder> = (
	^self fromIR: (compiler compileClassSource:  src within: nil) forExistingMixin: nil within: nil)
public reflecting: mixin <InstanceMixin> ^<ClassDeclarationBuilder> = (
	| m = ClassDeclarationMirror reflecting: mixin. |
	nil = m enclosingClass ifFalse: 
		[^m enclosingClass asBuilder instanceSide nestedClasses findMirrorNamed: m simpleName].
	
	^self
		fromIR: (classDeclIRFor: mixin within: nil)
		forExistingMixin: mixin
		within: nil
)
)
class ClassDeclarationMirror reflecting: mixin = (|
	private reflectee = mixin.
	public instanceSide <MixinMirror> = MixinMirror reflecting: mixin.
	public classSide <MixinMirror> = 
	   MixinMirror reflecting: 
	      (Mixin fromRuntimeMixin: (js propertyOf: (js propertyOf: mixin at: (js literal: 'runtimeMixin')) at: (js literal: 'meta'))).
	public accessModifier <Symbol> = #public. (*BOGUS*)
|) (
public asBuilder ^<ClassDeclarationBuilder> = (
	^ClassDeclarationBuilder reflecting: reflectee
)
public canUnderstand: selector <Symbol> ^ <Boolean> = (
	^instanceSide canUnderstand: selector (* BOGUS? *)
)
public enclosingClass ^ <ClassDeclarationMirror> = (
	| enclosing <Class> |
	enclosing:: (js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'enclosingMixin')). 
	(js operator: '===' with: enclosing and: (js ident: 'undefined')) ifTrue: [^nil].
	^ClassDeclarationMirror reflecting: (Mixin fromRuntimeMixin: enclosing)
)
public header ^<ClassHeaderMirror> = (
	^ClassHeaderMirror reflecting: reflectee
)
public name = (
	^(reflectee name splitBy: '`') last
)
public qualifiedName = (
	#BOGUS. (* Remove when currentMixinUID uses a proper token. *)
	^reflectee name
)
public simpleName = (
	^name
)
public source ^<String> = (
	| sb = StringBuilder new. |
	sb add: header source.
	sb writeln: ' ( '.
	instanceSide nestedClasses do: [:ea | sb writeln: ea source].
	instanceSide methods do: [:ea | sb writeln: ea source].
	sb writeln: ' ) : ( '.
	classSide methods do: [:ea | sb writeln: ea source].
	sb writeln: ' )'.
	^sb asString
)
) : (
)
class ClassHeaderMirror reflecting: mixin = (|
	private reflectee <Mixin> = mixin.
|) (
public classComment ^ <String> = (
	^(compilation parser classHeader parseString: source) classComment
)
public source ^<String> = (
	| sourceIndex = js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'header'). |
	^js propertyOf: (js ident: 'sources') at: sourceIndex.
)
) : (
)
public class ClassMirror reflecting: r <Class> = (|
public reflectee <Class> = r.
|) (
public allSuperclasses ^ <List[ClassMirror]> = (
	| klass <Class> superclasses <List[Class]> |
	superclasses:: List new.
	klass:: superclass.
	[klass isNil] whileFalse:[
		superclasses add: klass.
		klass:: klass superclass.
	].
	^superclasses
)
private computeMirrorGroup: mgAccessor <[:MixinMirror | MirrorGroup]> ^ <List[Mirror]> = (
(* Return a mirror group based on the mixins group and those of all superclasses. The argument mgAccessor extracts a mirror group from any mirror provided to it. *)
	| mg <MirrorGroup>  |
	mg:: List new.
	(allSuperclasses reverse add: self; yourself)
		do:[:klass <ClassMirror> | mg addAll: (mgAccessor value: klass mixin)].
	^ mg	
)
public enclosingObject ^<ObjectMirror> = (
	^ObjectMirror reflecting: reflectee enclosingObject
)
public methods ^ <MirrorGroup[MethodMirror]> = (
	^computeMirrorGroup: [:r | r methods]
)
public mixin ^ <MixinMirror> = (
	^MixinMirror reflecting: reflectee mixin
)
public name = (
	^reflectee name
)
public nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (
	^computeMirrorGroup: [:r | r nestedClasses]
)
public simpleName = (
	^(reflectee name splitBy: '`') last
)
public slots ^ <MirrorGroup[SlotMirror]> = (
	^computeMirrorGroup: [:r | r slots].
)
public superclass ^ <ClassMirror> = (
	reflectee superclass isNil ifTrue:[^nil].
	^ClassMirror reflecting: reflectee superclass
)
) : (
)
class MethodBuilder reflecting: mir in: mb source: s = (| 
reflecteeX <IntermediateMethod> = mir. 
definingMixinX <MixinBuilder> = mb. 
public source <String> = s.
|) (
public accessModifier = (
	^reflecteeX accessModifier
)
public definingMixin ^ <MixinBuilder> = (
	^definingMixinX
)
public name ^<Symbol> = (
	^reflecteeX name
)
public simpleName ^<Symbol> = (
	^reflecteeX name
)
) : (
)
class MethodMirror named: n in: dm source: s = (|
	public name <Symbol> = n.
	public definingMixin <MixinMirror> = dm.
	private sourceIndex <Integer> = s.
|) (
public accessModifier = (
(* Ths won't work for slots and classes it seems. So should we set this up explicitly and store the access? If we had the mangled name we could use that to decided; might be easier to keep mangled name and unmangle it on demand *)
	(source startsWith: 'public ') ifTrue: [^#public].
	(source startsWith: 'private ') ifTrue: [^#private].
	^#protected
)
public simpleName ^<Symbol> = (
	^name
)
public source ^<String> = (
	^js propertyOf: (js ident: 'sources') at: sourceIndex.
)
) : (
)
class MixinBuilder forClassDeclaration: cdb ir: ir em: em = (|
mixinIR <IntermediateMixin> = ir.
public declaration <ClassDeclarationBuilder> = cdb.
public isMeta <Boolean> = ir isMeta.
public slots = ir slots collect: [:ea | SlotDeclarationMirror named: ea name].
public methods <MutableMethodGroup> = MutableMethodGroup group: ((ir methods reject: [:ea | ea isSynthetic]) collect: [:ea | MethodBuilder reflecting: ea in: self source: ea source]) within: self ir: ir.
public nestedClasses <MutableNestedClassGroup> = 
   MutableNestedClassGroup group: (ir nestedClasses collect: [:ea <IntermediateClassDeclaration> | ClassDeclarationBuilder fromIR: ea forExistingMixin: (find: ea qualifiedName in: em) within: cdb]) within: self ir: ir.
|) (
public canUnderstand: selector <Symbol> ^ <Boolean> = (
	^methods includesMirrorNamed: selector
)
find: name in: existingMixin = (
	^Mixin fromRuntimeMixin: 
		(js propertyOf: 
			(js propertyOf: existingMixin at: (js literal: 'runtimeMixin')) at: (compilation names manglePublic: name))
)
public isKindOfMixinMirror ^<Boolean> = (
	^true
)
) : (
public reflecting: mxn <Mixin | ClassMixin> ^<MixinBuilder> = (
	^mxn isMeta
		ifTrue: [(ClassDeclarationBuilder reflecting: (MixinMirror reflecting: mxn) declaration instanceSide reflectee) classSide]
		ifFalse: [(ClassDeclarationBuilder reflecting: mxn) instanceSide]
)
)
class MixinMirror reflecting: mixin <Mixin> = (|
	private reflectee <Mixin> = mixin.
|) (
public apply: newSuperclass <Class> withName: n <Symbol>= (
	^ClassMirror reflecting: (reflectee applyTo: newSuperclass withName: n)
)
public asBuilder ^<MixinBuilder> = (
	^isMeta 
		ifTrue: [declaration asBuilder classSide]
		ifFalse: [declaration asBuilder instanceSide]
)
public canUnderstand: selector <Symbol> ^ <Boolean> = (
	^methods includesMirrorNamed: selector
)
public declaration ^<ClassDeclarationMirror> = (
	^ClassDeclarationMirror 
		reflecting: (isMeta 
			ifFalse: [reflectee]
			ifTrue: [(Mixin fromRuntimeMixin: (js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'nonMeta')))])
)
public isKindOfMixinMirror ^<Boolean> = (
	^true
)
public isMeta ^<Boolean> = (
	^reflectee isMeta
)
public methods ^<MirrorGroup[MethodMirror]> = (
	| raw <Array[MethodMirror]> |
	raw:: ((js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'methods'))
		select: [:each | (js propertyOf: each at: (js literal: 'isSynthetic')) not])
		collect: [:each | MethodMirror named: (js propertyOf: each at: (js literal: 'name')) in: self source: (js propertyOf: each at: (js literal: 'source'))].
	^ImmutableMirrorGroup group: raw
)
public nestedClasses ^<MirrorGroup[ClassDeclarationMirror]> = (
	| raw <Array[ClassDeclarationMirror]> |
	raw:: (js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'nestedClasses'))
		collect: [:each | ClassDeclarationMirror reflecting: 
			(Mixin fromRuntimeMixin:
				(js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (vmmirror mangleSelector: each)))].
	^ImmutableMirrorGroup group: raw
)
public slots ^<MirrorGroup[SlotDeclarationMirror]> = (
	| raw <Array[SlotDeclarationMirror]> |
	raw:: ((js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'slots'))
		select: [:each | (js propertyOf: each at: (js literal: 'isSynthetic')) not])
		collect: [:each | SlotDeclarationMirror named: (js propertyOf: each at: (js literal: 'name'))].
	^ImmutableMirrorGroup group: raw
)
) : (
)
class MutableMethodGroup group: ms <List[Mirror]> 
  within: mb <MixinBuilder> 
  ir: ir <IntermediateMixin> = MutableMirrorGroup group: ms within: mb ir: ir () (
public addFromSource: s <String> ^ <MethodBuilder> = (
	| 
	result <IntermediateMethod>
	newM <MethodBuilder>
	sourceIndex <Integer>
	|
	result:: compiler
		compileMethodSource: s
		within: enclosingMixin.

	(* TODO: check for name conflicts *)
	
	newM:: MethodBuilder reflecting: result in: enclosingMixin source: s.
      removeMirrorNamed: result name. 
	mixinIR methods add: result.
	addMirror: newM.
	^newM
)
public removeMirrorNamed: m <Symbol | String>^ <Mirror> = (
	| 	oldMirror <MethodMirror> |
	oldMirror:: super removeMirrorNamed: m.
	oldMirror isNil 
	  ifFalse: [ (* we are removing an existing method *)
		mixinIR methods removeAllSuchThat: [:ea  <IntermediateMethod> | ea name = m].
	      ]. 
     ^oldMirror
)
) : (
)
class MutableMirrorGroup group: ms <List[Mirror]> within: mb ir: ir = ImmutableMirrorGroup group: ms (|
public enclosingMixin <MixinBuilder> = mb.
protected mixinIR <IntermediateMixin> = ir.
|) (
addMirror: m <Mirror>  ^ <Mirror> = (
	mirrors keysAndValuesDo: [:index <Integer> :mirror <Mirror> | 
		mirror simpleName = m simpleName ifTrue: [^mirrors at: index put: m]].
	^mirrors addLast: m
)
public removeMirrorNamed: m <Symbol | String>^ <Mirror> = (
	mirrors keysAndValuesDo: [:index :mirror | 
		mirror simpleName = m  ifTrue: [^mirrors remove: mirror]].
	^nil	
)
) : (
)
class MutableNestedClassGroup group: ms within: mb ir: ir = MutableMirrorGroup group: ms within: mb ir: ir () (
) : (
)
public class ObjectMirror reflecting: r = (|
	public reflectee = r.
|) (
public evaluate: expression <String>
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (
	|
	compiler
	ir
	dnuHandlers
	writer
	sb
	src
	func
	result
	|
	[compiler:: compilation Compiler new.
	ir:: compiler
			compileExpressionSource: expression
			inMixin: getClass mixin.
	dnuHandlers:: compiler dnuHandlers.
	
	writer:: generation Writer new.
	sb:: StringBuilder new.
	writer generateSourceFor: dnuHandlers on: sb.
	src:: sb asString.
	func:: js call: (js ident: 'eval') with: {'(',src, ')'}.
	js call: func with: {js verbatim: 'Object.prototype'}.
	
	writer:: generation Writer new.
	sb:: StringBuilder new.
	writer generateSourceFor: ir function on: sb.
	src:: sb asString.
	src out.
	func:: js call: (js ident: 'eval') with: {'(',src, ')'}.
	] on: Error do: [:e | ^compilationErrorHandler value: e].
	[result:: js call: (js propertyOf: func at: (js literal: 'call')) with: {reflectee}.]
		on: Error do: [:e | ^evalErrorHandler value: e].
	^ObjectMirror reflecting: result
)
public getClass = (
	#BOGUS. (* Wrong for bilingual objects. *)
	^ClassMirror reflecting:
		(js propertyOf: reflectee at: (js literal: 'newspeakClass')).
)
public getSlot: selector = (
	|
	mangledName = vmmirror mangleSelector: selector, '`slot'.
	raw = js propertyOf: reflectee at: mangledName.
	|
	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [halt].
	^ObjectMirror reflecting: raw
)
public setSlot: selector to: value = (
	|
	mangledName = vmmirror mangleSelector: selector, '`slot'.
	raw = js propertyOf: reflectee at: mangledName.
	|
	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [^halt].
	js assign: (js propertyOf: reflectee at: mangledName) toBe: value.
)
) : (
)
class SlotDeclarationMirror named: n = (|
	public name <Symbol> = n.
	public accessModifier <Symbol> = #public. (*BOGUS*)
|) (
) : (
)
classDeclIRFor: mixin within: enclosing = (
	| source = 'Newspeak3 ''Uncategorized'' ', (ClassDeclarationMirror reflecting: mixin) source. |
	(*('compiling class:', source) out.*)
	^compiler compileClassSource: source within: enclosing
)
sourceForMethod: methodName <String> ofMixin: m <Mixin> ^ <String> = (
   | js = generation factory. sourceIndex <Integer> |
	sourceIndex:: sourceIndexForMethod: methodName ofMixin: m.
	^js propertyOf: (js ident: 'sources') at: sourceIndex.
)
sourceIndexForMethod: methodName <String> ofMixin: m <Mixin> ^ <Integer> = (
   | js = generation factory. methodMetadata |
	methodMetadata:: (js propertyOf: m at: (js literal: 'methods')) select:[:e | (js propertyOf: e at: 'name') = methodName].
	^js propertyOf: methodMetadata at: 'source'.  (* compute the source index from the metadata *)
)
) : (
)
