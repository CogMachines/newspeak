Newspeak3
'Mirrors'
class ActivationMirrors usingPlatform: platform <Platform> = (
(* Mirrors for method activations and processes.

Copyright (c) 2009 Peter von der Ahe
Copyright (c) 2011 Gilad Bracha, Ryan Macnak and Cadence Design Systems
Copyright (c) 2012 Cadence Design Systems

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
''Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. *)|
	OutOfScopeNotification = platform blackMarket OutOfScopeNotification.
	SyntaxErrorNotification = platform blackMarket SyntaxErrorNotification.
	Project = platform blackMarket Project.
	DebuggerMethodMap = platform blackMarket DebuggerMethodMap.

	mirrors = platform mirrors.
	ObjectMirror = mirrors ObjectMirror.
	MixinBuilder = mirrors MixinBuilder.
	MixinMirror = mirrors MixinMirror.
	MethodMirror = mirrors MethodMirror.
	activationMirrors = self.
|)
(
class ActivationMirror onContext: ctxt <ContextPart> = (|
	protected context_slot = ctxt.
	protected sender_slot
	protected home_slot
	protected sourceMap_slot
	protected methodNode_slot
	protected localNames_slot
	protected definingClass_slot
	protected methodMirror_slot
|)
('as yet unclassified'
activationsDo: action <[:ActivationMirror]> = (
	| currentMirror |
	currentMirror:: self.
	[currentMirror isNil] whileFalse:
		[action value: currentMirror.
		currentMirror:: currentMirror sender]
)
activationsUpTo: activation <ActivationMirror> = (
	(* Answer an Array of activations up to, but not including, activationOrNil *)
	^Array streamContents:
		[:s | | current |
		current:: self.
		[s nextPut: current.
		 activation isSenderOf: current] whileFalse:
			[current:: current sender]]
)
compile: newSource ifFail: onFail ^ <NS2MethodMirror> = (
	self subclassResponsibility.
)
definingClass  ^ <Class> = (
	warnObsolete.
	definingClass_slot ifNil:
		[definingClass_slot:: home ifNotNil:
			[:it |
			self == it
				ifTrue: [definingClassOf: homeMethod methodClass]
				ifFalse: [it definingClass]]].
	^definingClass_slot
)
definingClassOf: clsOrNil = (
	warnObsolete.
	^clsOrNil ifNotNil: [:cls| cls mixin definingClass]
)
errorReportOn: stream = (
	context_slot errorReportOn: stream
)
evaluate: expression <String> 
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (
	subclassResponsibility
)
evaluate: expression <String> 
withBlackMarket: blackMarket <Object> 
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (
	(* Most languages don't need extra blackMarket during debugging *)
	^self evaluate: expression
	ifCompilerError: compilationErrorHandler
	ifError: evalErrorHandler
)
hasActivation: activation <ActivationMirror> ^ <Boolean> = (
	^context_slot hasSender: activation context_slot
)
public home ^<ActivationMirror> = (
	^isBlockActivation
		ifTrue:
			[home_slot ifNil:
				[context_slot home ifNotNil:
					[:it | home_slot:: class onContext: it]].
			home_slot]
		ifFalse:
			[self]
)
homeInThread ^ <ActivationMirror> = (
	isBlockActivation ifFalse: [^self].
	home ifNotNil:
		[:homeMirror <ActivationMirror>  |
		(hasActivation: homeMirror) ifTrue:
			[activationsDo:
				[:each <ActivationMirror> |
				each context_slot == homeMirror context_slot ifTrue: [^each]]]].
	^nil
)
homeMethod ^ <CompiledMethod> = (
	^home ifNotNil:
		[:it |
		self == it
			ifTrue: [context_slot method]
			ifFalse: [it homeMethod]]
)
public isBlockActivation ^<Boolean> = (
	^context_slot closure notNil
)
isMessageNotUnderstood  ^ <Boolean> = (
	warnObsolete.
	^context_slot selector = #doesNotUnderstand:
)
isSenderOf: activation <ActivationMirror> ^ <Boolean> = (
	^(self == activation sender_slot)
		or: [context_slot == activation context_slot sender]
)
localNames ^ <List[String]>= (
  subclassResponsibility
)
localNamesWithValuesDo: action <[:String :ObjectMirror]> = (
	localNames doWithIndex:
		[:localName :i |
		action
			value: localName
			value: (ObjectMirror reflecting: ([home context_slot at: i] ifError: ['<error getting value>']))]
)
localVariableValueMirror: name <String> = (
	| index |
	index:: localNames indexOf: name.
	^ObjectMirror reflecting: ([home context_slot at: index] ifError: ['<error getting value>'])
)
public method ^<MethodMirror> = (
	methodMirror_slot ifNil:[methodMirror_slot:: MethodMirror reflecting: homeMethod].
	^methodMirror_slot
)
methodNode ^ <MethodNode> = (
	methodNode_slot ifNil:
		[methodNode_slot:: homeMethod ifNotNil: [:it | it methodNode]].
	^methodNode_slot
)
notUnderstoodArguments = (
	^(context_slot tempAt: 1) arguments
)
notUnderstoodMessage ^ <Symbol> = (
	^(context_slot tempAt: 1) selector
)
pc = (
	^context_slot pc
)
pcForHighlightingIn: thread <ThreadMirror> ^ <Integer|nil> = (
	(* The pc to use for highlighting depends on whther the context is the active (top) contex or not.
	The top context's pc is its effective pc.  But other contexts' pcs are those following a send,
	since they are suspended after a send.  Hence their highlighting pc is the pc	 previous to the current pc. *)
	^context_slot pc ifNotNil:
		[:ctxtpc |
		(thread isActiveContext: context_slot)	
			ifTrue: [ctxtpc]	
			ifFalse: [context_slot method pcPreviousTo: ctxtpc]]
)
pcRangeIn: thread <ThreadMirror> ^ <Interval> = (
	| pcForHighlighting <Integer>  i <Integer>  end <Integer> |
	pcForHighlighting:: pcForHighlightingIn: thread.
	(methodNode isNil
		or: [sourceMap isNil
		or: [sourceMap isEmpty
		or: [pcForHighlighting isNil]]]) ifTrue:
			[^1 to: 0].
	i:: sourceMap indexFor: pcForHighlighting -> nil.
	i < 1 ifTrue: [^1 to: 0].
	i > sourceMap size ifTrue:	
		[end:: sourceMap inject: 0 into:			
			[:acc :each | acc max: each value last].
		^end + 1 to: end].
	^(sourceMap at: i) value
)
printOn: s = (
	isBlockActivation
		ifTrue:
			[home ifNotNil:
				[:it |
				s nextPutAll: '[] in '.
				it printOn: s.
				^self].
			s nextPutAll: '<<Orphaned block>>']
		ifFalse:
			[homeMethod ifNotNil:
				[:it | | receiverMixin methodMixin |
				receiverMixin:: (receiver getClassIfFail: [halt]) mixin.
				s nextPutAll: receiverMixin simpleName.
				methodMixin:: method definingMixin.
				(receiverMixin = methodMixin)
					ifFalse:
						[s nextPut: "(".
						s nextPutAll: methodMixin simpleName.
						s nextPut: ")"].
				s space.
				s nextPutAll: (it selector ifNil: [it defaultSelector]).
				isMessageNotUnderstood ifTrue:
					[s space.
					notUnderstoodMessage printOn: s].
				^self].
			s nextPutAll: '<<Anonymous method>>']
)
proposedMissingClassSource ^ <String> = (
	| message  |
	isMessageNotUnderstood ifFalse: [^''].
	message:: notUnderstoodMessage.
	assert:[message isUnary] message: 'Cannot define non-unary class accessor'.
	assert:[(receiver getClassIfFail: [halt]) reflectee language isNewspeakLanguage3] message: 'Only Newspeak code can have nested classes'.

	^'class ', message asString, ' = ()( )'
)
proposedMissingMessageSource ^ <String> = (
	| message args |
	isMessageNotUnderstood ifFalse: [^''].
	message:: notUnderstoodMessage.
	args:: notUnderstoodArguments.
	message isUnary
		ifTrue: [message:: message, ' ']
		ifFalse:
			[message:: String streamContents:
				[:s |
				message keywords withIndexDo:
					[:each :i |
					s nextPutAll: each.
					s space.
					s nextPutAll: 'argument'.
					s nextPutAll: i asString.
					s space.
					s nextPut: "<".
					putInferredTypeOf: (args at: i) on: s.
					s nextPut: ">".
					s space]]].

	^method definingMixin reflectee definingClass language isNewspeakLanguage3
		ifTrue: [message asString, '= (\	halt\)' withCRs]
		ifFalse: [message asString]
)
putInferredTypeOf: arg on: s <Stream> = (
	arg isBehavior ifTrue: [^s nextPutAll: 'Class'].
	arg isBlock ifTrue:
		[s nextPut: "[".
		(1 to: arg argumentCount)
			do: [:ignored | s nextPutAll: '_, '].
		s space.
		^s nextPutAll: '^_]'].
	s nextPutAll: (definingClassOf: arg class) simpleName
)
public receiver ^<ObjectMirror> = (
	^ObjectMirror reflecting: context_slot receiver
)
refresh = (
	sender_slot ifNotNil:
		[:it |
		it context_slot == context_slot sender
			ifFalse: [sender_slot:: nil]].
	home_slot:: nil.
	sourceMap_slot:: nil.
	methodNode_slot:: nil.
	localNames_slot:: nil.
)
public sender ^<ActivationMirror> = (
	sender_slot ifNil:
		[context_slot sender ifNotNil:
			[:it | sender_slot:: (ActivationMirror reflecting: it)]].
	^sender_slot
)
setLocalVariable: variableName <String> to: exprString <String> ifFail: onFail <[:String]> ^<Object> = (
	| index newValue <ObjectMirror> |
	#BOGUS. (* Should take an ObjectMirror for the new value and call should choose with version of evaluate. *)
	index:: localNames indexOf: variableName ifAbsent:
		[variableName asInteger asString = variableName asString
			ifTrue: [variableName asInteger + localNames size]].
	(index isNil or: [index < 1 or: [index > stackDepth]])
		ifTrue: [^onFail valueWithPossibleArgument: 'Not found: ', variableName].
	newValue:: self
		evaluate: exprString
		ifCompilerError: [:e | ^onFail cull: e description]
		ifError: [:e | ^onFail cull: e description].
	home context_slot at: index put: newValue reflectee.
)
setLocalVariable: variableName <String> toValue: newValue  ifFail: onFail <[:String]> ^<Object> = (
	| index  |
	index:: localNames indexOf: variableName ifAbsent:
		[variableName asInteger asString = variableName asString
			ifTrue: [variableName asInteger + localNames size]].
	(index isNil or: [index < 1 or: [index > stackDepth]])
		ifTrue: [^onFail valueWithPossibleArgument: 'Not found: ', variableName].
	home context_slot at: index put: newValue.
)
sourceAvailable = (
	^(homeMethod properties includesKey: #source) 
	      or:[(homeMethod properties includesKey: #isSubinitializer)
		or: [homeMethod isSynthetic not]]
)
sourceMap ^ <SortedList[Association[Integer, Interval]]>= (
  subclassResponsibility
)
stackDepth ^ <Integer> = (
	isBlockActivation ifTrue: [^context_slot size].
	^home context_slot size
)
stackIndicesWithValuesDo: action <[:Integer :ObjectMirror]> = (

	| tempFrameSize |
(*	receiverClass language isNewspeakLanguage3 ifTrue: [
		#BOGUS yourself.
		tempFrameSize:: 0.	
	] ifFalse: [ *)
		tempFrameSize: localNames size.
	(* ]. *)

	stackDepth to: tempFrameSize + 1 by: -1 do:
		[:i |
		action
			value: i - localNames size
			value: (ObjectMirror reflecting: (context_slot at: i))]
)'private'
relateTo: activation <ActivationMirror> = (
	(* Called by a thread mirror after the stack has changed as a consequence of executing or simulating instructions.

This activation represents the new stack top aka. current activation. *)
	| current |

	(activation isSenderOf: self)
		ifTrue: [sender_slot: activation refresh. ^self].

	(* Activation represent a sender further up the stack. *)
	(hasActivation: activation)
		ifTrue: [sender relateTo: activation refresh. ^self].

	(* See if self represents an activation further up the stack from activation and use existing mirror. *)
	current:: activation.
	[current context_slot == context_slot ifTrue: [^current refresh].
	current sender_slot isNil]
		whileFalse: [current:: current sender_slot].

	activation refresh.
)) : ('as yet unclassified'
public reflecting: c <ContexPart> ^ <Instance> = (

	^c methodClass language activationMirrorFor: c using: activationMirrors
))
class ActivationMirrorCompiledByNewspeak onContext: c <ContextPart> = ActivationMirror onContext: c (
(* A mirror on activations whose code was produced by the Newspeak compiler (NS3 and above). *)|
	private debugInfo_slot
	private debugMapper_slot
|assert: [c isMethodContext]
	message: 'NS3+ does not generate BlockContext blocks, so it should always have MethodContext activations')
('as yet unclassified'
compile: newSource ifFail: onFail ^ <NS2MethodMirror> = (
	| builder newSelector declMirror mixinMirror |

	builder:: MixinBuilder reflecting: method definingMixin reflectee.
	newSelector:: (builder methods addFromSource: newSource) simpleName.
	declMirror:: builder declaration install.

	mixinMirror:: builder isMeta
		ifTrue: [declMirror classSide]
		ifFalse: [declMirror instanceSide].	

	^mixinMirror methods findMirrorNamed: newSelector.
)
debugInfo ^<DebugInfo> = (
	debugInfo_slot ifNil: [
		| llmm <LowLevelMethodMirror> |
		(homeMethod properties includesKey: #debugInfo)
			ifTrue: [^debugInfo_slot:: homeMethod properties at: #debugInfo].
		llmm:: mirrors compiler
			compileMethodSource: method source readStream within: method definingMixin.
		debugInfo_slot:: llmm debugInfo.
	].
	^debugInfo_slot
)
debugMapper = (
	debugMapper_slot ifNil: [
		debugMapper_slot:: debugInfo mapperForContext: context_slot
	].
	^debugMapper_slot
)
evaluate: expression <String> 
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (

	(* Evaluate [expression] with the reflectee as the receiver. Names in scope in the current activation will be available, with the exception that from a closure activation any setters for temporaries not written to in that closure will only update the value seen in that closure, not all enclosing contexts where that temporary is in scope. If [expression] cannot be compiled, activate [compilationErrorHandler] with the exception. If the evaluation of [expression] raises an error, activate [evalErrorHandler] with the error. Otherwise return an ObjectMirror on the result of [expression]. *)
	| mxnMirror mtdMirror result |
	[mxnMirror:: method definingMixin. (* Super, outer and implicit receiver sends should behave like the expression is in the method class, not the receiver class. *)
	mtdMirror:: mirrors compiler
		compileExpressionSource: expression readStream
		inContext: context_slot
		inMixin: mxnMirror. 
		
	mtdMirror metadata at: #category put: 'DoIts'.
	mtdMirror klass: mxnMirror reflectee.
	mtdMirror compiledMethod properties
		at: #source put: expression;
		at: #debugInfo put: mtdMirror debugInfo]
			on: Error
			do: [:e | ^compilationErrorHandler cull: e ].
		
	[result:: mirrors vmmirror 
		object: context_slot receiver
		executeMethod: mtdMirror compiledMethod
		with: {context_slot}
		ifFail: [ ^compilationErrorHandler cull: (Error description: 'primitiveExecuteMethod failed') ]]
			on: Error
			do: [:e | ^evalErrorHandler cull: e].

	^mirrors ObjectMirror reflecting: result
)
evaluate: expression <String> 
withBlackMarket: blackMarket <Object> 
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (

	(* Evaluate [expression] with the reflectee as the receiver. Names in scope in the current activation will be available, with the exception that from a closure activation any setters for temporaries not written to in that closure will only update the value seen in that closure, not all enclosing contexts where that temporary is in scope. Allow [`] as an identifier, bound to [blackMarket]. If [expression] cannot be compiled, activate [compilationErrorHandler] with the exception. If the evaluation of [expression] raises an error, activate [evalErrorHandler] with the error. Otherwise return an ObjectMirror on the result of [expression]. *)

	| mxnMirror mtdMirror result |
	[mxnMirror:: method definingMixin. (* Super, outer and implicit receiver sends should behave like the expression is in the method class, not the receiver class. *)
	mtdMirror:: mirrors compiler
		compileExpressionSource: expression readStream
		inContext: context_slot
		inMixin: mxnMirror
		allowBlackMarket: true. 
		
	mtdMirror metadata at: #category put: 'DoIts'.
	mtdMirror klass: mxnMirror reflectee.
	mtdMirror compiledMethod properties
		at: #source put: expression;
		at: #debugInfo put: mtdMirror debugInfo]
			on: Error
			do: [:e | ^compilationErrorHandler cull: e ].
		
	[result:: mirrors vmmirror 
		object: context_slot receiver
		executeMethod: mtdMirror compiledMethod
		with: {context_slot. blackMarket}
		ifFail: [ ^compilationErrorHandler cull: (Error description: 'primitiveExecuteMethod failed') ]]
			on: Error
			do: [:e | ^evalErrorHandler cull: e].

	^mirrors ObjectMirror reflecting: result
)
isInitializer ^ <Boolean> = (
	^method isInitializer
)
localNames ^ <List[String]>= (

	sourceAvailable ifFalse: [^{}].

	localNames_slot ifNil: [
		localNames_slot:: debugMapper localNames 
	].
	^localNames_slot
)
localNamesWithIndicesDo: action <[:String :Integer]> = (
	localNames doWithIndex: [:localName :index | action value: localName value: index].
)
localNamesWithValuesDo: action <[:String :ObjectMirror]> = (

	localNames do: [:ea | action value: ea value: 
		(ObjectMirror reflecting: ([debugMapper getValueOf: ea] 
			ifError: ['<error getting value>']))].
)
localVariableValueMirror: name <String> = (
	^ObjectMirror reflecting: (debugMapper getValueOf: name)
)
localVariableValueMirrorForIndex: desiredIndex <Number> = (
	localNames doWithIndex: 
		[:localName :index |
		index = desiredIndex ifTrue: 
			[^ObjectMirror reflecting: (debugMapper getValueOf: localName)]]
)
pcRangeIn: thread <ThreadMirror> ^ <Interval> = (
	sourceAvailable ifFalse: [^1 to: 0].
	^debugInfo sourceMapping at: (pcForHighlightingIn: thread) ifAbsent: [1 to: 0].
)
source = (
	warnObsolete.
	^sourceAvailable
		ifTrue: [(MethodMirror reflecting: homeMethod) source]
		ifFalse: ['No source available']
)
stackIndicesWithValuesDo: action <[:Integer :ObjectMirror]> = (
	| tempFrameSize |
	#BOGUS yourself.
	(* Need to specialize.  The operand stack isn't simply after the number of locals in scope because remote temps don't take one slot each on the stacks of nested-closures. *)

	tempFrameSize: localNames size (* + hidden itvs, setters, pushnils *).

	stackDepth to: tempFrameSize + 1 by: -1 do:
		[:i |
		action
			value: i - tempFrameSize
			value: (ObjectMirror reflecting: (context_slot at: i))]
)) : ()
class ActivationMirrorCompiledBySqueak onContext: ctxt = ActivationMirror onContext: ctxt (
(* A mirror that operates on activations whose code was compiled by the Squeak back-end. This includes code produced by the Smalltalk, NS0, NS1 and NS2 compilers. *)|
	methodMap_slot
|)
('as yet unclassified'
compile: newSource ifFail: onFail ^ <NS2MethodMirror> = (

	| klass newSelector newCM |
	klass:: definingClass.
	newSelector:: klass
		compile: newSource 
		classified: 'as-yet-unclassified'
		notifying: nil.
	newCM:: klass compiledMethodAt: newSelector.

	^MethodMirror reflecting: newCM
)
evaluate: expression <String> 
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (
	[
		| newValue |
		newValue:: definingClass theNonMetaClass language compiler new
			evaluate: expression asString
			in: context_slot
			to: receiver reflectee
			notifying: (* requestor *) nil
			ifFail: [^compilationErrorHandler valueWithPossibleArgument: 'Error'].
		^ObjectMirror reflecting: newValue
	] on: SyntaxErrorNotification do: [:ex | ^compilationErrorHandler cull: ex]
	on: OutOfScopeNotification do: [:ex | ex resume: true]
)
localNames ^ <SequenceableCollection[String]>= (
	localNames_slot ifNil: [		
		(* localNames_slot:: methodNode ifNotNil: [:it | it tempNames] *)
		localNames_slot:: methodMap tempNamesForContext: context_slot
	].
	^localNames_slot ifNil: [{}]
)
localNamesWithIndicesDo: action <[:String :Number]> = (
	localNames doWithIndex: [:localName :index | action value: localName value: index].
)
localNamesWithValuesDo: action <[:String :ObjectMirror]> = (
	localNames doWithIndex:
		[:localName :i |
		action
			value: localName
			value: (ObjectMirror reflecting: (methodMap namedTempAt: i in: context_slot))]
)
localVariableValueMirror: name <String> = (
	| index |
	index:: localNames indexOf: name.
	^ObjectMirror reflecting: ([methodMap namedTempAt: index in: context_slot] ifError: ['<error getting value>'])
)
localVariableValueMirrorForIndex: desiredIndex <Number> = (
	localNames doWithIndex:
		[:localName :index|
		index = desiredIndex ifTrue:
			[^ObjectMirror reflecting: ([methodMap namedTempAt: index in: context_slot] ifError: ['<error getting value>'])]].
)
methodMap ^<DebuggerMethodMap> = (
	methodMap_slot ifNil: [
		methodMap_slot:: DebuggerMethodMap forMethod: homeMethod.
	].
	^methodMap_slot
)
methodNode ^ <MethodNode> = (
	methodNode_slot ifNil:
		[methodNode_slot:: homeMethod ifNotNil: [:it | it methodNode]].
	^methodNode_slot
)
pcRangeIn: thread <ThreadMirror> ^ <Interval> = (
	^context_slot debuggerMap
		rangeForPC: pc
		contextIsActiveContext: (thread isActiveContext: context_slot)
)
sourceMap ^ <SortedList[Association[Integer, Interval]]> = (
	sourceMap_slot ifNil:
		[sourceMap_slot:: methodNode ifNotNil: [:it | it sourceMap]].
	^sourceMap_slot
)) : ()
class SyntaxListener ifFail: handler <[:String]> = (|
	onFail = handler.
|)
('as yet unclassified'
bindingOf: variableName <String> = (
	error: variableName asString, ' undeclared'
)
error: message <String> = (
	onFail value: message
)
isKindOf: ignored = (
	^false
)
notify: message <String> = (
	error: message
)
notify: message <String> at: location <Integer> = (
	error: message
)
notify: message <String> at: location <Integer> in: stream <ReadStream> = (
	error: message
)
requestor = (
	^#error:
)
selectFrom: ignored1 to: ignored2 = (
	error: 'Error'
)
selection = (
	^nil
)
selectionInterval = (
	^1 to: 0
)) : ()
class ThreadMirror on: process <Process> = (
(* Represents a thread of control. *)|
	protected squeakProcess = process.
	protected wasMorphic = Project uiProcess == process.
|)
('accessing'
name = (
	^wasMorphic
		ifTrue: ['UI event loop']
		ifFalse: ['thread ', squeakProcess name].
)
summary = (
	^name, ' @ priority ', squeakProcess priority asString
)'as yet unclassified'
activationFor: newContext <ContextPart> relativeTo: activation <ActivationMirror> = (
	(* Find the activation mirror corresponding to the given context, or create a new mirror. *)
	| newActivation |

	(* Same context *)
	newContext == activation context_slot
		ifTrue: [^activation refresh].

	(* Returned to sender *)
	activation sender ifNotNil:
		[:it |
		newContext ==  it context_slot
			ifTrue: [^it refresh]].

	^(ActivationMirror reflecting: newContext)
		relateTo: activation
)
install: method <NS2MethodMirror> restart: activation <ActivationMirror> ifFail: onFail = (
	| newContext |
	activation sender. (* Remember sender *)
	activation ifNil: [^onFail value: 'Block''s method not on stack'].
	newContext:: squeakProcess popTo: activation context_slot.
	newContext == activation context_slot ifFalse:
		[onFail value: 'Method saved, but error during unwind.'.
		^activationFor: newContext relativeTo: activation].
	squeakProcess
		restartTopWith: method reflectee;
		stepToSendOrReturn.
	^activation refresh
)
isActiveContext: aContext <MethodContext> = (
	^squeakProcess suspendedContext == aContext
)
restart: activation <ActivationMirror> ^<ActivationMirror> = (
	| newContext |
	activation sender. (* Remember sender *)
	newContext:: squeakProcess popTo: activation context_slot.
	newContext == activation context_slot ifTrue:
		[newContext:: squeakProcess restartTop; stepToSendOrReturn].
	^activationFor: newContext relativeTo: activation
)
return: mirror <ObjectMirror> from: activation <ActivationMirror> ^<ActivationMirror> = (
	squeakProcess popTo: activation sender context_slot value: mirror reflectee.
	^activation sender refresh
)
stepInto: activation <ActivationMirror> ^<ActivationMirror> = (
	activation sender. (* Remember sender *)
	squeakProcess step: activation context_slot.
	^activationFor: squeakProcess stepToSendOrReturn relativeTo: activation.
)
stepIntoBlock: activation <ActivationMirror> ^<ActivationMirror> = (
	activation sender. (* Remember sender *)
	squeakProcess stepToHome: activation context_slot.
	^activationFor: squeakProcess stepToSendOrReturn relativeTo: activation.
)
stepOver: activation <ActivationMirror> ^ <ActivationMirror> = (
	| newContext |
	activation sender. (* Remember sender *)
	newContext:: squeakProcess completeStep: activation context_slot.
	newContext == activation context_slot ifTrue:
		[newContext:: squeakProcess stepToSendOrReturn].
	^activationFor: newContext  relativeTo: activation
)
unwindRecursion: activation <ActivationMirror> ^<ActivationMirror> = (
	| newContext |
	activation sender. (* Remember sender *)
	newContext:: squeakProcess popTo: activation context_slot findSecondToOldestSimilarSender.
	^activationFor: newContext relativeTo: activation
)'printing'
printOn: stream = (
	stream
		nextPutAll: 'ThreadMirror:';
		nextPutAll: name
)'testing'
isActiveThread = (
	^squeakProcess isActiveProcess
)'thread control'
resume = (
	| oldUiProcess |
	wasMorphic
		ifTrue:
			[oldUiProcess:: Project uiProcess.
			Project resumeProcess: squeakProcess]
		ifFalse:
			[squeakProcess resume].
	wasMorphic ifTrue: [oldUiProcess terminate]
)
suspend = (
	(* Special case for the Morphic UI thread. NsFFISessionManager takes care of native UI thread. *)
	Project spawnNewProcessIfThisIsUI: squeakProcess.

	squeakProcess suspend.
)
terminate = (
	Project spawnNewProcessIfThisIsUI: squeakProcess.
	squeakProcess terminate
)) : ()'accessing'
onContext: context <ContextPart> ^ <ActivationMirror> = (
	assert: [context isNil not] message: 'context is nil'.
	^ActivationMirror reflecting: context
)
onProcess: process <Process> ^ <ThreadMirror> = (
	assert: [process isNil not] message: 'process is nil'.
	^ThreadMirror on: process
)) : ()