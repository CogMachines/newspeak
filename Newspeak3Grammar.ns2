Newspeak3
'Newspeak3'
class Newspeak3Grammar parserLib: parsers = NewspeakObject (
"
   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
 ExecutableGrammar = parsers ExecutableGrammar.
 CollectingCommentParser = parsers CollectingCommentParser.
 
 PredicateTokenParser = parsers PredicateTokenParser.
 protected CombinatorialParser = parsers CombinatorialParser.
 protected ParserError = parsers ParserError.
 |)
(
class NS3Grammar = ExecutableGrammar ( 
"Grammar for Newspeak3 (without types)."| 
 whitespace = super whitespace. "cache whitespace parser"
 colon =  tokenFromChar: $:.
 comma =  tokenFromChar: $,.
 dollar = tokenFromChar: $$.
 dot = tokenFromChar: $..
 equalSign = tokenFromChar:$=.
 hat = tokenFromChar: $^.
 lbracket = tokenFromChar: $[.
 lcurly = tokenFromChar: ${.
 lparen = tokenFromChar: $(.
 langleBracket = tokenFromChar: $<.
 pound = tokenFromChar: $#.
 rangleBracket = tokenFromChar: $>.
 rbracket = tokenFromChar: $].
 rcurly = tokenFromChar: $}.
 rparen = tokenFromChar: $).
 semicolon = tokenFromChar: $;.
 slash = tokenFromChar: $/.
 vbar = tokenFromChar: $|.
 digit = charBetween: $0 and: $9.
 digits =  digit plus.
 uppercaseLetter = charBetween: $A and: $Z.
 extendedDigits = (digit | uppercaseLetter) plus.
 radix = digits, (char: $r).                  
 fraction =  dot, digits.
 extendedFraction =  dot, extendedDigits.                    
 exponent = (char: $e), (char: $- ) opt, digits.
 decimalNum = (char: $-)  opt,  
                  digits, 
                  fraction opt,
                  exponent opt.
 radixNum = radix,
               (char: $-)  opt,  
               extendedDigits, 
               extendedFraction opt,
               exponent opt.       
 num =   radixNum | decimalNum.
 "must distinguish internal use of productions from use as tokens"                              
 number =  tokenFor: num.
 letter = PredicateTokenParser new accept:[:c | c isLetter]
                                                      errorMsg: 'letter expected'.
 specialCharacter = (char: $+ )  | (char: $/ ) |  
                                       (char: $\ ) | (char: $* )   |
                                       (char: $~ ) | (char: $<) | (char: $>) |
                                       (char: $=) | (char: $@ )  |
                                       (char: $% ) | (char: $| )  |
                                       (char: $& ) | (char: $? )  |
                                       (char: $! ) |  (char: $, ).                                                    
 character = digit | letter | specialCharacter | (char: $[  ) | (char: $]  ) |
                        (char: ${ ) | (char: $} ) | (char: $(  ) |
                        (char:$) ) | (char: $^ ) | (char: $; ) | (char: $$ ) | (char: $#  ) |
                        (char: $: ) | (char: $. ) | (char: $-) | (char: $_) | (char: $`) "the Smalltalk grammar neglects to add - to characters, or to comments. It does add | [self char: $' ], but these are both bugs. We intend to support underscores, which Squeak insists on turning into assignment arrows. However, we do not support these as assignments. At the moment, we do not accept them in identifiers, but this will change in time.".
                        

  id =  (letter | _),  ((letter | digit | _)) star
                 wrapper:[:fst   :snd  | fst asString, (String withAll: snd)].
                                           
 identifier =  tokenFor: id.

 aChar = (char: $$),  (character | (char: $' ) | (char: $" ) | (char:$ )).

 characterConstant = tokenFor: aChar.

 twoQuotes = (char: $' ),  (char: $' )
                   wrapper:[:q1 : q2 | ''''].

 str = (char: $' ),
           stringBody,
                   "[(character | [aWhitespaceChar] | (char: $" ") | twoQuotes) star],"
          (char: $')
              wrapper:[:oq :es :eq | es inject:'' into:[:s : e | s, e asString]].
 
 string = tokenFor: str.

 kw = id, (char: $:) wrapper:[: i  :c   | i, $: asString]. 

 kwds = kw plus wrap:[:c | c inject: '' into:[:s :e | s, e]].   
  
 keyword = tokenFor: kw. 

 setterKw = kw, (char: $:) wrapper:[: i  :c   | i, $: asString]. 

 setterKeyword = tokenFor: setterKw. 

 sym = str | kwds | binSel | id. 
 
 symbol = tokenFor: sym.
 
 commentDelimiter = char: $".

 beginComment = commentDelimiter.

 endComment = commentDelimiter.

 twoDblQuotes = (char: $" ),  (char: $" )
                   wrapper:[:q1 : q2 | '"'].

 comment = beginComment, commentBody, endComment.
 

 binSel =  (specialCharacter | (char: $- )), specialCharacter star
                          wrapper:[:c1  :c2  |
                                              c2 isEmpty ifTrue:[c1 asString asSymbol]
                                                             ifFalse:[(c1 asString, (c2 inject: '' into:[:s :e | s, e asString])) asSymbol ]
                                           "probably delay interning as symbol until later phase"
                                           ].
                                           
 binarySelector = tokenFor: binSel. "maybe intern as symbol here" 


"syntactic productions"

symbolConstant =   pound,  symbol.

 tuple =   lcurly,
           (expression starSeparatedOrTerminatedBy:  dot),
           rcurly.
 

"patterns"

"adding literals for patterns"
literal =
  pattern | number | symbolConstant | characterConstant | string | tuple.

pattern =  (tokenFromChar: $<), patternLiteral, (tokenFromChar: $>).
patternLiteral = wildcardPattern | literalPattern | keywordPattern.

wildcardPattern = tokenFromChar: $_.

"values which are comparable by means of #="
literalPattern = tokenFor:
  number | symbolConstant | characterConstant | string | tuple.

"keyword patterns"
keywordPattern = kwPatternPair plus.
kwPatternPair = keyword, kwPatternValue opt.
kwPatternValue =
  wildcardPattern | literalPattern | variablePattern | nestedPatternLiteral.
variablePattern = tokenFor: ( (char: $?), id ).
nestedPatternLiteral = tokenFor: ( pattern ).


"values which are comparable by means of #="
"literalPattern = tokenFor: (number | 
	symbolConstant | 
	characterConstant | 
	string | 
	tuple).

variablePattern = tokenFor: ( (char: $?), id ).

wildcardPattern = tokenFor: ( char: $_ ).

nestedPatternLiteral = tokenFor: ( patternLiteral ).
"
"keyword patterns"
"kwPatternValue = literalPattern | 
	variablePattern | 
	wildcardPattern | 
	nestedPatternLiteral.

kwPatternPair = keyword, kwPatternValue opt.

keywordPattern = kwPatternPair plus.
"
"integration"

"pattern = keywordPattern | literalPattern.

patternLiteral =  (tokenFromChar: $<), pattern, (char: $>).

 literal =  patternLiteral | number | 
	symbolConstant | 
	characterConstant |
	string | 
	tuple."
                                  
 slotName =  identifier.
                                                                                                                                                               
 unarySelector = UnarySelectorParser new on: self. " the one hack/flaw. See UnarySelectorParser for details"
                                          
 parenthesizedExpression =  lparen, expression, rparen.
                                                                                                          
 primary =  slotName | 
                   literal | 
                   block | 
                   parenthesizedExpression.
 
 unaryExpression = primary, unarySelector star.

 binaryMsg = binarySelector, unaryExpression.

 binaryExpression = unaryExpression, binaryMsg star.
                                                                
 keywordMsg =  (keyword, binaryExpression) plus.

 message = keywordMsg | unarySelector | binaryMsg.

 nontrivialUnaryMessages = unarySelector plus, binaryMsg star,  keywordMsg opt.

 nontrivialBinaryMessages = binaryMsg plus, keywordMsg opt.

 keywordMessages = keywordMsg.

 nonEmptyMessages = nontrivialUnaryMessages |
						nontrivialBinaryMessages  |
						keywordMessages.
                                               
 keywordExpression =  binaryExpression, keywordMsg opt.

 keywordHereSend = keywordMsg.

 cascadeMsg = semicolon, (keywordMsg | binaryMsg | unarySelector).

 msgCascade = nonEmptyMessages, cascadeMsg star.
                                                                                                                        
 cascadedMessageExpression = primary, msgCascade opt.

 sendExpression = keywordHereSend | cascadedMessageExpression. 

 expression = setterKeyword star, sendExpression.
                                              
 returnStatement = hat,  expression, dot opt.
                                                                                                                        
 furtherStatements = dot,  statements.             
                                                            
 statementSequence = expression, furtherStatements  opt.
                                         
 statements = returnStatement  |   
                  statementSequence |
                  empty.
                             
 blockParameter = colon, slotDecl.
                                          
 blockParameters =  blockParameter plus, vbar.

 slotDefs = slotDef star.
 seqSlotDecls = vbar, slotDefs, vbar.
 simSlotDecls = vbar, vbar, slotDefs, vbar, vbar.
 slotDecls = simSlotDecls | seqSlotDecls.

 temporaries = slotDecls.

 codeBody = temporaries opt,  statements.
                              
 block = lbracket,  blockParameters opt, codeBody,  rbracket.
                      
 slotDecl = identifier.

 accessModifier =  ((tokenFromSymbol: #private) | 
                              (tokenFromSymbol: #public) | 
                              (tokenFromSymbol: #protected)), whitespace.

 slotDef =  accessModifier opt, slotDecl, 
                    (((tokenFromSymbol: #=) | 
                      (tokenFromSymbol: #'::=')
                     ), expression, dot) opt.
                    
 initExprs = expression starSeparatedOrTerminatedBy: dot.

 unaryMsgPattern = unarySelector.

 binaryMsgPattern = binarySelector, slotDecl.  
                                                         
 keywordMsgPattern = (keyword, slotDecl) plus.                                        
                                                                                  
 messagePattern =  unaryMsgPattern |
                                binaryMsgPattern |
                                keywordMsgPattern.       

 method = messagePattern, codeBody, eoi. "A method in a browser"
                                                                 
 methodHeader = accessModifier opt, [messagePattern].         
     
                                                                 "Top level productions for classes"

 methodDecl = accessModifier opt, messagePattern, equalSign, lparen, codeBody, rparen.

 methodDef = methodDecl | method. "For now, a rule that accepts either old browser form or new file form"

 nestedClassDecl = accessModifier opt, classDeclaration.
 
 category = string, methodDecl star.

 classComment = whitespace, comment. "A hack, to preserve comments from a complete class declaration"                                            

 sideDecl =  lparen, nestedClassDecl star, category star, rparen.

 classSideDecl = colon, lparen, category star, rparen.

 languageId = identifier.

 classCategory = string opt.

 superclassClause = slotName, message opt.

 classHeader =  (identifier, messagePattern, equalSign, 
                        superclassClause opt, lparen,  classComment opt, 
                        slotDecls opt, initExprs,  rparen) |
                        (identifier, empty, equalSign,
                        superclassClause opt, lparen,  classComment opt, 
                        slotDecls opt,  initExprs, rparen).
"A gross hack to allow for a default constructor pattern.  This should at least be refactored (note the awful use of empty to keep the arity the same for the wrapper in the parser. Ugh). 
It would be nice to just say messagePattern opt]. Alas, because the '|' operator  'cuts' at the first successful branch  rather than evaluating all branches in parallel or backtracking, this won't work."
 classDeclaration = (tokenFromSymbol: #class), classHeader, sideDecl, classSideDecl opt.

 toplevelClass = classCategory, classDeclaration.

 compilationUnit =  languageId, toplevelClass, eoi.
|)
('as yet unclassified'
_ = (
	^char: $_
)'grammar'
commentBody = (


"As an optimization, we process the body of a comment with a dedicated scanning parser. 
It should be equivalent to:

 ^(self character | self aWhitespaceChar | (self char: $' ) | self twoDblQuotes) star, "
^CollectingCommentParser new 
   termBlock:[: input | | c|
                c: input peek.
                c isNil 
                    ifTrue:[false] "let main routine handle end of input"
                    ifFalse:[c = $" 
                              ifFalse:[false]
                              ifTrue:[| pos | 
                                         pos: input position.
                                       input next.
                                       input peek = $" ifTrue:[false] ifFalse:[input position: pos. true]
                                     ]
                            ]
             ]
)
stringBody = (


"As an optimization, we process the body of a string with a dedicated scanning parser.
It should be equivalent to:

  ^(self character | self aWhitespaceChar | (self char: $"" ) | self twoQuotes) star"
^CollectingCommentParser new 
   termBlock:[: input | | c|
                c: input peek.
                c isNil 
                    ifTrue:[false] "let main routine handle end of input"
                    ifFalse:[c = $' 
                              ifFalse:[false]
                              ifTrue:[| pos | 
                                       pos: input position.
                                       input next.
                                       input peek = $' ifTrue:[false] ifFalse:[input position: pos. true]
                                     ]
                             ]
               ]
))
class TypedNS3Grammar = NS3Grammar (
"A parser for Strongtalk syntax. Adds productions for the Strongtalk type expression sublanguage, and the changes needed to use types in Newsqueak code."|                   

 arg = tokenFromSymbol: #arg.
 for = tokenFromSymbol: #for.
 generic = tokenFromSymbol: #generic.
 inheritedTypeOf = tokenFromSymbol: #inheritedTypeOf.
 is = tokenFromSymbol: #is.
 mssg = tokenFromSymbol: #message.
 of = tokenFromSymbol: #of.

 receiverType = tokenFromSymbol: #receiverType.
 subtypeOf = tokenFromSymbol: #subtypeOf.
 typeArg = tokenFromSymbol: #typeArg.
 where = tokenFromSymbol: #where.
 returnType = hat, type.

                                                                 "Type Grammar"
                                                                 
  type = langleBracket, typeExpr,  rangleBracket.
  typePrimary = identifier, typeArguments opt.
  typeFactor =  typePrimary |
                   blockType |
                   tupleType |
                   parenthesizedTypeExpression.
  parenthesizedTypeExpression =  lparen,  typeExpr,  rparen.
  typeTerm = typeFactor, identifier star.
  typeExpr = typeTerm, ((vbar | semicolon | slash), typeExpr) opt.
  typeArguments = lbracket, (typeExpr plusSeparatedBy: comma),  rbracket. 
  blockType =  lbracket, blockTypeArgList,  rbracket.
  tupleType = lcurly, (typeExpr starSeparatedBy: dot), rcurly.
  nonEmptyBlockTypeArgList = (typeExpr plusSeparatedBy: comma), 
                                     (comma, blockReturnType) opt.
  blockTypeArgList =  nonEmptyBlockTypeArgList |
                                   blockReturnType opt.
  newBlockTypeArgList = (colon, typeExpr) star, typeExpr opt.
  blockReturnType =  hat, typeExpr.
                                        
                                         "Type inference"
                                         
  typePattern = langleBracket, typeFormal, (semicolon, typeFormal) star,  rangleBracket. "changed from {} to <> brackets to avoid conflict with tuples"
  typeFormal =  where, identifier, typeParamConstraint opt, is, inferenceClause.
  typeParamConstraint =  langleBracket,  typeBoundQualifier opt,  typeExpr, rangleBracket.
  typeBoundQualifier =  subtypeOf | inheritedTypeOf.
  inferenceClause = receiverType | 
                                      (returnType, returnTypeInferenceClause) |
                                      typeArgInferenceClause |
                                      (arg,  number, (of, msgSelector) opt).
  returnTypeInferenceClause =  of, msgSelector.
  msgSelector =  symbolConstant, mssg, of, inferenceClause.
  typeArgInferenceClause = typeArg, number, for, generic, symbolConstant, of, inferenceClause. 
 |)
('grammar'
messagePattern = (
     ^super messagePattern, returnType opt, typePattern opt. "Type annotations"
  )
slotDecl = (
    ^super slotDecl , type opt.
  ))
class UnarySelectorParser = CombinatorialParser (
"In the absence of a separate lexer, an ambiguity arises, which this parser deals with.
 The problem is that when parsing a unary expression that is an argument to a keyword
 message, one expects a unary selector, which is an identifer.  However, it may be that the next
 token is actually a keyword, part of the surrounding message. If we aren't actually tokenizing,
 the prefix of the keyword will be misinterpreted as an identifier and hence as another unary
 message being sent to the argument.
 
 Using a lexer solves this but introduces a subtlety around the assignment operator :=. In that case
 if there is no whitespace between a variable name and the assignment, the variable name will
 be tokenized as a keyword rather than as an identifier. The Strongtalk parser, DeltaParser, deals
 with this specially. In the longterm, that is probably the way to go."| p |)
('as yet unclassified'
on: s = (
	p: s.
)
parse: input inContext: context ifError: blk = (
	| pos |
	pos:: input position.
	p keyword
		parse: input inContext: context
		ifError: [:msg :position | 
			input position: pos.
			^p identifier parse: input inContext: context ifError: blk].
	input position: pos.
	blk value: 'should not print' value: pos
)))