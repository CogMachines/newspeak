Newspeak3
'NS2 Combinatorial Parsing'
class PegDslAST usingLib: platform = (
(*AST module for EBNF/PEG DSL.*))
(
class AST = (
(*An abstract syntax tree. An AST knows where in the source code the corresponding construct is.  The slots start and end are indices into the source code marking that position.

In some cases, the corresponding construct may be associated with tokens that are not strictly part of the abstract syntax. For example, in

 (foo) 

the parentheses are not part of the abstract syntax but foo is. Nonetheless, it may be useful to know where the parens are, since they are strongly associated withthe AST. We use the slots concStart and concEnd for that purpose.*)| startPosition ::= 0.  endPosition ::= 0. concStart <Integer> concEnd <Integer> |)
('as yet unclassified'
apply: aTool = (
    ^self subclassResponsibility
  )
concreteEnd ^ <Integer> = (
(*To be used by leaf nodes; they will typically only have a stored concrete end if it was set by the parser (usually due to surrounding parens), though the AST copier might set it regardless*)
^ concEnd isNil ifTrue:[self end] ifFalse:[concEnd]
 )
concreteEnd: i <Integer> = (
	concEnd:: i
)
concreteStart ^ <Integer> = (
(*To be used by leaf nodes; they will typically only have a stored concrete start if it was set by the parser (usually due to surrounding parens), though the AST copier might set it regardless*)
^ concStart isNil ifTrue:[self start] ifFalse:[concStart]
)
concreteStart: i <Integer> = (
	concStart:: i
)
end ^ <Integer> = (
	^endPosition
)
end: i <Integer> = (
	endPosition: i
)
start ^ <Integer> = (
	^startPosition
)
start: i <Integer> = (
	startPosition: i
)) : ()
class AlternationAST right: r <AST> left: l <AST> = AST (
(*Alternatives in a grammar.*)|
	right <AST> = r.
	left <AST> = l.
|)
('as yet unclassified'
apply: aTool = (^ aTool alternationNode: self)) : ()
class GrammarAST rules: ps <List[ProductionAST]> = AST (
(*AST node for a complete grammar.*)|
  productions <List[ProductionAST]> = ps.
|)
('as yet unclassified'
apply: aTool = (^ aTool grammarNode: self)) : ()
class NegationAST negating: p <AST> = AST (
(*PEG negation: ~P.*)|
  operand <AST> = p.
|)
('as yet unclassified'
apply: aTool = (^ aTool negationNode: self)) : ()
class OneOrMoreAST repeating:  node <AST> = AST (
(*One or more repetitions: P+.*)|
  operand <AST> = node.
|)
('as yet unclassified'
apply: aTool = (^ aTool oneOrMoreNode: self)) : ()
class OptionAST operand: p <AST> = AST (
(*Optional clausesin a grammar: [P] or P?.*)|
  operand <AST> = p.
|)
('as yet unclassified'
apply: aTool = (^ aTool optionNode: self)) : ()
class ProductionAST named: n <Symbol> rhs: r = AST (
(*A grammar production.*)|
  name <Symbol> = n.
  rhs <AST> = r.
|)
('as yet unclassified'
apply: aTool = (^ aTool productionNode: self)) : ()
class ProductionReferenceAST id: id <String> = AST (
(*The name of a production.*)|
	identifier <Symbol>= id.
|)
('as yet unclassified'
apply: aTool = (^ aTool productionReferenceNode: self)) : ()
class SequenceAST sequence: s <List[AST]> = AST (
(*A sequence in a grammar: P1 P2 .. Pn.*)|
  sequence <List[AST]> = s.
|)
('as yet unclassified'
apply: aTool = (^ aTool sequenceNode: self)) : ()
class StringAST val: v <String> = AST (
(*Litreal strings in a grammar.*)|
	val <String> = v.
|)
('as yet unclassified'
apply: aTool = (^ aTool stringNode: self)) : ()
class ZeroOrMoreAST repeating: node <AST> = AST (
(*Describe the class in this comment.*)|
  operand <AST> = node.
|)
('as yet unclassified'
apply: aTool = (^ aTool zeroOrMoreNode: self)) : ()) : ()