Newspeak3
'Newspeak'
class NewspeakParsing usingLib: platform ast: astModule grammar: ns3Grammar = (
"The Newspeak parser.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2010 Felix Geller and Ryan Macnak
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
      OrderedCollection = platform collections OrderedCollection.

      ASTModule = astModule.
      TypedNS2Grammar = ns3Grammar TypedNS3Grammar.
 	ParserError = ns3Grammar ParserError.

	BinaryTypeOpAST = astModule BinaryTypeOpAST.
	BlockAST = astModule BlockAST.
	BlockTypeAST = astModule BlockTypeAST.
	CascadedSendAST = astModule CascadedSendAST.
	CategoryAST = astModule CategoryAST.
	CharAST = astModule CharAST.
	ClassHeaderAST = astModule ClassHeaderAST.
	CodeBodyAST = astModule CodeBodyAST.
	GenericInvocationAST = astModule GenericInvocationAST.
	MessageAST = astModule MessageAST.
	MessagePatternAST = astModule MessagePatternAST.
	MethodAST = astModule MethodAST.
	NormalSendAST = astModule NormalSendAST.
	NumberAST = astModule NumberAST.
	ReturnStatAST = astModule ReturnStatAST.
	SetterSendAST = astModule SetterSendAST.
	SideAST = astModule SideAST.
	StringAST = astModule StringAST.
	SymbolAST = astModule SymbolAST.
	TupleAST = astModule TupleAST.
	TypeIdAST = astModule TypeIdAST.
	UnaryTypeOpAST = astModule UnaryTypeOpAST.
	VarDeclAST = astModule VarDeclAST.
	VariableAST = astModule VariableAST.
	protected ImmutableSlotDefAST = astModule ImmutableSlotDefAST.
	protected MixinApplicationAST = astModule MixinApplicationAST.
	protected MutableSlotDefAST = astModule MutableSlotDefAST.
	protected NSSideAST = astModule NSSideAST.
	protected ClassDeclarationAST = astModule ClassDeclarationAST.

	"patterns"
	protected KeywordPatternAST = astModule KeywordPatternAST.
	protected KeywordPatternPairAST = astModule KeywordPatternPairAST.
	protected WildcardPatternAST = astModule WildcardPatternAST.
	protected LiteralPatternAST = astModule LiteralPatternAST.
	protected VariablePatternAST = astModule VariablePatternAST.
|)
(
class Parser = TypedNS2Grammar (
"Parser for Newsqueak2. Produces a Newsqueak AST. This tree represents syntax only. No attribution information such as scopes/symbol tables, types etc. is present in the tree. The tree  only gives its structure and the source code positions of the nodes.

The parser works by overridding the accessors for most grammar productions in its superclasses. The superclass methods deal with the grammar alone; each production defines a parser that will parse the syntax and return the corresponding set of tokens. The methods here process the output of the superclass methods to yield parsers that will construct ASTs. Hence, the typical method for a production foo is something like

foo

^super foo wrapper:[:w :x :y :z | FooAST new from: x and: y; start: w start; end: z end]

This example assumes that the semantic content of foo is given by x and y. Typically, x and y will be the results of  productions that have also been overridden, to provide  ASTs that will be subtrees of the Foo node. In contarst, w and z are likely to be tokens used in the concrete syntax to delimit the Foo construct. They may (or may not) be used to extract source code position information, and then discarded.")
('as yet unclassified'
blockTypeArgList ^ <List[TypeExpr]> = (
	^super blockTypeArgList
		wrap:[:bta <TypeExpr | List[TypeExpr]> | 
				bta isNil 
					ifTrue:[{}] "nullary block type with default return type"
					ifFalse:[
						(bta isKindOfCollection) ifFalse: [{bta}] ifTrue:[bta]
						]
				"nullary block type with non-trivial return type will cause bta to be a type expression. In that case, we package it as a collection"
			]
)
hereSetterSendFromMsg: msg = (

	"Build an implicit here send with the message msg"

	^SetterSendAST to: self hereNode  
                          	send: msg
    	                      	start: msg start
					end: msg end
)
keywordMessages ^<Tuple[List[MessageAST], List[MessageAST], MessageAST]> = (
	^super keywordMessages wrapper:
		[  :kwMsg <MessageAST> | 
		"keywordMsg"
			{{}. {}. kwMsg}.
		]
)
keywordPattern ^ <KeywordPatternAST> = (
^ super keywordPattern
	wrap: [ :pairs | |kws kwsAST pats patsAST st ed |
		st:: pairs first start.
		ed:: pairs last end.
		
		kws:: OrderedCollection new.
		pats:: pairs inject: OrderedCollection new 
					into: [:m :p | |kwAST|
							kwAST:: SymbolAST new 
										val: p keyword token asSymbol;
										start: p keyword start;
										end: p keyword end.
							kws add: kwAST.
							m add: p pattern; yourself].
						
		kwsAST:: TupleAST new
					elements: kws;
					start: st; end: ed.
		patsAST:: TupleAST new
					elements: pats;
					start: st; end: ed.

		KeywordPatternAST new
			keywords: kwsAST;
			patterns: patsAST;
			start: st;
			end: ed.
	].
)
kwPatternPair = (
^ super kwPatternPair
	wrapper: [ :keyw  :val |
		KeywordPatternPairAST new
			keyword: keyw;
			pattern: (val isNil 
						ifTrue: [WildcardPatternAST new 
									start: keyw end; end: keyw end] 
						ifFalse: [val]);
			start: keyw start;
			end: (val isNil ifTrue: [keyw end] ifFalse: [val end])
	].
)
literalMessage = (
	^super literalMessage wrap:
		[:kwsOrMsg |
		kwsOrMsg isCollection
			ifTrue:
				[| sel  args  |
				args:: OrderedCollection new.
				sel:: kwsOrMsg inject: '' into:
						[:s :kwd | 
						args add: (kwd at:2). 
						s, (kwd at:1) token].
				MessageAST new send: sel asSymbol with: args;
					start: kwsOrMsg first first concreteStart;
					end: args last concreteEnd]
			ifFalse:
				[kwsOrMsg]]
)
literalMessageComment = (
	^super literalMessageComment wrap:
		[:tokens| "beginNSComment :literalmessage: wsp literalMessage endNSComment"
		tokens at: 4]
)
literalPattern ^ <LiteralPatternAST> = (
^ super literalPattern
	wrap: [ :litTok | 
		LiteralPatternAST new
			literal: litTok token;
			start: litTok start; end: litTok end.
	].
)
nestedPatternLiteral = (
 ^ super nestedPatternLiteral wrap: [ :nestedTok | nestedTok token ]	
)
newBlockArgType = (
	^super newBlockArgType wrapper: 
		[:c :rt | 
		rt concreteStart: c start.
		rt].
)
newBlockType = (
	^super newBlockType wrapper:
		[:lb :tas :rb | | z | 
		z:: tas isCollection ifTrue: [tas] ifFalse: [{tas}].
		GenericInvocationAST new generic: (TypeIdAST new name: #Block); 
                                               arguments: z;
                                               start: lb start;
                                               end: rb end
              ].
)
newNonEmptyBlockArgList = (
	^super newNonEmptyBlockArgList wrapper:
		[:ats :vbarreturnt | 
		| targs |
		targs:: OrderedCollection new addAll: ats; yourself.
            vbarreturnt isNil 
			ifTrue:[targs addLast: (TypeIdAST new name: #Object)]
                  ifFalse:[targs add: (vbarreturnt at: 2)].
		targs].
)
nontrivialBinaryMessages ^ <Tuple[List[MessageAST], List[MessageAST], MessageAST]> = (
	^super nontrivialBinaryMessages wrapper:
		[ :bmsgs <List[MessageAST]> :kwMsg <MessageAST> | 
		"binaryMessages+ [keywordMsg]"
			assert:[bmsgs isEmpty not].
			{{}. bmsgs. kwMsg}
		]
)
pattern ^ <PatternAST> = (
^ super pattern
	wrapper: [ :del1 :pat :del2 | pat. ]
)
sendMessages: msgs <List[MessageAST]> to: receiver <ExpressionAST> ^ <ExpressionAST> = (
"if msgs is non-empty, the return type will always be NormalSendAST"
	^msgs inject: receiver into:[:r :msg | 
									NormalSendAST new to: r send: msg;
														left: r; right: msg
								].
)
seqSlotDecls = (

^super seqSlotDecls
     wrapper:[:vb1 :sds :vb2  | 
                  sds isEmpty ifFalse:[sds first concreteStart: vb1 start.
                                           sds last concreteEnd: vb2 end.
                                           ].
                  {true. sds}
                ].
)
simSlotDecls = (

^super simSlotDecls
     wrapper:[:vb1 :vb2 :sds :vb3 :vb4  | 
                  sds isEmpty ifFalse:[sds first concreteStart: vb1 start.
                                           sds last concreteEnd: vb4 end.
                                           ].
                  {false. sds}
                ].
)
tupleType = (


^super tupleType
   wrapper:[:lc :es :rc | 
               GenericInvocationAST new generic: (TypeIdAST new name: #Tuple); 
                                               arguments:  es;
                                               start: lc start;
                                               end: rc end
              ].
)
variablePattern ^ <VariablePatternAST> = (
^ super variablePattern
	wrapper: [ :varTok | VariablePatternAST new
					variableName: (varTok token at: 2); 
					start: varTok start; end: varTok end ].
)
wildcardPattern ^ <WildcardPatternAST> = (
^ super wildcardPattern
	wrap: [ :wcTok | WildcardPatternAST new
					start: wcTok start; end: wcTok end ].
)'grammar'
binaryExpression = (


	^super binaryExpression wrapper:
		[ :ue :bmsgs | "unaryExpression binaryMsg*"
		bmsgs inject: ue into:
			[ :receiverExpr :b <MessageAST> |
			b sel = #'|>'
				ifTrue:
					[ mixinApplicationOf: receiverExpr on: b args first ]
				ifFalse:
					[ NormalSendAST new
						to: receiverExpr send: b;
						left: receiverExpr; right: b
						]]]
)
binaryMsg ^ <MessageAST> = (

^super binaryMsg
     wrapper:[:b :e  |
                | args |
                  args:: OrderedCollection new.
                  args add: e.
                  MessageAST new send: b token with: args ;
                                      start: b start; right: e 
                ].
)
binaryMsgPattern = (

^super binaryMsgPattern
    wrapper:[:sel :p  |
                | params |
                 params:: OrderedCollection new add:p; yourself.
                 MessagePatternAST new selector: sel token parameters: params ;
                                              start: sel start; right: p            
               ].
)
block = (

^super block
          wrapper:[:lb :params :cb :rb  |
                      | ps |
                                                                                                                                           
                       ps::  params isNil ifTrue:[OrderedCollection new] ifFalse:[params].
                       cb parameters: ps.
                       BlockAST new body: cb;
                                        start: lb start; end: rb end
                     ].
)
blockParameter = (

^super blockParameter
    wrapper:[:c :v  | 
                v concreteStart: c start.
                v
               ].
                                
)
blockParameters = (

^super blockParameters
          wrapper:[:params :vb  | 
                      self assert:[params isEmpty not] message: 'Assert failed'.
                      params last concreteEnd: vb end. "dubious"
                      params
                     ].
)
cascadeMsg = (

^super cascadeMsg
    wrapper:[:sm :msg  | msg].
                                
                         
)
cascadedMessageExpression ^ <CascadedSendAST> = (

^super cascadedMessageExpression
          wrapper:[:p <ExpressionAST> 
				:msgs <Tuple[Tuple[List[MessageAST], List[MessageAST], MessageAST], List[MessageAST]]>  |
				| 
				se <SendAST> 
				unaries <List[MessageAST]> 
				binaries <List[MessageAST]> 
				kwMsg <MessageAST> 
				cascade  <List[MessageAST]> 
				unarySend <ExpressionAST>  
				binarySend <ExpressionST> 
				|
				"primary [msgCascade]"
				msgs isNil 
					ifTrue:[p]
					ifFalse:[
							unaries:: msgs first first.
							binaries:: msgs first at: 2.
							kwMsg:: msgs first last.
							cascade:: msgs last.
							unarySend:: sendMessages: unaries to: p.
							binarySend:: sendMessages: binaries to: unarySend.
							se:: kwMsg isNil 
								ifTrue:[binarySend] 
								ifFalse:[sendMessages: {kwMsg} to: binarySend].
                       				cascade inject: se into:[:e  <SendAST> :m  <MessageASAT> |
                                                     CascadedSendAST new to: e cascade: m;
													left: e;  right: m                
                                                    ]  
							]
]      
                     
)
category = (

^super category
          wrapper:[:cn :ms  |
                      | end |
                       end:: ms isEmpty ifTrue:[cn end] ifFalse:[ms last end].
                       CategoryAST new name: cn val asSymbol; methods: ms;
                                            start: cn start; end: end
                     ].
)
classComment = (

^super classComment
  wrapper:[:ws :c | (c at:2)  inject:'' into:[:s :ch | s, ch asString]]
)
classDeclaration ^ <ClassDeclarationAST> = (
 
^super classDeclaration
     wrapper:[ :ckw :hdr :instSide  :classSide  |
                 | klassSide kat |
                  klassSide:: classSide isNil  
                                          ifTrue:[SideAST new vars: OrderedCollection new 
	                                                                    cats: OrderedCollection new
	                                              ]
                                                 ifFalse:[classSide].
                  ClassDeclarationAST new hdr: hdr;
                                   instanceSide: instSide;
                                   classSide: klassSide;
                                   start: ckw start;
                                   end: (classSide isNil ifTrue:[instSide end] ifFalse:[classSide end])            
               ].
)
classDefinition = (
 
"%Cleanup when NS1 and NS0  are gone"
"Retained for compatibility with older Newsqueak versions. We renamed classDefinition to ClassDeclaration in the grammar, but there is code that needs to use older parsers, and hence uses the old protocol"
^compilationUnit
)
classHeader ^ <ClassHeaderAST> = (

^super classHeader
     wrapper:[:klassName :cons :eq :superClause :lp :cmnt :instVars :inits :rp  | 
                | vs kat start  konstruktor superCall isSeq |
			isSeq:: true.
                  kat:: nil. start:: klassName start.
                  konstruktor:: cons isNil 
                       ifTrue:[defaultConstructorPattern start: klassName end + 1; end: klassName end]
                       ifFalse:[cons].
                  superCall:: superClause isNil 
                                     ifTrue:[defaultSuperCallAt: eq end + 1 ending: eq end] 
                                     ifFalse:[superClause].
                  vs:: instVars isNil ifTrue:[OrderedCollection new] ifFalse:[isSeq:: instVars first. instVars last].
                  ClassHeaderAST new name: klassName snd asSymbol; 
                                                    constructor: konstruktor;
                                                    superclassName: superCall recv msg sel;
                                                    superConstructorCall: superCall msg;
                                                    slots: vs; isSeq: isSeq; initExprs: inits; category: kat ;
                                                    classComment: cmnt;
                                                    start: start; end: rp end                   
                ].
)
classSideDecl ^ <SideAST> = (

^super classSideDecl 
   wrapper:[:cn :lp :cats :rp  | 
	               SideAST new vars: OrderedCollection new cats: cats;
	                                    start: cn start; end: rp end.
	          ]
)
codeBody ^ <CodeBodyAST> = (

^super codeBody
          wrapper:[:litMsgs :tmps :stmts |
                      | ts ss start end  cstart cend isSeq | 
				isSeq:: true.
                       end:: nil.
                       start:: end.
                       ts:: tmps isNil ifTrue:[OrderedCollection new] ifFalse:[isSeq:: tmps first. tmps last].      
                       ss:: stmts isNil ifTrue:[OrderedCollection new]  ifFalse:[stmts]. 
                       ts isEmpty 
				ifFalse:[cstart:: ts first concreteStart. start:: ts first start.
					cend::  ts last concreteEnd. end::  ts last end.
					].       
                       ss isEmpty ifFalse:[start isNil 
								ifTrue:[start:: ss first start]. 
								end:: ss last end. 
								cend:: ss last concreteEnd
							].
                       CodeBodyAST new temporaries: ts
                                            statements: ss;
							  literalMessages: litMsgs;
							  isSeq: isSeq;
                                            start: start;
                                            end: end;
					    		  concreteStart:  cstart;
                                            concreteEnd: cend
                     ].
)
compilationUnit = (

^super compilationUnit
   wrapper:[:lid  :u : e | u] "throw out end-of-input indicator" 
)
expression = (
	^super expression wrapper:[:setters :msg  |
		| e setSend args setSelector |
		e:: msg.
		setters isNil ifFalse:[  
			setters reverseDo: [:setter |
				args:: OrderedCollection new add: e; yourself.
				setSelector:: setter token asString.
				setSend:: MessageAST new
					send: (setSelector copyWithSize: setSelector size -1) asSymbol with: args;
					start: setter start; end: setter end;
					right: e.
				e:: self hereSetterSendFromMsg: setSend.
			].
		].
		e      
	].
)
furtherStatements = (

^super furtherStatements
     wrapper:[:d :stmts  | stmts].
)
keywordExpression ^ <NormalSendAST> = (

^super keywordExpression
     wrapper:[:bo :msg <MessageAST> |
                  msg isNil 
                       ifTrue:[bo]
                       ifFalse:[NormalSendAST new to: bo send: msg; left: bo; right: msg]
                ].
)
keywordHereSend = (

^super keywordHereSend
          wrap:[:msg  |
                  self hereSendFromMsg: msg                               
                 ].
)
keywordMsg ^ <MessageAST> = (

^super keywordMsg
          wrap:[:kws  |
                  | sel  <String> args <List[Expression]> |
                    args:: OrderedCollection new.
                    sel:: kws inject:'' into:[:s <String>    :kwd   | 
                                                 args add: (kwd at:2). 
                                                 s, (kwd at:1) token
                                               ].
                    MessageAST new send: sel asSymbol with: args ;
                                        start: kws first first start;
                                        right: args last                            
                 ].
)
keywordMsgPattern ^ <MessagePatternAST> = (

^super keywordMsgPattern
     wrap:[:kws  |
             | sel  params |
              params:: OrderedCollection new.
              self assert:[kws isEmpty not] message: 'Assert failed'.
              sel:: kws inject: '' into:[:s  :kwp | 
                                           params add: kwp last.
                                           s, kwp first token
                                          ].
              MessagePatternAST new selector: sel asSymbol parameters: params  ;
                                          start: kws first first start;
                                          right: params last
            ].
)
messagePattern ^ <MessagePattern> = (

^super messagePattern
    wrapper:[:pt :rt :tp  |
                tp isNil ifTrue:[rt isNil ifFalse:[pt end: rt concreteEnd]]
                         ifFalse:[pt end: tp concreteEnd].
                                 
                pt returnType: rt; typePattern: tp                    
               ].
)
method ^ <MethodAST> = (

^super method
     wrapper:[:msg :cb :ei  |
                   cb parameters: msg parameters.
                   MethodAST new pattern: msg 
                                      body: cb
                                      visibility: #public;
                                      start: msg start;
                                      right: cb                             
                ].
)
methodDecl ^ <MethodAST> = (

^super methodDecl
     wrapper:[:am :msg :eq :lp :cb :rp  |
                   cb parameters: msg parameters.                                                           
                   MethodAST new pattern: msg 
                                      body: cb
                                      visibility: #public;
                                      start: (am = nil
							ifTrue: [msg start]
							ifFalse: [am first start]);
                                      end: rp end                                                
                ].
)
mixinApplication ^ <MixinApplicationAST> = (
	^super mixinApplication wrapper:[:ms <MixinSpecifierAST> :mao <Token> :scc |
				MixinApplicationAST new 
		               mixinExpr: ms;
		               superclassExpr: scc;
		               left:  ms; right: scc
		"start: ms concreteStart;
		end: scc concreteEnd"
		]
)
moduleBody = (

 "^super moduleBody 
     wrapper:[:lp :sds :cds :rp |
	             ModuleBodyAST new vars: sds; classes: cds; start: lp start; end: rp end
                  ]."
)
moduleDeclaration = (

"^super moduleDeclaration
       wrapper:[:lid :mdkw :n :patt :eq :mb :el |
	               ModuleAST new name: n; constructor: patt; body: mb; exports: el;
	                                       start: mdkw start; end: el last end
                    ]"
)
nestedClassDecl = (

^super nestedClassDecl 
   wrapper:[:am  :cd  |   cd ]
)
parenthesizedExpression = (

^super parenthesizedExpression
    wrapper:[:l :e :r  | 
                e concreteStart: l start; concreteEnd: r end.
                e
               ].
)
returnStatement ^ <ReturnStatAST> = (

^super returnStatement
    wrapper:[:r :e  :od  |
                 OrderedCollection new add: (ReturnStatAST new expr:e; start: r start; right: e); yourself         
               ].
)
sideDecl ^ <SideAST> = (

^super sideDecl
     wrapper:[:lp   :classes :categories :rp  |    
                  NSSideAST new vars: OrderedCollection new cats: categories ; nestedClasses: classes;
                                 start: lp start; end: rp end                   
                ].
)
slotDecl ^ <VarDeclAST> = (

^super slotDecl
    wrapper:[:n :t  | 
                | end |
                end:: t isNil ifTrue:[n end] ifFalse:[t concreteEnd].
                (VarDeclAST name: n token asSymbol type: t)
                                   start: n start; end: end 
               ].
)
slotDef = (

^super slotDef 
    wrapper:[:am :sd :init  |   
                | start end slotClass expr msg | 
			start:: am = nil
				ifTrue: [sd start]
				ifFalse: [am first start].
                 init isNil ifTrue:[ end:: sd end. 
							slotClass:: MutableSlotDefAST. 
							msg:: MessageAST new send: #nil
                                                                        with: OrderedCollection new;
                                                                        start: sd start; end: sd end.
                                 		expr:: hereSendFromMsg: msg.    
							]
                              ifFalse:[end:: init last concreteEnd. 
	                                     expr:: init at: 2. 
	                                     slotClass:: (init at: 1) token = #'::=' ifTrue:[MutableSlotDefAST] 
	                                                                                                 ifFalse:[ImmutableSlotDefAST]
	                                   ].

		slotClass new
			accessModifier: (am = nil ifTrue: [ #protected ] ifFalse: [am first token]);
			slotDecl: sd; 
			initializer: expr;
			start: start;
			end: end 
               ].
)
slotName = (


^super slotName "change to create a here send"
          wrap:[:n   | | msg sn |
	             sn:: n token asSymbol.
	             (sn = #self or: [sn = #super or:[ sn = #outer or:[sn = #thisContext]]])  "thisContext will have to go at some point"
	               ifTrue:[(self pseudoVariableNode: sn) start: n start; end: n end]
	               ifFalse:[
                                 msg:: MessageAST new send: sn
                                                                        with: OrderedCollection new;
                                                                        start: n start; end: n end.
                                 self hereSendFromMsg: msg.   
                                 ]     
                 ].
)
statementSequence = (

^super statementSequence
     wrapper:[:e :rst  |
                  rst isNil
                    ifTrue:[OrderedCollection new add:e; yourself]
                    ifFalse:[OrderedCollection new add:e; addAll: rst; yourself]                
                ].
)
superclassClause = (

^super superclassClause
    wrapper:[:sn :msg |  | constructorCall |
	constructorCall:: msg isNil "default constructor is 'create'"
	                            ifTrue:[defaultConstructorCall start: sn start; end: sn end]
	                            ifFalse:[msg].
	NormalSendAST new recv: sn; msg: constructorCall; 
	                         start: sn start; end: constructorCall end
	]
)
symbolConstant = (

^super symbolConstant
     wrapper:[:h :s  | s start: h start].
)
toplevelClass = (

^super toplevelClass 
   wrapper:[:cat  :cd  |   
	| kat |
	cat isNil ifFalse:[ cd hdr category: cat val.
		cd start: cat start.
		].
	cd 
	]
)
tuple = (

^super tuple
   wrapper:[:lc :es :rc | 
               TupleAST new elements: es; start: lc start; end: rc end
              ].
)
unaryExpression ^ <ExpressionAST> = (

^super unaryExpression
     wrapper:[:o <ExpressionAST>  :s <List[MessageAST]> |
                 self assert:[s isNil not] message: 'Assert failed'.
                 s inject: o into:[:e <ExpressionAST> :umsg <MessageAST> |
                                    NormalSendAST new to: e 
                                                            send: umsg;
                                                            start: e start;
                                                            end: umsg end
                                   ]                
                ].
)
unaryMsgPattern ^ <MessagePatternAST> = (

^super unaryMsgPattern
          wrap:[:sel   <Symbol> |
                   MessagePatternAST new selector: sel sel parameters: OrderedCollection new;
                                               start: sel start; end: sel end
                 ].
)
unarySelector ^ <MessageAST> = (

^super unarySelector
     wrap:[:u  | 
             MessageAST new send: u token asSymbol with: OrderedCollection new;
                                              start: u start; end: u end 

            ].
)'lexical'
characterConstant = (

^super characterConstant
   wrap:[: t | CharAST new val: t token last; start: t start; end: t end].
)
decimalNum ^ <Number> = (

 
^super decimalNum wrapper:[:sgn :ip <List[Character]> :fp <Number> :ep <Integer> | 
	|  sum <Number> exp <Integer> f <Number>  | 
	f:: fp isNil ifTrue:[0] ifFalse:[fp].
	sum:: (computeDigits: ip) + f.
	sgn isNil ifFalse:[sum::  -1 * sum].
	exp:: ep isNil ifTrue:[0] ifFalse:[ep].
	sum* (10** exp).
	]
)
exponent ^ <Integer> = (

| exp <Integer> |
 
^super exponent wrapper:[:e :sgn :ds <List[Character]> | 
	exp:: computeDigits: ds.
	sgn isNil ifTrue:[exp] ifFalse:[-1*exp]
	].
)
extendedFraction ^ <List[Character]> = ( 
	^super extendedFraction wrapper:[:period  :ds  | ds]
)
fraction ^ <Number> = ( 
	^super fraction wrapper:[:period  :ds  | computeFraction: ds]
)
number = (

^super number
   wrap:[: t | NumberAST new val: t token; start: t start; end: t end].
)
radix ^ <Integer> = (

| exp <Integer> |
 
^super radix wrapper:[:ds  :r  | computeDigits: ds]
)
radixNum = (
^super radixNum
  wrapper:[:r <Integer> :sgn :ip <List[Character]> :fp <List[Character]> :ep <Integer> | 
	|  sum <Number> power <Integer>  exp <Integer> fs <List[Character]> | 
	assert:[ip isEmpty not] message:'internal error: integer part is empty'.
	fs:: fp isNil ifTrue:[OrderedCollection new] ifFalse:[fp].
	power:: ip size.
	sum:: (ip concatenate: fs) inject: 0 into:[:s <Number> :c <Character> | | d0 <Integer> d <Integer> |
		d0:: c asciiValue.
		(d0 > 47 and:[d0  < 58]) 
			ifTrue:[d:: d0 - 48] "c is a numeric digit"
			ifFalse:[
				(d0 > 64 and:[d0 < 71]) 
					ifTrue:[d:: d0 -55] "c is upper case"
					ifFalse:[
						assert:[d0 > 96 and:[d0 < 123]] 
						message: 'Internal error - illegal character in radix number'.
						d:: d0 - 87.
						]. "c is lower case"
				].	"c is a letter"
		assert:[d < r] message: 'Malformed number: digit exceeds radix'.
		power:: power - 1.  
		d * (r ** power) + s.			
		].
	sgn isNil ifFalse:[sum::  -1 * sum].
	exp:: ep isNil ifTrue:[0] ifFalse:[ep].
	sum* (10** exp).
	]
)
string = (

^super string
   wrap:[: t | StringAST new val: t token; start: t start; end: t end]. 
)
symbol = (

^super symbol
   wrap:[: t | SymbolAST new val: t token asSymbol; start: t start; end: t end].
)'parsing'
parse: input inContext: context  ifError: blk = (
 
	[ super parse: input inContext: context  ifError: blk ]
		on: ParserError do: [ :ex | ^blk value: ex message with: ex position ]
)'private'
charsToString: cs <List[Character]> ^ <String> = (


^cs inject: '' into:[:s <String>  :c <Character>  | s, c asString].
)
computeDigits: ds <List[Character]> ^ <Integer>= (

| power <Integer> |

power:: ds size. 
^ds inject: 0 into:[:s <Integer> :c <Character> | 
		power:: power - 1.  
		s + ((c asciiValue - 48) * (10 ** power))
		].
)
computeFraction: ds <List[Character]> ^ <Number>= (

| power <Integer> |

power:: 0. 
^ds inject: 0 into:[:s <Integer>  :c <Character> | 
		power:: power - 1.  
		s + ((c asciiValue - 48) * (10 ** power))
		].
)
defaultConstructorCall ^ <MessageAST> = (

"default constructor is 'create'"
^MessageAST new send: defaultConstructorSelector with: {}
)
defaultConstructorPattern ^ <MessagePatternAST> = (

"default constructor is 'new'"
^MessagePatternAST new selector: defaultConstructorSelector parameters: {}
)
defaultConstructorSelector ^ <Symbol> = (

"default constructor is 'new'"
^#new
)
defaultSuperCallAt: start <Integer> ending: end  <Integer> ^ <NormalSendAST> = (


| objId |

objId:: hereSendFromMsg: (MessageAST new send: #Object with:{}; start: start; end: end).
^NormalSendAST new recv: objId; msg: (defaultConstructorCall start: start; end: end)
)
hereNode ^<VariableAST> = (
	"Generates an AST representing the implicit receiver. We use a string so that we can represent a name that is not a legal identier"
	
	^VariableAST new name: #'@here'; start: 0; end: 0.
)
hereSendFromMsg: msg = (

" Build an implicit here send with the message msg"

^NormalSendAST new to: self hereNode  
                          send: msg;
                          start: msg start; end: msg end
)
mixinApplicationOf: mixinExpr on: superclassExpr = (


	mixinExpr isNormalSendNode ifFalse:
		[ ^ParserError new
			message: 'Expected send expression';
			position: mixinExpr start;
			signal ].
	mixinExpr msg isMessageNode ifFalse:
		[ ^ParserError new
			message: 'Expected message expression';
			position: mixinExpr msg start;
			signal ].
	mixinExpr msg sel = #mixin ifFalse:
		[ ^ParserError new
			message: 'Expected #mixin';
			position: mixinExpr msg start;
			signal ].
	^MixinApplicationAST new 
		mixinExpr: mixinExpr;
		superclassExpr: superclassExpr;
		left:  mixinExpr; right: superclassExpr
		"start: mixinExpr concreteStart;
		end: superclassExpr concreteEnd"
)
pseudoVariableNode: psvName = (

"generate a an AST representing self; used for implicit self sends"
self assert:[{#self. #super. #outer. #thisContext} includes: psvName] message: 'Assert failed'. "thisContext will have to go at some point"
^VariableAST new name: psvName asSymbol; start: 0; end: 0.
)'types'
blockReturnType = (


^super blockReturnType
   wrapper:[:h :rt | rt].
)
blockType = (

	"BlockTypeAST formals:return:"
	^super blockType wrapper:
		[:lb :tas :rb | 
			(tas isEmpty ifTrue: [
				(BlockTypeAST
					formals: {}
					return: nil)
			] ifFalse: [
				(BlockTypeAST
					formals: (tas asArray allButLast: 1)
					return: tas last)
			])
			start: lb start;
			end: rb end
		"GenericInvocationAST new 
			generic: (TypeIdAST new name: #Block); 
			arguments:  tas;
			start: lb start;
			end: rb end"]
)
newBlockTypeArgList = (


^super newBlockTypeArgList
   wrapper:[:tas :rt | 
               | targs |
                 targs:: tas collect:[:p | p last].
                 rt isNil ifTrue:[targs addLast: (TypeIdAST new name: #Object)]
                          ifFalse:[targs add: rt].
                 targs

              ].
)
nonEmptyBlockTypeArgList = (


^super nonEmptyBlockTypeArgList
   wrapper:[:tas :rt | 
               | targs |
                 targs:: OrderedCollection new addAll:tas; yourself.
                 rt isNil ifTrue:[targs addLast: (TypeIdAST new name: #Object)]
                          ifFalse:[targs add: rt last].
                 targs

              ].
)
parenthesizedTypeExpression = (


^super parenthesizedTypeExpression
   wrapper:[:lp :te :rp | 
               te concreteStart: lp start; concreteEnd: rp end.
               te
               ].
)
returnType = (

^super returnType 
   wrapper:[:h :rt | 
               rt concreteStart: h start.
               rt
              ].
)
type = (


^super type 
   wrapper:[:lb :te :rb |
               te concreteStart: lb start; concreteEnd: rb end.
               te
              ]
)
typeArguments ^  <{List[TypeExpr]. Token}> = (


^super typeArguments 
   wrapper:[:lb <Token>  :tas <List[TypeExpr]> :rb <Token>  |   
                 {tas. rb}
              ]
)
typeExpr = (


^super typeExpr 
   wrapper:[:lOperand :msg | 
               | operator rOperand |
                 msg isNil ifTrue:[ lOperand] 
                            ifFalse:[BinaryTypeOpAST new lOperand: lOperand; 
                                                                 operator: msg first token; 
                                                                 rOperand: msg last ;
                                                                 start: lOperand start;
                                                                 end: msg last end
                                     ]
              ]
)
typePrimary ^ <TypeIdAST | GenericInvocationAST> = (


^super typePrimary
   wrapper:[:g <Token> :tas <{List[TypeExpr]. Token}>  | 
               | tid <TypeIdAST>  |
                tid:: TypeIdAST new name: g token; start: g start; end: g end.
                tas isNil ifTrue:[tid]
                          ifFalse:[GenericInvocationAST new generic: tid; 
                                                                   arguments: tas first; 
                                                                   start: g start;
                                                                   end: tas last end
                                   ]
             ]
         
)
typeTerm ^ <TypeExpression> = (


^super typeTerm 
   wrapper:[:operand :operators | 
               operators inject: operand into:[:te <TypeExpression> :op | 
                                                    UnaryTypeOpAST new operand: te; operator: op token;
                                                                               start: te start; end: op end
                                                  ] 
              ]
)) : ()'as yet unclassified'
language = (

	^ 'Newspeak'
)) : ()