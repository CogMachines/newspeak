Newspeak3
'Newspeak'
class NewspeakCompilation usingPlatform: p asts: asts = (
(* Facilities common to each of the Newspeak compilers, such as scopes and the scope builder. A common Rewriter should eventually be located here as well.

It is intended that module definitions for each compilation target will be mixed-in to this module definition, and so inherit the facilities provided here. Until general mixin application is supported, the target-specific modules must use the same cheat used by BlocklessCombinatorialParsing of declaraing a superclass clause matching the factory of the class it will be later mixed-in to.


This module is derived from Newspeak2SqueakCompilation, which is why the pre-2013 copyrights apply.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2010 Gilad Bracha, Felix Geller and Ryan Macnak
Copyright 2011 Matthias Kleine, Ryan Macnak and Cadence Design Systems
Copyright 2013 Ryan Macnak

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 *)|
	protected Dictionary = p collections Dictionary.
	protected OrderedCollection = p collections OrderedCollection.

	protected ASTTool = asts ASTTool.
	protected AST = asts AST.
	protected BlockAST = asts BlockAST.
	protected CodeBodyAST = asts CodeBodyAST.
	protected MessageAST = asts MessageAST.
	protected MessagePatternAST = asts MessagePatternAST.
	protected MethodAST = asts MethodAST.
	protected NormalSendAST = asts NormalSendAST.
	protected TupleAST = asts TupleAST.
	
	namer = Namer new.
|)
(
class ClassEntry forDeclaration: cd atDepth: d = SymbolTableEntry forAST: cd atDepth: d (|
enclosingClass <ClassEntry> (* Currently unused. The intention is to fill this in so we have the information needed to avoid the outer send to a sibling problem.*)
|)
('as yet unclassified'
isClassDeclaration ^<Boolean> = (
	^true
)) : ()
class Compiler = (| protected scopeMap <Dictionary[AST, Scope]> ::= Dictionary new. |)
(
class Rewriter = ASTTool (
(* This class is intended to become a common rewriter for the Squeak, Dart and JavaScript compilers. It should handle

*self/super/outer/implicitReceiver/ordinary send or local read/write.
*local/non-local return.
*implicit return self
*[] is [nil]
*slot initializers
*simultaneous slots
*setter temp
*inlined messages
*large tuples?

The common rewriter should be sufficient for Dart and JavaScript. Squeak will require a second rewrite phase for closure analysis, which should be simpler than the current implementation because determining which locals need to be indirected or copied down will be easier when the tree already has distinguished sends that are reads/writes to locals.
*)|
	scopeStack <OrderedCollection[Scope]> = OrderedCollection new.
	valueExpected <Boolean> ::= true.
	inClosure <Boolean> ::= false.
|)
(
class BlockLocalReturnAST expression: e = ReturnAST expression: e ()
('as yet unclassified'
apply: visitor = (
	^visitor blockLocalReturnNode: self
)) : ()
class BooleanAST withValue: b = AST (|
	val = b.
|)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool boolNode: self
)
isBoolNode = (
	^true
)
name = (
	^val printString asSymbol
)
printOn: stream = (
	stream nextPutAll: 'BooleanAST: '.
	val printOn: stream.
)) : ()
class ConditionalAST if: cond is: ifTrue_ then: t else: e = AST (|
	condition <ExpressionAST> = cond.
	ifTrue = ifTrue_.
	then <CodeBodyAST> = t.
	else <CodeBodyAST> = e.
	forValue <Boolean>
|)
('as yet unclassified'
cond = (
	^condition
)'testing'
isExpressionNode ^<Boolean> = (
	^forValue
)'visiting'
apply: aTool <ASTTool> = (
	^aTool conditionalNode: self
)) : ('as yet unclassified'
emptyBlock = (
	| block body |
	body:: CodeBodyAST new parameters: {}; temporaries: {}; statements: {NilAST new}.
	block:: BlockAST new body: body.
	scopeMap at: block put: nil.
	scopeMap at: block body put: nil.
	^block
)
if: cond <ExpressionAST> is: val <Boolean> then: t <BlockAST> ^<Instance> = (
	^self if: cond is: val then: t else: emptyBlock
))
class EnclosingObjectAST = AST (
(* See mailing list for debate over 'outer Foo' as an expression. *)| depth <Integer> |)
('testing'
isExpressionNode ^<Boolean> = (
	^true
)'visiting'
apply: aTool <ASTTool> = (
	^aTool enclosingObjectNode: self
)) : ()
class ImplicitReceiverSendAST = SendAST (|
depth <Integer> (* Used on targets that don't have implicit receiver lookup at runtime. *)
|)
('visiting'
apply: aTool <ASTTool> = (
	^aTool implicitReceiverSendNode: self
)) : ()
class LocalReadAST of: var = AST (|
	variable = var.
|)
('as yet unclassified'
apply: visitor = (
	^visitor localReadNode: self
)
name = (
	^variable ast name
)) : ()
class LocalWriteAST to: var assign: val = AST (|
	variable = var.
	value = val.
|)
('as yet unclassified'
apply: visitor = (
	^visitor localWriteNode: self
)) : ()
class LoopAST = AST (
(* This node represents a while loop. The general form of the loop is:

prologue; while (cond = whileTrue) { body}

*)|
	prologue <CodeBodyAST>
	condition <CodeBodyAST>
	isWhileTrue <Boolean>
	body <CodeBodyAST>
	forValue <Boolean>
|)
('as yet unclassified'
do: n <Integer> timesRepeat: block <BlockAST> = (
	|
	skope <Scope>
	loopVarName <Symbol>
	var <ParameterAST>
	|
	skope:: scopeMap at: block body.

	(* introduce counter variable *)
	loopVarName:: '.i' asSymbol.
	var:: (ParameterAST name: loopVarName type: nil) start: block start; end: block end.	
	skope at: loopVarName put: (SlotEntry forDeclaration: var atDepth: 0) ifThere: [ halt ].
	assert:[block body parameters isEmpty].
	block body parameters add: var.

	(* translate n timesRepeat: [blockBody]  into 1 to: n do: [ :.i | blockBody] *)
	from: (NumberAST new val: 1; start: block start; end: block end) to: n do: block
)
from: first <AST> to: last <AST> by: step <AST> do: block <BlockAST> = (
	|
	blockScope		<Scope>	
	counterVar		<TemporaryAST>
	counter		<TemporaryVariableAST>
	limitNeeded		<Boolean>
	limitName		<Symbol>
	limitVar		<TemporaryAST>
	limit			<LiteralAST | VariableAST>
	condSel			<Symbol>
	condArg		<MutableList[ExpressionAST]>
	condExpr		<ExpressionAST>
	condBody		<CodeBodyAST>
	condStats		<MutableList[StatementAST]>
	incArg			<MutableList[ExpressionAST]>
	incExpr			<ExpressionAST>
	incStat			<StatementAST>
	|
	(* preliminaries *)
	assert: [ step isNumberNode and: [step val isInteger] ].
	assert: [ block isBlockNode ].
	blockScope:: scopeMap at: block body.

	(* loop counter (= block parameter) *)
	counterVar:: TemporaryAST name: block parameters removeFirst name type: nil.
	counter:: TemporaryAST name:  counterVar name  start: block start end: block end.
	
	(* introduce counter limit variable if needed *)
	(limitNeeded:: last isLiteralNode not)
		ifFalse: [
			(* no limit variable needed - use last directly since there's no computation involved *)
			limit:: last
		]
		ifTrue: [
			limitName:: '.limit' asSymbol.
			limitVar:: TemporaryDeclarationAST name: limitName type: nil.
			limitVar start: block start; end: block end.
			prologue temporaries add: limitVar.
			blockScope at: limitName put: (SlotEntry forDeclaration: limitVar atDepth: 0) ifThere: [ assert: [false] ].
			limit:: TemporaryAST name: limitName start: block start end: block end.
		].
	
	(* setup loop condition => introduce condition block for whileTrue: loop *)
	condSel::
		step val < 0
			ifTrue: [ #<= ]
			ifFalse: [ #>= ].
	condArg:: OrderedCollection new add: counter ; yourself.
	condExpr:: NormalSendAST new to: limit send: (MessageAST new send: condSel with: condArg).
	(* limit <= counter OR limit >= counter *)
	condStats:: OrderedCollection new add: condExpr ; yourself.
	condBody::
		CodeBodyAST new
			parameters: OrderedCollection new;
			temporaries: OrderedCollection new;
			statements: condStats;
			start: block start; end: block end.

	(* add counter increment to loop body *)
	incArg:: OrderedCollection new add: counter ; yourself.
	incExpr:: NormalSendAST new to: step send: (MessageAST new send: #+ with: incArg).
	incExpr start: block start; end: block end.
	(* step + counter *)
	incStat:: AssignmentAST new to: counter assign: incExpr. 
	incStat start: block start; end: block end.
	(* counter := step + counter *)
	block body statements add: incStat.

	(* setup prologue *)
	prologue temporaries add: counterVar.
	prologue statements add: (AssignmentAST new to: counter assign: first).
	(* counter := first *)
	limitNeeded ifTrue: [
		(* initialize limit variable - note that this must be done *after* setting up the counter because of possible side effects *)
		prologue statements add: (AssignmentAST new to: limit assign: last). (* .limit := last *)
	].
	
	(* initialize loop instance variables *)
	condition:: condBody.
	isWhileTrue:: true.
	body:: block body
)
from: first <AST> to: last <AST> do: block <BlockAST> = (
	from: first to: last by: (NumberAST new val: 1) do: block
)
repeat: block <BlockAST> = (
    assert: [block isBlockNode].
    condition:: block body.
    condition statements add: ((BooleanAST withValue: true) start: condition end; end: condition end).
    isWhileTrue:: true.
    body:: nil
)
while: v <Boolean> do: b <BlockAST> = (
    assert: [b isBlockNode].
    condition:: b body.
    isWhileTrue:: v.
    body:: nil
)
while: b1 <BlockAST>  is: v <Boolean> do: b2 <BlockAST> = (
    assert: [b1 isBlockNode].
    assert: [b2 isBlockNode].
    condition:: b1 body.
    isWhileTrue:: v.
    body:: b2 body
)'testing'
isExpressionNode ^<Boolean> = (
	^forValue
)'visiting'
apply: aTool <ASTTool> = (
	^aTool loopNode: self
)) : ()
class MethodLocalReturnAST expression: e = ReturnAST expression: e ()
('as yet unclassified'
apply: visitor = (
	^visitor methodLocalReturnNode: self
)) : ()
class NilAST = AST ()
('as yet unclassified'
apply: aTool <ASTTool > = (
	^aTool nilNode: self
)
isNilNode = (
	^true
)
name = (
	^#nil
)) : ()
class NonlocalReturnAST expression: e = ReturnAST expression: e ()
('as yet unclassified'
apply: visitor = (
	^visitor nonLocalReturnNode: self
)) : ()
class OrdinarySendAST to: rcvr send: msg = AST (|
	receiver = rcvr.
	message = msg.
|)
('as yet unclassified'
apply: aTool <ASTTool> = (
	^aTool ordinarySendNode: self
)
msg = (
	^self message
)
recv = (
	^self receiver
)) : ()
class OuterSendAST = SendAST (|
depth <Integer>
|)
('visiting'
apply: aTool <ASTTool> = (
	^aTool outerSendNode: self
)) : ()
class ParameterAST name: n type: t = AST (|
name = n.
type = t.
|)
('as yet unclassified'
isVarDeclNode ^<Boolean> = (
	^true
)
variableClass = (
	halt.
	^ParameterAST
)) : ()
class ReceiverAST = AST ()
('as yet unclassified'
apply: tool = (
	^tool receiverNode: self
)
isExpressionNode = (
	^true
)) : ()
class ReturnAST expression: e = AST (|
expression <AST> = e.
|)
('as yet unclassified'
expr = (
	^self expression
)
isExpressionNode = (
	^false
)
isReturnStatNode = (
	^true
)) : ()
class SelfSendAST = SendAST ()
('visiting'
apply: aTool <ASTTool> = (
	^aTool selfSendNode: self
)) : ()
class SendAST = AST (|
	message <MessageAST>
|)
('as yet unclassified'
isExpressionNode = (
	^true
)
msg = (
	^self message
)) : ()
class SuperSendAST = SendAST ()
('visiting'
apply: aTool <ASTTool> = (
	^aTool superSendNode: self
)) : ()
class TemporaryAST name: n type: t = AST (| name = n. type = t. |)
('as yet unclassified'
isTemporaryAST = (
	#BOGUS.
	^true
)
isVarDeclNode ^<Boolean> = (
	^true
)
variableClass = (
	halt.
	^TemporaryAST
)) : ()'as yet unclassified'
applyForEffectTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: false.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
applyForValueTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: true.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
blockNode: node <BlockAST> = (
	| rewrittenBlock <BlockAST> last <AST> |
	inClosureDuring:
		[rewrittenBlock:: rewriteInlinedBlockNode: node forValue: true.
		last:: rewrittenBlock body statements last.
		(last isReturnStatNode or: [last isBlockLocalReturnAST]) ifFalse:
			[(* The last expression in a block is returned by it. *)
			rewrittenBlock body statements removeLast.
			rewrittenBlock body statements add:
				((BlockLocalReturnAST expression: last) start: last start; end: last end)]].
	^rewrittenBlock
)
canInlineSeqexps ^<Boolean> = (
	^true (* No on JS and Dart *)
)
charNode: node <CharAST> = (
	^node
)
codeBodyNode: node <CodeBodyAST> = (
	(* Move slot initializers to statements. Simultaneous slots. *)
	
	| bodyScope temporaries statements result |
	bodyScope:: pushScopeForNode: node.
	
	temporaries:: node temporaries collect: 
		[:t <VarDeclAST> |
		(TemporaryAST name: t name type: t type) 
			start: t start; end: t end].
	temporaries do: 
		[:t <TemporaryAST> | 
		(bodyScope at: t name) ast: t].
	
	statements:: OrderedCollection new.
	#TODO. (* siml slots rewrite *)
	node temporaries with: temporaries do: 
		[:varDecl <VarDeclAST> :temp <TemporaryAST> |
		varDecl initializer ifNotNil: [:it <ExpressionAST> |
			statements add: (AssignmentAST
				to: temp
				assign: (self applyForValueTo: it))]].
	node statements keysAndValuesDo:
		[:index :statement | 
		| rewritten |
		rewritten:: (index = node statements size and: [valueExpected])
			ifTrue: [applyForValueTo: statement]
			ifFalse: [applyForEffectTo: statement].
		statements add: rewritten].

	popScope.
	result:: CodeBodyAST new
		parameters: node parameters
		temporaries: temporaries
		statements: statements.
	scopeMap at: result put: bodyScope.
	^result
)
inClosureDuring: block = (
	| original |
	original:: inClosure.
	inClosure:: true.
	^block ensure: [inClosure:: original]
)
isHereNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #'@here'
)
isInlineableConditional: node <NormalSendAST> ^<Boolean> = (
	canInlineSeqexps ifFalse: [valueExpected ifTrue: [^false]].
	({#ifTrue:. #ifFalse:. #ifTrue:ifFalse:. #ifFalse:ifTrue:} includes: node msg sel)
	     ifFalse: [^false].
	node msg args do: [:arg <AST> | (isRemovableBlock: arg withArgs: 0) ifFalse: [^false]].
	^true
)
isInlineableLoop: node <NormalSendAST> ^<Boolean>= (
	| selector <Symbol>  args |
	canInlineSeqexps ifFalse: [valueExpected ifTrue: [^false]].
	selector:: node msg sel.
	args:: node msg args.
	({#whileTrue. #whileFalse. #whileTrue:. #whileFalse:. #repeat} includes: selector) ifTrue:
		[args do:
			[:each |
			(isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
		^isRemovableBlock: node recv withArgs: 0].
	
	(selector = #timesRepeat:) ifTrue:[^isRemovableBlock: args last withArgs: 0].
	({#to:do:. #to:by:do:}  includes:  selector) ifFalse:[^false].
	(isRemovableBlock: args last withArgs: 1) ifFalse:[^false].
	(selector = #to:do:) ifTrue:[^true].
	^args size = 3
)
isOuterNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #outer
)
isRemovableBlock: block <BlockAST> withArgs: numArgs <Integer> ^<Boolean> = (
	(* Answers true if block can be removed (inlined) within another block. *)
	block isBlockNode ifFalse: [^false].
	block parameters size = numArgs ifFalse: [^false].
	^true
)
isSuperNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #super 
)
messageNode: node <MessageAST> ^<MessageAST> = (
    ^MessageAST new
		send: node sel
		with: (node args collect: [:arg | applyForValueTo: arg]);
		start: node start;
		end: node end
)
messagePatternNode: node <MessagePatternAST> ^<MessagePatternAST> = (
	| params <OrderedCollection[ParameterAST]> patternScope <Scope> |
	params:: node parameters collect:
		[:p <VarDeclAST> | 
		(ParameterAST name: p name type: p type)
			start: p start;
			end: p end].
	patternScope:: scopeMap at: node.
	params do: [:p | (patternScope at: p name) ast: p].
	^MessagePatternAST new
		selector: node selector parameters: params;
		start: node start;
		end: node end.
)
methodNode: node <MethodAST> = (
	(* Need setter temp? Implicit ^self? *)
	| pattern body accessModifier result |
	pattern:: node pattern apply: self.
	body:: node body apply: self.
	(body statements isEmpty or: [body statements last isReturnStatNode not]) 
		ifTrue:	[body statements add:
					(MethodLocalReturnAST expression: ReceiverAST new)].
	assert: [inClosure not] message: ''.
	result:: MethodAST new
		pattern: pattern
		body: body
		accessModifier: node accessModifier.
	scopeMap at: result put: (scopeMap at: node).
	^result
)
mixinClassNode: node <MixinClassNode> = (
	#BOGUS. (* Should at least be mixed-in by NS2Squeak. *) 
	^node
)
normalSendNode: node <NormalSendAST> ^<AST> = (
	
	(isHereNode: node recv)
		ifTrue: [^processImplicitReceiverSend: node].
	(isOuterNode: node recv)
		ifTrue: [^processOuterSend: node].
	(isSuperNode: node recv)
		ifTrue: [^processSuperSend: node].	
	(isInlineableConditional: node)
		ifTrue: [^processInlineableConditional: node].
	(isInlineableLoop: node)
		ifTrue: [^processInlineableLoop: node].
	
	(* And lo, we really have a normal send. *)
	^(OrdinarySendAST
		to: (node recv apply: self) send: (node msg apply: self))
		start: node start; end: node end
)
numberNode: node <NumberAST> = (
	^node
)
processImplicitReceiverSend: node <NormalSendAST> = (
	(* implicit outer, local variable, debug mapped variable, true/false/nil *)
	| selector = node msg sel. binding <AST> |
	binding:: currentScope at: selector ifAbsent: [MessageAST new].
	
	binding isMessagePatternNode ifTrue:
		[ (* This is a message send for a lexically defined method. *)
		^processImplicitReceiverSend: node msg atDepth: binding depth].
	
	binding isVarDeclNode
		ifTrue: [^processLocalAccess: node msg of: binding].
	binding isDebugMappedLocalEntry
		ifTrue: [halt. ^processMappedVariable: aMsg decl: binding].
		
	({#true. #false. #nil. #self. #thisContext} includes: selector)
		ifTrue: [ (* Is it possible for these to show up above? If not, then these shouldn't be handled by processLocalAccess:decl:. *)
			^processLocalAccess: node msg of: nil].

	^ processImplicitReceiverSend: binding atDepth: 0
)
processImplicitReceiverSend: msg <MessageAST> atDepth: depth <Integer> = (
	^ImplicitReceiverSendAST new
		depth: depth;
		message: (msg apply: self)
)
processInlineableConditional: node <NormalSendAST> = (
	|
	receiver = node recv apply: self.
	selector = node msg sel.
	numArgs = node msg args size.
	arg1 = numArgs > 0 ifTrue: [rewriteInlinedBlockNode: (node msg args at: 1) forValue: valueExpected].
	arg2 = numArgs > 1 ifTrue: [rewriteInlinedBlockNode: (node msg args at: 2) forValue: valueExpected].
	|
	selector = #ifTrue:
		ifTrue: [^ConditionalAST if: receiver is: true then: arg1].
	selector = #ifFalse:
		ifTrue: [^ConditionalAST if: receiver is: false then: arg1].
	selector = #ifTrue:ifFalse:
		ifTrue: [^ConditionalAST if: receiver is: true then: arg1 else: arg2].
	selector = #ifFalse:ifTrue: 
		ifTrue: [^ConditionalAST if: receiver is: false then: arg1 else: arg2].
	assert: [false] message: 'Unknown conditional selector'
)
processInlineableLoop: node <NormalSendAST> ^<LoopAST> = (
	|
	rcvr = node recv.
	msg = node msg.
	sel = msg sel.
	numArgs = msg args size.
	arg1 = numArgs >= 1 ifTrue: [msg args at: 1].
	arg2 = numArgs >= 2 ifTrue: [msg args at: 2].
	arg3 = numArgs >= 3 ifTrue: [msg args at: 3].
	|
	
	sel = #whileTrue ifTrue: [^LoopAST new
		while: true
		do: (rewriteInlinedBlockNode: rcvr forValue: true)].
	sel = #whileFalse ifTrue: [^LoopAST new
		while: false
		do: (rewriteInlinedBlockNode: rcvr forValue: true)].
	sel = #whileTrue: ifTrue: [^LoopAST new
		while: (rewriteInlinedBlockNode: rcvr forValue: true) 
		is: true
		do: (rewriteInlinedBlockNode: arg1 forValue: false)].
	sel = #whileFalse: ifTrue: [^LoopAST new
		while: (rewriteInlinedBlockNode: rcvr forValue: true) 
		is: false
		do: (rewriteInlinedBlockNode: arg1 forValue: false)].
	
	sel = #repeat ifTrue: [^LoopAST new
		repeat: (rewriteInlinedBlockNode: rcvr forValue: false)].
	
	sel = #timesRepeat: ifTrue: [^LoopAST new
		do: (rcvr apply: self)
		timesRepeat: (rewriteInlinedBlockNode: arg1 forValue: false)].
	
	sel = #to:do: ifTrue: [^LoopAST new
		from: (rcvr apply: self)
		to: (arg1 apply: self)
		do: (rewriteInlinedBlockNode: arg2 forValue: false)].
	
	sel = #to:by:do: ifTrue: [^LoopAST new
		from: (rcvr apply: self)
		to: (arg1 apply: self)
		by: (arg2 apply: self)
		do: (rewriteInlinedBlockNode: arg3 forValue: false)].
	
	assert: [false] message: 'Unknown loop selector'
)
processInlineableSend: node <NormalSendAST> = (
	halt
)
processLocalAccess: msg <MessageAST> of: decl <SlotEntry> = (
	^msg sel last = $:
		ifTrue: [processLocalWrite: msg to: decl]
		ifFalse: [processLocalRead: msg from: decl]
)
processLocalRead: message <MessageAST> from: declaration <SlotEntry> = (
	assert: [message arguments isEmpty] message: ''.
	
	message selector = #self ifTrue: [^ReceiverAST new].
	message selector = #nil ifTrue: [^NilAST new].
	message selector = #false ifTrue: [^(BooleanAST withValue: false) start: message start; end: message end].
	message selector = #true ifTrue: [^(BooleanAST withValue: true) start: message start; end: message end].
	message selector = #thisContext ifTrue: [^ContextAST new].
	
	assert: [declaration isNil not] message: ''.
	^(LocalReadAST of: declaration)
		start: message start;
		end: message end
)
processLocalWrite: message <MessageAST> to: declaration <VarDeclAST> = (
	| var <VariableAST> varName <String> |
	assert: [message args size = 1] message: ''.
	varName:: (message selector asString copyWithSize: (message selector size -1)) asSymbol.
	assert: [(currentScope at: varName) isTemporaryAST] message: ''.
	
	var:: (TemporaryAST name: varName)
		start: message start; end: message end.

	^(AssignmentAST
		to: var assign: (applyForValueTo: message args first))
		start: message start;
		end: message end    
)
processSuperSend: node <NormalSendAST> = (
	^SuperSendAST new
		message: (node message apply: self)
)
returnStatNode: node <ReturnStatAST> = (
	^(inClosure ifTrue: [NonlocalReturnAST] ifFalse: [MethodLocalReturnAST])
		expression: (applyForValueTo: node expr)
)
rewriteInlinedBlockNode: node <BlockAST> forValue: forValue <Boolean> ^ <BlockAST> = (
(* An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined. *)
	| 
	rewrittenNode <BlockAST> 
      params <Collection[ParameterAST]>  
      bodyScope <Scope> 
	| 
	(* this shouldn't be handled here, but I'm not sure where the block / codebody 
	comes from. *)
	node body start isNumber
		ifFalse: [node body start: node start. node body end: node end].
	
	params:: node parameters collect:
		[:p <VarDeclAST> |
		(ParameterAST name: p name type: p type) start: p start; end: p end].
	bodyScope:: scopeMap at: node body.
	params do: [:each | (bodyScope at: each name) ast: each].
	rewrittenNode:: BlockAST new body: (node body apply: self).
	rewrittenNode start: node start; end: node end.
	rewrittenNode body parameters: params.
	node body statements isEmpty ifTrue:
		[rewrittenNode body statements add: (NilAST new start: node body start; end: node body end)].
	scopeMap at: rewrittenNode put: (scopeMap at: node).
	^rewrittenNode
)
setterSendNode: node <SetterSendAST> ^<AST> = (
	|
	setterBinding <AST>
	sTemp <TemporaryVariableAST> 
	sTempAssign <AssignmentAST> 
	message <MessageAST> 
	send <NormalSendAST>  
	cb <CodeBodyAST>  
	|
	setterBinding:: currentScope at: node msg sel ifAbsent: [MessageAST new].
	setterBinding isVarDeclNode
		ifTrue: [^processLocalAccess: node msg of: setterBinding].
	(* This is an assignment to a temporary - no special handling needed *)
	
	(* Otherwise, rewrite the setter send as follows:
		setter:: exp 
		=>
		t:=exp. setter: t. t
	This is much less wasteful than creating a block etc. per the spec. *)

	sTemp:: (TemporaryAST name: namer setterTemp) start: 0; end: 0.
	sTempAssign:: AssignmentAST to: sTemp assign: (node msg args first apply: self).  
	(* t := exp *)
	message:: MessageAST new sel: node msg sel; args: {sTemp}.
	send:: (NormalSendAST new to: node recv send: message) apply: self.
	(* setter: t *)
	cb:: (CodeBodyAST new 
			parameters: OrderedCollection new;
			temporaries: {};
			statements: {sTempAssign. send. sTemp}).(* t:=exp. setter: t. t *)
	scopeMap at: cb put: currentScope.
	^cb
)
stringNode: node <StringAST> = (
	^node
)
symbolNode: node <SymbolAST> = (
	^node
)
tupleNode: node <TupleAST> = (
	node elements size > 10 ifTrue: [halt].
	^TupleAST new elements: (node elements collect: [:e | applyForValueTo: e])
)
variableNode: aNode <VariableAST> = (
	#BOGUS. (* Duplication with processLocalRead: *)
	assert: [aNode start isNumber] message: ''.
	aNode name = #self ifTrue:
		[^ReceiverAST new start: aNode start; end: aNode end].
	aNode name = #nil ifTrue:
		[^NilAST new start: aNode start; end: aNode end].
	aNode name = #true ifTrue:
		[^(BooleanAST withValue: true) start: aNode start; end: aNode end].
	aNode name = #false ifTrue:
		[^(BooleanAST withValue: false) start: aNode start; end: aNode end].		
	aNode name = #thisContext ifTrue:
		[^ContextAST new start: aNode start; end: aNode end].
	(* recognize inst vars for accessor methods? handle temps etc. *)
	assert: [(aNode name = #super) not] message: '"super" is not a valid expression'.
	assert: [(aNode name = #outer) not] message: '"outer" is not a valid expression'.
	halt.
	^aNode
)'scopes'
currentScope ^<Scope> = (
	^scopeStack last
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
pushScope: scope <Scope> = (
	^scopeStack addLast: scope
)
pushScopeForNode: node <AST> = (
	^pushScope: (scopeMap at: node)
)) : ()
class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = ASTTool (
(* The scope builder is a visitor on the AST. It computes a tree of scopes that shadows the AST itself. More precisely, it computes a mapping from ASTs to their scopes. This allows us to get to the appropriate scope for an abstract syntax node without polluting the AST with extraneous data like scopes.

We could associate each node in the AST with the scope in which it is found, but this would be overkill. Instead, only nodes that actually introduce new scopes (such as class sides, message patterns, code bodies and blocks) actually get mapped in this manner. The intent is that later phases of compilation will visit the tree and look up the scopes at the points where they are introduced.

The builder starts at a given node, in the context of some mixin, described by a mirror. This is because, in an incremental environment, we may not have the complete AST for a module, but instead be asked to process a part of that module, such as a nested class, slot definition or method. The surrounding scope can be computed from the mirror representing the immediately enclosing mixin.

Then we traverse the tree, creating and populating new scopes as needed. We maintain a stack of scopes (scopeStack) that initially contains only the surrounding scope. Scopes get pushed on to the stack when we encounter a node that introduces a scope, and popped when we finish with that node. The scopes are chained to their super scopes (the scope below them on the stack).

A possible optimization is to avoid a traversal of an entire side of a class.
One can process only a side without its subtrees (i.e., methods and nested classes). These can be visited later, as long as we ensure that the processing of the subtree begins with a proper super scope on top of the scope stack. *)| 
scopeStack <OrderedCollection[Scope]> = OrderedCollection new.
currentDepth <Integer> ::= initialDepth. (* The lexical nesting level of the class declaration currently being visited; top-level classes are level 0. *)
|pushScope: initialScope)
('access'
visitNode: aNode <AST> within: m <ClassDeclarationMirror> ^ <Dictionary[AST, Scope]> = (
   pushScope: (buildScopeFor: m).
   aNode apply: self.
   ^scopeMap
)'as yet unclassified'
buildScopeFor: cd <ClassDeclarationMirror> ^<Scope> = (
	^prvtScopeFor: cd.
)
enclosingMixinsOf: m <ClassDeclarationMirror> ^<Collection[ClassDeclarationMirror]> = (
	(* top to bottom *)
	| current mixins |
	mixins:: OrderedCollection new.
	current:: m.
	[current isNil] whileFalse:
		[mixins addFirst: current.
		current: current enclosingClass].
	^mixins
)
prvtScopeFor: c <ClassDeclarationMirror> ^<Scope> = (
	(* When incrementally compiling a nested class, we need to reconstruct its scope. *)
	| 
	scope <Scope> 
	outerMixins <Collection[ClassDeclarationMirror]>
	depth <Integer>
	|

	outerMixins:: enclosingMixinsOf: c. (* Should use a cleaner API *)
	currentDepth:: outerMixins size - 1.
	depth:: 0.
	
	outerMixins do:
		[:o <ClassDeclarationMirror> |
		scope:: Scope new superScope: scope.
	
		depth = 0 ifTrue: [
			(* Top level to pretend it has an accessor at a level enclosing it. *)
			scope
			at: o simpleName asSymbol
			put: (SymbolTableEntry
				forMessage: o simpleName asSymbol
				atDepth: depth-1)].
	
		(selectorsFor: o) do: 
			[:sel |
			scope
			at: sel 
			put: (SymbolTableEntry forMessage: sel atDepth: depth)].
		
		depth:: depth + 1].
	
	^scope
)
selectorsFor: m <ClassDeclarationMirror> ^ <Collection[Symbol]> = (
	(* Should add a convenience method to mirrors to do this *)
	| result <Collection[Symbol]> |
	result:: OrderedCollection new.
	result addAll: (m instanceSide methods collect: [:s <MethodMirror> | s name]).
	result addAll: (m instanceSide slots collect: [:s <SlotMirror> | s name]).
	result addAll: ((m instanceSide slots select: [:s | s isMutable]) 
	                         collect: [:s <SlotMirror> | s name, ':']).
	result addAll: (m instanceSide nestedClasses
		collect: [:s <ClassDeclarationMirror> | s simpleName]).
	^result
)'node traversal'
blockNode: aNode <BlockAST> = (
	| parameterScope <Scope> |
	parameterScope:: Scope new.
	(* establish parameter scope *)
	aNode parameters do:
		[:parameter <VarDeclAST> | 
			parameterScope
			at: parameter name
			put: (SlotEntry
				forDeclaration: parameter
				atDepth: currentDepth)].
	nestScope: parameterScope.
	
	(* visit body *)
	aNode body apply: self.
	scopeMap at: aNode put: (scopeMap at: aNode body).
	
	popScope (* pop the parameter scope, ps *)
)
cascadedSendNode: aNode <CascadedSendAST> = (

	(* generic traversal code *)
	(* visit receiver and messages *)
	aNode prevSend apply: self.
	aNode msg apply: self.
)
charNode: aNode <CharAST> = (
	(* leaf, do nothing *)
)
classHeaderNode: aNode = (

	aNode constructor apply: self.
	aNode slots do: [:s | s initializer ifNotNil: [:i | i apply: self]].
	aNode initExprs do: [:e | e apply: self].
)
classNode: aNode <ClassDeclarationAST> = (

	| vs <Scope> |
	
	currentScope
		at: aNode name 
		put: (ClassEntry forDeclaration: (MessagePatternAST new selector: aNode name) atDepth: currentDepth).
		
	vs:: Scope new. (* establish instance side scope *)
	currentDepth:: currentDepth + 1.
	aNode hdr slots do: [:v <SlotDeclAST> | 
		| se = SlotEntry forDeclaration: (MessagePatternAST new selector: v name) atDepth: currentDepth. |
		vs at: v name put: se. (* getter *)
		vs at: (setterSelectorFor: v) put: se. (* setter *)].
		
	self nestScope: vs.
  		aNode instanceSide apply: self.
	popScope.
	self nestScope: Scope new. (* establish class side scope *)
  		aNode classSide apply: self.
	popScope.
	currentDepth:: currentDepth - 1.
)
codeBodyNode: aNode <CodeBodyAST> = (
	| ts <Scope> |
	(* establish local slot scope *)

	ts:: Scope new.
	aNode temporaries do:[:t <SlotDefAST> | 
		|svd|
		svd:: SlotEntry forDeclaration: t slotDecl atDepth: currentDepth.
		ts at: t name put: svd. (* getter *)
		ts at: (setterSelectorFor: t) put: t slotDecl. (* setter *)
		ts at: ('setOnce`',t name) asSymbol put: svd. (* trick so lookups of the initializer for immutables will find the right slot *)].

	nestScope: ts.
	scopeMap at: aNode put: ts.
	(* visit statements *)
	aNode temporaries do: [:t | 	t initializer isNil ifFalse: [t initializer apply: self]].
	aNode statements do:[: s <ReturnStatementAST | SendAST>  | s apply: self].
	popScope.
)
keywordPatternNode: n = (
	(* leaf, do nothing *)
)
literalPatternNode: n = (
	(* leaf, do nothing *)
)
messageNode: aNode <MessageAST> = (
	(* generic traversal code *)
	(* visit arguments *)
	aNode args do: [:arg <ExpressionAST> | arg apply: self]
)
messagePatternNode: aNode <MessagePatternAST> = (

	| parameterScope <Scope> |
	parameterScope:: Scope new.
	(* establish parameter scope *)
	aNode parameters do:
		[:parameter <VarDeclAST> | 
		parameterScope
		at: parameter name
		put: (SlotEntry
			forDeclaration: parameter
			atDepth: currentDepth)].
	
	nestScope: parameterScope.
	scopeMap at: aNode put: parameterScope.
	(* the pattern scope, ps, must be popped by the caller *)
	(* establish type parameter scope - skip for now *)
)
methodNode: aNode <MethodAST> = (

	(* register method in current scope *)
	currentScope
		at: aNode pattern selector
		put: (MethodEntry forDeclaration: aNode pattern atDepth: currentDepth).

	(* visit pattern *)
	aNode pattern apply: self.
	
	(* visit body *)
	aNode body apply: self.
	scopeMap at: aNode put: (scopeMap at: aNode body).

	popScope (* Pop pattern scope *)
)
mixinApplication: node <MixinApplicationAST> = (

	node mixinExpr apply: self.
	node superclassExpr apply: self
)
mixinClassNode: aNode = (
	(* leaf, do nothing *)
)
normalSendNode: aNode <NormalSendAST> = (
	(* generic traversal code *)
	(* visit recvr and msg *)
	aNode recv apply: self.
	aNode msg apply: self.
)
numberNode: aNode <NumberAST> = (
	(* leaf, do nothing *)
)
returnStatNode: aNode <ReturnStatAST> = (
	(* generic traversal code *)
	(* visit expression *)
	aNode expr apply: self
)
setterSendNode: aNode <SetterSendAST> = (
	(* visit recvr and msg *)
	aNode recv apply: self.
	aNode msg apply: self.
)
sideNode: aNode <SideAST> = (

	scopeMap at: aNode put: currentScope.

	(* visit methods *)
	aNode categories do:
		[:c <CategoryAST> | 
		c methods do:
			[:m <MethodAST> | m apply: self]].
	
	(* visit nested classes *)
	aNode nestedClasses do:
		[:nc <ClassDeclarationAST> | nc apply: self].
)
stringNode: aNode <StringAST> = (
	(* leaf, do nothing *)
)
symbolNode: aNode <SymbolAST> = (
	(* leaf, do nothing *)
)
tupleNode: aNode <TupleAST> = (
	(* visit elements *)
	aNode elements do: [:e <ExpressionAST> | e apply: self]
)
varDeclNode: aNode <VarDeclAST> = (
	(* Do nothing. It could arguably add aNode's data to current scope - but in practice, the context knows better how to do this. *)
)
variableNode: aNode <VariableAST> = (
	assert: [aNode name = #'@here' or: [isPseudoVariableNode: aNode]]
	message: 'Unexpected variable name'.
)
wildcardPatternNode: node = (
	(* leaf, do nothing *)
)'private'
currentScope ^ <Scope> = (
	^scopeStack last
)
isPseudoVariableNode: aNode <VariableAST> ^<Boolean> = (
	^aNode name = #self
		or: [aNode name = #super
		or: [aNode name = #outer
		or: [aNode name = #thisContext]]]
)
nestScope: s <Scope> = (
	(* Hook up a new lexically nested scope, and push onto the scope stack *)
	s superScope: currentScope.
	pushScope: s
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
pushScope: s <Scope> = (
	scopeStack addLast: s
)) : ('as yet unclassified'
new ^<Instance> = (
	^self nestedIn: Scope new atLevel: 0
))'as yet unclassified'
setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	subclassResponsibility
)
test: tree <MethodAST> = (
 	tree apply: (ScopeBuilder nestedIn: Scope new atLevel: 0).
	^tree apply: RewriterWIP new
)) : ()
class MethodEntry forDeclaration: decl atDepth: d = SymbolTableEntry forAST: decl atDepth: d (|
|)
() : ()
class Namer = ()
('as yet unclassified'
setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	^((slot isMutableSlot ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), slot name, ':') asSymbol.
)
setterTemp = (
	^#'@setterTemp'
)) : ()
class Scope = (
(* A generic scope facility. *)|
superScope <Scope>
bindings <Map[Symbol, SymbolTableEntry]> = Dictionary new.
|)
('access'
at: key <Symbol> ^<SymbolTableEntry> = (
	(* Answers the value associated with aKey in this or one the super scopes or fails if aKey is absent. *)
	^self at: key ifAbsent: [Error signal: 'Key ', key, ' not found!']
)
at: key <Symbol> ifAbsent: blk <[X def]> ^<SymbolTableEntry | X> = (
	(* Answers the value associated with aKey in this or one of the superScopes or the value of aBlock if aKey is absent. *)
	(* Optimization note: This is written using [nil] blocks to avoid passing non-clean blocks dynamically down the scope structure. *)

	| val <T> |
	(val:: self bindings at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	self superScope isNil
		ifTrue: [ ^blk value ].
	(val:: self superScope at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	^blk value
)
at: key <Symbol> put: value <SymbolTableEntry> = (
	^self bindings at: key put: value
)
at: key <Symbol> put: value <SymbolTableEntry> ifThere: aBlock <[X def]> ^<SymbolTableEntry | X>= (

	(* Associates aValue with aKey and answers aValue if aKey
    was absent. Otherwise answers the value of aBlock. *)
	| wasAbsent ::= false. |
	bindings at: key ifAbsent: [bindings at: key put: value. wasAbsent:: true].
	^wasAbsent
		ifTrue: [value]
		ifFalse: [aBlock value]
)
clear = (
	self bindings keys do: [:k | self bindings removeKey: k].
)
depth ^<Integer> = (
	superScope isNil ifTrue: [^0].
	^superScope depth + 1.
)
includesIndex: key <Symbol> ^<Boolean> = (
	(* should this search the superscope? *)
	^self bindings includesKey: key
)
includesIndexLocally: key <Symbol> ^<Boolean> = (
	^self bindings includesKey: key.
)
removeKey: key <Symbol> = (
	self bindings removeKey: key
)
removeKey: key ifAbsent: blk = (
	self bindings removeKey: key ifAbsent: blk
)'as yet unclassified'
printOn: stm = (
	stm nextPutAll: 'Scope('.
	bindings keys
		do: [:key | stm nextPutAll: key]
		separatedBy: [ stm nextPutAll: ', '].
	stm nextPutAll: ') in '.
	superScope printOn: stm.
)
setSuperScope: sc = (
	
	superScope isNil
		ifTrue: [superScope: sc]
		ifFalse: [superScope setSuperScope: sc]
)) : ()
class SlotEntry forDeclaration: decl <VarDeclAST> atDepth: d <Integer> = SymbolTableEntry forAST: decl atDepth: d (
(* Semantic info for a variable: slot, local or parameter. *)|
offset <Integer>
remote <Boolean> ::= false.
remoteVector <SlotEntry>

written <Boolean> ::= false.
readBeforeWritten <Boolean> ::= false.
|)
('as yet unclassified'
isTemporaryAST ^<Boolean> = (
	^ast isTemporaryAST
)
name = (
	^ast name
)
variableClass ^<Class> = (
	^ast variableClass
)) : ()
class SymbolTableEntry forAST: tree atDepth: d = (
(* An entry in a scope. *)|
ast <AST> ::= tree. (* Should investigate mutators of this slot and make immutable if possible. *)
depth <Integer> = d.
|)
('testing'
isMessagePatternNode ^<Boolean> = (
	^self ast isMessagePatternNode
)
isMethodNode ^<Boolean> = (
	^self ast isMethodNode
)
isVarDeclNode ^<Boolean> = (
	^self ast isVarDeclNode
)) : ('as yet unclassified'
forMessage: selector <Symbol> atDepth: depth <Integer> ^<SymbolTableEntry> = (
	^self forAST: (MessagePatternAST new selector: selector) atDepth: depth
))) : ()