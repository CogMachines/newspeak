Newspeak3
'Newspeak'
class NewspeakCompilation usingPlatform: p asts: asts = ((* Facilities common to each of the Newspeak compilers, such as scopes and the scope builder. A common Rewriter should eventually be located here as well.

It is intended that module definitions for each compilation target will be mixed-in to this module definition, and so inherit the facilities provided here. Until general mixin application is supported, the target-specific modules must use the same cheat used by BlocklessCombinatorialParsing of declaring a superclass clause matching the factory of the class it will be later mixed-in to.


This module is derived from Newspeak2SqueakCompilation, which is why the pre-2013 copyrights apply.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2010 Gilad Bracha, Felix Geller and Ryan Macnak
Copyright 2011 Matthias Kleine, Ryan Macnak and Cadence Design Systems
Copyright 2013 Ryan Macnak

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 *)|
	protected Dictionary = p collections Dictionary.
	protected OrderedCollection = p collections OrderedCollection.

	protected AST = asts AST.
	protected ASTTool = asts ASTTool.
	protected BlockAST = asts BlockAST.
	protected CascadedSendAST = asts CascadedSendAST.
	protected CodeBodyAST = asts CodeBodyAST.
	protected MessageAST = asts MessageAST.
	protected MessagePatternAST = asts MessagePatternAST.
	protected MethodAST = asts MethodAST.
	protected NormalSendAST = asts NormalSendAST.
	protected NumberAST = asts NumberAST.
	protected ReturnStatAST = asts ReturnStatAST.
	protected TupleAST = asts TupleAST.
	protected VariableAST = asts VariableAST.
	
	public namer = Namer new.
|)
(
class ClassEntry forDeclaration: cd atDepth: d = SymbolTableEntry forAST: cd atDepth: d (|
public enclosingClass <ClassEntry>
|)
('as yet unclassified'
public isClassBinding ^<Boolean> = (
	^true
)
public name = (
	^ast selector
)) : ()
class Compiler = (| protected scopeMap <Dictionary[AST, Scope]> ::= Dictionary new. |)
(
class Rewriter = ASTTool ((* This class is intended to become a common rewriter for the Squeak, Dart and JavaScript compilers. It should handle

*self/super/outer/implicitReceiver/ordinary send or local read/write.
*local/non-local return.
*implicit return self
*[] is [nil]
*slot initializers
*simultaneous slots
*setter temp
*inlined messages
*large tuples?

The common rewriter should be sufficient for Dart and JavaScript. Squeak will require a second rewrite phase for closure analysis, which should be simpler than the current implementation because determining which locals need to be indirected or copied down will be easier when the tree already has distinguished sends that are reads/writes to locals.
*)|
	scopeStack <OrderedCollection[Scope]> = OrderedCollection new.
	valueExpected <Boolean> ::= true.
	inClosure <Boolean> ::= false.
|)
(
class BlockLocalReturnAST expression: e = ReturnAST expression: e ()
('as yet unclassified'
public apply: visitor = (
	^visitor blockLocalReturnNode: self
)) : ()
class BooleanAST withValue: b = AST (|
	public val = b.
|)
('as yet unclassified'
public apply: aTool <ASTTool > ^ <Self> = (
	^aTool boolNode: self
)
public isBoolNode = (
	^true
)
name = (
	^val printString asSymbol
)
public printOn: stream = (
	stream nextPutAll: 'BooleanAST: '.
	val printOn: stream.
)) : ()
class ConditionalAST if: cond is: ifTrue_ then: t else: e = AST (|
	condition <ExpressionAST> = cond.
	ifTrue = ifTrue_.
	then <CodeBodyAST> = t.
	else <CodeBodyAST> = e.
	forValue <Boolean>
|assert: [then isCodeBodyNode] message: ''.
	assert: [else isCodeBodyNode] message: ''.
	assert: [then parameters size = 0] message: ''.
	assert: [else parameters size = 0] message: '')
('testing'
isExpressionNode ^<Boolean> = (
	^forValue
)'visiting'
public apply: tool <ASTTool> = (
	^tool conditionalNode: self
)) : ('as yet unclassified'
public if: cond <ExpressionAST> is: val <Boolean> then: t <BlockAST> ^<Instance> = (
	^self if: cond is: val then: t else: emptyBody
))
class ContextAST = AST ()
('as yet unclassified'
public apply: tool <ASTTool > ^ <Self> = (
	^tool contextNode: self
)
public isContextNode = (
	^true
)
public printOn: stream = (
	stream nextPutAll: 'ContextAST'
)) : ()
class EnclosingObjectAST = AST ((* See mailing list for debate over 'outer Foo' as an expression. *)| depth <Integer> |)
('as yet unclassified'
isExplicitRcvrNode = (
	^true
)'testing'
isExpressionNode ^<Boolean> = (
	^true
)'visiting'
public apply: tool <ASTTool> = (
	^tool enclosingObjectNode: self
)) : ()
class ImplicitReceiverSendAST = SendAST (|
public depth <Integer> (* Used on targets that don't have implicit receiver lookup at runtime. *)
public binding <ClassEntry | SlotEntry | MethodEntry>
|)
('as yet unclassified'
public isImplicitReceiverSendNode ^<Boolean> = (
	^true
)'visiting'
public apply: tool <ASTTool> = (
	^tool implicitReceiverSendNode: self
)) : ()
class LocalReadAST of: var = AST (|
	variable = var.
|)
('as yet unclassified'
public apply: visitor = (
	^visitor localReadNode: self
)
isExpressionNode ^<Boolean> = (
	^true
)
name = (
	^variable ast name
)) : ()
class LocalWriteAST to: var assign: val = AST (|
	variable = var.
	value = val.
|)
('as yet unclassified'
public apply: visitor = (
	^visitor localWriteNode: self
)
isExpressionNode ^<Boolean> = (
	^true
)
name = (
	^variable ast name
)) : ()
class LoopAST = AST ((* This node represents a while loop. The general form of the loop is:

prologue; while (cond = whileTrue) { body}

*)|
	prologue <CodeBodyAST> ::= emptyBody.
	condition <CodeBodyAST>
	isWhileTrue <Boolean>
	body <CodeBodyAST>
	forValue <Boolean>
|)
('as yet unclassified'
do: n <Integer> timesRepeat: b <BlockAST> = (
	|
	skope <Scope>
	loopVarName <Symbol>
	var <ParameterAST>
	|
	skope:: scopeMap at: b.

	(* introduce counter variable *)
	loopVarName:: '.i' asSymbol.
	var:: (ParameterAST name: loopVarName type: nil)
		start: b start; end: b end.	
	skope
		at: loopVarName
		put: (LocalEntry forDeclaration: var atDepth: 0)
		ifThere: [ halt ].
	assert: [b parameters isEmpty].
	b parameters add: var.

	(* translate n timesRepeat: [blockBody]
	into 1 to: n do: [ :.i | blockBody] *)
	from: (NumberAST new val: 1; start: b start; end: b end) to: n do: b
)
from: first <AST> to: last <AST> by: step <AST> do: block <BlockAST> = (
	|
	blockScope		<Scope>	
	counterVar		<TemporaryAST>
	counterEntry	
	counter		<TemporaryVariableAST>
	limitNeeded		<Boolean>
	limitName		<Symbol>
	limitVar		<TemporaryAST>
	limitEntry
	limit			<LiteralAST | VariableAST>
	condSel			<Symbol>
	condArg		<MutableList[ExpressionAST]>
	condExpr		<ExpressionAST>
	condBody		<CodeBodyAST>
	condStats		<MutableList[StatementAST]>
	incArg			<MutableList[ExpressionAST]>
	incExpr			<ExpressionAST>
	incStat			<StatementAST>
	|
	(* preliminaries *)
	assert: [ step isNumberNode and: [step val isInteger] ].
	assert: [ block isBlockNode ].
	blockScope:: scopeMap at: block body.

	(* loop counter (= block parameter) *)
	counterVar:: TemporaryAST name: block parameters removeFirst name type: nil.
	counterEntry:: LocalEntry forDeclaration: counterVar atDepth: nil.
	counter:: (LocalReadAST of: counterEntry) start: block start; end: block end.
	
	(* introduce counter limit variable if needed *)
	(limitNeeded:: last isLiteralNode not)
		ifFalse:
			[(* no limit variable needed - use last directly since there's no computation involved *)
			limit:: last]
		ifTrue:
			[limitName:: '.limit' asSymbol.
			 limitVar:: TemporaryAST name: limitName type: nil.
			 limitVar start: block start; end: block end.
			 limitEntry:: LocalEntry forDeclaration: limitVar atDepth: nil.
			 prologue temporaries add: limitVar.
			 blockScope at: limitName put: limitEntry ifThere: [ assert: [false] ].
			 limit:: (LocalReadAST of: limitEntry) start: block start; end: block end].
	
	(* setup loop condition => introduce condition block for whileTrue: loop *)
	condSel:: step val < 0 ifTrue: [ #<= ] ifFalse: [ #>= ].
	condArg:: OrderedCollection new add: counter; yourself.
	condExpr:: OrdinarySendAST to: limit send: (MessageAST new send: condSel with: condArg).
	(* limit <= counter OR limit >= counter *)
	condStats:: OrderedCollection new add: condExpr ; yourself.
	condBody::
		CodeBodyAST new
			parameters: OrderedCollection new;
			temporaries: OrderedCollection new;
			statements: condStats;
			start: block start; end: block end.
	scopeMap at: condBody put: nil.

	(* add counter increment to loop body *)
	incArg:: OrderedCollection new add: counter ; yourself.
	incExpr:: OrdinarySendAST to: step send: (MessageAST new send: #+ with: incArg).
	incExpr start: block start; end: block end.
	(* step + counter *)
	incStat:: LocalWriteAST to: counterEntry assign: incExpr. 
	incStat start: block start; end: block end.
	(* counter := step + counter *)
	block body statements add: incStat.

	(* setup prologue *)
	prologue temporaries add: counterVar.
	prologue statements add: (LocalWriteAST to: counterEntry assign: first).
	(* counter := first *)
	limitNeeded ifTrue: [
		(* initialize limit variable - note that this must be done *after* setting up the counter because of possible side effects *)
		prologue statements add: (LocalWriteAST to: limitEntry assign: last). (* .limit := last *)
	].
	
	(* initialize loop instance variables *)
	condition:: condBody.
	isWhileTrue:: true.
	body:: block body
)
from: first <AST> to: last <AST> do: block <BlockAST> = (
	from: first to: last by: (NumberAST new val: 1) do: block
)
repeat: b = (
    assert: [b isCodeBodyNode].
    condition:: b.
    condition statements add: ((BooleanAST withValue: true) start: condition end; end: condition end).
    isWhileTrue:: true.
    body:: emptyBody.
)
while: v <Boolean> do: b <BlockAST> = (
    assert: [b isCodeBodyNode].
    condition:: b.
    isWhileTrue:: v.
    body:: emptyBody
)
while: b1  is: v <Boolean> do: b2 = (
    assert: [b1 isCodeBodyNode].
    assert: [b2 isCodeBodyNode].
    condition:: b1.
    isWhileTrue:: v.
    body:: b2.
)'testing'
isExpressionNode ^<Boolean> = (
	^forValue
)'visiting'
public apply: aTool <ASTTool> = (
	^aTool loopNode: self
)) : ()
class MethodLocalReturnAST expression: e = ReturnAST expression: e ()
('as yet unclassified'
public apply: visitor = (
	^visitor methodLocalReturnNode: self
)) : ()
class NilAST = AST ()
('as yet unclassified'
public apply: tool <ASTTool > = (
	^tool nilNode: self
)
isNilNode = (
	^true
)
name = (
	^#nil
)) : ()
class NonlocalReturnAST expression: e = ReturnAST expression: e ()
('as yet unclassified'
public apply: visitor = (
	^visitor nonLocalReturnNode: self
)) : ()
class OrdinarySendAST to: rcvr send: msg = SendAST (|
	receiver = rcvr.
	message = msg.
|)
('as yet unclassified'
public apply: aTool <ASTTool> = (
	^aTool ordinarySendNode: self
)
isNormalSendNode = (
	^true
)
msg = (
	^self message
)
recv = (
	^self receiver
)) : ()
class OuterSendAST = SendAST (|
public depth <Integer>
public binding <ClassEntry | SlotEntry | MethodEntry>
|)
('as yet unclassified'
public isOuterSendNode ^<Boolean> = (
	^true
)'visiting'
public apply: tool <ASTTool> = (
	^tool outerSendNode: self
)) : ()
class ParameterAST name: n type: t = AST (|
name = n.
type = t.
|)
('as yet unclassified'
public apply: visitor = (
	^visitor parameterDeclNode: self
)
isVarDeclNode ^<Boolean> = (
	^true
)) : ()
class ReceiverAST = AST ()
('as yet unclassified'
public apply: tool = (
	^tool receiverNode: self
)
public isExpressionNode = (
	^true
)) : ()
class ReturnAST expression: e = AST (|
	public expression <AST> = e.
|)
('as yet unclassified'
public expr = (
	^self expression
)
public isExpressionNode = (
	^false
)
public isReturnStatNode = (
	^true
)) : ()
class SelfSendAST = SendAST (|
public binding <ClassEntry | SlotEntry | MethodEntry>
|)
('as yet unclassified'
public isSelfSendNode ^<Boolean> = (
	^true
)
public recv = (
	^ReceiverAST new
)'visiting'
public apply: tool <ASTTool> = (
	^tool selfSendNode: self
)) : ()
class SendAST = AST (|
	message <MessageAST>
|)
('as yet unclassified'
isExpressionNode = (
	^true
)
isSendNode = (^true)
msg = (
	^self message
)) : ()
class SuperSendAST = SendAST ()
('as yet unclassified'
public isSuperSendNode = (
	^true
)'visiting'
public apply: tool <ASTTool> = (
	^tool superSendNode: self
)) : ()
class TemporaryAST name: n type: t = AST (| name = n. type = t. |)
('as yet unclassified'
public apply: visitor = (
	^visitor temporaryDeclNode: self
)
public isTemporaryAST = (
	#BOGUS.
	^true
)
isVarDeclNode ^<Boolean> = (
	^true
)) : ()'as yet unclassified'
applyForEffectTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: false.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
applyForValueTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: true.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
canInlineSeqexps ^<Boolean> = (
	^true (* No on JS and Dart *)
)
depthOfEnclosingClass: name <Symbol> ^<Integer> = (
	| entry <ClassEntry> |
	entry:: currentScope at: #'@currentClass'.
	[entry isNil] whileFalse:
		[entry name = name ifTrue: [
			^entry depth].
		entry:: entry enclosingClass].
	Error signal: 'No enclosing class named "', name, '"'
)
emptyBody = (
	| body |
	#BOGUS. (* Should be able to use immutable collections. *)
	body:: CodeBodyAST new
		parameters: OrderedCollection new;
		temporaries: OrderedCollection new;
		statements: (OrderedCollection with: NilAST new).
	scopeMap at: body put: nil.
	^body
)
futureFor: expression <ExpressionAST> ^<ExpressionAST> = (
	(* @here Future computing: [expression] *)
	| 
	scope <Scope>
	block <BlockAST>
	codebody <CodeBodyAST>
	futureExp <ExpressionAST>
	|
	
	scope:: Scope new.
	scope superScope: currentScope.
	
	futureExp:: NormalSendAST new
		recv: (NormalSendAST new recv: implicitReceiverNode; msg: (MessageAST new sel: #Future; args: {}));
		msg: (MessageAST new sel: #computing:; args: {
			block:: BlockAST new body: (
				 codebody:: CodeBodyAST new
					parameters: OrderedCollection new;
					temporaries: OrderedCollection new;
					statements: {expression})}).

	scopeMap at: codebody put: scope.
	scopeMap at: block put: scope.
	^futureExp
)
implicitReceiverNode ^<VariableAST> = (
	^VariableAST new name: #'@here'; start: 0; end: 0.
)
inClosureDuring: block = (
	| original |
	original:: inClosure.
	inClosure:: true.
	^block ensure: [inClosure:: original]
)
isImplicitReceiverNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #'@here'
)
isInlineableConditional: node <NormalSendAST> ^<Boolean> = (
	canInlineSeqexps ifFalse: [valueExpected ifTrue: [^false]].
	node msg isEventual ifTrue: [^false].
	({#ifTrue:. #ifFalse:. #ifTrue:ifFalse:. #ifFalse:ifTrue:} includes: node msg sel)
	     ifFalse: [^false].
	node msg args do: [:arg <AST> | (isRemovableBlock: arg withArgs: 0) ifFalse: [^false]].
	^true
)
isInlineableLoop: node <NormalSendAST> ^<Boolean>= (
	| selector <Symbol>  args |
	canInlineSeqexps ifFalse: [valueExpected ifTrue: [^false]].
	node msg isEventual ifTrue: [^false].
	selector:: node msg sel.
	args:: node msg args.
	({#whileTrue. #whileFalse. #whileTrue:. #whileFalse:. #repeat} includes: selector) ifTrue:
		[args do:
			[:each |
			(isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
		^isRemovableBlock: node recv withArgs: 0].
	
	(selector = #timesRepeat:) ifTrue:[^isRemovableBlock: args last withArgs: 0].
	({#to:do:. #to:by:do:}  includes:  selector) ifFalse:[^false].
	(isRemovableBlock: args last withArgs: 1) ifFalse:[^false].
	(selector = #to:do:) ifTrue:[^true].
	^args size = 3
)
isOuterNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #outer
)
isRemovableBlock: block <BlockAST> withArgs: numArgs <Integer> ^<Boolean> = (
	(* Answers true if block can be removed (inlined) within another block. *)
	block isBlockNode ifFalse: [^false].
	block parameters size = numArgs ifFalse: [^false].
	^true
)
isSelfNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #self 
)
isSuperNode: node <AST> ^<Boolean> = (
	node isVariableNode ifFalse: [^false].
	^node name = #super 
)
offsetOfEnclosingObjectForClass: name <Symbol> ^<Integer> = (
	| entry <ClassEntry> |
	entry:: currentScope at: #'@currentClass'.
	[entry isNil] whileFalse:
		[entry name = name ifTrue: [
			| offset = outer Compiler currentDepth - entry depth - 1. |
			assert: [offset >= 0] message: 'Invalid enclosing object index'.
			^offset].
		entry:: entry enclosingClass].
	Error signal: 'No enclosing class named "', name, '"'
)
offsetOfImplicitReceiverTarget: binding <SymbolTableEntry> ^<Integer> = (
	(* Note this calculation differs from the one used by explicit outer sends by a factor of one. This is because an explicit outer send needs the depth of the enclosing object with for a class whose name is a given selector, whereas an implicit receiver send needs the depth of the enclosing object for the class that defined a given selector. *)
	| depth |
	depth:: outer Compiler currentDepth - binding depth.
	assert: [depth >= 0] message: 'Invalid enclosing object index'.
	^depth
)
processEventualSend: node <NormalSendAST> = (
	subclassResponsibility
)
processImplicitReceiverSend: node <NormalSendAST> = (
	| 
	message = node msg.
	selector = message sel. 
	binding <SymbolTableEntry>
	|
	
	selector = #self 
		ifTrue: [^ReceiverAST new copyPositionFrom: message].
	selector = #nil 
		ifTrue: [^NilAST new copyPositionFrom: message].
	selector = #false
		ifTrue: [^(BooleanAST withValue: false) copyPositionFrom: message].
	selector = #true
		ifTrue: [^(BooleanAST withValue: true) copyPositionFrom: message].
	selector = #thisContext
		ifTrue: [^ContextAST new copyPositionFrom: message].
	
	binding:: currentScope at: selector ifAbsent: [nil].
	
	binding isNil (* Nothing is lexically visible. *) 
		ifTrue: [^processImplicitReceiverSend: message binding: nil].
	
	binding isLocalBinding
		ifTrue: [^processLocalAccess: message of: binding].

	binding isDebugMappedLocalEntry
		ifTrue: [^processMappedVariable: message decl: binding].
	
	assert: [binding isMethodBinding | binding isSlotBinding | binding isClassBinding]
	message: 'Unknown binding type'.
	^processImplicitReceiverSend: message binding: binding
)
processImplicitReceiverSend: msg <MessageAST> binding: binding <ClassEntry | SlotEntry | MethodEntry> = (
	| depth = binding isNil ifTrue: [0] ifFalse: [offsetOfImplicitReceiverTarget: binding]. |
	^(ImplicitReceiverSendAST new
		depth: depth;
		binding: binding;
		message: (msg apply: self))
		copyPositionFrom: msg
)
processInlineableConditional: node <NormalSendAST> = (
	|
	receiver = node recv apply: self.
	selector = node msg sel.
	numArgs = node msg args size.
	arg1 = numArgs > 0 ifTrue: [(rewriteInlinedBlockNode: (node msg args at: 1) forValue: valueExpected) body].
	arg2 = numArgs > 1 ifTrue: [(rewriteInlinedBlockNode: (node msg args at: 2) forValue: valueExpected) body].
	|
	selector = #ifTrue:
		ifTrue: [^ConditionalAST if: receiver is: true then: arg1].
	selector = #ifFalse:
		ifTrue: [^ConditionalAST if: receiver is: false then: arg1].
	selector = #ifTrue:ifFalse:
		ifTrue: [^ConditionalAST if: receiver is: true then: arg1 else: arg2].
	selector = #ifFalse:ifTrue: 
		ifTrue: [^ConditionalAST if: receiver is: false then: arg1 else: arg2].
	assert: [false] message: 'Unknown conditional selector'
)
processInlineableLoop: node <NormalSendAST> ^<LoopAST> = (
	|
	rcvr = node recv.
	msg = node msg.
	sel = msg sel.
	numArgs = msg args size.
	arg1 = numArgs >= 1 ifTrue: [msg args at: 1].
	arg2 = numArgs >= 2 ifTrue: [msg args at: 2].
	arg3 = numArgs >= 3 ifTrue: [msg args at: 3].
	|
	
	sel = #whileTrue ifTrue: [^LoopAST new
		while: true
		do: (rewriteInlinedBlockNode: rcvr forValue: true) body].
	sel = #whileFalse ifTrue: [^LoopAST new
		while: false
		do: (rewriteInlinedBlockNode: rcvr forValue: true) body].
	sel = #whileTrue: ifTrue: [^LoopAST new
		while: (rewriteInlinedBlockNode: rcvr forValue: true) body
		is: true
		do: (rewriteInlinedBlockNode: arg1 forValue: false) body].
	sel = #whileFalse: ifTrue: [^LoopAST new
		while: (rewriteInlinedBlockNode: rcvr forValue: true) body
		is: false
		do: (rewriteInlinedBlockNode: arg1 forValue: false) body].
	
	sel = #repeat ifTrue: [^LoopAST new
		repeat: (rewriteInlinedBlockNode: rcvr forValue: false) body].
	
	sel = #timesRepeat: ifTrue: [^LoopAST new
		do: (rcvr apply: self)
		timesRepeat: (rewriteInlinedBlockNode: arg1 forValue: false)].
	
	sel = #to:do: ifTrue: [^LoopAST new
		from: (rcvr apply: self)
		to: (arg1 apply: self)
		do: (rewriteInlinedBlockNode: arg2 forValue: false)].
	
	sel = #to:by:do: ifTrue: [^LoopAST new
		from: (rcvr apply: self)
		to: (arg1 apply: self)
		by: (arg2 apply: self)
		do: (rewriteInlinedBlockNode: arg3 forValue: false)].
	
	assert: [false] message: 'Unknown loop selector'
)
processLocalAccess: msg <MessageAST> of: decl <SlotEntry> = (
	^msg sel last = $:
		ifTrue: [processLocalWrite: msg to: decl]
		ifFalse: [processLocalRead: msg from: decl]
)
processLocalRead: message <MessageAST> from: declaration <LocalEntry> = (
	assert: [message arguments isEmpty] message: ''.
	assert: [declaration isNil not] message: ''.
	^(LocalReadAST of: declaration)
		start: message start;
		end: message end
)
processLocalWrite: message <MessageAST> to: declaration <LocalEntry> = (
	assert: [message args size = 1] message: ''.
	assert: [declaration isTemporaryAST] message: ''.
	^(LocalWriteAST
		to: declaration assign: (applyForValueTo: message args first))
		copyPositionFrom: message
)
processOuterExpression: node <NormalSendAST> = (
	^EnclosingObjectAST new
		depth: (offsetOfEnclosingObjectForClass: node msg sel);
		start: node recv start;
		end: node msg end
)
processOuterSend: node <NormalSendAST> = (
	(* +1 because we're looking for members of the enclosing class, not the siblings of the enclosing class. *)
	| binding = currentScope at: node message selector depth: (depthOfEnclosingClass: node recv msg sel) + 1. |
	^OuterSendAST new
		depth: (offsetOfEnclosingObjectForClass: node recv msg sel);
		binding: binding;
		message: (node msg apply: self);
		start: node recv recv start;
		end: node msg end
)
processSelfSend: node <NormalSendAST> = (
	| binding = currentScope at: node message selector depth: outer Compiler currentDepth. |
	^SelfSendAST new
		message: (node message apply: self);
		binding: binding;
		copyPositionFrom: node
)
processSetterSend: node <SetterSendAST> binding: binding ^<AST> = (
	|
	setterTempBinding <LocalEntry>
	setterTempRead
	setterTempWrite
	message <MessageAST> 
	send <NormalSendAST>
	depth
	body <CodeBodyAST>  
	|
	setterTempBinding:: currentScope at: namer setterTemp.
	setterTempBinding used: true.
	
	(* t := exp *)
	setterTempWrite:: LocalWriteAST
		to: setterTempBinding
		assign: (node msg args first apply: self). 

	(* setter: t *)
	setterTempRead:: LocalReadAST of: setterTempBinding. 
	message:: MessageAST new sel: node msg sel; args: {setterTempRead}.
	assert: [isImplicitReceiverNode: node recv] message: 'Setter send receiver should be implicit'.
	depth:: binding isNil ifTrue: [0] ifFalse: [offsetOfImplicitReceiverTarget: binding].
	send:: ImplicitReceiverSendAST new
		depth: depth;
		binding: binding;
		message: message. (* Do not rewrite message twice *)

	(* t:=exp. setter: t. t *)
	body:: CodeBodyAST new 
		parameters: OrderedCollection new;
		temporaries: {};
		statements: {setterTempWrite. send. setterTempRead}.
	scopeMap at: body put: currentScope.
	^body
)
processSuperSend: node <NormalSendAST> = (
	^SuperSendAST new
		message: (node message apply: self);
		copyPositionFrom: node
)
rewriteBlockNode: node <BlockAST> forValue: forValue <Boolean> ^ <BlockAST> = (
(* An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined. *)
	| 
	rewrittenNode <BlockAST> 
      params <Collection[ParameterAST]>  
      bodyScope <Scope> 
	| 
	(* this shouldn't be handled here, but I'm not sure where the block / codebody 
	comes from. *)
	node body start isNumber
		ifFalse: [node body start: node start. node body end: node end].
	
	params:: node parameters collect:
		[:p <VarDeclAST> |
		checkForReservedWord: p name.
		(ParameterAST name: p name type: p type) start: p start; end: p end].
	bodyScope:: scopeMap at: node body.
	params do: [:each | (bodyScope at: each name) ast: each].
	rewrittenNode:: BlockAST new body: 
		(forValue ifTrue: [applyForValueTo: node body] ifFalse: [applyForEffectTo: node body]).
	rewrittenNode start: node start; end: node end.
	rewrittenNode body parameters: params.
	node body statements isEmpty ifTrue:
		[rewrittenNode body statements add: (NilAST new start: node body start; end: node body end)].
	scopeMap at: rewrittenNode put: (scopeMap at: node).
	^rewrittenNode
)
rewriteInlinedBlockNode: node <BlockAST> forValue: forValue <Boolean> ^ <CodeBodyAST> = (
(* An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined. *)
	^rewriteBlockNode: node forValue: forValue
)'node traversal'
public blockNode: node <BlockAST> = (
	| rewrittenBlock <BlockAST> last <AST> |
	inClosureDuring:
		[rewrittenBlock:: rewriteBlockNode: node forValue: true.
		last:: rewrittenBlock body statements last.
		(last isReturnStatNode or: [last isBlockLocalReturnAST]) ifFalse:
			[(* The last expression in a block is returned by it. *)
			rewrittenBlock body statements removeLast.
			rewrittenBlock body statements add:
				((BlockLocalReturnAST expression: last) copyPositionFrom: last)]].
	^rewrittenBlock
)
public cascadedSendNode: node <CascadedSendAST> = (
	| prevSend msg |
	prevSend:: node prevSend apply: self.
	msg:: node msg apply: self.
	^CascadedSendAST new to: prevSend cascade: msg
)
public charNode: node <CharAST> = (
	^node
)
public codeBodyNode: node <CodeBodyAST> = (
	(* Move slot initializers to statements. Simultaneous slots. *)
	
	| bodyScope temporaries setterEntry statements result |
	bodyScope:: pushScopeForNode: node.
	
	temporaries:: OrderedCollection new.
	node temporaries do: 
		[:varDecl <VarDeclAST> | | t |
		checkForReservedWord: varDecl name.
		t:: TemporaryAST name: varDecl name type: varDecl type.
		t copyPositionFrom: varDecl.
		(bodyScope at: t name) ast: t.
		temporaries add: t].

	setterEntry:: LocalEntry forDeclaration: (TemporaryAST name: namer setterTemp type: nil) atDepth: nil.
	bodyScope at: namer setterTemp put: setterEntry.
	bodyScope at: (namer setterTemp, ':') asSymbol put: setterEntry.
	temporaries add: setterEntry ast.
	
	statements:: OrderedCollection new.
	node temporaries do: 
		[:varDecl <VarDeclAST> |
		varDecl initializer ifNotNil: [:it <ExpressionAST> |
			| rewrittenInit |
			rewrittenInit:: self applyForValueTo: 
				(node isSeq ifTrue: [it] ifFalse: [futureFor: it]).
			statements add: (LocalWriteAST
				to: (bodyScope at: varDecl name)
				assign: rewrittenInit)]].

	node statements keysAndValuesDo:
		[:index :statement | 
		| rewritten |
		rewritten:: (index = node statements size and: [valueExpected])
			ifTrue: [applyForValueTo: statement]
			ifFalse: [applyForEffectTo: statement].
		statements add: rewritten].
	
	setterEntry used ifFalse: 
		[bodyScope at: namer setterTemp put: nil.
		bodyScope at: (namer setterTemp, ':') asSymbol put: nil.
		temporaries remove: setterEntry ast].

	popScope.
	result:: CodeBodyAST new
		parameters: node parameters
		temporaries: temporaries
		statements: statements.
	result literalMessages: node literalMessages.
	scopeMap at: result put: bodyScope.
	^result
)
public messageNode: node <MessageAST> ^<MessageAST> = (
    ^MessageAST new
		send: node sel
		with: (node args collect: [:arg | applyForValueTo: arg]);
		isEventual: node isEventual;
		start: node start;
		end: node end
)
public messagePatternNode: node <MessagePatternAST> ^<MessagePatternAST> = (
	| params <OrderedCollection[ParameterAST]> patternScope <Scope> |
	checkForReservedWord: node selector.
	params:: node parameters collect:
		[:p <VarDeclAST> | 
		checkForReservedWord: p name.
		(ParameterAST name: p name type: p type)
			start: p start;
			end: p end].
	patternScope:: scopeMap at: node.
	params do: [:p | (patternScope at: p name) ast: p].
	^MessagePatternAST new
		selector: node selector parameters: params;
		start: node start;
		end: node end.
)
public methodNode: node <MethodAST> = (
	(* Need setter temp? Implicit ^self? *)
	| pattern body accessModifier result |
	pattern:: node pattern apply: self.
	(* We add the implicit ^self before rewritting the body to ensure the last non-return statment is rewritten for effect. *)
	(node body statements isEmpty or: [node body statements last isReturnStatNode not])
		ifTrue:	[node body statements add:
					(ReturnStatAST new expr: (VariableAST new name: #self))].
	body:: node body apply: self.
	body parameters: pattern parameters.
	assert: [inClosure not] message: ''.
	result:: MethodAST new
		pattern: pattern
		body: body
		accessModifier: node accessModifier.
	scopeMap at: result put: (scopeMap at: node).
	^result
)
public normalSendNode: node <NormalSendAST> ^<AST> = (
	(node msg isEventual)
		ifTrue: [^processEventualSend: node].
	(isImplicitReceiverNode: node recv)
		ifTrue: [^processImplicitReceiverSend: node].
	(isSelfNode: node recv)
		ifTrue: [^processSelfSend: node].	
	(isSuperNode: node recv)
		ifTrue: [^processSuperSend: node].	
	(isOuterNode: node recv)
		ifTrue: [^processOuterExpression: node].
	(node recv isSendNode and: [isOuterNode: node recv recv])
		ifTrue: [^processOuterSend: node].
	(isInlineableConditional: node)
		ifTrue: [^processInlineableConditional: node].
	(isInlineableLoop: node)
		ifTrue: [^processInlineableLoop: node].
	
	(* And lo, we really have a normal send. *)
	^(OrdinarySendAST
		to: (node recv apply: self) send: (node msg apply: self))
		start: node start; end: node end
)
public numberNode: node <NumberAST> = (
	^node
)
public returnStatNode: node <ReturnStatAST> = (
	^((inClosure ifTrue: [NonlocalReturnAST] ifFalse: [MethodLocalReturnAST])
		expression: (applyForValueTo: node expr))
		copyPositionFrom: node
)
public setterSendNode: node <SetterSendAST> ^<AST> = (
	| 
	message = node msg.
	selector = message sel. 
	binding <SymbolTableEntry>
	|
	
	binding:: currentScope at: selector ifAbsent: [nil].
	
	binding isNil (* Nothing is lexically visible. *) 
		ifTrue: [^processSetterSend: node binding: nil].
	
	binding isLocalBinding
		ifTrue: [^processLocalAccess: message of: binding].

	binding isDebugMappedLocalEntry
		ifTrue: [^processMappedVariable: message decl: binding].
	
	^processSetterSend: node binding: binding
)
public stringNode: node <StringAST> = (
	^node
)
public symbolNode: node <SymbolAST> = (
	^node
)
public tupleNode: node <TupleAST> = (
	^TupleAST new elements: (node elements collect: [:e | applyForValueTo: e])
)
public variableNode: aNode <VariableAST> = (
	#BOGUS. (* Duplication with processLocalRead: *)
	assert: [aNode start isNumber] message: ''.
	aNode name = #self ifTrue:
		[^ReceiverAST new copyPositionFrom: aNode].
	aNode name = #nil ifTrue:
		[^NilAST new copyPositionFrom: aNode].
	aNode name = #true ifTrue:
		[^(BooleanAST withValue: true) copyPositionFrom: aNode].
	aNode name = #false ifTrue:
		[^(BooleanAST withValue: false) copyPositionFrom: aNode].		
	aNode name = #thisContext ifTrue:
		[^ContextAST new copyPositionFrom: aNode].
	(* recognize inst vars for accessor methods? handle temps etc. *)
	assert: [(aNode name = #super) not] message: '"super" is not a valid expression'.
	assert: [(aNode name = #outer) not] message: '"outer" is not a valid expression'.
	halt.
	^aNode
)'scopes'
currentScope ^<Scope> = (
	^scopeStack last
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
pushScope: scope <Scope> = (
	^scopeStack addLast: scope
)
pushScopeForNode: node <AST> = (
	^pushScope: (scopeMap at: node)
)) : ()
class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = ASTTool ((* The scope builder is a visitor on the AST. It computes a tree of scopes that shadows the AST itself. More precisely, it computes a mapping from ASTs to their scopes. This allows us to get to the appropriate scope for an abstract syntax node without polluting the AST with extraneous data like scopes.

We could associate each node in the AST with the scope in which it is found, but this would be overkill. Instead, only nodes that actually introduce new scopes (such as class sides, message patterns, code bodies and blocks) actually get mapped in this manner. The intent is that later phases of compilation will visit the tree and look up the scopes at the points where they are introduced.

The builder starts at a given node, in the context of some mixin, described by a mirror. This is because, in an incremental environment, we may not have the complete AST for a module, but instead be asked to process a part of that module, such as a nested class, slot definition or method. The surrounding scope can be computed from the mirror representing the immediately enclosing mixin.

Then we traverse the tree, creating and populating new scopes as needed. We maintain a stack of scopes (scopeStack) that initially contains only the surrounding scope. Scopes get pushed on to the stack when we encounter a node that introduces a scope, and popped when we finish with that node. The scopes are chained to their super scopes (the scope below them on the stack).

A possible optimization is to avoid a traversal of an entire side of a class.
One can process only a side without its subtrees (i.e., methods and nested classes). These can be visited later, as long as we ensure that the processing of the subtree begins with a proper super scope on top of the scope stack. *)| 
scopeStack <OrderedCollection[Scope]> = OrderedCollection new.
currentDepth <Integer> ::= initialDepth. (* The lexical nesting level of the class declaration currently being visited; top-level classes are level 0. *)
|pushScope: initialScope)
('as yet unclassified'
public buildScopeFor: mm <MixinMirror> ^<Scope> = (
	assert: [mm isMixinMirror] message: ''.
	^incrementalScopeFor: mm.
)
incrementalScopeFor: mm <MixinMirror> ^<Scope> = (
	|
	enclosingScope <Scope>
	scope <Scope>
	currentClass <ClassEntry>
	depth
	|
	mm declaration enclosingClass 
		ifNil: [enclosingScope:: Scope new]
		ifNotNil: [:it | enclosingScope:: incrementalScopeFor: it instanceSide].
	scope:: Scope new superScope: enclosingScope.
	depth:: scope depth.
	currentClass:: ClassEntry 
		forDeclaration: (MessagePatternAST new selector: mm declaration simpleName)
		atDepth: depth.
	currentClass enclosingClass: (scope at: #'@currentClass' ifAbsent: [nil]).
	scope at: #'@currentClass' put: currentClass.
	depth:: depth + 1.
	mm slots do: [:s <SlotMirror> | 
		| se = SlotEntry
			forDeclaration: (MessagePatternAST new selector: s name; accessModifier: s accessModifier)
			atDepth: depth. |
		scope at: s name put: se. (* getter *)
		scope at: (namer setterSelectorFor: s) put: se. (* setter *)].
	mm methods do: [:m <MethodMirror> | 
		| me = MethodEntry
			forDeclaration: (MessagePatternAST new selector: m name; accessModifier: m accessModifier)
			atDepth: depth. |
		scope at: m name put: me].
	mm nestedClasses do: [:c <ClassDeclarationMirror> | 
		| ce = ClassEntry
			forDeclaration: (MessagePatternAST new selector: c simpleName; accessModifier: c accessModifier)
			atDepth: depth. |
		ce enclosingClass: currentClass.
		scope at: c simpleName put: ce].
	^scope
)'node traversal'
public blockNode: aNode <BlockAST> = (
	| parameterScope <Scope> |
	parameterScope:: Scope new.
	(* establish parameter scope *)
	aNode parameters do:
		[:parameter <VarDeclAST> | 
			parameterScope
			at: parameter name
			put: (LocalEntry
				forDeclaration: parameter
				atDepth: currentDepth)].
	nestScope: parameterScope.
	
	(* visit body *)
	aNode body apply: self.
	scopeMap at: aNode put: (scopeMap at: aNode body).
	
	popScope (* pop the parameter scope, ps *)
)
public cascadedSendNode: aNode <CascadedSendAST> = (

	(* generic traversal code *)
	(* visit receiver and messages *)
	aNode prevSend apply: self.
	aNode msg apply: self.
)
public charNode: aNode <CharAST> = (
	(* leaf, do nothing *)
)
public classHeaderNode: aNode = (

	aNode constructor apply: self.
	aNode slots do: [:s | s initializer ifNotNil: [:i | i apply: self]].
	aNode initExprs do: [:e | e apply: self].
)
public classNode: aNode <ClassDeclarationAST> = (
	| thisClass <ClassEntry> vs <Scope> |
	
	thisClass:: ClassEntry
		forDeclaration: (MessagePatternAST new selector: aNode name; accessModifier: aNode accessModifier)
		atDepth: currentDepth.
	thisClass enclosingClass: (currentScope at: #'@currentClass' ifAbsent: [nil]).
	
	currentScope at: aNode name put: thisClass.
		
	vs:: Scope new. (* establish instance side scope *)
	currentDepth:: currentDepth + 1.
	aNode hdr slots do: [:v <SlotDeclAST> | 
		| se = SlotEntry
			forDeclaration: (MessagePatternAST new selector: v name; accessModifier: v accessModifier)
			atDepth: currentDepth. |
		vs at: v name put: se. (* getter *)
		vs at: (namer setterSelectorFor: v) put: se. (* setter *)].
		
	self nestScope: vs.
		currentScope at: #'@currentClass' put: thisClass.
  		aNode instanceSide apply: self.
	popScope.
	self nestScope: Scope new. (* establish class side scope *)
		currentScope at: #'@currentClass' put: thisClass.
  		aNode classSide apply: self.
	popScope.
	currentDepth:: currentDepth - 1.
)
public codeBodyNode: aNode <CodeBodyAST> = (
	| ts <Scope> |
	(* establish local slot scope *)

	ts:: Scope new.
	aNode temporaries do:[:t <SlotDefAST> | 
		|svd|
		svd:: LocalEntry forDeclaration: t slotDecl atDepth: currentDepth.
		ts at: t name put: svd. (* getter *)
		ts at: (setterSelectorFor: t) put: svd. (* setter *)
		ts at: ('setOnce`',t name) asSymbol put: svd. (* trick so lookups of the initializer for immutables will find the right slot *)].

	nestScope: ts.
	scopeMap at: aNode put: ts.
	(* visit statements *)
	aNode temporaries do: [:t | t initializer isNil ifFalse: [t initializer apply: self]].
	aNode statements do: [:statement | statement apply: self].
	popScope.
)
public keywordPatternNode: n = (
	(* leaf, do nothing *)
)
public literalPatternNode: n = (
	(* leaf, do nothing *)
)
public messageNode: aNode <MessageAST> = (
	(* generic traversal code *)
	(* visit arguments *)
	aNode args do: [:arg <ExpressionAST> | arg apply: self]
)
public messagePatternNode: aNode <MessagePatternAST> = (

	| parameterScope <Scope> |
	parameterScope:: Scope new.
	(* establish parameter scope *)
	aNode parameters do:
		[:parameter <VarDeclAST> | 
		parameterScope
		at: parameter name
		put: (LocalEntry
			forDeclaration: parameter
			atDepth: currentDepth)].
	
	nestScope: parameterScope.
	scopeMap at: aNode put: parameterScope.
	(* the pattern scope, ps, must be popped by the caller *)
	(* establish type parameter scope - skip for now *)
)
public methodNode: aNode <MethodAST> = (

	(* register method in current scope *)
	currentScope
		at: aNode pattern selector
		put: (MethodEntry
			forDeclaration: (MessagePatternAST new selector: aNode selector; accessModifier: aNode accessModifier)
			atDepth: currentDepth).

	(* visit pattern *)
	aNode pattern apply: self.
	
	(* visit body *)
	aNode body apply: self.
	scopeMap at: aNode put: (scopeMap at: aNode body).

	popScope (* Pop pattern scope *)
)
public mixinApplication: node <MixinApplicationAST> = (

	node mixinExpr apply: self.
	node superclassExpr apply: self
)
public mixinApplicationClass: aNode <MixinApplicationClassAST> = (
	| thisClass <ClassEntry> vs <Scope> |
	#BOGUS yourself. (* WIP *)
	thisClass:: ClassEntry
		forDeclaration: (MessagePatternAST new selector: aNode name)
		atDepth: currentDepth.
	thisClass enclosingClass: (currentScope at: #'@currentClass' ifAbsent: [nil]).
	
	currentScope at: aNode name put: thisClass.
	scopeMap at: aNode put: currentScope.
)
public mixinClassNode: aNode = (
	(* leaf, do nothing *)
)
public normalSendNode: aNode <NormalSendAST> = (
	(* generic traversal code *)
	(* visit recvr and msg *)
	aNode recv apply: self.
	aNode msg apply: self.
)
public numberNode: aNode <NumberAST> = (
	(* leaf, do nothing *)
)
public returnStatNode: aNode <ReturnStatAST> = (
	(* generic traversal code *)
	(* visit expression *)
	aNode expr apply: self
)
public setterSendNode: aNode <SetterSendAST> = (
	(* visit recvr and msg *)
	aNode recv apply: self.
	aNode msg apply: self.
)
public sideNode: aNode <SideAST> = (

	scopeMap at: aNode put: currentScope.

	(* visit methods *)
	aNode categories do:
		[:c <CategoryAST> | 
		c methods do:
			[:m <MethodAST> | m apply: self]].
	
	(* visit nested classes *)
	aNode nestedClasses do:
		[:nc <ClassDeclarationAST> | nc apply: self].
)
public stringNode: aNode <StringAST> = (
	(* leaf, do nothing *)
)
public symbolNode: aNode <SymbolAST> = (
	(* leaf, do nothing *)
)
public tupleNode: aNode <TupleAST> = (
	(* visit elements *)
	aNode elements do: [:e <ExpressionAST> | e apply: self]
)
public varDeclNode: aNode <VarDeclAST> = (
	(* Do nothing. It could arguably add aNode's data to current scope - but in practice, the context knows better how to do this. *)
)
public variableNode: aNode <VariableAST> = (
	assert: [aNode name = #'@here' or: [isPseudoVariableNode: aNode]]
	message: 'Unexpected variable name'.
)
public wildcardPatternNode: node = (
	(* leaf, do nothing *)
)'private'
currentScope ^ <Scope> = (
	^scopeStack last
)
isPseudoVariableNode: aNode <VariableAST> ^<Boolean> = (
	^aNode name = #self
		or: [aNode name = #super
		or: [aNode name = #outer
		or: [aNode name = #thisContext]]]
)
nestScope: s <Scope> = (
	(* Hook up a new lexically nested scope, and push onto the scope stack *)
	s superScope: currentScope.
	pushScope: s
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
pushScope: s <Scope> = (
	scopeStack addLast: s
)) : ('as yet unclassified'
public new ^<Instance> = (
	^self nestedIn: Scope new atLevel: 0
))'as yet unclassified'
checkForReservedWord: selector = (
	(namer isReservedWord: selector) ifTrue:
		[Error signal: '"', selector, '" is a reserved word'].
)
setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	subclassResponsibility
)) : ()
class LocalEntry forDeclaration: decl <VarDeclAST> atDepth: d <Integer> = SymbolTableEntry forAST: decl atDepth: d ((* Semantic info for a parameter or temporary. *)|
public offset <Integer>
public remote <Boolean> ::= false.
public remoteVector <LocalEntry>

public used ::= false.
|)
('as yet unclassified'
public isLocalBinding ^<Boolean> = (
	^true
)
public isTemporaryAST ^<Boolean> = (
	^ast isTemporaryAST
)
public name = (
	^ast name
)) : ()
class MethodEntry forDeclaration: decl atDepth: d = SymbolTableEntry forAST: decl atDepth: d (|
|)
('as yet unclassified'
public isMethodBinding ^<Boolean> = (
	^true
)) : ()
class Namer = ()
('as yet unclassified'
public fullyQualifySimpleName: sn with: fqp = (
	^(fqp, syntheticNameSeparator, sn) asSymbol
)
public isReservedWord: selector = (
	^{#self. #super. #outer. #true. #false. #nil. #thisContext} includes: selector
)
public mixinNameOfClassNamed: className = (
	|
	simpleNames
	rawNames
	|
	rawNames:: className subStrings: syntheticNameSeparator. 
	rawNames size =1 ifTrue:[^className].
	simpleNames:: rawNames select: [:n | n initialIntegerOrNil isNil].
	assert: [simpleNames size >= 2] message: ''.
	^(simpleNames fold: [:sn1 :sn2 | sn1, syntheticNameSeparator, sn2]) asSymbol
)
public mixinSlotNameFor: nestedName = (
	| mixinName |
	mixinName:: self mixinNameOfClassNamed: nestedName.
	^(mixinName, syntheticNameSeparator, 'slot') asSymbol
)
public setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	^((slot isMutableSlot ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), slot name, ':') asSymbol.
)
public setterTemp = (
	^#'@setterTemp'
)
public slotNameForNestedClassNamed: ncn <String> within: outerName <String> ^ <String> = (
	^mixinSlotNameFor: (fullyQualifySimpleName: ncn with: outerName).
)
public syntheticNameSeparator = (
	^'`'
)) : ()
class Scope = ((* A generic scope facility. *)|
public superScope <Scope>
bindings <Map[Symbol, SymbolTableEntry]> = Dictionary new.
|)
('access'
public at: key <Symbol> ^<SymbolTableEntry> = (
	(* Answers the value associated with aKey in this or one the super scopes or fails if aKey is absent. *)
	^self at: key ifAbsent: [Error signal: 'Key ', key, ' not found!']
)
public at: key depth: d = (
	depth = d ifFalse: [
		superScope isNil
			ifTrue: [^nil]
			ifFalse: [^superScope at: key depth: d]].
	^bindings at: key ifAbsent: [nil]
)
public at: key <Symbol> ifAbsent: blk <[X def]> ^<SymbolTableEntry | X> = (
	(* Answers the value associated with aKey in this or one of the superScopes or the value of aBlock if aKey is absent. *)
	(* Optimization note: This is written using [nil] blocks to avoid passing non-clean blocks dynamically down the scope structure. *)

	| val <T> |
	(val:: self bindings at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	self superScope isNil
		ifTrue: [ ^blk value ].
	(val:: self superScope at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	^blk value
)
public at: key <Symbol> put: value <SymbolTableEntry> = (
	^self bindings at: key put: value
)
public at: key <Symbol> put: value <SymbolTableEntry> ifThere: aBlock <[X def]> ^<SymbolTableEntry | X>= (

	(* Associates aValue with aKey and answers aValue if aKey
    was absent. Otherwise answers the value of aBlock. *)
	| wasAbsent ::= false. |
	bindings at: key ifAbsent: [bindings at: key put: value. wasAbsent:: true].
	^wasAbsent
		ifTrue: [value]
		ifFalse: [aBlock value]
)
clear = (
	self bindings keys do: [:k | self bindings removeKey: k].
)
public depth ^<Integer> = (
	superScope isNil ifTrue: [^0].
	^superScope depth + 1.
)
removeKey: key <Symbol> = (
	self bindings removeKey: key
)
removeKey: key ifAbsent: blk = (
	self bindings removeKey: key ifAbsent: blk
)'as yet unclassified'
public printOn: stm = (
	stm nextPutAll: 'Scope('.
	bindings keys
		do: [:key | stm nextPutAll: key]
		separatedBy: [ stm nextPutAll: ', '].
	stm nextPutAll: ') in '.
	superScope printOn: stm.
)
public setSuperScope: sc = (
	superScope isNil
		ifTrue: [superScope: sc]
		ifFalse: [superScope setSuperScope: sc]
)) : ()
class SlotEntry forDeclaration: decl <VarDeclAST> atDepth: d <Integer> = SymbolTableEntry forAST: decl atDepth: d ()
('as yet unclassified'
public isSlotBinding ^<Boolean> = (
	^true
)
public name = (
	^ast name
)) : ()
class SymbolTableEntry forAST: tree atDepth: d = ((* An entry in a scope. *)|
public ast <AST> ::= tree. (* Should investigate mutators of this slot and make immutable if possible. *)
public depth <Integer> = d.
|)
('testing'
public isMessagePatternNode ^<Boolean> = (
	^self ast isMessagePatternNode
)
public isVarDeclNode ^<Boolean> = (
	^self ast isVarDeclNode
)) : ()) : ()