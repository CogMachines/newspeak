Newspeak3
'HopscotchIDE'
class IDETools usingPlatform: p ide: ide = (
"Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2011 Ryan Macnak and other contributors.
Copyright 2012 Cadence Design Systems, Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"||
	"Ungood imports"
	private Semaphore = p blackMarket Kernel Semaphore.
	private Processor = p blackMarket Processor.
	private Color = p blackMarket Graphics Color.
	"private SystemMetadata = p blackMarket NewsqueakMixins SystemMetadata."
	private WorldState = p blackMarket Morphic WorldState.
	private NewsqueakDockingBar = p blackMarket Newspeak 
NewsqueakDockingBar.
	private SqueakVmMirror = p blackMarket VmMirror SqueakVmMirror.
	private Cursor = p blackMarket Graphics Cursor.
	private NativeSession = p blackMarket NativeSession NativeSession.
	private SmalltalkImage = p blackMarket System SmalltalkImage.
	private OSProcess = p blackMarket OSProcess OSProcess.
	private Smalltalk = p blackMarket Smalltalk.
	private blackMarket = p blackMarket.
	
	"Doubleplusgood imports"
	private ActiveIcon = p brazil widgets ActiveIcon.
	private Gradient = p brazil plumbing Gradient.
	private Menu = p brazil menus Menu.
	private MenuItem = p brazil menus MenuItem.
	private SeparatorItem = p brazil menus SeparatorItem.
	private TextView = p brazil widgets TextView.
	private 
OrderedCollection = p collections OrderedCollection.
	private TextEditorFragment = p hopscotch fragments TextEditorFragment. 
	private HopscotchImages = p hopscotch HopscotchImages.
	private HopscotchWindow = p hopscotch core HopscotchWindow.
	private Presenter = p hopscotch core Presenter.
	
	private ide = ide. 
	private SystemscapeSubject = ide browsingMisc SystemscapeSubject.
	private ClassCategorySubject = ide browsingMisc ClassCategorySubject.
	private NSClassSubject = ide browsingNS3 ClassSubject.
	private PackageWithClassesSubject = ide browsingMisc PackageWithClassesSubject.
	private ClassCategoryDocsPresenter = ide browsingMisc ClassCategoryDocsPresenter.
	private SelectorSubject = ide browsing SelectorSubject.
	private GlobalReferencesSubject = ide browsingST GlobalReferencesSubject.
	private HomeSubject = ide browsingMisc HomeSubject.
	private HomePresenter = ide browsingMisc HomePresenter.
	private QueriesSubject = ide browsingMisc QueriesSubject.
	private QueriesPresenter = ide browsingMisc QueriesPresenter.
	private UnsavedChangesPresenter = ide browsingMisc UnsavedChangesPresenter.
	private SearchResultsSubject= ide browsingMisc SearchResultsSubject.
	||)
(
class ClassCommentPresenter onSubject: s = EditableDefinitionPresenter onSubject: s (
"The subject is a ClassSubject. Displays a static text view with the text of the class comment and an ''edit'' control on the right. Clicking the control switches the view to edit mode."| showPartialIfLong::= true.
 showingPartial |)
('accessing'
showFullComment = (

	showPartialIfLong:: false.
	refresh
)
showLessComment = (

	showPartialIfLong:: true.
	refresh
)'actions'
respondToAccept = (
	subject classCommentText: editor textBeingAccepted. leaveEditState.
)'definition'
presentationDefinition = (

	| textToDisplay |
	textToDisplay:: retrieveComment.
	textToDisplay isEmpty ifTrue: 
		[textToDisplay:: '(no comment)'].
	^column:
		{textDisplay: textToDisplay.
		showingPartial 
			ifTrue: [(link: 'show full comment' action: [showFullComment]) tinyFont]
			ifFalse: [(link: 'hide full comment' action: [showLessComment]) tinyFont].
		}
)'private'
definitionText = (
	"In this class, only used by the editor side of the presenter to get the text to show in the editor."

	^fullCommentText
)
fullCommentText = (

	^subject classCommentText asString withBlanksTrimmed
)
maybePartialCommentText ^<String> = (
	"Answer the comment text, but not more than one paragraph, and set the value of the showingPartial slot accordingly."

	| text paragraphs result |
	text:: fullCommentText.
	paragraphs:: text findTokens: {Character cr. Character lf}.
	result:: paragraphs 
		detect: [:some | some withBlanksTrimmed notEmpty]
		ifNone: [String new].
	showingPartial:: (paragraphs select: 
		[:any |
		any notEmpty and: [any ~= result]]) isEmpty not.
	^showingPartial
		ifTrue: [result, ' [...]']
		ifFalse: [result]
)
retrieveComment ^<String> = (
	"Get the text to display--either the whole thing or the first paragraph, depending on the text and the settings--and set the showingPartial slot accordingly."

	^showPartialIfLong
		ifTrue: 
			[maybePartialCommentText]
		ifFalse: 
			[showingPartial:: false.
			fullCommentText]
)) : ()
class ClassNamePresenter onSubject: s = ProgrammingPresenter onSubject: s (
"The subject is a ClassSubject. Displays as a row with a class icon and the name of the class as a clickable link that navigates to the class."| highlightIfRecent ::= true. |)
('as yet unclassified'
classLanguageIcon = (
	^subject classUiDescription classIcon
)
namePart = (

	| result |
	result:: row: {
		linkToBrowseClassOrMirror: subject model. 
		smallBlank}.
	(highlightIfRecent and: [subject isRecentlyVisited]) ifTrue: 
		[result:: result color: recentlyVisitedColor].
	^result
)'definition'
definition = (

	^row: {
		draggableImage: classLanguageIcon forSubject: subject.
		smallBlank.
		holder: [namePart]. "this makes it dynamically updatable"
		smallBlank.
		deferred:
			[holder: 
				[subject isAbstract
					ifTrue: [image: HopscotchImages default tinySubclassResponsibilityImage]
					ifFalse: [nothing]]]
		}.
)) : ()
class CodeEditorFragment new = TextEditorFragment (
"Same as TextEditorFragment, but with an editor widget specializing in displaying code (possibly with syntax highlighting)."| colorizerBlockX enterKeyResponseX |)
('as yet unclassified'
colorizerBlock = (

	^colorizerBlockX
)
colorizerBlock: oneArgBlock = (

	colorizerBlockX:: oneArgBlock.
	hasVisual ifTrue: [editor colorizerBlock: oneArgBlock]
)
createEditor = (
	"We create a colorizing CodeView rather than the stock TextView."

	editor:: CodeView new.
	editor suppressScrollbars: true.
	editor text: text copy.
	editor hasEditsFromUserChannel => 
		[:hasChanges |
		textBeingAccepted:: editor text copy.
		hasChanges ifTrue: [respondToChange]].
	editor acceptKeyResponse:
		[:defaultResponse |
		respondToAccept].
	editor colorizerBlock: colorizerBlockX.
	editor enterKeyResponse: enterKeyResponseX.
	^editor
)
enterKeyResponse = (

	^enterKeyResponseX
)
enterKeyResponse: action <[[]]> = (

	enterKeyResponseX:: action.
	hasVisual ifTrue: [editor enterKeyResponse: action]
)) : ()
class CodeView new = TextView (
"Enhances TextView with the ability to color the text it displays. Colorization is performed by colorizerBlock set by the client of the view. The block accepts the text to colorize and returning the same text (but not necessarily the same instance of Text) colorized."| colorizerBlockX
colorizationProcess 
colorizationMutex::= Semaphore forMutualExclusion.
 |[initialize. create. createAttributes] ifError: [])
('accessing'
colorizerBlock = (

	^colorizerBlockX
)
colorizerBlock: oneArgBlock = (

	colorizerBlockX:: oneArgBlock.
	maybeColorize.
)
text: newText = (

	super text: newText asText.
	maybeColorize
)'parameters'
backgroundProcessPriority ^<Integer> = (
"The priority colorization runs on. We want it to be lower than the regular UI priority, but higher than the background (which deferred content installers run on)."

^Processor userBackgroundPriority + 1
)'private'
doColorize = (
	"Expects that the sender ensures that the colorizerBlock is present and the current text is a Text and schedules this as a background process saved in the colorizationProcess slot."

	| startingContent newText |
	agent isNil ifTrue: [^self].
	startingContent:: text asString.
	newText:: colorizerBlock clone value: startingContent asText.
	colorizationMutex critical:
		[(newText isText and: [isMapped]) ifTrue:
			[desktop scheduleUIAction:
				[(startingContent = text asString)  ifTrue:
					[text runs: newText runs.
					isMapped ifTrue: [agent reemphasizeText: text]]]].
		colorizationProcess:: nil]
)
maybeColorize = (
	"Invoked after a character has been typed and the content of the view changed."

	agent isNil ifTrue: [^self].
	colorizerBlock notNil & text isText ifTrue:
		[colorizationMutex critical:
			[colorizationProcess ifNotNil: 
				[colorizationProcess terminate].
			colorizationProcess:: 
				[doColorize] clone forkAt: backgroundProcessPriority]]
)'restricted'
acceptTextFromAgent: newText <Text | String> = (
	"The text has been changed in the view by the user and the agent gives us the current content."

	| tweakedText |
	flag: #BOGUS. "the following should not be necessary when we have proper text support, but for now we should expect that an agent may pass us a naked String while the visual is holding onto a Text it wants to colorize. in that case promote the text from agent to a Text so colorization isn't disabled."
	tweakedText:: (newText isText not and: [text isText])
		ifTrue: [newText asText]
		ifFalse: [newText].
	super acceptTextFromAgent: tweakedText.
	maybeColorize
)
createAgentUsing: aMapping = (

	super createAgentUsing: aMapping.
	maybeColorize
)) : ()
class DefinitionListPresenter onSubject: s = ProgrammingPresenter onSubject: s (
"DefinitionListPresenter is an abstract superclass of presenters that display helper ''transient'' presenters that visually appear to belong to the main list of subject presenters. One common example is a method list presenter which can at times include presenters for methods being added or residue presenters of removed methods."| prefixes content suffixes |)
('actions'
collapseAll = (
	"Collapse all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse."

	majorUpdate:
		[content presenters do: [:each | each collapse]]
)
expandAll = (
	"Expand all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse."

	majorUpdate:
		[content presenters do: [:each | each expand]]
)'definition'
contentList = (

	^list: [contentPresenters]
)
definition = (

	prefixes:: list.
	content:: contentList.
	suffixes:: list.
	^column: {
		prefixes.
		content.
		suffixes.
		}
)'private'
contentPresenters ^<Collection[Presenter]> = (

	^OrderedCollection new
)) : ()
class DefinitionResidue = ProgrammingPresenter onSubject: nil (
""| caption definitionText extraData restoreResponse forgetResponse |)
('as yet unclassified'
= anotherPresenter = (

	^self == anotherPresenter
)
hash = (

	^self identityHash
)'definition'
definition = (

	^heading:
		(row: {
			(label: caption) color: (Color gray: 0.7).
			largeBlank.
			})
	details:
		[TextEditorFragment new
			text: definitionText;
			acceptLabelText: 'restore';
			cancelLabelText: 'forget';
			acceptResponse: [restoreResponse valueWithPossibleArgument: self];
			cancelResponse: [forgetResponse valueWithPossibleArgument: self];
			enterEditState]
)) : ()
class DefinitionTemplate = ProgrammingPresenter onSubject:nil (
""| caption initialText::= String new.
 acceptResponse cancelResponse editor 
colorizerBlock::= [ :text | text asString asText] fixTemps. "default: remove any formatting"
 |)
('accessing'
text = (

	^editor textBeingAccepted
)'as yet unclassified'
= anotherPresenter = (

	^self == anotherPresenter
)
hash = (

	^self identityHash
)'definition'
definition = (

	^(row: {
		mediumBlank.
		elastic:
			(column: {
				smallBlank.
				label: [caption ifNil: [String new]].
				editorDefinition.
				mediumBlank.
 			}).
		smallBlank.
		})
			color: (Gradient from: (Color h: 100 s: 0.3 v: 0.9) to: (Color h: 100 s: 0.3 v: 0.8))
)
editorDefinition = (

	editor:: CodeEditorFragment new
		text: initialText;
		acceptLabelText: 'save';
		cancelLabelText: (cancelResponse ifNil: [nil] ifNotNil: ['cancel']);
		controlBarColor: nil;
		acceptResponse: [acceptResponse clone valueWithPossibleArgument: self];
		cancelResponse: [cancelResponse valueWithPossibleArgument: self];
		colorizerBlock: colorizerBlock;
		enterEditState.
	^editor
)) : ()
class EditableDefinitionPresenter onSubject: s = ProgrammingPresenter onSubject: s (
"An abstract superclass of presenters that display some kind of a static (non-interactive) representation of their subject that can be transformed into a text editor allowing to edit the subject. It is the subclass' responsibility to define what the static representation actually looks like, how the edit state is entered, and how the text of the definition is mapped back onto the model state."| editor 
isEditing::= false. |)
('accessing'
= anotherPresenter = (

	^self == anotherPresenter
)
hash = (

	^self identityHash
)'actions'
respondToAccept = (

	subclassResponsibility
)
respondToCancel = (

	leaveEditState
)
respondToEdit = (

	enterEditState
)'definition'
definition = (

	^holder: 
		[isEditing
			ifTrue: [editorDefinition]
			ifFalse: [viewerDefinition]]
)'private'
definitionText = (

	subclassResponsibility
)
editorDefinition = (
	
editor:: TextEditorFragment new.
editor
	text: definitionText;
	cancelResponse: [respondToCancel];
	acceptResponse: [respondToAccept];
	enterEditState.
^editor
)
enterEditState = (

	isEditing:: true.
	refresh
)
leaveEditState = (

	isEditing:: false.
	refresh
)
presentationDefinition = (

	subclassResponsibility
)
viewerDefinition = (
^
	row: {
		elastic: 
			presentationDefinition.
		smallBlank.
		linkImage: HopscotchImages default editImage action: [respondToEdit]
		}
)) : ()
class IDEWindow new = HopscotchWindow (
"The HopscotchWindow specific to Smalltalk/Newspeak programming tools. Provides additional navigational aids such as the search field, as well as convenient instance creation and opening messages on the class side. For historical reasons, this is considered THE Hopscotch class."| reflectionS searchStringField metaMenuButton operateMenuButton vmMirrorS unitTestingS
	inspectionS  |)
('accessing'
unitTesting ^<UnitTesting> = (
	"Answer the UnitTesting object shared by all presenters in this browser."

	^fakeOuter unitTesting
)'actions'
eraseHistory = (
"Also discard the old reflection instance."
reflectionS:: nil.
super eraseHistory
)'as yet unclassified'
addFileMenuItemsTo: menu = (
operateMenuItemDefinitions do:
	[:each | | item |
	item:: each = nil
		ifTrue: [SeparatorItem new]
		ifFalse: [MenuItem label: each key action: [WorldState addDeferredUIMessage: [each value value]] fixTemps].
	menu add: item].
)
addMenuBarItemsTo: menu <Menu> = (
| fileMenu <Menu> |
	fileMenu:: Menu new.
	addFileMenuItemsTo: fileMenu.
	menu add: (SubmenuItem new
		label: '&File';
		submenu: fileMenu
		).
	super addMenuBarItemsTo: menu.
	menu 	add: (SubmenuItem new
		label: '&Meta';
		submenu: metaMenu).
)
addToolbarItemsTo: toolbar = (

	super addToolbarItemsTo: toolbar.

	toolbar addElasticBlank.
	buildSearchStringField.
	toolbar add: buildFindButton.

	toolbar addBlankSize: 5.
	toolbar add: buildMetaMenuButton.
	toolbar add: buildOperateMenuButton.
)
authorizeUnsavedChanges = (
	enterPresenter: UnsavedChangesPresenter new.
	^false
)
buildMenuBar = (
"It's the brave new world."
^nil
)
confirmQuit = (
| answer |
answer:: MessageBox new
	yesNoCancel: 'Save changes before quitting?';
	open.
answer == #yes ifTrue: [saveThenQuit].
answer == #no ifTrue: [quit].
)
homePresenter = (
	^HomePresenter
)
homeSubject = (
	^HomeSubject
)
inspectApplication = (
	IDEWindow openOnObject: self
)
inspectWindow = (
	IDEWindow openOnVisual: window
)
inspection = (
	^ide inspection
)
metaMenu ^ <Menu> = (

	^Menu new
			add: (MenuItem label: 'Inspect Application' 
					action: [inspectApplication]);
			add: (MenuItem label: 'Enable Inspectors' 
					action: [respondToEnableInspectors]);
			add: (MenuItem label: 'Inspect Window' 
					action: [inspectWindow]);
			yourself
)
openMetaMenu = (
| menu |
menu:: metaMenu.
menu ownerVisual: window.
menu
	openIn: window desktop 
	at: (0 @ metaMenuButton extent y
			translateFrom: metaMenuButton
			to: window desktop)
)
openOperateMenu = (
| menu |
menu:: Menu forVisual: window.
operateMenuItemDefinitions do:
	[:each | | item |
	item:: each = nil
		ifTrue: [SeparatorItem new]
		ifFalse: [MenuItem label: each key action: [WorldState addDeferredUIMessage: [each value value]] fixTemps].
	menu add: item].
menu 
	openIn: window desktop 
	at: (0 @ operateMenuButton extent y
			translateFrom: operateMenuButton
			to: window desktop)
)
operateMenuItemDefinitions ^ <Association[String, [] ]> = (

	^Array streamContents: [:s |
		s nextPut: 'Run App' -> [NewsqueakDockingBar someInstance runApp].
		s nextPut: 'Open File' -> [NewsqueakDockingBar someInstance openFile].
		s nextPut: 'Open File List'  -> [NewsqueakDockingBar someInstance openFileList].
		s nextPut: 'Open OS File Browser' -> [NewsqueakDockingBar someInstance openOsFileBrowser].
		s nextPut: 'Compile File' -> [NewsqueakDockingBar someInstance compileLanguageFile].
		OSProcess isWindows ifTrue:
			[s nextPut: nil.
			s nextPut: 'Show Console Window' -> [NativeSession soleInstance focusSqueakWindow]].
		s nextPut: nil.
		s nextPut: 'Save Image'  ->[NewsqueakDockingBar someInstance saveImage].
		s nextPut: 'Save Image As...' -> [NewsqueakDockingBar someInstance saveImageAs].
		s nextPut: 'Quit' -> [NewsqueakDockingBar someInstance quit]
	]
)
quit = (
"Must be in Morphic UI process"
WorldState addDeferredUIMessage:
	[SmalltalkImage current snapshot: false andQuit: true]
)
refresh = (
	| isDebugger isInNamespace |
	super refresh.
	
	isDebugger:: blackMarket BlackMarket ide yourself = ide yourself.
	isInNamespace:: blackMarket IDETools mixin = outer IDETools class mixin.
	
	isDebugger ifFalse: 
		[searchStringField text: 'Not the debugger'].
	isInNamespace ifFalse: 
		[searchStringField text: 'Not in namespace'].
	isDebugger not & isInNamespace not ifTrue: 
		[searchStringField text: 'Neither the debugger nor in namespace'].
	"Otherwise normal, so don't mess with the search field's state"
)
respondToEnableInspectors = (
currentPresenter withAllChildrenDo: [:each | each enableInspection]
)
saveThenQuit = (
"Must be in Morphic UI process"
WorldState addDeferredUIMessage:
	[SmalltalkImage current snapshot: true andQuit: true]
)
vmMirror ^<SqueakVmMirror> = (
	"Answer the SqueakVmMirror object shared by all presenters in this browser."

	vmMirrorS ifNil:
		[vmMirrorS:: SqueakVmMirror usingPlatform: blackMarket BlackMarket platform].
	^vmMirrorS
)'private-toolbar'
buildFindButton = (

	| button images |
	button:: ActiveIcon new.
	images:: HopscotchImages default.
	button
		image: images findSquareLeftImage;
		hoverImage: images findSquareLeftOverImage;
		downImage: images findSquareLeftDownImage;
		action: [find].
	^button 
)
buildMetaMenuButton = (

	| images |
	metaMenuButton:: ActiveIcon new.
	images:: HopscotchImages default.
	metaMenuButton
		actOnMouseDown: true;
		image: images metaMenuImage;
		hoverImage: images metaMenuOverImage;
		downImage: images metaMenuDownImage;
		action: [openMetaMenu].
	^metaMenuButton 
)
buildOperateMenuButton = (

	| images |
	operateMenuButton:: ActiveIcon new.
	images:: HopscotchImages default.
	operateMenuButton
		actOnMouseDown: true;
		image: images operateMenuImage;
		hoverImage: images operateMenuOverImage;
		downImage: images operateMenuDownImage;
		action: [openOperateMenu].
	^operateMenuButton 
)
buildSearchStringField = (

	searchStringField:: toolbar addNew: TextView setup:
		[:field |
		field text: ''.
		field enterKeyResponse: [:defaultK | find].
		field area width: 200].	
	^searchStringField
)
find = (

	| term |
	Cursor wait showWhile:
		[term:: searchStringField text asString withBlanksTrimmed.
		term isEmpty ifTrue:
			[^searchStringField 
				flash;
				text: 'type search term here'].
		enterSubject: (SearchResultsSubject onModel: term)]
)) : ('as yet unclassified'
onClass: aClass = (

	^withSubjectFromBlock: 
		[:shell | subjectForClass: aClass]
)
open = (
	^openSubjectFromBlock: [:me | HomeSubject new]
)
openOnObject: anObject = (

	openSubjectFromBlock:
		[:shell |
		shell inspection ObjectSubject onModel: (shell vmMirror reflectOn: anObject)]
)
openOnVisual: aVisual = (

	openSubjectFromBlock:
		[:shell | shell inspection BrazilVisualTreeSubject onModel: aVisual]
)
openSubject: aSubject <Subject> = (
	^openSubjectFromBlock: [:instance | aSubject]
)
openSubjectFromBlock: aBlock = (
	^(withSubjectFromBlock: aBlock) open
)
subjectForClass: aClass = (

	^aClass language classSubjectFor: aClass using: ide
)
withSubjectFromBlock: aBlock = (

	| instance |
	#BOGUS yourself. "copied from HopscotchShell"

	instance:: self new.
	instance subject: (aBlock value: instance).
	^instance
)'instance creation'
onHome = (

	^withSubjectFromBlock: [:shell | HomeSubject new]
)
onSystem = (

	^withSubjectFromBlock: [:shell | SystemscapeSubject new]
)
openOnClass: aClass = (

	^(onClass: aClass) open
)
openOnClassCategory: categoryName <String> = (

	openSubjectFromBlock: [:shell | ClassCategorySubject onModel: categoryName]
)
openOnHome = (

	^onHome open
)
openOnSelector: selector = (

	openSubjectFromBlock: [:shell | SelectorSubject onModel: selector]
)
openOnSystem = (

	^onSystem open
))
class OneLineDefinitionTemplate new = DefinitionTemplate (
""|  |)
('as yet unclassified'
definition = (
^row: {
	(elastic: (padded: (
		row: {
			label: [caption ifNil: [String new]].
			elastic: (column: {editorDefinition})
		}) with: {10. 5. 10. 5}))
			color: (Gradient from: (Color h: 100 s: 0.3 v: 0.9) to: (Color h: 100 s: 0.3 v: 0.8))}
)) : ()
class PopularityRecord = (
"PopularityRecord keeps track of most recently visited packages, categories and classes. It is a singleton class, with the default instance available as ''HopscotchGlobalState defaultPopularityRecord''.

   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"| 
	packageVisits::= OrderedCollection new: 10.
	categoryVisits::= OrderedCollection new: 10.
	classVisits::= OrderedCollection new: 10.
 |)
('as yet unclassified'
rememberCategoryVisit: categoryName = (


	self rememberVisit: categoryName in: categoryVisits
)
rememberClassVisit: className = (


	self rememberVisit: className in: classVisits
)
rememberPackageVisit: packageName = (


	self rememberVisit: packageName in: packageVisits
)
rememberVisit: name <Symbol> in: records <OrderedCollection> = (


	(records includes: name)
		ifTrue:
			[records remove: name.
			records addFirst: name]
		ifFalse:
			[[records size > 14] whileTrue: [records removeLast].
			records addFirst: name]
)) : ()
class ProgrammingPresenter onSubject: s = Presenter onSubject: s (
"An abstract superclass of all presenters used in programming tools. Defines all kinds of methods useful for navigation between code artifacts or their consistent display."|  |)
('accessing'
inspection = (

	^shell inspection
)
unitTesting = (

	^shell unitTesting
)
vmMirror = (

	^shell vmMirror
)'actions'
browseClassCategory: categoryName <Symbol> = (

	ide defaultPopularityRecord
		rememberCategoryVisit: categoryName.
	enterSubject: (ClassCategorySubject onModel: categoryName)
)
browseClassCategoryDocs: categoryName <Symbol> = (

	sendUp navigatorDo:
		[:navigator |
		navigator enterPresenter: 
			(ClassCategoryDocsPresenter onSubject: 
				(ClassCategorySubject onModel: categoryName))]
)
browseClassNamed: aSymbol = (

	| theClass |
	theClass:: Smalltalk at: aSymbol ifAbsent: [nil].
	theClass isNil ifTrue:
		[^enterSubject: (SearchResultsSubject onModel: aSymbol)].
	theClass isBehavior ifFalse: [theClass:: theClass class].
	ide defaultPopularityRecord
		rememberClassVisit: theClass name.
	browseClass: theClass
)
browseClassOrMirror: aClassOrMirror = (

	aClassOrMirror isBehavior
		ifTrue: [browseClass: aClassOrMirror]
		ifFalse: [browseClassMirror: aClassOrMirror]
)
browseClassReferences: aClass = (

	self browseReferencesToKey: aClass theNonMetaClass name
)
browsePackage: packageName <String> = (

	ide defaultPopularityRecord
		rememberPackageVisit: packageName.
	enterSubject: (PackageWithClassesSubject onModel: packageName)
)
browseReferencesToKey: aSymbol = (

	enterSubject: (GlobalReferencesSubject onModel: aSymbol)
)
browseSelector: selector = (

	enterSubject: (SelectorSubject onModel: selector)
)
browseSystem = (

	sendUp
		navigatorDo: [:navigator | navigator enterSubject: SystemscapeSubject new]
)
confirm: label ifConfirmed: block = (

	| menu |
	menu:: Menu forVisual: visual.
	menu add: (MenuItem key: #ok label: label action: block).
	menu openIn: visual desktop
)
goToMessagesOf: methodPresenter <MethodPresenter> = (

	| messagesAndActions |
	messagesAndActions:: OrderedCollection new.
	messagesAndActions add:
		methodPresenter selector -> [browseSelector: methodPresenter selector].
	methodPresenter messages asSortedCollection do:
		[:selector |
		selector == methodPresenter selector ifFalse:
			[messagesAndActions add:
				selector -> [browseSelector: selector] fixTemps]]. "Squeakism"
	methodPresenter variableBindingKeys asSortedCollection do:
		[:eachKey |
		(eachKey notNil and: [eachKey ~= methodPresenter className]) ifTrue:
			[messagesAndActions add:
				eachKey -> [browseClassNamed: eachKey] fixTemps]].
	openMenuWithLabelsAndActions: messagesAndActions
)
inspect: anObject = (

	enterSubject:: objectSubjectFor: anObject
)
inspectObjectMirror: objectMirror <SqueakVmMirror ObjectMirror> = (

	enterSubject:: objectSubjectForMirror: objectMirror
)
objectSubjectFor: anObject = (

	^objectSubjectForMirror: (vmMirror reflectOn: anObject)
)
objectSubjectForMirror: objectMirror <SqueakVmMirror ObjectMirror> = (

	^inspection ObjectSubject onModel: objectMirror
)
testClasses: classes <Collection> = (
| runner <TestRunner> |
runner:: TestRunner new.
ToolBuilder open: runner.
runner
	setCategoriesSelected:	(classes asSet collect: [:ea | ea category]);
	setClassesSelected: classes asSet.
runner runAll
)'as yet unclassified'
browseClass: aClass = (

	| theClass |
	theClass:: aClass theNonMetaClass mixin definingClass.
	ide defaultPopularityRecord
		rememberClassVisit: theClass name.
	sendUp 
		ifUndelivered: [IDEWindow openOnClass: theClass];
		navigatorDo:
			[:navigator |
			navigator enterSubject: 
				(subjectForClass: theClass)]
)
browseClassMirror: aMirror = (

	ide defaultPopularityRecord rememberClassVisit: aMirror name.
	enterSubject:: ide browsingNS3 ClassSubject onModel: aMirror.
)
enableInspection = (
inspectionHolder ifNotNil:
	[:it |
	it content: (link: '[i]' action: [respondToInspectPresenter]) tinyFont]
)
inspectionHolder = (
	^nil
)
linkToBrowseClassOrMirror: aClassOrMirror = (

^aClassOrMirror isBehavior
	ifTrue: [linkToBrowseClass: aClassOrMirror]
	ifFalse: [linkToBrowseClassMirror: aClassOrMirror]
)
respondToInspectPresenter = (
inspect: self
)
subjectForClass: aClass = (
	"Manufacture a subject appropriate for the given class object."

	^aClass language classSubjectFor: aClass using: ide
)
testRunnerLauncherButtonAction: aBlock = (

	^imageButton: 
		{HopscotchImages default accept16px}
	action: aBlock
)'buttons'
acceptButtonWithAction: aBlock = (

	^imageButton: 
		{HopscotchImages default accept16px.
		HopscotchImages default accept16pxOver.
		HopscotchImages default accept16pxDown}
	action: aBlock
)
addButtonWithAction: aBlock = (

	^imageButton: 
		{HopscotchImages default hsAddImage.
		HopscotchImages default hsAddOverImage.
		HopscotchImages default hsAddDownImage}
	action: aBlock
)
cancelButtonWithAction: aBlock = (

	^imageButton: 
		{HopscotchImages default cancel16px.
		HopscotchImages default cancel16pxOver.
		HopscotchImages default cancel16pxDown}
	action: aBlock
)
collapseButtonWithAction: aBlock = (

	^imageButton: 
		{HopscotchImages default hsCollapseImage.
		HopscotchImages default hsCollapseOverImage.
		HopscotchImages default hsCollapseDownImage}
	action: aBlock
)
deleteItemButtonWithAction: aBlock = (

	^imageButton: 
		{HopscotchImages default itemDeleteImage}
	action: aBlock
)
expandButtonWithAction: aBlock = (

	^imageButton: 
		{HopscotchImages default hsExpandImage.
		HopscotchImages default hsExpandOverImage.
		HopscotchImages default hsExpandDownImage}
	action: aBlock
)
itemMenuButtonWithAction: aBlock = (

	^imageButton: 
		{HopscotchImages default itemMenuImage}
	action: aBlock
)
itemReferencesButtonWithAction: aBlock = (

	^imageButton: {HopscotchImages default itemReferencesImage}
	action: aBlock
)
itemReferencesMenuButtonWithAction: aBlock = (

	^imageButton: {HopscotchImages default itemReferencesImage}
	action: aBlock
	actOnMouseDown: true
)
reorderButtonWithAction: aBlock = (

	^imageButton: 
		{HopscotchImages default hsReorderImage.
		HopscotchImages default hsReorderOverImage.
		HopscotchImages default hsReorderDownImage}
	action: aBlock
)'colors'
actionLinkColor = (

	^Color black
)
dangerColor = (

	^Color h: 0 s: 0.5 v: 1
)
majorHeadingColor = (
	"This color is used for major definitions such as class headings."

	^Gradient 
		from: (Color h: 240 s: 0.05 v: 0.92) 
		to: (Color h: 240 s: 0.05 v: 0.86)
)
methodHeadingColor ^<Color> = (
	"This is the color of expanded methods headings. It should agree with majorHeadingColor and minorClassHeadingColor to establish a clear visual hierarchy in a class presenter."

	^Color gray: 0.95
)
minorClassHeadingColor = (
	"This color is used for sections headings of a class presentation, such as instance and class method lists. It should agree with majorHeadingColor and methodHeadingColor to establish a clear visual hierarchy in a class presenter."

	^Gradient 
		from: (Color h: 240 s: 0.02 v: 0.94) 
		to: (Color h: 240 s: 0.02 v: 0.9)
)
minorHeadingColor = (
^Gradient 
	from: (Color h: 240 s: 0.02 v: 0.94) 
	to: (Color h: 240 s: 0.02 v: 0.9)
)
recentlyVisitedColor = (
	"Recently visited things are highlighted using this color."

	^Color h: 60 s: 0.35 v: 1
)
secondaryTextColor = (

	^Color gray: 0.62
)'layout'
darkerBlock: body = (

	^(column: {
		mediumBlank.
		row: {
			mediumBlank.
			elastic: body
			}.
		mediumBlank
		})
			color: (Color gray: 0.9)
)
endDebugMarker = (

	^(label: '----- end (this layout debugging marker should not appear cut off) -----') 
		color: Color gray
)
farIndentedBlock: body = (

	^column: {
		mediumBlank.
		row: {
			largeBlank.
			elastic: body
			}.
		mediumBlank
		}
)
headingBlock: body = (

	^(column: {
		mediumBlank.
		row: {
			mediumBlank.
			elastic: body
			}.
		mediumBlank
	})
		color: (Gradient from: (Color gray: 0.92) to: (Color gray: 0.85))
)
indentedBlock: body = (

	^column: {
		mediumBlank.
		row: {
			mediumBlank.
			elastic: body
			}.
		mediumBlank
		}
)
largeBlank = (

	^blank: 20
)
majorHeadingBlock: body = (

	^(padded: body with: {10. 10. 5. 10.})
		color: majorHeadingColor
)
minorClassHeadingBlock: body = (

	^(padded: body with: {10. 5. 5. 5.})
		color: minorClassHeadingColor
)
minorHeadingBlock: body = (

	^(padded: body with: {10. 5. 5. 5.})
		color: minorHeadingColor
)
smallBlank = (

	^blank: 5
)'links'
linkToBrowseCategory: categoryName = (

	^link: categoryName action: [browseClassCategory: categoryName]
)
linkToBrowseClass: aClass = (

	^link: aClass name action: [browseClass: aClass]
)
linkToBrowseClassMirror: aMirror = (
|	cs = aMirror name subStrings: '`'.
	legibleClassName = cs reverse reduce: [ :m :o | m, ' in ', o]. | 
	^ link: legibleClassName action: [browseClassMirror: aMirror]
)
linkToBrowseSelector: selector = (

	^link: selector action: [browseSelector: selector]
)'private'
iconForClass: aClass = (

	^(ide languageUiDescriptionRegistry descriptionForClass: aClass) classIcon
)
iconForClassNamed: aSymbol = (

	^(ide languageUiDescriptionRegistry descriptionForClassNamed: aSymbol) classIcon
)) : ()) : ()