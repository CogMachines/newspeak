Newspeak3
'VictoryFuel'
class VictoryFuel usingPlatform: p vm: vm = (
(* Clustered serialization inspired by Fuel and Parcels.

A traditional serialization scheme recursively visits the references of a object, and writes back references for objects already encountered or starts writing a new object body. Clustered serialization visits all the references and assigns the objects to clusters (e.g., based on class), then writes all the object bodies (byte data, nodes), then writes all the object references (pointer data, edges). Clustering allows writing and reading the type information once per cluster instead of once per object, and for allocating objects in tight loops. Placing all nodes before all edges allows for filling objects in tight loops.

Serialization:
- Push the root object onto a work stack.
- While the work stack is not empty, pop an object. Record that we have seen this object. Assign it to a cluster, either based on its class or whether it is a 'global' that will pre-exist for the deserializer. Visit its references, and push any we haven't seen onto the stack. (Use of an explicit stack avoids deep recursion and context-stack mapping busy work.)
- For each cluster, write the bodies (byte data, nodes) of each object and assign each object a back ref.
- For each cluster, write the references (pointer data, edges) of each object using back ref.
- Write the root's back ref.

Deserialization:
- For each cluster, allocate each object and fill its byte data.
- For each cluster, fill the pointer data of each object.
- For each cluster, set the class of each object. (We must do this after all edges have been read to be sure the class's format field is valid and the object will not be truncated or have bytes interpreted as pointers or vis versa.)
- For each cluster, send #rehash to each object. (Identity hashes are not preserved across serialization.)

Perfomance compared to NewspeakObjectFormat:
     BootstrapRuntimeForSqueak  RuntimeForSqueak  HopscotchIDEApp
VF Ser       154.6ms +- 0.54%      419.5ms +- 2.27%     401.9ms +- 2.8%
NOF Ser     367.6ms +- 2.12%    1017.2ms +- 0.48%   1019.8ms +- 1.78%
NOF/VF                2.37                        2.42                         2.537
VF Des         45.4ms +- 2.24%      108.7ms +- 0.82%    108.7ms +- 0.54%
NOF Des     279.4ms +- 4.95%      900.3ms +- 0.90%     882.2ms +- 0.88%
NOF/VF                6.15                        8.28                          8.11

TODO:
- Handle Floats specially so they are portable between 32 and 64 bit images.
- Handle Integers up to 64 bits specially for portability.
- Use mirror primitives to allocate/trace/fill compiled methods.
- Write an identity map in Newspeak that uses mirror primitives for == and identityHash.
- The size of a WeakSet can change between analysis and writing edges to do a major GC, introducing an unanalyzed integer. How does Fuel deal with this?

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. *)|
	private List = p squeak OrderedCollection.
	private IdentityMap = p squeak IdentityDictionary.
	private CompiledMethod = p squeak CompiledMethod. (* Replace with mirror primitive for allocation. *)
	private WideString = p squeak WideString.
	private WideSymbol = p squeak WideSymbol.
	private processorAssociation = p squeak Smalltalk associationAt: #Processor.
	private vmmirror = vm.
	
	private SmiPsuedoFormat = -1.
	private CharPsuedoFormat = -2.
	private SymbolPsuedoFormat = -3.
	private WideSymbolPsuedoFormat = -4.
	private GlobalsPsuedoFormat = -5.
	private Version = 1.
|) (
public class Deserializer over: stream_ <ReadStream> withGlobals: globals_ <Map[Symbol, Object]> = (|
stream <ReadStream> = stream_.
globals <Map[Symbol, Object]> = globals_.
clusters <Array>
backRefs <Array>
nextBackRef <Integer>
|) (
class CharacterCluster = () (
'as yet unclassified'
public adoptInstances = (
)
public doRehash = (
)
public readEdges = (
)
public readNodes = (
	| numInstances |
	numInstances:: stream uint16.
	numInstances timesRepeat:
		[registerBackRef: (Character codePoint: stream int32)].
)
) : (
)
class CompiledMethodCluster for: fmt = (|
	format = fmt.
	klass
	backRefStart <Integer>
	backRefStop <Integer>
|) (
'as yet unclassified'
public adoptInstances = (
	|
	prim = vmmirror.
	stop = [halt].
	localClass = klass.
	|
	backRefStart to: backRefStop do: [:i |
		prim ifFail: stop haveClass: localClass adoptInstance: (backRefs at: i)].
)
public doRehash = (
)
public readEdges = (
	|
	prim = vmmirror.
	stop = [stop].
	namedSlots = format bitAnd: 16rFFFF.
	|
	klass:: readBackRef.
	backRefStart to: backRefStop do: [:i |
		| object = backRefs at: i. |
		1 to: object numLiterals + 1 do: [:j | 
			#BOGUS. (* Use a mirror primitive *)
			object objectAt: j put: readBackRef]].
)
public readNodes = (
	| prim stop allocClass numInstances |
	prim:: vmmirror.
	stop:: [halt].
	(* allocClass:: TemporaryClass withFormat: format. *)
	backRefStart:: nextBackRef.
	numInstances:: stream uint16.
	numInstances timesRepeat:
		[| numLiterals byteSize object |
		numLiterals:: stream uint16.
		byteSize:: stream uint16.
		#BOGUS. (* Should use mirror primitives. *)
		object:: CompiledMethod newMethod: byteSize header: numLiterals.
		object initialPC to: object basicSize do: [:i | prim ifFail: stop indexedSlotOf: object at: i put: stream next].
		registerBackRef: object].
	backRefStop:: nextBackRef - 1.
)
) : (
)
class FixedPointersCluster for: fmt = (|
	format = fmt.
	klass
	backRefStart <Integer>
	backRefStop <Integer>
	allocClass
|) (
'as yet unclassified'
public adoptInstances = (
	|
	prim = vmmirror.
	stop = [halt].
	localClass = klass.
	|
	backRefStart to: backRefStop do: [:i |
		prim ifFail: stop haveClass: localClass adoptInstance: (backRefs at: i)].
)
public doRehash = (
	backRefStart to: backRefStop do: [:i | (backRefs at: i) rehash].
)
public readEdges = (
	|
	prim = vmmirror.
	stop = [halt].
	namedSlots = format bitAnd: 16rFFFF.
	|
	klass:: readBackRef.
	backRefStart to: backRefStop do: [:i |
		| object = backRefs at: i. |
		1 to: namedSlots do: [:jj | prim ifFail: stop namedSlotOf: object at: jj put: readBackRef]].
)
public readNodes = (
	| 
	prim = vmmirror.
	stop = [halt].
	numInstances
	namedSlots = format bitAnd: 16rFFFF.
	|
	allocClass:: TemporaryClass withFormat: format.
	backRefStart:: nextBackRef.
	numInstances:: stream uint16.
	numInstances timesRepeat:
		[| object |
		object:: prim ifFail: stop instantiateFixedClass: allocClass.
		registerBackRef: object].
	backRefStop:: nextBackRef - 1.
)
) : (
)
class GlobalsCluster = () (
'as yet unclassified'
public adoptInstances = (
)
public doRehash = (
)
public readEdges = (
)
public readNodes = (
	| numInstances |
	numInstances:: stream uint16.
	numInstances timesRepeat: [
		|
		keySize = stream uint16.
		key = String new: keySize.
		|
		1 to: keySize do: [:i | key basicAt: i put: stream next].
		registerBackRef: (globals at: key asSymbol)].
)
) : (
)
class SmallIntegerCluster = () (
'as yet unclassified'
public adoptInstances = (
)
public doRehash = (
)
public readEdges = (
)
public readNodes = (
	| numInstances |
	numInstances:: stream uint16.
	numInstances timesRepeat:
		[registerBackRef: stream int32].
)
) : (
)
class SymbolCluster = () (
'as yet unclassified'
public adoptInstances = (
)
public doRehash = (
)
public readEdges = (
)
public readNodes = (
	| localStream = stream. numInstances |
	numInstances:: localStream uint16.
	numInstances timesRepeat:
		[ | size object |
		size:: localStream uint16.
		object:: String new: size.
		1 to: size do: [:i | object basicAt: i put: localStream next].
		registerBackRef: object asSymbol].
)
) : (
)
class Uint32Cluster for: fmt = (|
	format = fmt.
	klass
	backRefStart <Integer>
	backRefStop <Integer>
|) (
'as yet unclassified'
public adoptInstances = (
	|
	prim = vmmirror.
	stop = [halt].
	localClass = klass.
	|
	backRefStart to: backRefStop do: [:i |
		prim ifFail: stop haveClass: localClass adoptInstance: (backRefs at: i)].
)
public doRehash = (
)
public readEdges = (
	klass:: readBackRef.
)
public readNodes = (
	| prim allocClass numInstances |
	prim:: vmmirror.
	allocClass:: TemporaryClass withFormat: format.
	backRefStart:: nextBackRef.
	numInstances:: stream uint16.
	numInstances timesRepeat:
		[ | size object |
		size:: stream uint32.
		object:: prim ifFail: [halt] instantiateVariableClass: allocClass withSize: size.
		1 to: size do: [:i | prim ifFail: [halt] indexedSlotOf: object at: i put: stream uint32].
		registerBackRef: object].
	backRefStop:: nextBackRef - 1.
)
) : (
)
class Uint8Cluster for: fmt = (|
	format = fmt.
	klass
	backRefStart <Integer>
	backRefStop <Integer>
|) (
'as yet unclassified'
public adoptInstances = (
	|
	prim = vmmirror.
	stop = [halt].
	localClass = klass.
	|
	backRefStart to: backRefStop do: [:i |
		prim ifFail: stop haveClass: localClass adoptInstance: (backRefs at: i)].
)
public doRehash = (
)
public readEdges = (
	klass:: readBackRef.
)
public readNodes = (
	| prim allocClass numInstances localStream = stream. |
	prim:: vmmirror.
	allocClass:: TemporaryClass withFormat: format.
	backRefStart:: nextBackRef.
	numInstances:: localStream uint16.
	numInstances timesRepeat:
		[ | size object |
		size:: localStream uint32.
		object:: prim ifFail: [halt] instantiateVariableClass: allocClass withSize: size.
		1 to: size do: [:i | prim ifFail: [halt] indexedSlotOf: object at: i put: localStream next].
		registerBackRef: object].
	backRefStop:: nextBackRef - 1.
)
) : (
)
class VariablePointersCluster for: fmt = (|
	format = fmt.
	klass
	backRefStart <Integer>
	backRefStop <Integer>
|) (
'as yet unclassified'
public adoptInstances = (
	|
	prim = vmmirror.
	stop = [halt].
	localClass = klass.
	|
	backRefStart to: backRefStop do: [:i |
		prim ifFail: stop haveClass: localClass adoptInstance: (backRefs at: i)].
)
public doRehash = (
	backRefStart to: backRefStop do: [:i | (backRefs at: i) rehash].
)
public readEdges = (
	|
	prim = vmmirror.
	stop = [halt].
	namedSlots = format bitAnd: 16rFFFF.
	|
	klass:: readBackRef.
	backRefStart to: backRefStop do: [:i |
		| object = backRefs at: i. |
		1 to: namedSlots do:
			[:j | prim ifFail: stop namedSlotOf: object at: j put: readBackRef].
		1 to: (prim indexedSlotsOf: object) do:
			[:j | prim ifFail: stop indexedSlotOf: object at: j put: readBackRef]].
)
public readNodes = (
	| prim allocClass numInstances |
	prim:: vmmirror.
	allocClass:: TemporaryClass withFormat: format.
	backRefStart:: nextBackRef.
	numInstances:: stream uint16.
	numInstances timesRepeat:
		[| size object |
		size:: stream uint16.
		object:: prim ifFail: [halt] instantiateVariableClass: allocClass withSize: size.
		registerBackRef: object].
	backRefStop:: nextBackRef - 1.
)
) : (
)
class WideSymbolCluster = () (
'as yet unclassified'
public adoptInstances = (
)
public doRehash = (
)
public readEdges = (
)
public readNodes = (
	| localStream = stream. numInstances |
	numInstances:: localStream uint16.
	numInstances timesRepeat:
		[ | size object |
		size:: localStream uint16.
		object:: WideString new: size.
		1 to: size do: [:i | object basicAt: i put: localStream uint32].
		registerBackRef: object asSymbol].
)
) : (
)
'as yet unclassified'
WeakPointerCluster = (
	(* Same behavior during deserialization. *)
	^VariablePointersCluster
)
public deserialize = (
	| numClusters |
	assert: [stream uint16 = 16r1984] message: 'Not VictoryFuel'.
	assert: [stream uint16 = Version] message: 'Version mismatch'.
	numClusters:: stream uint16.
	clusters:: Array new: numClusters.
	backRefs:: Array new: stream uint16.
	nextBackRef:: 1.
	registerBackRef: nil.
	registerBackRef: false.
	registerBackRef: true.
	registerBackRef: processorAssociation.

	1 to: numClusters do: [:i | clusters at: i put: readCluster readNodes].
	1 to: numClusters do: [:i | (clusters at: i) readEdges].
	1 to: numClusters do: [:i | (clusters at: i) adoptInstances].
	1 to: numClusters do: [:i | (clusters at: i) doRehash].
	^readBackRef
)
readBackRef = (
	^backRefs at: stream uint16
)
readCluster = (
	| format = readFormat. instSpec |
	
	format == SmiPsuedoFormat ifTrue: [^SmallIntegerCluster new].
	format == CharPsuedoFormat ifTrue: [^CharacterCluster new].
	format == SymbolPsuedoFormat ifTrue: [^SymbolCluster new].
	format == WideSymbolPsuedoFormat ifTrue: [^WideSymbolCluster new].
	format == GlobalsPsuedoFormat ifTrue: [^GlobalsCluster new].

	instSpec:: (format bitShift: -16) bitAnd: 16r1F.
	instSpec <= 1 ifTrue: [^FixedPointersCluster for: format].
	instSpec <= 3 ifTrue: [^VariablePointersCluster for: format].
	instSpec <= 4 ifTrue: [^WeakPointerCluster for: format].
	instSpec <= 5 ifTrue: [^EphemeronCluster for: format].	
	instSpec <= 9 ifTrue: [halt].
	instSpec <= 11 ifTrue: [^Uint32Cluster for: format].
	instSpec <= 15 ifTrue: [^Uint16Cluster for: format].
	instSpec <= 23 ifTrue: [^Uint8Cluster for: format].
	instSpec <= 31 ifTrue: [^CompiledMethodCluster for: format].
		
	Error signal: 'Unknown format'.
)
readFormat = (
	^stream int32
)
registerBackRef: object = (
	backRefs at: nextBackRef put: object.
	nextBackRef:: nextBackRef + 1.
)
) : (
)
public class Serializer over: stream_ <ReadStream> withGlobals: globals_ <Map[Symbol, Object]> = (|
stream = stream_.
clusters = IdentityMap new.
stack = List new: 32.
backRefs = IdentityMap new: 4096.
nextBackRef
reverseGlobals = IdentityMap new.
|globals_ keysAndValuesDo: [:k :v | reverseGlobals at: v put: k]) (
class CharacterCluster for: cls = (|
klass = cls.
objects = List new.
|) (
'as yet unclassified'
public analyze: object <Character> = (
	objects add: object.
)
public writeEdges = (
)
public writeNodes = (
	writeFormat: CharPsuedoFormat.
	stream uint16: objects size.
	objects do: [:object |
		registerBackRef: object.
		stream uint32: object codePoint].
)
) : (
)
class Cluster = () (
) : (
)
class CompiledMethodCluster for: cls = (|
klass = cls.
namedSlots = cls instSize.
objects = List new.
|) (
'as yet unclassified'
public analyze: object = (
	objects add: object.
	pointersOf: object do: [:each | enqueue: each].
)
pointersOf: object do: action = (
	#BOGUS. (* Should use mirror primitives. *)
	1 to: object numLiterals + 1 do: [:i | action value: (object objectAt: i)].
)
public writeEdges = (
	writeBackRef: klass.
	objects do: [:object |
		pointersOf: object do: [:each | writeBackRef: each]].
)
public writeNodes = (
	| prim = vmmirror. |
	writeFormat: klass format.
	stream uint16: objects size.
	objects do: [:object | 
		registerBackRef: object.
		#BOGUS. (* Should use mirror primitives. *)
		stream uint16: object numLiterals.
		stream uint16: object basicSize - object initialPC + 1.
		object initialPC to: object basicSize do: [:i | stream nextPut: (object basicAt: i)]].
)
) : (
)
class FixedPointersCluster for: cls = (|
klass = cls.
namedSlots = cls format bitAnd: 16rFFFF.
objects = List new.
|) (
'as yet unclassified'
public analyze: object = (
	|
	prim = vmmirror.
	stop = [halt].
	|
	objects add: object.
	1 to: namedSlots do: [:i | enqueue: (prim ifFail: stop namedSlotOf: object at: i)].
)
public writeEdges = (
	|
	prim = vmmirror.
	stop = [halt].
	n = namedSlots.
	|
	writeBackRef: klass.
	objects do: [:object |
		1 to: n do: [:i | writeBackRef: (prim ifFail: stop namedSlotOf: object at: i)]].
)
public writeNodes = (
	writeFormat: klass format.
	stream uint16: objects size.
	objects do: [:object | registerBackRef: object].
)
) : (
)
class GlobalsCluster new = (|
	klass
	objects = List new.
|) (
'as yet unclassified'
public analyze: object = (
	objects add: object.
)
public writeEdges = (
)
public writeNodes = (
	writeFormat: GlobalsPsuedoFormat.
	stream uint16: objects size.
	objects do: [:object |
		|
		key = reverseGlobals at: object.
		keySize = key size.
		|
		registerBackRef: object.
		stream uint16: keySize.
		1 to: keySize do: [:i | stream nextPut: (key basicAt: i)]].
)
) : (
)
class SmallIntegerCluster for: cls = (|
klass = cls.
objects = List new.
|) (
'as yet unclassified'
public analyze: object <SmallInteger> = (
	objects add: object.
)
public writeEdges = (
)
public writeNodes = (
	writeFormat: SmiPsuedoFormat.
	stream uint16: objects size.
	objects do: [:object |
		registerBackRef: object.
		stream int32: object].
)
) : (
)
class SymbolCluster for: cls = (|
klass = cls.
objects = List new.
|) (
'as yet unclassified'
public analyze: object <ByteSymbol> = (
	objects add: object.
)
public writeEdges = (
)
public writeNodes = (
	writeFormat: SymbolPsuedoFormat.
	stream uint16: objects size.
	objects do: [:object |
		registerBackRef: object.
		stream uint16: object size.
		1 to: object size do: [:i | stream nextPut: (object basicAt: i)]].
)
) : (
)
class Uint32Cluster for: cls = (|
klass = cls.
objects = List new.
|) (
'as yet unclassified'
public analyze: object = (
	objects add: object.
)
public writeEdges = (
	writeBackRef: klass.
)
public writeNodes = (
	|
	prim = vmmirror.
	stop = [halt].
	|
	writeFormat: klass format.
	stream uint16: objects size.
	objects do: [:object |
		registerBackRef: object.
		stream uint32: object size.
		1 to: object size do: [:i | stream uint32: (prim ifFail: stop indexedSlotOf: object at: i)]].
)
) : (
)
class Uint8Cluster for: cls = (|
klass = cls.
objects = List new.
|) (
'as yet unclassified'
public analyze: object = (
	objects add: object.
)
public writeEdges = (
	writeBackRef: klass.
)
public writeNodes = (
	|
	prim = vmmirror.
	stop = [halt].
	|
	writeFormat: klass format.
	stream uint16: objects size.
	objects do: [:object |
		registerBackRef: object.
		stream uint32: object size.
		1 to: object size do: [:i | stream nextPut: (prim ifFail: stop indexedSlotOf: object at: i)]].
)
) : (
)
class VariablePointersCluster for: cls = (|
klass = cls.
namedSlots = cls instSize.
objects = List new.
|) (
'as yet unclassified'
public analyze: object = (
	objects add: object.
	pointersOf: object do: [:each | enqueue: each].
)
pointersOf: object do: action = (
	| prim = vmmirror. |
	1 to: namedSlots do:
		[:i | action value: (prim ifFail: [halt] namedSlotOf: object at: i )].
	1 to: (prim indexedSlotsOf: object) do:
		[:i | action value: (prim ifFail: [halt] indexedSlotOf: object at: i)].
)
public writeEdges = (
	writeBackRef: klass.
	objects do: [:object |
		pointersOf: object do: [:each | writeBackRef: each]].
)
public writeNodes = (
	| prim = vmmirror. |
	writeFormat: klass format.
	stream uint16: objects size.
	objects do: [:object | 
		registerBackRef: object.
		stream uint16: (prim indexedSlotsOf: object)].
)
) : (
)
class WeakPointersCluster for: cls = (|
klass = cls.
namedSlots = cls instSize.
objects = List new.
|) (
'as yet unclassified'
public analyze: object = (
	objects add: object.
	strongPointersOf: object do: [:each | enqueue: each].
)
strongPointersOf: object do: action = (
	(* The fixed pointers of format 4 objects are strong, and the indexed pointers are weak. *)
	| prim = vmmirror. |
	1 to: namedSlots do:
		[:i | action value: (prim namedSlotOf: object at: i ifFail: [halt])].
)
weakPointersOf: object do: action = (
	(* The fixed pointers of format 4 objects are strong, and the indexed pointers are weak. *)
	| prim = vmmirror. |
	1 to: (prim indexedSlotsOf: object) do:
		[:i | action value: (prim ifFail: [halt] indexedSlotOf: object at: i)].
)
public writeEdges = (
	|
	prim = vmmirror.
	stop = [halt].
	n = namedSlots.
	|
	writeBackRef: klass.
	objects do: [:object |
		1 to: n do:
			[:i | writeBackRef: (prim ifFail: stop namedSlotOf: object at: i)].
		1 to: (prim indexedSlotsOf: object) do:
			[:i | writeWeakBackRef: (prim ifFail: stop indexedSlotOf: object at: i)]].
)
public writeNodes = (
	| prim = vmmirror. |
	writeFormat: klass format.
	stream uint16: objects size.
	objects do: [:object | 
		registerBackRef: object.
		stream uint16: (prim indexedSlotsOf: object)].
)
) : (
)
class WideSymbolCluster for: cls = (|
klass = cls.
objects = List new.
|) (
'as yet unclassified'
public analyze: object <WideSymbol> = (
	objects add: object.
)
public writeEdges = (
)
public writeNodes = (
	writeFormat: WideSymbolPsuedoFormat.
	stream uint16: objects size.
	objects do: [:object |
		registerBackRef: object.
		stream uint16: object size.
		1 to: object size do: [:i | stream uint32: (object basicAt: i)]].
)
) : (
)
'as yet unclassified'
analyze: object = (
	(clusterFor: object) analyze: object
)
clusterFor: object = (
	(reverseGlobals includesKey: object) ifTrue: [^clusterForClass: nil].
	^clusterForClass: (vmmirror classOf: object).
)
clusterForClass: klass = (
	^clusters at: klass ifAbsentPut: [newClusterForClass: klass].
)
enqueue: object = (
	backRefs at: object ifAbsentPut: [stack add: object. 0].
)
newClusterForClass: klass = (
	| instSpec |
	nil == klass ifTrue: [^GlobalsCluster new].
	
	enqueue: klass.

	0 class == klass ifTrue: [^SmallIntegerCluster for: klass].
	$a class == klass ifTrue: [^CharacterCluster for: klass].
	#hi class == klass ifTrue: [^SymbolCluster for: klass].
	WideSymbol == klass ifTrue: [^WideSymbolCluster for: klass].

	instSpec:: klass instSpec.
	instSpec <= 1 ifTrue: [^FixedPointersCluster for: klass].
	instSpec <= 3 ifTrue: [^VariablePointersCluster for: klass].
	instSpec <= 4 ifTrue: [^WeakPointersCluster for: klass].
	instSpec <= 5 ifTrue: [^EphemeronCluster for: klass].	
	instSpec <= 9 ifTrue: [halt].
	instSpec <= 11 ifTrue: [^Uint32Cluster for: klass].
	instSpec <= 15 ifTrue: [^Uint16Cluster for: klass].
	instSpec <= 23 ifTrue: [^Uint8Cluster for: klass].
	instSpec <= 31 ifTrue: [^CompiledMethodCluster for: klass].
	halt.
)
registerBackRef: object = (
	backRefs at: object put: nextBackRef.
	nextBackRef:: nextBackRef + 1.
)
public serialize: root = (
	| rewind fastforward |
	nextBackRef:: 1.
	registerBackRef: nil.
	registerBackRef: false.
	registerBackRef: true.
	registerBackRef: processorAssociation.

	enqueue: root.
	[stack isEmpty] whileFalse: [analyze: stack removeLast].
	
	stream uint16: 16r1984.
	stream uint16: Version.
	stream uint16: clusters size.
	rewind:: stream position.
	stream uint16: 0.
	clusters do: [:c | c writeNodes].
	clusters do: [:c | c writeEdges].
	writeBackRef: root.

	fastforward:: stream position.
	stream position: rewind.
	stream uint16: nextBackRef.
	stream position: fastforward.
)
writeBackRef: object = (
	stream uint16: (backRefs at: object).
)
writeFormat: format = (
	stream int32: format.
)
writeWeakBackRef: object = (
	| ref = backRefs at: object ifAbsent: [backRefs at: nil]. |
	stream uint16: ref.
)
) : (
)
class TemporaryClass withFormat: fmt = (
(* A fake class used for allocation. If deserialization is successful, no message should be sent to any object before the graph is fully deserialized, and the VM will only interpret the format field of this object. If things go wrong, the other fields should make messages to incomplete objects result in MessageNotUnderstood: PartiallyDeserializedObject>>message instead of a crash. *)|
	superclassX = Object.
	methodDictionaryX = Object methodDictionary.
	formatX = fmt.
	mixinX
	enclosingObjectX
	subclassesX
	public name = 'PartiallyDeserializedObject'.
|) (
) : (
)
) : (
'as yet unclassified'
FORMAT = ((*
	
== Header ==
16: magic number
16: num clusters
16: num back refs

== Nodes ==
	== Cluster ==
	32: psuedo format or class format
	16: num instances
		== Object ==
		[16: size if variable]
		[n: data, if bits]

== Edges ==
	== Cluster ==
	{16: class backref}
		== Object ==
		{16: backrefs}

== Footer ==
16: root backref

*))
)
