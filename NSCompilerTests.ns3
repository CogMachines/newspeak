Newspeak3
'Newspeak3-tests'
class NSCompilerTests usingPlatform: p ns: ns minitest: minitest = NewspeakObject (
"Describe the class in this comment."|
	TestContext = minitest TestContext.
	
      private Smalltalk = p collections Dictionary new. "A fake namespace for testing"
	ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	ClassDeclarationMirror = p mirrors ClassDeclarationMirror.
	
	parserLib = ns BlocklessCombinatorialParsing usingLib: p.
	ns3grammar = ns Newspeak3Grammar parserLib: parserLib.
	astModule = ns Newspeak3AST usingLib: p.
	parsingModule = ns Newspeak3Parsing usingLib: p
                                                       ast: astModule
                                                       grammar: ns3grammar.
	mirrors = ns NewspeakMirrors usingLib: p.
	compilationModule = ns Newspeak3Compilation usingPlatform: p 
                                           newspeakParser: parsingModule
                                           mirrorLib: mirrors.
|)
(
class CompilerTests = TestContext (
"This class is intended to test the compiler.

It will include tests for:


A. Straight line code:

An empty method with no parameters (which should return self).
An empty method with one parameter.
An empty method with two parameters.
An empty method with N parameters (where N is some meaningful boundary condition - 8, 16. 32)
Same for N+1.

A method that consists of a simple single literal:
An integer, a float, a boolean, nil, a character, a string, a symbol.

These tests simply check that the compiler doesn't crash, and that the resulting method returns
self.

A method that assigns a single literary to a temporary.  Testing as above.

A method that returns a single literal. These check for the expected result.

A method that assigns a single literal to a temporary and returns it. As above.

A method that accepts a single parameter and returns it.
A method  that accepts a single parameter and assigns it to a temporary.
A method  that accepts a single parameter and assigns it to a temporary and returns it.

A method that assigns one temporary to another.
Same, but returns the result (test that it is nil).

A method that reads a slot; a method that assigns a slot; returns a slot?

Some bad stuff: assigning to self, super or a parameter and checking that this is rejected.

A method that performs a unary message send.  The send should have some testable side effect we can verify.
Same, but return the result of the send.
Similar pairs for binary and keyword methods, with simple literals as arguments.
Similar pairs for binary and keyword methods, where the arguments are themselves message sends.
Versions with ''depth'' 2 and 3.

Test tuple literals of size: 0, 1, 2,8, 16, 32, 64.
Same, but return them.

Method with a series of statements:
1. Each statement is a simple literal.
2. Each statement is a send.
3. As above, but ending with a return statement.


B. Methods with control flow:

1. IfTrue:, ifTrue:ifFalse:, ifFalse:, ifFalse:ifTrue:, all without nesting.
2. whileTrue:, whileFalse: without nesting.
3. As above, but nested to2 levels. 36 combinations
4. As above, but nested to 3 levels (only a few variations).

C. Blocks:

A method that returns with a single empty block with no arguments
A method that returns a single empty block with one argument.
A method that returns a single empty block with two arguments.
All these test that a block comes back, and can be invoked to return nil.

A method that returns a block with no arguments, with a single literal inside. Test that it yields
expected result.

A method that returns a block with one argument, with a statement that consists of the incoming parameter.
Same, but the block adds 1 to the argument.
Same, but the block contains a temporary of its own, to, which the parameter is assigned, then
the temporary is the last statement.
As above, but increment the temp by 1.

Code with a block that does a non-local return.
...
Until  a case like
{#a. #b} do:[:each | menu at: each putAction:[Transcript show: each]]
where Squeak will fail because it wil reuse the parameter.

   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
	klass ::= (ClassDeclarationBuilder fromUnitSource: sourceForTestClass) install reflectee apply: Object.
	ns2compiler = compilationModule Compiler new.
|)
('as yet unclassified'
checkClass: klass hasAccessorsFor: s = (
 

| getter setter |

getter:: s. 
setter:: (s, ':' ) asSymbol.
self assert:[ (klass methodDictionary includesKey: getter) and: [klass methodDictionary includesKey: setter]].
"check that the accessors are invisible"

self assert:[(klass whichCategoryIncludesSelector: getter) isNil].
self assert:[(klass whichCategoryIncludesSelector: setter) isNil].
)
cleanUp = (
 	"klass removeFromSystem."
	klass:: nil.
)
compileClassSource: src <String> = (
 
"Compile a class and install the change"
"| rep <MixinRep>  |
  rep:: ns2compiler compileClassSource: src readStream within: nil.
  Reflection new installMixinReps: {rep}
"
	| builder mixin klazz |
	builder:: (ClassDeclarationBuilder fromUnitSource: src).
	mixin:: builder install reflectee.
	klazz:: mixin apply: Object withName: builder simpleName.
	Smalltalk at: klazz name put: klazz. "BOGUS: tests shouldn't be mucking up Smalltalk"
  	^klazz
)
compileMethodSource: src <String> = (
 	| cdb |
	cdb:: (ClassDeclarationBuilder reflecting: klass mixin).
	cdb instanceSide methods addFromSource: src.
	cdb install.
)
donttestReturnTupleLiteral32 = (


| nu |
   compileMethodSource: 'returnTupleLiteral32 = (^{ #abc.  0. $z.  ''def''. true. false. nil. self.  1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. $a. $b. $c. $d. $e. $f. $g. $h}) '.
   nu:: klass new.
   assert:[{ #abc.  0. $z.  'def'. true. false. nil. nu.  1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. $a. $b. $c. $d. $e. $f. $g. $h} = nu returnTupleLiteral32].
   
)
donttestReturnTupleLiteral64 = (

"disabled for now"
| nu |
   compileMethodSource: 'returnTupleLiteral64 = (^{ #abc.  0. $z.  ''def''. true. false. nil. self.  1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. $a. $b $c. $d. $e. $f. $g. $h. $i. $j. $k. $l. $m. $n. $o. $p. $q. $r. $s. $t. $u. $v. $w. $x. $y. $z. $A. $B. $C. $D. $E. $F. $G. $H. $I. $J. $K. $L. $M .$N}) '.
   nu:: klass new.
   assert:[{ #abc.  0. $z.  'def'. true. false. nil. nu.  1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. $a. $b. $c. $d. $e. $f. $g. $h. $i. $j. $k. $l. $m. $n. $o. $p. $q. $r. $s. $t. $u. $v. $w. $x. $y. $z. $A. $B. $C. $D. $E. $F. $G. $H. $I. $J. $K. $L. $M .$N} = nu returnTupleLiteral64].
   
)
donttestTupleLiteral32 = (


| nu |
   compileMethodSource: 'tupleLiteral32 = ({ #abc.  0. $z.  ''def''. true. false. nil. self.  1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. $a. $b. $c. $d. $e. $f. $g. $h}) '.
   nu:: klass new.
   assert:[nu = nu tupleLiteral32].
   
)
donttestTupleLiteral64 = (


| nu |
   compileMethodSource: 'tupleLiteral64 = ({ #abc.  0. $z.  ''def''. true. false. nil. self.  1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. $a. $b. $c. $d. $e. $f. $g. $h. $i. $j. $k. $l. $m. $n. $o. $p. $q. $r. $s. $t. $u. $v. $w. $x. $y. $z. $A. $B. $C. $D. $E. $F. $G. $H. $I. $J. $K. $L. $M .$N}) '.
   nu:: klass new.
   assert:[nu = nu tupleLiteral64].
   
)
ns2TestDynamicSuper ^ <ReadStream> = (
^'Newsqueak2 
''NS2-tests''
class NS2DynamicSuperTest sup: Sup =  (
  | App = Inner mixin |> Sup. |
)
( 
   class Inner = () (
	''access''
	species = (^#Specious, super class printString)
   )

  class MixedUp = App()()
)' readStream.	
)
ns2TestExplicitOuterInInitializer ^ <ReadSteam> = (
^' Newsqueak2 
''NS2-tests''
class NS2ExplicitOuterInInitTest  =  ()
( 
   class Inner = (
     |  
     f = 2 * outer NS2ExplicitOuterInInitTest m.
     |) (
)

''access''

  m = (^91)
)' readStream.	
)
ns2TestImplicitOuterInInitializer ^ <ReadSteam> = (
^' Newsqueak2 
''NS2-tests''
class NS2ImplicitOuterInInitTest  =  ()
( 
   class Inner = (
     |  
     f = 2 * m.
     |) (
)

''access''

  m = (^91)
)' readStream.
)
ns2TestParseAccessors ^ <ReadSteam> = (
^'Newsqueak2 

''NS2-tests''

class NS2ParseAccessorsTest =  (

)

( 

   ''access''

	private wintergreen = (^true)

	protected schweik = (^true)

	public enemy = (^true)

	privateFirstClass = (^true)

	protectedSpeech = (^true)

	publicServant = (^true)



)' readStream.
)
ns2test12 = (
^'Newsqueak2
''NS2-testing''
class NS2Test12 s: aClass =  (
"Test for n-levels of nesting"

| Sup = aClass. |

)
(

 class Inner1 = Sup ()
      ( 
        class Inner11 = Sup ()
           (
           class Inner111 = Sup () 
              ( 
                ''tests'' 
                baz = (^outer Inner11 bar + outer Inner1 foo + outer NS2Test12 m)
              )

             '' tests''
             bar = (^outer NS2Test12 m + outer Inner1 foo)
           )

       '' tests''
        foo = (
            ^outer NS2Test12 m
           )

     )
''access''
"(NS2Test12 s: Object) Inner1 new Inner11 new Inner111 new bar = 364"
 m = (
      ^91
     )

)


'
)
ns2test14a = (
^'Newsqueak2
''NS2-testing''
class NS2Test14a  = (
"A nested test case"
)
(

 class Inner1 create =  ( )
      ( ''nested calls''
        foo = (
            ^m
           )
       )


''access''
 m = (
      ^91
     )

)

'
)
ns2test14b = (
^'Newsqueak2
''NS2-testing''
class NS2Test14b s: aClass = (
"A nested test case"
|
Sup = aClass.
|
)
(

 class Inner2  = Sup create ( )
      ( ''nested calls''
        bar = (
            ^foo
           )
       )


''access''
"(NS2Test14b s: NS2Test14a new Inner1) Inner2 new bar = 91"
 m = (
      ^42
     )

)

'
)
ns2test15 = (
^'Newsqueak2
''NS2-testing''
class NS2Test15 = () (
  class I = ( ) (
  ):(''class methods'' static = ( ^I new))

)'
)
ns2test16 = (
^'Newsqueak2
''NS2-testing''
class NS2Test16 = () (
  class ISup = ( ) (
   '' cat sup''
   ketchup = (^16)
  )

  class ISub = ISup ()(
  ''cat sub''
   mayo = (^ketchup+1)
  )

)'
)
ns2test17 = (
^'Newsqueak2
''NS2-testing''
class NS2Test17 x: i y: j z: k =  (
"Test initializers"
| x ::= i. y ::= j. z rho theta |

 z: x + y + k.
 rho: 1000*z.
 theta:: rho+y
)
(

)

'
)
ns2test18 = (
"This test creates a situation where the an object's enclosing instance with respect to its class (Inner2) is an instance of the same class (NS2Test18) as its enclosing instance with respect to its superclass (Inner1).  
"
^'Newsqueak2
''NS2-testing''
class NS2Test18 s: Sup =  (
" o1:: NSTest18 s: platform Object.
  o2:: NSTest18 s: o1 Inner1.
"
| SuperClass = Sup. | 
) (
  class Inner1 = ()(''misc''  i1 = (^Inner1))
  class Inner2 = SuperClass ()(
''misc''
      i1 = (^Inner1)
      supI1 = (^super i1)
  )
)
'
)
ns2test20 = (
^'Newsqueak2
''NS2-testing''
class NS2Test20 new = Object new (
"" 
|  |
)
(

class Outer = (
"Describe the class in this comment."
)
(

class Inner = (
"Describe the class in this comment."

)
(''NS2Test20 new OuterSub new Inner new foo = 85 ''
foo = (
	^m + y
)

)''as yet unclassified''
m = (
	^91
)

y = (
	^8
)

)

class OuterSub = Outer (
"Describe the class in this comment."

)
(''as yet unclassified''
m = (
	^77
)

))
'
)
ns2test21 = (

^'Newsqueak2 
''NS2-tests'' 
class NS2Test21= NewspeakObject ("NS2Test21new C new B1 newb B1a") 
( 
	class A = ()() 
	class B = A() 
	( 
		class B1 = () 
		( 
			class B1a = A ()() 
		) 
	) 
	class C = B ()() 
)
'
)
ns2test22 = (

^'Newsqueak2 
''NS2-tests'' 
class NS2Test22= NewspeakObject ("NS2Test22 new testMultipleSetters2 = 91") 
( 
''uncategorized''

a: alpha = ()

b: beta = ()

testMultipleSetters2 = (
	| x  |
	
	^x::  (a:: 42) + (b:: 49).
)
)
'
)
ns2test23 = (

^'Newsqueak2 
''NS2-tests'' 
class NS2Test23= NewspeakObject ("NS2Test23 new testMultipleSetters2 = 135") 
( 
''uncategorized''

a: alpha = ()

b: beta = ()

c: gamma = ()

testMultipleSetters2 = (

	^a:: 42 + (b:: 49) + (c:: 44).

))
'
)
ns2test3 = (
^'Newsqueak2
''NS2-testing''
class NS2Test3 s: aClass = (
"A nested test case"
|
Sup = aClass.
|
)
(

 class Inner create = Sup ( )
      ( ''nested calls''
        foo = (
            ^m
           )
       )


''access''
"(NS2Test3 s: Object) Inner create foo = 91"
 m = (
      ^91
     )

)

'
)
ns2test7 = (
^'Newsqueak2
''NS2-testing''
class NS2Test7 s: aClass =  (
"A perverse nested test case. This example only works if nested classes
are created lazily (as they are right now). An eager semantics would
cause an infinite regress of nested classes being created.

Is even the eager case actually a problem? One can always write an 
infinite loop in an initializer. How is this different?"
|
Sup = aClass.
|
)
(

 class Inner = Sup s: Sup ( ) "Under comb semantics the argument  "
      ( ''nested calls'' "refers to Inner''s Sup, which is not yet 
                        initialized. A real puzzler.
Under new semantics, lexically evident  Sup will be used rather than inherited one - which is what we expect.
Arguably, both should work, but Squeak dies if the superclass is nil"
        foo = (
            ^m
           )
       )


''access''
"(NS2Test7 s: NS2Test7) Inner new Inner new Inner new foo = 91"
 m = (
      ^91
     )

)


'
)
ns2test8 = (
^'Newsqueak2
''NS2-testing''
class NS2Test8 s: aClass =  (
"Test for n-levels of nesting"

| Sup = aClass. |

)
(

 class Inner1 = Sup ()
      ( 
        class Inner11 = Sup ()
           (
           class Inner111 = Sup () 
              ( 
                ''tests'' 
                baz = (^bar + foo + m)
              )

             '' tests''
             bar = (^m + foo)
           )

       '' tests''
        foo = (
            ^m
           )

     )
''access''
"(NS2Test8 s: Object) Inner1 new Inner11 new Inner111 new bar = 364"
 m = (
      ^91
     )

)


'
)
ns2test9 = (
^'Newsqueak2
''NS2-testing''
class NS2Test9 = (
"Test mutually referential nested classes (and implicit use of Object)"
)
(

 class Inner1  =  ( )
      ( ''nested calls''
        foo = (
            ^Inner2 new val
           )
       )



"(NS2Test9 new Inner1 new foo = 91"
 class Inner2  =  ( )
      ( ''nested calls''
        val = (
            ^91
           )
       )

)

'
)
ns2testModifyInitWithSchemaChange ^ <ReadSteam> = (
^'Newsqueak2 
''NS2-tests''
class NS2TestModifyInitWithSchemaChange = (
 | aVar = 3. | 
)(
  class Inner = (| myVar = aVar +1. |) ()

)
' readStream
)
ns2testModifyInitWithSchemaChange2 ^ <ReadSteam> = (
^'Newsqueak2 
''NS2-tests''
class NS2TestModifyInitWithSchemaChange = (
 | aVar = 3. anotherVar = 4. | 
)(
  class Inner = (| myVar = aVar +1. |) ()

)
' readStream
)
ns2testSetter = (
^'Newsqueak2
''NS2-testing''
class NS2TestSetter =  (

| slot slot2 slot3 |

)
(
''category''
method = (
	| local |
	local:: local:: 1.

	self assert: [local = 1] message: ''1''.
	
	slot:: slot:: slot:: 2.
	
	self assert: [slot = 2] message: ''2''.
	
	local:: slot:: 3.
	
	self assert: [local = 3] message: ''l3''.
	self assert: [slot = 3] message: ''s3''.
	
	local:: 4.
	
	^slot:: slot2:: slot3:: local
)

)


'
)
nsTestIfCascade = (
	^'Newspeak3
''NS2-testing''

class TestIfCascade = ( | slot1 slot2 | )(
''unclassified''
 fail = (
  |x| x: class new.
  x slot1: (true ifTrue: [3] ifFalse: [4]); slot2: 8.
  ^x 
 )
)'
)
nsTestInlinedSetters = (
	^'Newspeak3
''NS2-testing''

class TestInlinedSetters = ( | slot1 slot2 field0 field1 field2 field3 field4  | )(
''unclassified''
expr1 = (^23)
expr2 = (^36)
expr3 = (^52)
expr4 = (^69)

y = (
 	| a b |
	field0: (slot1:: 0). "Correct: uses method''s setter temp"
	[
		field1: (slot2:: self expr1)."Correct: uses closures''s setter temp"
		field2: (true ifTrue: [slot2:: self expr2]). "WRONG: uses method''s setter temp"
		field3: ([true] value ifTrue: [slot2:: self expr3]). "WRONG: uses method''s setter temp"
		field4:(slot2:: self expr4). "Correct: uses closures''s setter temp"
	] value.
)
)'
)
resources = (
	^super resources, {CompilerTestResource setUp:[] tearDown:[]}
)
sourceForTestClass ^<ReadStream> = (

^' Newsqueak2 
''NS2-tests''
class NS2CompilationTest =  Object  ( | testSlot | ) ()' readStream
)
testAssignBooleanLiteral = (


| nu |
   compileMethodSource: 'assignBooleanLiteral = (| t |  t:: false) '.
   nu:: klass new.
   assert:[nu = nu assignBooleanLiteral].
   
)
testAssignCharacterLiteral = (


| nu |
   compileMethodSource: 'assignCharacterLiteral = (| t |  t:: $c) '.
   nu:: klass new.
   assert:[nu = nu assignCharacterLiteral].
   
)
testAssignFloatLiteral = (


| nu |
   compileMethodSource: 'assignFloatLiteral = (| t |  t:: 3.14159) '.
   nu:: klass new.
   assert:[nu = nu assignFloatLiteral].
   
)
testAssignIntLiteral = (


| nu |
   compileMethodSource: 'assignIntLiteral = (| t |  t:: 42) '.
   nu:: klass new.
   assert:[nu = nu assignIntLiteral].
   
)
testAssignNil = (


| nu |
   compileMethodSource: 'assignNil = (| t |  t:: nil) '.
   nu:: klass new.
   assert:[nu = nu assignNil].
   
)
testAssignParam = (


| nu |
   compileMethodSource: 'assignParam: x = (| t | t:: x) '.
   nu:: klass new.
   assert:[nu = (nu assignParam: 91) ].
   
)
testAssignStringLiteral = (


| nu |
   compileMethodSource: 'assignStringLiteral = (| t |  t:: ''abc'') '.
   nu:: klass new.
   assert:[nu = nu assignStringLiteral].
   
)
testAssignSymbolLiteral = (


| nu |
   compileMethodSource: 'assignSymbolLiteral = (| t |  t:: #abc) '.
   nu:: klass new.
   assert:[nu = nu assignSymbolLiteral].
   
)
testAssignTemps = (


| nu |
   compileMethodSource: 'assignTemps = (| t1 t2  | t1:: t2) '.
   nu:: klass new.
   assert:[nu = nu assignTemps ].
   
)
testBooleanLiteral = (


| nu |
   compileMethodSource: 'booleanLiteral = (true) '.
   nu:: klass new.
   assert:[nu = nu booleanLiteral].
   
)
testCharacterLiteral = (


| nu |
   compileMethodSource: 'characterLiteral = ($c) '.
   nu:: klass new.
   assert:[nu = nu characterLiteral].
   
)
testClassMethodScope15 = (


| klassA  innerKlass   anInstance anInnerInstance anInnerInnerInstance  |

compileClassSource: ns2test15.
klassA:: Smalltalk at: #NS2Test15.
anInstance:: klassA new.

innerKlass::  anInstance I.
assert:[innerKlass static class = innerKlass].

)
testClosureNLR = (


| nu closure1 closure2 |
	compileMethodSource: 'nlr: x = ( [^x] value. ^2 )'.
 	nu:: klass new.
	assert: [(nu nlr: 42) = 42].
)
testClosureNLR2 = (


| nu closure1 closure2 |
	compileMethodSource: 'closureNLR2 = (
	| block |

	block:: [:n | n < 10 ifTrue: [^true] ifFalse: [block value: n-1]].

	block value: 20.

	^false
)'.
 	nu:: klass new.
	assert: [(nu closureNLR2) = true].
)
testClosureNestCounters = (


| nu gen c1 c2 |
	compileMethodSource: '
counterGenerator: param = (
	| totalCount ::= 9. |
	^[
		| count ::= 0. |
		[
			count:: count+1.
			totalCount:: totalCount + 1.
			count @ totalCount
		]
	].
)'.
 	nu:: klass new.
	
	gen:: nu counterGenerator: #ignored.
	c1:: gen value.
	c2:: gen value.
	
	assert: [c1 value = (1@10)].
	assert: [c1 value = (2@11)].
	assert: [c2 value = (1@12)].
	assert: [c1 value = (3@13)].
	assert: [c2 value = (2@14)].
	c1:: gen value.
	assert: [c1 value = (1@15)].
	assert: [c1 value = (2@16)].
	assert: [c2 value = (3@17)].
)
testClosureReentrancy = (
| nu  |
	compileMethodSource: '
closureFactorial = (
	| factorial |
        factorial:: [:n| n = 1 ifTrue: [1] ifFalse: [(factorial value: n - 1) * n]].
       ^(1 to: 10) collect: factorial
)'.
 	nu:: klass new.
	assert: [nu closureFactorial = {1. 2. 6. 24. 120. 720. 5040. 40320. 362880. 3628800}].
)
testClosureTempFrame = (


| nu closure1 closure2 |
	compileMethodSource: 'insideInlinedBlock = (
	| a b c|
	a: 10.
	b: 20.
	c: 40.
	a < 200 ifTrue: [
		^(b < 1000) and: [c > 0]
	]
) '.
 	nu:: klass new.
	assert: [nu insideInlinedBlock = true].
)
testCompilePseudoVariables = (


| aKlass |

"create a test class"
compileClassSource: ' Newsqueak2 
''NS2-tests''
class NS2CompilePseudoVariablesTest create =  () ()'.

aKlass:: Smalltalk at: #NS2CompilePseudoVariablesTest.

aKlass compile: 'foo: param314159 ^param314159 + 7'.
self assert:[(aKlass create foo:3) = 10].

aKlass compile: 'bar  ^self foo:5'.
self assert:[(aKlass create bar) = 12].

aKlass compile: 'snafu: x  ^x foo:84'.
aKlass compile: 'baz  ^snafu::self'.
self assert:[(aKlass create baz) = 91].

)
testDoublyNestedIWhileInIf = (

| nu |
   compileMethodSource: 'doublyNestedWhileInIf = (| tf tg |  
     	tf:: 1 + 1 * 2.
	tg:: 2*2*2*2.
	tg <1000 
		ifTrue:[
			[tg < 10000]
				whileTrue:[
					tg < 5000
						ifTrue:[tg:: tg *2]
						ifFalse:[
							tg:: tg + 1000.
							[tf > 10] whileFalse:[tf:: tf+ 1].
							]
				]
			]
		ifFalse:[].
	^tg + tf
	)'.
   nu:: klass new.
   assert:[10203 = nu doublyNestedWhileInIf].
   
)
testDynamicSuper = (


| aKlass anInstance anInnerInstance anInnerInnerInstance |

compileClassSource: ns2TestDynamicSuper.
aKlass:: Smalltalk at: #NS2DynamicSuperTest.
anInstance:: aKlass sup: aKlass.
assert:[anInstance App = anInstance App].
assert:[anInstance App new species beginsWith: 'SpeciousNS2DynamicSuperTest'].

aKlass removeFromSystem.
)
testEmptyNoParamBlock = (


| nu |
   compileMethodSource: 'emptyNoParamBlock = (^[]) '.
   nu:: klass new.
   assert:[nu emptyNoParamBlock isBlock].
   assert:[nil = nu emptyNoParamBlock value].

   
)
testEmptyOneParam = (


| nu |
   compileMethodSource: 'emptyOneParam: aParam = () '.
   nu:: klass new.
   assert:[nu = (nu emptyOneParam: 3)].
   
)
testEmptyOneParamBlock = (


| nu |
   compileMethodSource: 'emptyOneParamBlock = (^[:x | ]) '.
   nu:: klass new.
   assert:[nu emptyOneParamBlock isBlock].
   assert:[nil = (nu emptyOneParamBlock value: 91)].

   
)
testEmptyTwoParamBlock = (


| nu |
   compileMethodSource: 'emptyTwoParamBlock = (^[:x :y | ]) '.
   nu:: klass new.
   assert:[nu emptyTwoParamBlock isBlock].
   assert:[nil = (nu emptyTwoParamBlock value: 91 value: 42)].

   
)
testEmptyTwoParams = (


| nu |
   compileMethodSource: 'emptyParam1: x param2: y = () '.
   nu:: klass new.
   assert:[nu = (nu emptyParam1: 42 param2: 91)].
   
)
testEmptyZeroParams = (


| nu |
   compileMethodSource: 'emptyZeroParams = () '.
   nu:: klass new.
   assert:[nu = nu emptyZeroParams].
   
)
testExplicitOuterInInitializer = (


| aKlass |

"create a test class" 
compileClassSource: ns2TestExplicitOuterInInitializer contents.
aKlass:: Smalltalk at:  #NS2ExplicitOuterInInitTest.
"check that they work as expected"
self assert:[ aKlass new Inner new f = 182].
"remove class"
)
testFloatLiteral = (


| nu |
   compileMethodSource: 'floatLiteral = (5.2) '.
   nu:: klass new.
   assert:[nu = nu floatLiteral].
   
)
testIfCascade = (
"Regression for bitbucket issue 85"
| nu aKlass |
   compileClassSource: nsTestIfCascade.
   aKlass:: Smalltalk at: #TestIfCascade.
   nu:: aKlass new.
   assert:[nu fail slot1 = 3].	
   assert:[nu fail slot2 = 8].	
)
testIfFalse1 = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testIfFalse1 = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf < 32 ifFalse:[tf:: 96]. ) '.
   nu:: klass new.
   assert:[96 = nu testIfFalse1].
   
)
testIfFalse2 = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testIfFalse2 = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf > 32 ifFalse:[tf:: 96]. ) '.
   nu:: klass new.
   assert:[nil = nu testIfFalse2].
   
)
testIfTrue1 = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testIfTrue1 = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf > 32 ifTrue:[tf:: 64]. ) '.
   nu:: klass new.
   assert:[64 = nu testIfTrue1].
   
)
testIfTrue2 = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testIfTrue2 = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf < 32 ifTrue:[tf:: 64]. ) '.
   nu:: klass new.
   assert:[nil = nu testIfTrue2].
   
)
testIfTrueIfFalseElse = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testIfTrueIfFalse = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf < 32 ifTrue:[tf:: 64] ifFalse:[tf:: 96]. ) '.
   nu:: klass new.
   assert:[96 = nu testIfTrueIfFalse].
   
)
testIfTrueIfFalseThen = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testIfTrueIfFalse = (| ta tb  tc td te tf tg th |  tf:: 37. 
^tf > 32 ifTrue:[tf:: 64] ifFalse:[tf:: 96]. ) '.
   nu:: klass new.
   assert:[64 = nu testIfTrueIfFalse].
   
)
testImplicitOuterInInitializer = (


| aClass |

"create a test class" 
compileClassSource: ns2TestImplicitOuterInInitializer contents.
aClass:: Smalltalk at:  #NS2ImplicitOuterInInitTest.
"check that they work as expected"
self assert:[ aClass new Inner new f = 182].
"remove class"
)
testImplicitSend = (
"Regression: test will fail if implict sends do not handle popping of nested expressions off the operand stack correctly"
| nu |
   compileMethodSource: 'brokenMethod: stream = (
		[[stream atEnd] whileFalse: [stream next]] value
	)'.
	
	
   compileMethodSource: 'bar = (
	   | s |
	   brokenMethod:(s: ''abc'' readStream)
      )'.
   nu:: klass new.
   assert:[nu  bar = nu].
)
testIncestuousSiblings16 = (



| klassA  innerSup innerSub   anInstance anInnerInstance  |

compileClassSource: ns2test16.
klassA:: Smalltalk at: #NS2Test16.
anInstance:: klassA new.

innerSup::  anInstance ISup.
innerSub:: anInstance ISub.

assert:[innerSub superclass =  innerSup].

anInnerInstance:: innerSub new.

assert:[anInnerInstance mayo = 17].
assert:[anInnerInstance ketchup = 16].

"Now modify the nested class declarations"
compileClassSource:  ' Newsqueak2 
''NS2-testing''
class NS2Test16  =   ( ) (

  class ISup =  ( | x y |) (
   '' cat sup''
   ketchup = (^x + y + w + z)
  )
  class ISub = ISup (| w z | ) (
  ''cat sub''
   mayo = (^ketchup+1)
  )
)'.

"Test that the changes took"

self checkClass: innerSub hasAccessorsFor: #w.
self checkClass: innerSub hasAccessorsFor: #z.
self checkClass: innerSub superclass hasAccessorsFor: #x.
self checkClass: innerSub superclass hasAccessorsFor: #y.

anInnerInstance x:1; y:2; w:3; z:4.

assert:[anInnerInstance mayo = 11].
assert:[anInnerInstance ketchup = 10].

innerSub removeFromSystem.
innerSup removeFromSystem.
klassA removeFromSystem.
)
testInit17 = (


| aKlass subklass innerKlass innerInnerKlass  anInstance  anInnerInstance |

compileClassSource: ns2test17.
aKlass:: Smalltalk at: #NS2Test17.

anInstance:: aKlass x: 42 y: 91 z: 19.

assert:[anInstance z = (anInstance x + anInstance y + 19)].
assert:[anInstance rho = 152000].
assert:[anInstance theta = 152091].
)
testInlinedSetters = (
"Regression for bitbucket issue 91"
| nu aKlass |
   compileClassSource: nsTestInlinedSetters.
   aKlass:: Smalltalk at: #TestInlinedSetters.
   nu:: aKlass new.
   nu y.
   assert:[nu slot1 = 0].	
   assert:[nu field1 = nu expr1].	
   assert:[nu field2 = nu expr2].	
   assert:[nu field3 = nu expr3].	
   assert:[nu field4 = nu expr4].	
   assert:[nu slot2 = nu expr4].	
)
testInner12 = (


| aKlass innerKlass innerInnerKlass innerInnerInnerKlass anInstance anInnerInstance anInnerInnerInstance  |

compileClassSource: ns2test12.
aKlass:: Smalltalk at: #NS2Test12.
anInstance:: aKlass s: Object.

assert:[anInstance Inner1 = anInstance Inner1].
assert:[anInstance Inner1 new foo = 91].

innerKlass::  anInstance Inner1.
anInnerInstance:: innerKlass new.

assert:[anInnerInstance Inner11 = anInnerInstance Inner11].
assert:[anInnerInstance  Inner11 new bar = 182].

innerInnerKlass:: anInnerInstance Inner11.
anInnerInnerInstance::  innerInnerKlass  new.

innerInnerInnerKlass::  anInnerInnerInstance Inner111.
assert:[anInnerInnerInstance Inner111 = anInnerInnerInstance Inner111].
assert:[anInnerInnerInstance  Inner111 new baz = 364].

)
testInner14 = (


| klassA klassB innerKlass innerInnerKlass innerInnerInnerKlass anInstance anInnerInstance anInnerInnerInstance  |

compileClassSource: ns2test14a.
compileClassSource: ns2test14b.
klassA:: Smalltalk at: #NS2Test14a.
klassB:: Smalltalk at: #NS2Test14b.
anInstance:: klassB s: klassA new Inner1.

assert:[anInstance Inner2 = anInstance Inner2].
assert:[anInstance m = 42].

innerKlass::  anInstance Inner2.
anInnerInstance:: innerKlass new.

assert:[anInnerInstance bar = 91].

)
testInner18 = (


| aKlass  innerKlass11 innerKlass12  o1  o2  o1i1 o1i2 o2i1 o2i2 innerKlass21 innerKlass22   |

compileClassSource: ns2test18.
aKlass:: Smalltalk at: #NS2Test18.
o1:: aKlass s:  Object.
o2:: aKlass s: o1 Inner1.
o1i1:: o1 Inner1 new.
o1i2:: o1 Inner2 new.
o2i1:: o2 Inner1 new.
o2i2:: o2 Inner2 new.
innerKlass11:: o1 Inner1.
innerKlass12:: o1 Inner2.
innerKlass21:: o2 Inner1.
innerKlass22:: o2 Inner2.

assert:[o2 Inner2 superclass = o1 Inner1].
assert:[o1 Inner1 = o1i1 i1].
assert:[o1 Inner1 = o1i2 i1].
assert:[o2 Inner1 = o2i1 i1].
assert:[o2 Inner1 = o2i2 i1].
assert:[o1 Inner1 = o1i2 i1].
assert:[o1 Inner1 = o2i2 supI1].
assert:[(o1 Inner1 = o2 Inner1) not].

"cleanup"
o1i1:: nil. 
o1i2:: nil. 
o2i1:: nil. 
o2i2:: nil. 
o1:: nil.
o2:: nil.

)
testInner20 = (


| aKlass innerKlass innerInnerKlass anInstance anInnerInstance |

compileClassSource: ns2test20.
aKlass:: Smalltalk at: #NS2Test20.

anInstance:: aKlass new.
innerKlass: anInstance OuterSub.
anInnerInstance::  innerKlass new.
innerInnerKlass:: anInnerInstance Inner.
assert:[innerInnerKlass new foo = 85].

)
testInner21 = (


| aKlass innerKlass innerInnerKlass innerInnerInnerKlass  
anInstance anInnerInstance anInnerInnerInstance |

compileClassSource:  ns2test21.
aKlass:: Smalltalk at: #NS2Test21.

anInstance:: aKlass new.
innerKlass: anInstance C.
anInnerInstance::  innerKlass new.
innerInnerKlass:: anInnerInstance B1.
anInnerInnerInstance:: innerInnerKlass new.
innerInnerInnerKlass:: anInnerInnerInstance B1a.
innerInnerInnerKlass new.

)
testInner3 = (


| aKlass anInstance |

compileClassSource: ns2test3.
aKlass:: Smalltalk at: #NS2Test3.
anInstance:: aKlass s: Object.
assert:[anInstance Inner = anInstance Inner].
assert:[anInstance Inner create foo = 91].

)
testInner7 = (


| aKlass anInstance anInnerInstance anInnerInnerInstance |

compileClassSource: ns2test7.
aKlass:: Smalltalk at: #NS2Test7.
anInstance:: aKlass s: aKlass.
assert:[anInstance Inner = anInstance Inner].
assert:[anInstance Inner new foo = 91].

anInnerInstance:: anInstance Inner new.
assert:[anInnerInstance Inner new foo = 91].
assert:[anInnerInstance Inner = anInnerInstance Inner].

anInnerInnerInstance:: anInstance Inner new Inner new.
assert:[anInnerInnerInstance Inner new foo = 91].
assert:[anInnerInnerInstance Inner = anInnerInnerInstance Inner].

)
testInner8 = (


| aKlass innerKlass innerInnerKlass innerInnerInnerKlass anInstance anInnerInstance anInnerInnerInstance  |

compileClassSource: ns2test8.
aKlass:: Smalltalk at: #NS2Test8.
anInstance:: aKlass s: Object.

assert:[anInstance Inner1 = anInstance Inner1].
assert:[anInstance Inner1 new foo = 91].

innerKlass::  anInstance Inner1.
anInnerInstance:: innerKlass new.

assert:[anInnerInstance Inner11 = anInnerInstance Inner11].
assert:[anInnerInstance  Inner11 new bar = 182].

innerInnerKlass:: anInnerInstance Inner11.
anInnerInnerInstance::  innerInnerKlass  new.

innerInnerInnerKlass::  anInnerInnerInstance Inner111.
assert:[anInnerInnerInstance Inner111 = anInnerInnerInstance Inner111].
assert:[anInnerInnerInstance  Inner111 new baz = 364].

)
testInner9 = (


| aKlass innerKlass innerInnerKlass  anInstance  anInnerInstance  |

compileClassSource: ns2test9.
aKlass:: Smalltalk at: #NS2Test9.
anInstance:: aKlass new.

assert:[anInstance Inner1 = anInstance Inner1].
assert:[anInstance Inner1 new foo = 91].

innerKlass::  anInstance Inner1.
anInnerInstance:: innerKlass new.

)
testIntLiteral = (


| nu |
   compileMethodSource: 'intLiteral = (5) '.
   nu:: klass new.
   assert:[nu = nu intLiteral].
   
)
testModifyInitWithSchemaChange = (


| oklass  oInstance1 oInstance2 o1InnerInstance o2InnerInstance |
"create class and instances"
compileClassSource: ns2testModifyInitWithSchemaChange.
oklass:: Smalltalk at: #NS2TestModifyInitWithSchemaChange.
oInstance1:: oklass new.
oInstance2:: oklass new.
o1InnerInstance:: oInstance1 Inner new.
o2InnerInstance:: oInstance2 Inner new.

  "do schema change."
compileClassSource: ns2testModifyInitWithSchemaChange2.

assert:[oInstance1 Inner new  myVar = 4].
assert:[oInstance2 Inner new myVar = 4].

)
testMultipleSetters = (
| nu |
   compileMethodSource: 'testMultipleSetters = (
	| x y z |
	
	^x::  (y:: 42) + (z:: 49).
)'.
  nu:: klass new.
   assert:[nu testMultipleSetters = 91].
)
testMultipleSetters22 = (


| aKlass anInstance |

compileClassSource:  ns2test22.
aKlass:: Smalltalk at: #NS2Test22.

anInstance:: aKlass new.
assert:[anInstance testMultipleSetters2 = 91].

)
testMultipleSetters23 = (


| aKlass anInstance |

compileClassSource:  ns2test23.
aKlass:: Smalltalk at: #NS2Test23.

anInstance:: aKlass new.
assert:[anInstance testMultipleSetters2 = 135].

)
testNLR0 = (


| nu |
	compileMethodSource: 'NLR0: x = ( [^x] value. ^2) '.
 	nu:: klass new.
 	assert:[1 = (nu NLR0: 1)].
 	assert:[3 = (nu NLR0: 3)].
)
testNLR1 = (


| nu |
	compileMethodSource: 'NLR1: x = ( x > 2 ifTrue:[^x]. ^2) '.
 	nu:: klass new.
 	assert:[2 = (nu NLR1: 1)].
 	assert:[3 = (nu NLR1: 3)].
)
testNLR2 = (


| nu |
	compileMethodSource: 'NLR2: x = ( x > 2 ifTrue:[^x+1]. ^2) '.
 	nu:: klass new.
 	assert:[2 = (nu NLR2: 1)].
 	assert:[4 = (nu NLR2: 3)].
)
testNLR3 = (


| nu |
	compileMethodSource: 'NLR3: x = ( [^x + 2] value. ^2) '.
 	nu:: klass new.
 	assert:[3 = (nu NLR3: 1)].
 	assert:[5= (nu NLR3: 3)].
)
testNLRInIf1 = (
	| nu |
	compileMethodSource: 'depth: arg = (^arg ifTrue: [1] ifFalse: [^0].)'.
 	nu:: klass new.
	
	assert: [true] message: 'Mostly just checking for no error during compilation'.
	assert: [(nu depth: true) = 1].
	assert: [(nu depth: false) = 0].
)
testNLRInIf2 = (
	| nu |
	compileMethodSource: 'depth: arg = (^arg ifTrue: [^1] ifFalse: [0].)'.
 	nu:: klass new.
	
	assert: [true] message: 'Mostly just checking for no error during compilation'.
	assert: [(nu depth: true) = 1].
	assert: [(nu depth: false) = 0].
)
testNLRInIf3 = (
	| nu |
	compileMethodSource: 'depth: arg = (^arg ifTrue: [^1] ifFalse: [^0].)'.
 	nu:: klass new.
	
	assert: [true] message: 'Mostly just checking for no error during compilation'.
	assert: [(nu depth: true) = 1].
	assert: [(nu depth: false) = 0].
)
testNestedIWhileInIf = (

| nu |
   compileMethodSource: 'nestedWhileInIf = (| tf tg |  
	tg:: 2*2*2*2.
	tg <1000 
		ifTrue:[[tg < 10000] whileTrue:[tg:: tg *2]]
		ifFalse:[tg:: tg +200].
	^tg
	)'.
   nu:: klass new.
   assert:[16384 = nu nestedWhileInIf].
   
)
testNestedIfFalse = (

| nu |
   compileMethodSource: 'nestedIfFalse = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
tf < 32 ifTrue:[tf:: 64] ifFalse:[tf*tf > 100 ifTrue:[tf:: 96]]. ^tg + tf) '.
   nu:: klass new.
   assert:[170 = nu nestedIfFalse].
   
)
testNestedIfInWhile = (

| nu |
   compileMethodSource: 'nestedIfInWhile = (| tf tg |  
	tf:: 50. 
	tg:: tf *2. 
	[tg < 10000] whileTrue:[
		tg > 1000 ifTrue:[
			tg:: tg *2
			] ifFalse:[
				tg:: tg +200.
			]
		].
	^tg)
	'.
   nu:: klass new.
   assert:[17600 = nu nestedIfInWhile].
   
)
testNestedIfTrue = (

| nu |
   compileMethodSource: 'nestedIfTrue = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
tf > 32 ifTrue:[tf*tf > 100 ifTrue:[tf:: 64] ifFalse:[tf:: 96]]. ^tg + tf) '.
   nu:: klass new.
   assert:[138 = nu nestedIfTrue].
   
)
testNilLiteral = (


| nu |
   compileMethodSource: 'nilLiteral = (nil) '.
   nu:: klass new.
   assert:[nu = nu nilLiteral].
   
)
testOneParamBlock = (


| nu |
   compileMethodSource: 'oneParamBlock = (^[:x | x + 32] value:59) '.
   nu:: klass new.
   assert:[91 = nu oneParamBlock].
   
)
testOperandStackDepth1  = (
"Regression - flushes out bug in operand stack depth required for closures"
| nu |
   compileMethodSource: 'testOperandStackDepth1 = (
	100 timesRepeat: [
		{1. 2. 3}  doWithIndex: [:x :i | 
			x = x ifTrue: []]].
)'.
  nu:: klass new.
   assert:[nu testOperandStackDepth1 = nu].
)
testParseAccessors = (




| aKlass o |



"Create a class"

compileClassSource: ns2TestParseAccessors contents.

aKlass:: Smalltalk at: #NS2ParseAccessorsTest.

o:: aKlass new.

assert:[o wintergreen].

assert:[o schweik].

assert:[o enemy].

assert:[o privateFirstClass].

assert:[o protectedSpeech].

assert:[o publicServant].

)
testRepeatingWhile = (

| nu |
   compileMethodSource: 'brokenMethod: stream = (
		[[stream atEnd] whileFalse: [stream next]] value
	)'.
   nu:: klass new.
   assert:[(nu  brokenMethod:  '1234567890123456789' readStream) isNil not].
   
)
testReturnAssignBooleanLiteral = (


| nu |
   compileMethodSource: 'returnAssignBooleanLiteral = (| t |  ^t:: false) '.
   nu:: klass new.
   assert:[false = nu returnAssignBooleanLiteral].
   
)
testReturnAssignCharacterLiteral = (


| nu |
   compileMethodSource: 'returnAssignCharacterLiteral = (| t |  ^t:: $c) '.
   nu:: klass new.
   assert:[$c = nu returnAssignCharacterLiteral].
   
)
testReturnAssignFloatLiteral = (


| nu |
   compileMethodSource: 'returnAssignFloatLiteral = (| t |  ^t:: 3.14159) '.
   nu:: klass new.
   assert:[3.14159 = nu returnAssignFloatLiteral].
   
)
testReturnAssignIntLiteral = (


| nu |
   compileMethodSource: 'returnAssignIntLiteral = (| t |  ^t:: 42) '.
   nu:: klass new.
   assert:[42 = nu returnAssignIntLiteral].
   
)
testReturnAssignNil = (


| nu |
   compileMethodSource: 'returnAssignNil = (| t |  ^t:: nil) '.
   nu:: klass new.
   assert:[nil = nu returnAssignNil].
   
)
testReturnAssignParam = (


| nu |
   compileMethodSource: 'returnAssignParam: x = (| t |  ^t:: x) '.
   nu:: klass new.
   assert:[91 = (nu returnAssignParam: 91) ].
   
)
testReturnAssignStringLiteral = (


| nu |
   compileMethodSource: 'assignReturnStringLiteral = (| t |  ^t:: ''abc'') '.
   nu:: klass new.
   assert:['abc' = nu assignReturnStringLiteral].
   
)
testReturnAssignSymbolLiteral = (


| nu |
   compileMethodSource: 'assignReturnSymbolLiteral = (| t |  ^t:: #abc) '.
   nu:: klass new.
   assert:[#abc = nu assignReturnSymbolLiteral].
   
)
testReturnAssignTemps = (


| nu |
   compileMethodSource: 'returnAssignTemps = (| t1 t2  | ^t1:: t2) '.
   nu:: klass new.
   assert:[nil = nu returnAssignTemps ].
   
)
testReturnBooleanLiteral = (


| nu |
   compileMethodSource: 'returnBooleanLiteral = (^false) '.
   nu:: klass new.
   assert:[false = nu returnBooleanLiteral].
   
)
testReturnCharacterLiteral = (


| nu |
   compileMethodSource: 'returnCharacterLiteral = (^$c) '.
   nu:: klass new.
   assert:[$c = nu returnCharacterLiteral].
   
)
testReturnClosure = (


| nu closure1 closure2 |
	compileMethodSource: 'returnClosure = (| t | t::1. ^[t:: t + 1]) '.
 	nu:: klass new.
	closure1:: nu returnClosure.
	closure2:: nu returnClosure.
 	assert:[2 = closure1 value].
 	assert:[3 = closure1 value].
 	assert:[2 = closure2 value].
 	assert:[4 = closure1 value].
 	assert:[3 = closure2 value].   
)
testReturnConditionalClosure = (


| nu closure1 closure2 |
	compileMethodSource: 'returnConditionalClosure = (| t | t::1. 
	^[t > 1 ifFalse:[t::t * 2. t] ifTrue:[t:: t + 1]]) '.
 	nu:: klass new.
	closure1:: nu returnConditionalClosure.
	closure2:: nu returnConditionalClosure.
 	assert:[2 = closure1 value].
 	assert:[3 = closure1 value].
 	assert:[2 = closure2 value].
 	assert:[4 = closure1 value].
 	assert:[3 = closure2 value].   
)
testReturnConditionalClosure2 = (


| nu closure1 closure2 |
	compileMethodSource: 'returnConditionalClosure2 = (
	| t | 
	t::1. 
	^[ | x | 
		x:: t > 1 
			ifFalse:[t::t * 2. t] 
			ifTrue:[t:: t + 1]. 
		x = t ifTrue:[| y z | y:: x -1.  z:: y + 1. z]
		]
	) '.
 	nu:: klass new.
	closure1:: nu returnConditionalClosure2.
	closure2:: nu returnConditionalClosure2.
 	assert:[2 = closure1 value].
 	assert:[3 = closure1 value].
 	assert:[2 = closure2 value].
 	assert:[4 = closure1 value].
 	assert:[3 = closure2 value].   
)
testReturnFinalClosure = (


| nu closure1 closure2 |
	compileMethodSource: 'returnFinalClosure = (| t | t::1. ^[t ]) '.
	nu:: klass new.
	closure1:: nu returnFinalClosure.
	closure2:: nu returnFinalClosure.	
	assert:[1 =closure1 value].
	assert:[1 =closure1 value].
 	assert:[1 =closure2 value].
	assert:[1 =closure2 value].  
)
testReturnFloatLiteral = (


| nu |
   compileMethodSource: 'returnFloatLiteral = (^3.14159) '.
   nu:: klass new.
   assert:[3.14159 = nu returnFloatLiteral].
   
)
testReturnIntLiteral = (


| nu |
   compileMethodSource: 'returnIntLiteral = (^42) '.
   nu:: klass new.
   assert:[42 = nu returnIntLiteral].
   
)
testReturnNestedClosure = (


| nu closure1 closure2 |
	compileMethodSource: 'returnNestedClosure = (| t | t::1. ^[[t:: t + 1]]) '.
 	nu:: klass new.
	closure1:: nu returnNestedClosure.
	closure2:: nu returnNestedClosure.
 	assert:[2 = closure1 value value].
 	assert:[3 = closure1 value value].
 	assert:[2 = closure2 value value].
 	assert:[4 = closure1 value value].
 	assert:[3 = closure2 value value].   
)
testReturnNil = (


| nu |
   compileMethodSource: 'returnNil = (^nil) '.
   nu:: klass new.
   assert:[nil = nu returnNil].
   
)
testReturnNoParamBlock = (


| nu |
   compileMethodSource: 'returnNoParamBlock = (^[false]) '.
   nu:: klass new.
   assert:[false = nu returnNoParamBlock value].
   
)
testReturnOneParamBlock = (


| nu |
   compileMethodSource: 'returnOneParamBlock = (^[:x | x ]) '.
   nu:: klass new.
   assert:[3 = (nu returnOneParamBlock value: 3)].
   
)
testReturnOneParamBlockIncrement = (


| nu |
   compileMethodSource: 'returnOneParamBlockIncrement = (^[:x | x + 1]) '.
   nu:: klass new.
   assert:[4 = (nu returnOneParamBlockIncrement value: 3)].
   
)
testReturnOneParamBlockWithTemp = (


| nu |
   compileMethodSource: 'returnOneParamBlockWithTemp = (^[:x | | y |  y:: x ]) '.
   nu:: klass new.
   assert:[3 = (nu returnOneParamBlockWithTemp value: 3)].
   
)
testReturnOneParamBlockWithTempIncrement = (


| nu |
   compileMethodSource: 'returnOneParamBlockWithTempIncrement = (^[:x | | y |  y:: x. y + 1]) '.
   nu:: klass new.
   assert:[4 = (nu returnOneParamBlockWithTempIncrement value: 3)].
   
)
testReturnParam = (


| nu |
   compileMethodSource: 'returnParam: x = (^x) '.
   nu:: klass new.
   assert:[91 = (nu returnParam: 91) ].
   
)
testReturnStringLiteral = (


| nu |
   compileMethodSource: 'returnStringLiteral = (^''abc'') '.
   nu:: klass new.
   assert:['abc' = nu returnStringLiteral].
   
)
testReturnSymbolLiteral = (


| nu |
   compileMethodSource: 'returnSymbolLiteral = (^#abc) '.
   nu:: klass new.
   assert:[#abc = nu returnSymbolLiteral].
   
)
testReturnTupleLiteral0 = (


| nu |
   compileMethodSource: 'returnTupleLiteral0 = (^{}) '.
   nu:: klass new.
   assert:[{} = nu returnTupleLiteral0].
   
)
testReturnTupleLiteral1 = (


| nu |
   compileMethodSource: 'returnTupleLiteral1 = (^{ 1 }) '.
   nu:: klass new.
   assert:[{1} = nu returnTupleLiteral1].
   
)
testReturnTupleLiteral16 = (


| nu |
   compileMethodSource: 'returnTupleLiteral16 = (^{ #abc.  0. $z.  ''def''. true. false. nil. self.  1. 2. 3. 4. 5. 6. 7. 8.}) '.
   nu:: klass new.
   assert:[{ #abc.  0. $z.  'def'. true. false. nil. nu.  1. 2. 3. 4. 5. 6. 7. 8.} = nu returnTupleLiteral16].
   
)
testReturnTupleLiteral2 = (


| nu |
   compileMethodSource: 'returnTupleLiteral2 = (^{ #abc.  1 }) '.
   nu:: klass new.
   assert:[{ #abc.  1 } = nu returnTupleLiteral2].
   
)
testReturnTupleLiteral8 = (


| nu |
   compileMethodSource: 'returnTupleLiteral8 = (^{ #abc.  1. $z.  ''def''. true. false. nil. self }) '.
   nu:: klass new.
   assert:[{ #abc.  1. $z.  'def'. true. false. nil. nu } = nu returnTupleLiteral8].
   
)
testReturnUnarySend = (


| nu |
   compileMethodSource: 'returnUnarySend = (^testSlot) '.
   nu:: klass new.
   assert:[nu returnUnarySend = nu testSlot].
   
)
testSetter = (

| aKlass anInstance |

compileClassSource: ns2testSetter.
aKlass:: Smalltalk at: #NS2TestSetter.
anInstance:: aKlass new.

assert:[anInstance slot = nil].
assert:[anInstance method = 4].
assert:[anInstance slot = 4].
assert:[anInstance slot2 = 4].
assert:[anInstance slot3 = 4].

)
testStackDepthTracking2 = (
	| nu |
	compileMethodSource: '
	
	createProcess: commandLine <String>
withCurrentDirectory: dir <FileDirectory>
withTitle: title <String>
withStdInput: stdInput <Alien | Integer>
withStdOutput: stdOutput <Alien | Integer>
withStdError: stdError <Alien | Integer>
^<Win32apiPROCESSINFORMATION> = (
	| lpProcessInformation lpStartupInfo result |
	lpProcessInformation:: PROCESS_INFORMATION newGC.
	lpStartupInfo:: STARTUPINFO newGC.
	Alien autoFreeAfter: [ :autoFree |
		lpStartupInfo
			dwFlags: STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			wShowWindow: SW_HIDE;
			lpTitle: (autoFree value: (Alien newCString: title)) address;
			hStdInput: (stdInput isInteger ifTrue: [stdInput] ifFalse: [stdInput asUnsignedLong]);
			hStdOutput: (stdOutput isInteger ifTrue: [stdOutput] ifFalse: [stdOutput asUnsignedLong]);
			hStdError: (stdError isInteger ifTrue: [stdError] ifFalse: [stdError asUnsignedLong]).
		result:: self CreateProcess
			boolValue: 0 "lpApplicationName"
			value: (autoFree value: (Alien newCString: commandLine)) address
			value: 0 "lpProcessAttributes"
			value: 0 "lpThreadAttributes"
			value: 1 "bInheritHandles"
			value: 0 "dwCreationFlags"
			value: 0 "lpEnvironment"
			value: (autoFree value: (Alien newCString: dir fullName)) address
			value: lpStartupInfo address
			value: lpProcessInformation address.
		result ifFalse: [^reportError]].
	^Process new lpProcessInformation: lpProcessInformation
)
	
	'.
 	nu:: klass new.
	assert: [true] message: 'Just checking no error during compilation.  Error is avoided by removing the cascaded sends.'.
)
testStackDepthTracking3 = (
	| nu |
	compileMethodSource: '
	
	createProcess: commandLine <String>
withCurrentDirectory: dir <FileDirectory>
withTitle: title <String>
withStdInput: stdInput <Alien | Integer>
withStdOutput: stdOutput <Alien | Integer>
withStdError: stdError <Alien | Integer>
^<Win32apiPROCESSINFORMATION> = (
	| lpProcessInformation lpStartupInfo result |
	lpProcessInformation:: PROCESS_INFORMATION newGC.
	lpStartupInfo:: STARTUPINFO newGC.
	Alien autoFreeAfter: [ :autoFree |
		lpStartupInfo
			dwFlags: STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			wShowWindow: SW_HIDE;
			lpTitle: (autoFree value: (Alien newCString: title)) address;
			hStdInput: (stdInput isInteger ifTrue: [stdInput] ifFalse: [stdInput asUnsignedLong]);
			hStdOutput: (stdOutput isInteger ifTrue: [stdOutput] ifFalse: [stdOutput asUnsignedLong]);
			hStdError: (stdError isInteger ifTrue: [stdError] ifFalse: [stdError asUnsignedLong]).
		result:: self CreateProcess
			boolValue: 0 "lpApplicationName"
			value: (autoFree value: (Alien newCString: commandLine)) address
			value: 0 "lpProcessAttributes"
			value: 0 "lpThreadAttributes"
			value: 1 "bInheritHandles"
			value: 0 "dwCreationFlags"
			value: 0 "lpEnvironment"
			value: (autoFree value: (Alien newCString: dir fullName)) address
			value: lpStartupInfo address
			value: lpProcessInformation address.
		result ifFalse: [^reportError]].
	^Process new lpProcessInformation: lpProcessInformation
)
	
	'.
 	nu:: klass new.
	assert: [true] message: 'Just checking no error during compilation.  Error is avoided by removing the cascaded sends.'.
)
testStackDepthTracking4 = (
	| nu |
	compileMethodSource: '
	
	createProcess: commandLine <String>
withCurrentDirectory: dir <FileDirectory>
withTitle: title <String>
withStdInput: stdInput <Alien | Integer>
withStdOutput: stdOutput <Alien | Integer>
withStdError: stdError <Alien | Integer>
^<Win32apiPROCESSINFORMATION> = (
	|  lpStartupInfo  |

	Alien autoFreeAfter: [ :autoFree |
		lpStartupInfo
			dwFlags: STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			wShowWindow: SW_HIDE;
			lpTitle: (autoFree value: (Alien newCString: title)) address;
			hStdInput: (stdInput isInteger ifTrue: [stdInput] ifFalse: [stdInput asUnsignedLong]);
			hStdOutput: (stdOutput isInteger ifTrue: [stdOutput] ifFalse: [stdOutput asUnsignedLong]);
			hStdError: (stdError isInteger ifTrue: [stdError] ifFalse: [stdError asUnsignedLong]).
			^3
		].
)
	
	'.
 	nu:: klass new.
	assert: [true] message: 'Just checking no error during compilation.  Error is avoided by removing the cascaded sends.'.
)
testStringLiteral = (


| nu |
   compileMethodSource: 'stringLiteral = (''abc'') '.
   nu:: klass new.
   assert:[nu = nu stringLiteral].
   
)
testSymbolLiteral = (


| nu |
   compileMethodSource: 'symbolLiteral = (#abc) '.
   nu:: klass new.
   assert:[nu = nu symbolLiteral].
   
)
testSymbolLiteralBlock = (


| nu |
   compileMethodSource: 'symbolLiteralBlock = (^[#xx]) '.
   nu:: klass new.
   assert:[#xx = nu symbolLiteralBlock value].
   
)
testTimesRepeat = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testTimesRepeat = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf timesRepeat:[tf:: tf +1].
	^tf
	 ) '.
   nu:: klass new.
   assert:[74 = nu testTimesRepeat].
   
)
testToByDo1 = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testToByDo1 = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf to: 74 by: 1 do:[:i <integer> |  tf:: tf +1].
	^tf
	 ) '.
   nu:: klass new.
   assert:[75 = nu testToByDo1].
   
)
testToByDo2 = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testToByDo2 = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf to: 74 by: 36 do:[:i <integer> |  tf:: tf +1].
	^tf
	 ) '.
   nu:: klass new.
   assert:[39 = nu testToByDo2].
   
)
testToDo1 = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testToDo1 = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf to: 74  do:[:i <integer> |  tf:: tf +1].
	^tf
	 ) '.
   nu:: klass new.
   assert:[75 = nu testToDo1].
   
)
testToDo2 = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testToDo2 = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf to: tf*2  do:[:i <integer> |  tf:: tf +1].
	^tf
	 ) '.
   nu:: klass new.
   assert:[75 = nu testToDo2].
   
)
testToDo3 = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testToDo3 = (
	| ta tb  tc td te tf tg th |  
	tf:: 37. 
	tf to: tf*2  do:[:i <integer> |  tf:: i].
	^tf
	 ) '.
   nu:: klass new.
   assert:[74 = nu testToDo3].
   
)
testTupleLiteral0 = (


| nu |
   compileMethodSource: 'tupleLiteral0 = ({}) '.
   nu:: klass new.
   assert:[nu = nu tupleLiteral0].
   
)
testTupleLiteral1 = (


| nu |
   compileMethodSource: 'tupleLiteral1 = ({ 1 }) '.
   nu:: klass new.
   assert:[nu = nu tupleLiteral1].
   
)
testTupleLiteral16 = (


| nu |
   compileMethodSource: 'tupleLiteral16 = ({ #abc.  0. $z.  ''def''. true. false. nil. self.  1. 2. 3. 4. 5. 6. 7. 8.}) '.
   nu:: klass new.
   assert:[nu = nu tupleLiteral16].
   
)
testTupleLiteral2 = (


| nu |
   compileMethodSource: 'tupleLiteral2 = ({ #abc.  1 }) '.
   nu:: klass new.
   assert:[nu = nu tupleLiteral2].
   
)
testTupleLiteral8 = (


| nu |
   compileMethodSource: 'tupleLiteral8 = ({ #abc.  1. $z.  ''def''. true. false. nil. self }) '.
   nu:: klass new.
   assert:[nu = nu tupleLiteral8].
   
)
testTwoParamBlock = (


| nu |
   compileMethodSource: 'twoParamBlock = (^[:x :y | x -y] value:91 value: 49) '.
   nu:: klass new.
   assert:[42 = nu twoParamBlock].
   
)
testWhileFalse = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testWhileFalse = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
[tg:: tg *2. tg > 10000] whileFalse.
^tg)'.
   nu:: klass new.
   assert:[18944 = nu testWhileFalse].
   
)
testWhileFalseColon = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testWhileFalseColon = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
[tg >= 10000] whileFalse:[tg:: tg *2].
^tg)'.
   nu:: klass new.
   assert:[18944 = nu testWhileFalseColon].
   
)
testWhileInBlock = (
"Regression: check that loops leave something on the operand stack"
| nu |
   compileMethodSource:'testWhileInBlock = (	| copied |
	copied::  ''abc'' readStream.
	^ Array streamContents: [:resultStream |
		[copied atEnd] whileFalse: [
			resultStream nextPut: copied next]].
      )'.
   nu:: klass new.
   assert:[{$a. $b. $c} = nu testWhileInBlock].
)
testWhileTrue = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testWhileTrue = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
[tg:: tg *2. tg < 10000] whileTrue.
^tg)'.
   nu:: klass new.
   assert:[18944 = nu testWhileTrue].
   
)
testWhileTrueColon = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testWhileTrueColon = (| ta tb  tc td te tf tg th |  tf:: 37. tg:: tf *2. 
[tg < 10000] whileTrue:[tg:: tg *2].
^tg)'.
   nu:: klass new.
   assert:[18944 = nu testWhileTrueColon].
   
)
testWhileWithScope = (

"the convention for naming the methods that test control structures differs from others. We retain the leading word test. This is so name completion is not corrupted by the presence of these methods"
| nu |
   compileMethodSource: 'testWhileWithScope = ( | i n |
i:: 5. 
n:: 1. 
[ | j | j:: 0. i > j] whileTrue:[i:: i -1. n:: n*2].
^n
) '.
   nu:: klass new.
   assert:[32 = nu testWhileWithScope].
   
)) : ('as yet unclassified'
TEST_CONTEXT = (
	
))) : ()