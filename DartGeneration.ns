Newspeak3
'NS2Dart'
class DartGeneration usingPlatform: platform = (
(* Building blocks of Dart syntax trees and a tree writer. The nodes are intended to represent Dart code to be generated rather than the result of parsing an arbitrary Dart program, so these nodes may not provide for complete expression of Dart.

Derived from the JavascriptGeneration class in NS2JS, which is why the SAP copyright below applies.

Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
	private List = platform collections List.
	private Map = platform collections Map.
	private WriteStream = platform streams CharacterReadWriteStream.

	syntax = Syntax new.
	factory = Factory new.
|) (
class Factory = () (
'as yet unclassified'
assign: lhs <Node> toBe: rhs <Node> ^<Node> = (
	assert: [lhs isDartNode] message: 'Dart node expected on left'.
	assert: [rhs isDartNode] message: 'Dart node expected on right'.
	^syntax AssignmentExpression leftHandSide: lhs rightHandSide: rhs
)
block: statements <List[Node]> ^<Node> = (
	statements do: [:each | assert: [each isDartNode] message:'Malformed statement tree'].
	^syntax Block statements: statements
)
class: name extends: supername fields: fields constructors: constructors methods: methods = (
	^syntax ClassDeclaration 
		name: name
		superclassName: supername
		fields: fields
		constructors: constructors
		methods: methods
)
for: initExpr while: testExpr step: incExpr do: bodyStmt = (
	^syntax ForStatement
		initExpression: initExpr
		test: testExpr
		increment: incExpr
		body: bodyStmt
)
functionOf: params body: body <Block> = (
	| paramIds |
	paramIds:: params collect: [:each | each isString ifTrue: [ident: each]  ifFalse: [each]].
	^syntax FunctionLiteral parameters: paramIds body: body
)
ident: name <String> ^<Node> = (
	assert: [name isString] message: 'name must be a string'.
	^syntax IdentifierExpression name: name
)
if: expression <Node> then: then <Node> ^<Node> = (
	^syntax IfStatement expression: expression then: then else: nil
)
if: expression <Node> then: then <Node> else: else <Node> ^<Node> = (
	^syntax IfStatement expression: expression then: then else: else
)
invoke: func with: args = (
	^syntax FunctionInvocation function: func arguments: args
)
library: name classes: classes = (
	halt.
	^syntax LibraryDeclaration name: name classes: classes
)
list: elements <List[Node]> ^<ListExpression> = (
	elements do: [:each | assert: [each isDartNode] message: 'Dart node expected'].
	^syntax ListExpression elements: elements
)
literal: value <Boolean | Integer> ^<Node> = (
	value isString ifTrue: [^syntax StringLiteral value: value].
	value isNumber ifTrue: [^syntax IntegerLiteral value: value].
	(true = value or: [false = value]) ifTrue: [^syntax BooleanLiteral value: value].
	error: 'this value cannot be a Dart literal'
)
memberOf: expression <Node> at: memberName <Node> = (
	assert: [expression isDartNode] message: 'Dart node expected'.
	assert: [memberName isString or: [memberName isIdentifier]]
		message: 'String expected for member name'.
	^syntax MemberExpression primary: expression property: 
		(memberName isString ifTrue: [memberName] ifFalse: [memberName name])
)
method: name <String> params: params body: body <Block> = (
	| canonicalName canonicalParams |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	canonicalParams:: params collect: [:each | each isString ifTrue: [ident: each]  ifFalse: [each]].
	^syntax MethodDeclaration name: canonicalName parameters: canonicalParams body: body
)
new: expression <Node> with: args <List[Node]> ^<Node> = (
	^syntax NewExpression expression: expression arguments: args
)
on: target invoke: method with: arguments <List[Node]> = (
	^syntax MethodInvocation target: target method: method arguments: arguments
)
operator: name <String> with: left <Node> and: right <Node> = (
	assert: [left isDartNode] message: 'Dart node expected on left'.
	assert: [right isDartNode] message: 'Dart node expected on right'.
	^syntax OperatorExpression operator: name with: left and: right
)
postfixOperator: name <String> on: operand <Node> = (
	^syntax UnaryOperatorExpression operator: name postfix: true on: operand
)
prefixOperator: name <String> on: operand <Node> = (
	^syntax UnaryOperatorExpression operator: name postfix: false on: operand
)
rethrow ^<Node> = (
	^syntax ReThrowStatement new
)
return = (
	^syntax ReturnStatement expression: nil
)
return: expression <Node | nil> = (
	^syntax ReturnStatement expression: expression
)
subscript: obj at: index = (
	^syntax SubscriptExpression object: obj index: index
)
ternaryIf: condition then: then else: else = (
	^syntax TernaryOperatorExpression
		if: condition
		then: then
		else: else
)
throw: expression <Node> ^<Node> = (
	^syntax ThrowStatement expression: expression
)
try: block <Block> catch: varName <String> with: catchBlock <Block> = (
	^self try: block on: nil catch: varName with: catchBlock
)
try: block <Block> finally: finallyBlock <Block>= (
	^self try: block on: nil catch: nil with: nil finally: finallyBlock
)
try: block <Block> on: varType catch: varName <String> with: catchBlock <Block> = (
	| canonicalVarName |
	canonicalVarName:: varName isNil
		ifTrue: [varName]
		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].
	^syntax TryStatement 
		block: block 
		on: varType catch: canonicalVarName with: catchBlock
		finally: nil
)
try: block <Block> on: varType catch: varName <String> with: catchBlock <Block> finally: finallyBlock <Block>= (
	| canonicalVarName |
	canonicalVarName:: varName isNil
		ifTrue: [varName]
		ifFalse: [varName isString ifTrue: [ident: varName] ifFalse: [varName]].
	^syntax TryStatement
		block: block 
		on: varType catch: canonicalVarName with: catchBlock
		finally: finallyBlock
)
var: name <String> ^<VariableStatement> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax VariableStatement name: canonicalName initializer: nil
)
var: name <String> value: expr <Node> ^<VariableStatement> = (
	| canonicalName |
	canonicalName:: name isNil
		ifTrue: [name]
		ifFalse: [name isString ifTrue: [ident: name] ifFalse: [name]].
	^syntax VariableStatement name: canonicalName initializer: expr
)
verbatim: text <String> = (
	 assert:[text isString] message: 'String expected'.
	^syntax VerbatimNode text: text
)
while: condition <Node> do: body <Node> = (
	^syntax WhileStatement
		condition: condition
		body: body
)
) : (
)
class Syntax = (
(* The AST nodes. The preferred way to construct instances is to use the factory object (an instance of Factory, a sibling of this class) held onto by the module. *)) (
class AssignmentExpression leftHandSide: lhs rightHandSide: rhs = Node (|
	leftHandSide <Expression> = lhs.
	rightHandSide <Expression> = rhs.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode 
		and: [leftHandSide = anotherNode leftHandSide
			and: [rightHandSide = anotherNode rightHandSide]]	
)
isOperatorExpression = (
	^true
)
public printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	leftHandSide printOn: stream.
	stream nextPutAll: ', '.
	rightHandSide printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitAssignmentExpression: self
)
) : (
'as yet unclassified'
var: name <String> to: expr <Expression> = (
	^AssignmentExpression
		leftHandSide: (IdentifierExpression name: name)
		rightHandSide: expr
)
)
class Block statements: s = Node (|
	statements <List[Statement | Expression]> = s.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [statements = anotherNode statements]
)
asBlock = (
	^self
)
isStatement = (
	^true
)
visitBy: visitor = (
	^visitor visitBlock: self
)
visitStatementsBy: visitor = (
	| result |
	statements do: [:each | result:: each visitBy: visitor].
	^result
)
) : (
'as yet unclassified'
empty = (
	^Block statements: {}
)
)
class ClassDeclaration name: n superclassName: s fields: f constructors: c methods: m = Node (|
name <String> = n.
superclassName <String> = s.
fields = f.
constructors = c.
methods = m.
|) (
'as yet unclassified'
visitBy: visitor = (
	^visitor visitClassDeclaration: self
)
) : (
)
class ForStatement initExpression: initExpr test: testExpr increment: incExpr body: body = Node (|
	initExpression = initExpr.
	testExpression = testExpr.
	incrementExpression = incExpr.
	body = body.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[initExpression = anotherNode initExpression and:
		[testExpression = anotherNode testExpression and:
		[incrementExpression = anotherNode incrementExpression and:
		[body = anotherNode body]]]]
)
isStatement = (
	^true
)
visitBy: visitor = (
	^visitor visitForStatement: self
)
) : (
)
class FunctionInvocation function: func arguments: args = Node (|
	function = func.
	arguments = args.
|) (
'as yet unclassified'
visitBy: visitor = (
	^visitor visitFunctionInvocation: self.
)
) : (
)
class FunctionLiteral parameters: names <List[IdentifierExpression]> body: b = Node (|
	parameters <List[IdentifierExpression]> = names.
	body <Block> = b asBlock.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[parameters = anotherNode parameters and:
		[body = anotherNode body]]
)
visitBy: visitor = (
	^visitor visitFunctionLiteral: self
)
) : (
)
class IdentifierExpression name: s <String> = Node (
(* a case of PrimaryExpression *)|
	name = s.
|assert: [isLegalIdentifier: s] message: 'Not a legal Dart identifier') (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [name = anotherNode name]
)
isIdentifier = (
	^true
)
public printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	stream nextPutAll: name.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitIdentifierExpression: self
)
) : (
)
class IfStatement expression: expr then: then else: else = Node (
(* if ( expression ) thenStatement else elseStatement *)|
	expression = expr.
	thenStatement = then.
	elseStatement = else.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[expression = anotherNode expression and:
		[thenStatement = anotherNode thenStatement and:
		[elseStatement = anotherNode elseStatement]]]
)
isStatement = (
	^true
)
visitBy: visitor = (
	^visitor visitIfStatement: self
)
) : (
'as yet unclassified'
expression: expr then: then = (
	^IfStatement expression: expr then: then else: nil
)
)
class IntegerLiteral value: v <Integer> = Node (|
	value = v.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[value = anotherNode value]
)
public printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	value printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitIntegerLiteral: self
)
) : (
)
class LibraryDeclaration name: n classes: c = Node (
(* Describe the class in this comment. *)|
	name <String> = n.
	classes <List[ClassDeclaration]> = c.
|) (
'as yet unclassified'
visitBy: visitor = (
	^visitor visitLibraryDeclaration: self
)
) : (
)
class ListExpression elements: elements_ = Node (
(* A list expression, e.g. [1,2,3]. *)|
	elements = elements_.
|) (
'as yet unclassified'
visitBy: visitor = (
	^visitor visitListExpression: self
)
) : (
)
class MemberExpression primary: expr <Expression> property: p <Node> = Node (
(* primary.property *)|
	primary = expr.
	property = p.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[primary = anotherNode primary and:
		[property = anotherNode property]]
)
isMemberExpression = (
	^true
)
visitBy: visitor = (
	^visitor visitMemberExpression: self
)
) : (
)
class MethodDeclaration name: n parameters: p body: b = Node (|
	name = n.
	parameters = p.
	body = b.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[name = anotherNode name and:
		[parameters = anotherNode parameters and:
		[body = anotherNode body]]]
)
visitBy: visitor = (
	^visitor visitMethodDeclaration: self
)
) : (
)
class MethodInvocation target: t method: m arguments: a = Node (
(* target.method(a1, a2, ... aN) *)|
	target <Expression> = t.
	method <String> = m.
	arguments <List[Expression]> = a.
	cascade <Boolean> ::= false.
|) (
'as yet unclassified'
isMethodInvocation = (
	^true
)
visitBy: visitor = (
	^visitor visitMethodInvocation: self
)
) : (
)
class NewExpression expression: expr arguments: args = Node (
(* new expr ( arg, .... ) *)|
	expression = expr.
	arguments = args.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[expression = anotherNode expression and:
		[arguments = anotherNode arguments]]
)
visitBy: visitor = (
	^visitor visitNewExpression: self
)
) : (
)
class Node = (
(* The superclass of all other nodes, both statements and expressions. *)|
	comment <String>
|) (
'as yet unclassified'
= anotherNode = (
	^class = anotherNode class
)
asBlock = (
	^Block statements: {self}
)
isDartNode = (
	^true
)
isReturnStatement = (
	^false
)
isStatement = (
	^false
)
) : (
)
class OperatorExpression operator: name <String> with: left <Node> and: right <Node> = Node (|
	operatorName = name.
	left = left.
	right = right.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[operatorName = anotherNode operatorName and:
		[left = anotherNode left and:
		[right = anotherNode right]]]
)
isOperatorExpression = (
	^true
)
visitBy: visitor = (
	^visitor visitOperatorExpression: self
)
) : (
)
class ReThrowStatement = Node (|
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [expression = anotherNode expression]
)
isStatement = (
	^true
)
visitBy: visitor = (
	^visitor visitReThrowStatement: self
)
) : (
)
class ReturnStatement expression: expr = Node (
(* return expression/opt. *)|
	expression <Expression | nil> = expr.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [expression = anotherNode expression]
)
isReturnStatement = (
	^true
)
isStatement = (
	^true
)
public printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	expression printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitReturnStatement: self
)
) : (
'as yet unclassified'
noValue = (
	^ReturnStatement expression: nil
)
)
class StringLiteral value: string <String> = Node (|
	value = string.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[value = anotherNode value]
)
public printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	value printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitStringLiteral: self
)
) : (
)
class SubscriptExpression object: o index: i = Node (
(* object[index] *)|
	object = o.
	index = i.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode 
		and: [object = anotherNode object
			and: [index = anotherNode index]]	
)
visitBy: visitor = (
	^visitor visitSubscriptExpression: self
)
) : (
)
class TernaryOperatorExpression if: condExpr then: thenExpr else: elseExpr = Node (|
	protected condition = condExpr.
	protected then = thenExpr.
	protected else = elseExpr.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[condition = anotherNode condition and:
		[then = anotherNode then and:
		[else = anotherNode else]]]
)
visitBy: visitor = (
	^visitor visitTernaryOperatorExpression: self
)
) : (
)
class ThrowStatement expression: expr = Node (|
	expression = expr.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [expression = anotherNode expression]
)
isStatement = (
	^true
)
visitBy: visitor = (
	^visitor visitThrowStatement: self
)
) : (
)
class TryStatement block: pb <Block> on: varType catch: cvar <IdentifierExpression | nil> with: cb <Block | nil> finally: fb <Block | nil> = Node (
(* try { pb } on varType catch(cvar) { cb } finally { fb } *)|
	protectedBlock = pb.
	catchVarType = varType.
	catchVar = cvar.
	catchBlock = cb.
	finallyBlock = fb.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[protectedBlock = anotherNode protectedBlock and:
		[catchVar = anotherNode catchVar and:
		[catchBlock = anotherNode catchBlock and:
		[finallyBlock = anotherNode finallyBlock]]]]
)
isStatement = (
	^true
)
visitBy: visitor = (
	^visitor visitTryStatement: self
)
) : (
'as yet unclassified'
block: pb catch: cvar with: cb = (
	^TryStatement block: pb on: nil catch: cvar with: cb finally: nil
)
)
class UnaryOperatorExpression operator: name <String> postfix: postfix <Boolean> on: node <Node> = Node (
(* A unary operator application, either prefix or postfix. *)|
	operatorName <String> = name.
	isPostfix <Boolean> = postfix.
	operand <Node> = node.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[operatorName = anotherNode operatorName and:
		[isPostfix = anotherNode isPostfix and:
		[operand = anotherNode operand]]]
)
visitBy: visitor = (
	^visitor visitUnaryOperatorExpression: self
)
) : (
)
class VariableStatement name: n <IdentifierExpression> initializer: expr <Expression> = Node (
(* var name [= expression] *)|
	name = n.
	initializer = expr.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[name = anotherNode name and:
		[initializer = anotherNode initializer]]
)
isStatement = (
	^true
)
public printOn: stream = (
	super printOn: stream.
	stream nextPutAll: ' ('.
	name printOn: stream.
	stream nextPutAll: ', '.
	initializer printOn: stream.
	stream nextPutAll: ')'
)
visitBy: visitor = (
	^visitor visitVariableStatement: self
)
) : (
'as yet unclassified'
name: s = (
	^VariableStatement name: s initializer: nil
)
)
class VerbatimNode text: s <String> = Node (
(* A node holding onto arbitrary text, to be emitted verbatim into the generated Javascript source. Nothing but the text is emitted, however the context may insert additional tokens before or after the text. For example if a verbatim node appears as a statement in a block, it will have a terminating semicolon. *)|
	text = s.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and: [text = anotherNode text]
)
visitBy: visitor = (
	^visitor visitVerbatimNode: self
)
) : (
)
class WhileStatement condition: c body: b = Node (
(* while(c) b *)|
	condition <Expression> = c.
	body <Statement> = b.
|) (
'as yet unclassified'
= anotherNode = (
	^super = anotherNode and:
		[condition = anotherNode condition and:
		[body = anotherNode body]]
)
isStatement = (
	^true
)
visitBy: visitor = (
	^visitor visitWhileStatement: self
)
) : (
)
'as yet unclassified'
isLegalIdentifier: id <String> ^<Boolean> = (
	id size > 0 ifFalse: [^false].
	id do: [:char | ('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_' includes: char) ifFalse: [^false]].
	^id first isNumber not
)
) : (
)
class Writer = (
(* Writes out a tree of Dart syntax elements. *)|
	private output <WriteStream>
	private tabLevel <Integer>
	private stringTranslation = Map new.
|stringTranslation at: "\" put: '\\'.
	stringTranslation at: Character cr put: '\r"', String lf, '"'.
	stringTranslation at: Character lf put: '\n"', String lf, '"'.
	stringTranslation at:  """ put: '\"'.
	stringTranslation at:  "$" put: '\$') (
'accessing'
generateSourceFor: node <Node> on: stream <WriteStream> = (
	(* Generate Javascript source to represent the node, writing it out to the stream. *)
	beginNewWriteCycleUsing: stream.
	node visitBy: self.
)
'as yet unclassified'
visitForStatement: node = (
	write: 'for ('.
	node initExpression visitBy: self.
	write: '; '.
	node testExpression visitBy: self.
	write: '; '.
	node incrementExpression visitBy: self.
	write: ') '.
	node body asBlock visitBy: self.
)
visitReThrowStatement: node <ThrowStatement> = (
	write: 'rethrow;'
)
'node traversal'
visitAssignmentExpression: node <AssignmentExpression> = (
	node leftHandSide visitBy: self.
	write: ' = '.
	node rightHandSide visitBy: self.
)
visitBlock: node <Block> = (
	(* | statements |
	statements: node statements.
	statements isEmpty ifTrue:
		[^write: '{}'].
	write: '{'.
	indentCr.
	statements
		do:
			[:each |
			each visitBy: self.
			each isStatement ifFalse: [write: ';']]
		separatedBy:
			[cr].
	unindentCr.
	write: '}' *)
	writeBlock: node
)
visitClassDeclaration: node <ClassDeclaration> = (
	write: 'class '.
	write: node name.
	write: ' extends '.
	write: node superclassName.
	write: ' '.
	inIndentedBlock: [
		node fields, node constructors, node methods
			do: [:ea | ea visitBy: self]
			separatedBy: [lf]]
)
visitFunctionInvocation: node <FunctionInvocation> = (
	node function visitBy: self.
	write: '('.
	node arguments do: [:ea | ea visitBy: self] separatedBy: [write: ', '].
	write: ')'.
)
visitFunctionLiteral: node <FunctionLiteral> = (
	write: '('.
		write: '('.
		node parameters
			do: [:each | each visitBy: self]
			separatedBy: [write: ', '].
		write: ') '.
		writeBlock: node body.
	write: ')'.
)
visitIdentifierExpression: node <IdentifierExpression> = (
	write: node name
)
visitIfStatement: node <IfStatement> = (
	write: 'if ('.
	node expression visitBy: self.
	write: ') '.
	writeBlock: node thenStatement asBlock.
	node elseStatement ifNotNil:
		[:else |
		write: ' else '.
		writeBlock: node elseStatement asBlock]
)
visitIntegerLiteral: node <IntegerLiteral> = (
	write: node value printString.
)
visitLibraryDeclaration: lib <LibraryDeclaration> = (
	write: '#library('.
	write: lib name.
	write: ');'.
	lf. lf.
	lib classes do: [:ea | ea visitBy: self] separatedBy: [lf. lf].
)
visitListExpression: node <ListExpression> = (
	| elements |
	elements: node elements.
	elements isEmpty ifTrue:
		[^write: '[]'].
	elements size = 1 ifTrue:
		[write: '['.
		elements first visitBy: self.
		^write: ']'].
	write: '['.
	indentLf.
	elements
		do:
			[:each | each visitBy: self]
		separatedBy:
			[write: ','.
			lf].
	unindentLf.
	write: ']'
)
visitMemberExpression: node <MemberExpression> = (
	node primary visitBy: self.
	write: '.'.
	write: node property.
)
visitMethodDeclaration: node <MethodDeclaration> = (
	node name visitBy: self.
	write: '('.
	node parameters do: [:ea | ea visitBy: self] separatedBy: [write: ', '].
	write: ') '.
	(node body statements size = 1
	and: [node body statements first isReturnStatement])
		ifTrue: 
			[write: '=> '. 
			node body statements first expression visitBy: self.
			write: ';']
		ifFalse: 
			[node body visitBy: self].
)
visitMethodInvocation: node <MethodInvocation> = (
	node target visitBy: self.
	node cascade ifTrue: [write: '..'] ifFalse: [write: '.'].
	node method visitBy: self.
	write: '('.
	node arguments do: [:ea | ea visitBy: self] separatedBy: [write: ', '].
	write: ')'.
)
visitNewExpression: node <NewExpression> = (
	write: 'new '.
	node expression visitBy: self.
	write: '('.
	node arguments do: [:ea | ea visitBy: self] separatedBy: [write: ', '].
	write: ')'.
)
visitOperatorExpression: node <OperatorExpression> = (
	| parenthesizeLeft parenthesizeRight |
	parenthesizeLeft:: node left isOperatorExpression.
	parenthesizeRight:: node right isOperatorExpression.
	parenthesizeLeft ifTrue: [write: '('].
	node left visitBy: self.
	parenthesizeLeft ifTrue: [write: ') '] ifFalse: [write: ' '].
	(* Some operators require space to tokenize correctly, e.g. is *)
	write: node operatorName.
	parenthesizeRight ifTrue: [write: ' ('] ifFalse: [write: ' '].
	node right visitBy: self.
	parenthesizeRight ifTrue: [write: ')']
)
visitReturnStatement: node <ReturnStatement> = (
	write: 'return '.
	node expression visitBy: self.
	write: ';'.
)
visitStringLiteral: node <StringLiteral> = (
	write: '"'.
	node value do:
		[:each | | s |
		s:: stringTranslation
			at: each
			ifAbsent: [{each}].
		write: s].
	write: '"'
)
visitSubscriptExpression: node <SubscriptExpression> = (
	node object visitBy: self.
	write: '['.
	node index visitBy: self.
	write: ']'
)
visitTernaryOperatorExpression: node = (
	(* We parenthesize the then and else expressions because they might contain cascades. *)
	write: '('.
	node condition visitBy: self.
	write: ' ? ('.
	node then visitBy: self.
	write: ') : ('.
	node else visitBy: self.
	write: ') )'
)
visitThrowStatement: node <ThrowStatement> = (
	write: 'throw '.
	node expression visitBy: self.
	write: ';'.
)
visitTryStatement: node <TryStatement> = (
	write: 'try '.
	writeBlock: node protectedBlock.
	node catchBlock ifNotNil:
		[:catch |
		node catchVarType ifNotNil: [:it | write: ' on '. it visitBy: self].
		write: ' catch ('.
		node catchVar visitBy: self.
		write: ') '.
		writeBlock: catch].
	node finallyBlock ifNotNil:
		[:finally |
		write: ' finally '.
		writeBlock: finally]
)
visitUnaryOperatorExpression: node <UnaryOperatorExpression> = (
	| isPostfix isOnOperator |
	isPostfix:: node isPostfix.
	isOnOperator:: node operand isOperatorExpression.
	isPostfix ifFalse: [write: node operatorName].
	isOnOperator ifTrue: [write: '(']. (* not always necessary, but safer *)
	node operand visitBy: self.
	isOnOperator ifTrue: [write: ')'].
	isPostfix ifTrue: [write: node operatorName].
)
visitVariableStatement: node <VariableStatement> = (

	#FLAG. (* It is not clear whether the semicolon should be included here, as there are places we may want to include var that are not statements, such as parameter lists. Perhaps we should have a separate param node? *)

	write: 'var '.
	node name visitBy: self.
	node initializer ifNotNil: [:it | 
		write: ' = '.
		it visitBy: self].
	write: ';'.
)
visitVerbatimNode: node = (
	write: node text
)
visitWhileStatement: node = (
	write: 'while ('.
	node condition visitBy: self.
	write: ') '.
	node body asBlock visitBy: self.
)
'private'
beginNewWriteCycleUsing: stream <WriteStream> = (
	output:: stream.
	tabLevel:: 0.
)
inIndentedBlock: closure = (
	write: '{'.
	indentLf.
	^closure ensure: 
		[unindentLf.
		write: '}']
)
indentLf = (
	tabLevel: tabLevel + 1.
	lf
)
lf = (
	(* Write a newline and the next line's indentation. *)
	output lf.
	tabLevel timesRepeat: [output space]
)
unindentLf = (
	tabLevel:: 0 max: tabLevel - 1.
	lf
)
write: text <String> = (
	output nextPutAll: text
)
writeBlock: block = (
	| statements |
	statements: block statements.
	statements isEmpty
		ifTrue: [write: '{}']
		ifFalse:
			[inIndentedBlock:
				[statements
					do: 
						[:each |
						each visitBy: self.
						each isStatement ifFalse: [write: ';']]
					separatedBy:
						[lf]]]
)
) : (
)
) : (
)
