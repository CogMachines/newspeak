Newspeak3
'Actors'
class Actors2Testing usingPlatform: p actors: a testActor: ta minitest: m = (|
	private TestActor = ta.
	private TestContext = m TestContext.
	private Semaphore = p squeak Semaphore.
	private MessageNotUnderstood = p kernel MessageNotUnderstood.
	private Resolver = a Resolver.
	private Timer = a Timer.
	private actors = a.
|) (
public class SingleActorTests = TestBase () (
'as yet unclassified'
public factorial: n = (
	^n > 1 
		ifTrue: [(self <-: factorial: n - 1) <-: * n]
		ifFalse: [1]
)
public returnBrokenPromise = (
	^self <-: doesNotExist
)
public returnPromise = (
	^self <-: yourself
)
public returnPromise: n = (
	^n == 0
		ifTrue: [self]
		ifFalse: [self <-: returnPromise: n - 1].
)
public signalError = (
	Error signal: 'some error'.
)
public testChainAfterForwarded = (
	| r p r2 p2 p3 |
	r:: Resolver new.
	p:: r promise.
	r2:: Resolver new.
	p2:: r2 promise.
	p whenResolved: [:res | deny: res isPromise].
	p3:: [(*A*) [ p (*B*)whenResolved: [r2 resolve: 42]] <-: value. 21] <-: value.
	assert: [p3 isPromise].
	r resolve: p3.
	
	(* No way to guarentee B happens after p is resolved to p3, but this happens in the current implementation. *)
	
	assert: p2 resolvesTo: 42.
)
public testChainAfterResolved = (
	| r p r2 p2 |
	r:: Resolver new.
	p:: r promise.
	r2:: Resolver new.
	p2:: r2 promise.
	p whenResolved: [p whenResolved: [r2 resolve: 42]].
	r resolve: 21.
	
	assert: p2 resolvesTo: 42.
)
public testChainAfterSmashed = (
	| r p r2 p2 |
	r:: Resolver new.
	p:: r promise.
	r2:: Resolver new.
	p2:: r2 promise.
	p whenResolved: [halt] whenSmashed: [p whenResolved: [halt] whenSmashed: [r2 resolve: 42]].
	r smash: 21.
	
	assert: p2 resolvesTo: 42.
)
public testChainPromiseToError = (
	| p |
	p:: self <-: returnBrokenPromise.
	assert: [p isPromise].
	
	assert: p smashedWith: MessageNotUnderstood.
)
public testChainPromiseToValue = (
	| p |
	p:: self <-: returnPromise.
	assert: [p isPromise].
	
	assert: p resolvesTo: self.
)
public testDatalock = (
	| flag epimenides p |
	flag:: true.
	epimenides:: [flag <-: not].
	flag:: epimenides <-: value.
	
	assertTimesOut: flag.
)
public testDeeplyChainedPromise = (
	| p |
	p:: self <-: returnPromise: 2.
	assert: [p isPromise].
	
	assert: p resolvesTo: self.
)
public testEventualSendToNearPromiseError = (
	| p |
	p:: (self <-: yourself) <-: doesNotExist.
	assert: [p isPromise].
	
	assert: p smashedWith: MessageNotUnderstood.
)
public testEventualSendToNearPromiseValue = (
	| p |
	p:: (self <-: yourself) <-: yourself.
	assert: [p isPromise].
	
	assert: p resolvesTo: self.
)
public testEventualSendToNearRefError = (
	| p |
	p:: self <-: doesNotExist.
	assert: [p isPromise].
	
	assert: p smashedWith: MessageNotUnderstood.
)
public testEventualSendToNearRefValue = (
	| p |
	p:: self <-: yourself.
	assert: [p isPromise].
	
	assert: p resolvesTo: self.
)
public testFactorial = (
	assert: (factorial: 10) resolvesTo: 3628800.
)
public testMissingWhenSmashed = (
	| r p |
	r:: Resolver new.
	p:: r promise
		whenResolved: [:v | halt].
	assert: [p isPromise].
	r smash: Error new.
	
	assert: p smashedWith: Error.
)
public testPromiseContagion = (
	| p |
	p:: (self <-: signalError) <-: doesNotExist.
	assert: [p isPromise].
	
	assert: p smashedWith: Error.  (* Not MessageNotUnderstood *)
)
public testPromiseContagion2 = (
	| p |
	p:: (self <-: signalError) <-: yourself.
	assert: [p isPromise].
	
	assert: p smashedWith: Error.
)
public testPromiseContagion3 = (
	| p |
	p:: (self <-: signalError) whenResolved: [halt].
	assert: [p isPromise].
	
	assert: p smashedWith: Error.
)
public testPromiseStopContagion = (
	| p |
	p:: (self <-: signalError)
		whenResolved: [halt]
		whenSmashed: [:e | assert: e class equals: Error. 'Return without exception'].		
	assert: [p isPromise].
	
	assert: p resolvesTo:  'Return without exception'.
)
public testResolveAfterWhen = (
	| r p |
	r:: Resolver new.
	p:: r promise.
	p:: p whenResolved: [:v | assert: v equals: #foo. 1].
	r resolve: #foo.
		
	assert: p resolvesTo: 1.
)
public testResolveBeforeWhen = (
	| r p |
	r:: Resolver new.
	p:: r promise.
	r resolve: #foo.
	p:: p whenResolved: [:v | assert: v equals: #foo. 1].
		
	assert: p resolvesTo: 1.
)
public testUnresolved = (
	| r p |
	r:: Resolver new.
	p:: r promise.
	
	deny: [p isResolved].
)
public testWhenResolvedError = (
	| r p |
	r:: Resolver new.
	p:: r promise
		whenResolved: [:v | Error signal: 'Something']
		whenSmashed: [:e | fail].
	assert: [p isPromise].
	r resolve: 21.
	
	assert: p smashedWith: Error.
)
public testWhenResolvedValue = (
	| r p |
	r:: Resolver new.
	p:: r promise
		whenResolved: [:v | v * 2]
		whenSmashed: [:e | fail].
	assert: [p isPromise].
	r resolve: 21.
	
	assert: p resolvesTo: 42.
)
public testWhenSmashedError = (
	| r p |
	r:: Resolver new.
	p:: r promise
		whenResolved: [:v | halt]
		whenSmashed: [:e | doesNotExist].
	assert: [p isPromise].
	r smash: Error new.
	
	assert: p smashedWith: MessageNotUnderstood.
)
public testWhenSmashedValue = (
	| r p |
	r:: Resolver new.
	p:: r promise
		whenResolved: [:v | halt]
		whenSmashed: [:e | 42].
	assert: [p isPromise].
	r smash: Error new.
	
	assert: p resolvesTo: 42.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
class TestBase = TestContext () (
'as yet unclassified'
assert: promise resolvesTo: expectedValue = (
	|
	state ::= #unresolved.
	resolution
	sem = Semaphore new.
	|
	promise
		whenResolved: 
			[:value |
			resolution:: value.
			state:: #resolved.
			sem signal]
		whenSmashed:
			[:error |
			resolution:: error.
			state:: #smashed.
			sem signal].
	sem waitTimeoutMSecs: 200.

	state = #unresolved ifTrue:
		[^failWithMessage: 'Timed out'].
	state = #smashed ifTrue:
		[^failWithMessage: 'Expected resolution of ', expectedValue printString, ' but smashed with ', resolution printString].
	assert: resolution equals: expectedValue.
)
assert: promise smashedWith: expectedErrorClass = (
	|
	state ::= #unresolved.
	resolution
	sem = Semaphore new.
	|
	promise
		whenResolved: 
			[:value |
			resolution:: value.
			state:: #resolved.
			sem signal]
		whenSmashed:
			[:error |
			resolution:: error.
			state:: #smashed.
			sem signal].
	sem waitTimeoutMSecs: 200.

	state = #unresolved ifTrue:
		[^failWithMessage: 'Timed out'].
	state = #resolved ifTrue:
		[^failWithMessage: 'Expected smashed with ', expectedErrorClass printString, ' but smashed with ', resolution printString].
	assert: resolution class equals: expectedErrorClass.
)
assertTimesOut: promise = (
	|
	state ::= #unresolved.
	resolution
	sem = Semaphore new.
	|
	promise
		whenResolved: 
			[:value |
			resolution:: value.
			state:: #resolved.
			sem signal]
		whenSmashed:
			[:error |
			resolution:: error.
			state:: #smashed.
			sem signal].
	sem waitTimeoutMSecs: 200.

	state = #resolved ifTrue:
		[^failWithMessage: 'Expected timeout but resolved with ', resolution printString].
	state = #smashed ifTrue:
		[^failWithMessage: 'Expected timeout but smashed with ', resolution printString].
)
) : (
)
public class TimerTests = TestBase () (
'as yet unclassified'
public testCoTimers = (
	| r ticks t1 t2 |
	r:: Resolver new.
	ticks:: 0.
	t1:: Timer every: 20 do: [:t | ticks:: ticks + 1].
	t2:: Timer after: 50 do: [t1 cancel. r resolve: ticks].

	[[assert: r promise resolvesTo: 2] ensure: [t1 cancel]] ensure: [t2 cancel].
)
public testOneShotTimer = (
	| r t |
	r:: Resolver new.
	t:: Timer after: 100 do: [deny: [t isActive]. r resolve: 42].
	assert: [t isActive].
	
	[assert: r promise resolvesTo: 42] ensure: [t cancel].
)
public testRepeatingTimer = (
	| count ::= 0. r t |
	r:: Resolver new.
	t:: Timer every: 10 do:
		[:timer |
		assert: timer equals: t.
		count:: count + 1.
		assert: [timer isActive].
		count = 5 ifTrue: [timer cancel. deny: [timer isActive]. r resolve: 42].
		count > 5 ifTrue: [failWithMessage: 'Cancel failed']].
	
	[assert: r promise resolvesTo: 42] ensure: [t cancel].
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
public class TwoActorTests = TestBase () (
'as yet unclassified'
public testFarSendEcho = (
	| testActor p |
	testActor:: (actors createActor: TestActor name: 'other') <-: new.
	p:: testActor <-: echo: self.
	
	assert: p resolvesTo: self.
)
public testFarSendError1 = (
	| testActor p |
	testActor:: (actors createActor: TestActor name: 'other') <-: new.
	p:: testActor <-: signalError.
	
	p:: p whenResolved: [halt] whenSmashed: [:e | e <-: class <-: name].
	assert: p resolvesTo: 'Error'.
)
public testFarSendError2 = (
	| testActor p |
	testActor:: (actors createActor: TestActor name: 'other') <-: new.
	p:: testActor <-: doesNotExist.
	
	p:: p whenResolved: [halt] whenSmashed: [:e | e <-: class <-: name].
	assert: p resolvesTo: 'MessageNotUnderstood'.
)
public testFarSendPromiseValue = (
	| testActor p |
	testActor:: (actors createActor: TestActor name: 'other') <-: new.
	p:: testActor <-: returnPromise42.
	
	assert: p resolvesTo: 42.
)
public testFarSendPromiseValue2 = (
	| testActor p |
	testActor:: (actors createActor: TestActor name: 'other') <-: new.
	p:: testActor <-: returnPromiseYourself.
	
	assert: (p whenResolved: [:testActorRef | testActor <-: = testActorRef]) resolvesTo: true.
)
public testFarSendValue = (
	| testActor p |
	testActor:: (actors createActor: TestActor name: 'other') <-: new.
	p:: testActor <-: return42.
	
	assert: p resolvesTo: 42.
)
public testPipelining = (
	| testActor p |
	testActor:: (actors createActor: TestActor name: 'other') <-: new.
	
	(* add:and: should not be waiting on the 42 promises in this actor to be resolved. *)
	p:: testActor <-: add: (testActor <-: returnPromise42) and: (testActor <-: returnPromise42).
	
	assert: p resolvesTo: 84.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
) : (
)
