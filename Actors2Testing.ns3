Newspeak3
'Actors'
class Actors2Testing usingPlatform: p actors: a minitest: m = (|
	private TestContext = m TestContext.
	private Semaphore = p squeak Semaphore.
	private MessageNotUnderstood = p kernel MessageNotUnderstood.
	private Resolver = a Resolver.
	private actors = a.
|) (
public class PromiseTest = TestContext () (
'as yet unclassified'
assert: promise resolvesTo: expectedValue = (
	|
	state ::= #unresolved.
	resolution
	sem = Semaphore new.
	|
	promise
		whenResolved: 
			[:value |
			resolution:: value.
			state:: #resolved.
			sem signal]
		whenSmashed:
			[:error |
			resolution:: error.
			state:: #smashed.
			sem signal].
	sem waitTimeoutMSecs: 200.

	state = #unresolved ifTrue: [^failWithMessage: 'Timed out'].
	state = #smashed ifTrue: [^failWithMessage: 'Expected resolution of ', expectedValue printString, ' but smashed with ', resolution printString].
	assert: resolution equals: expectedValue.
)
assert: promise smashedWith: expectedErrorClass = (
	|
	state ::= #unresolved.
	resolution
	sem = Semaphore new.
	|
	promise
		whenResolved: 
			[:value |
			resolution:: value.
			state:: #resolved.
			sem signal]
		whenSmashed:
			[:error |
			resolution:: error.
			state:: #smashed.
			sem signal].
	sem waitTimeoutMSecs: 200.

	state = #unresolved ifTrue: [^failWithMessage: 'Timed out'].
	state = #resolved ifTrue: [^failWithMessage: 'Expected smashed with ', expectedErrorClass printString, ' but smashed with ', resolution printString].
	assert: resolution class equals: expectedErrorClass.
)
public returnBrokenPromise = (
	^self <-: doesNotExist
)
public returnPromise = (
	^self <-: yourself
)
public returnPromise: n = (
	^n == 0
		ifTrue: [self]
		ifFalse: [self <-: returnPromise: n - 1].
)
public signalError = (
	Error signal: 'some error'.
)
public testChainAfterForwarded = (
	| r p r2 p2 p3 |
	r:: Resolver new.
	p:: r promise.
	r2:: Resolver new.
	p2:: r2 promise.
	p whenResolved: [:res | deny: res isPromise].
	p3:: [(*A*) [ p (*B*)whenResolved: [r2 resolve: 42]] <-: value. 21] <-: value.
	assert: [p3 isPromise].
	r resolve: p3.
	
	(* No way to guarentee B happens after p is resolved to p3, but this happens in the current implementation. *)
	
	assert: p2 resolvesTo: 42.
)
public testChainAfterResolved = (
	| r p r2 p2 |
	r:: Resolver new.
	p:: r promise.
	r2:: Resolver new.
	p2:: r2 promise.
	p whenResolved: [p whenResolved: [r2 resolve: 42]].
	r resolve: 21.
	
	assert: p2 resolvesTo: 42.
)
public testChainAfterSmashed = (
	| r p r2 p2 |
	r:: Resolver new.
	p:: r promise.
	r2:: Resolver new.
	p2:: r2 promise.
	p whenResolved: [halt] whenSmashed: [p whenResolved: [halt] whenSmashed: [r2 resolve: 42]].
	r smash: 21.
	
	assert: p2 resolvesTo: 42.
)
public testChainPromiseToError = (
	| p |
	p:: self <-: returnBrokenPromise.
	assert: [p isPromise].
	
	assert: p smashedWith: MessageNotUnderstood.
)
public testChainPromiseToValue = (
	| p |
	p:: self <-: returnPromise.
	assert: [p isPromise].
	
	assert: p resolvesTo: self.
)
public testDeeplyChainedPromise = (
	| p |
	p:: self <-: returnPromise: 1000.
	assert: [p isPromise].
	
	assert: p resolvesTo: self.
)
public testEventualSendToNearPromiseError = (
	| p |
	p:: (self <-: yourself) <-: doesNotExist.
	assert: [p isPromise].
	
	assert: p smashedWith: MessageNotUnderstood.
)
public testEventualSendToNearPromiseValue = (
	| p |
	p:: (self <-: yourself) <-: yourself.
	assert: [p isPromise].
	
	assert: p resolvesTo: self.
)
public testEventualSendToNearRefError = (
	| p |
	p:: self <-: doesNotExist.
	assert: [p isPromise].
	
	assert: p smashedWith: MessageNotUnderstood.
)
public testEventualSendToNearRefValue = (
	| p |
	p:: self <-: yourself.
	assert: [p isPromise].
	
	assert: p resolvesTo: self.
)
public testMissingWhenSmashed = (
	| r p |
	r:: Resolver new.
	p:: r promise
		whenResolved: [:v | halt].
	assert: [p isPromise].
	r smash: Error new.
	
	assert: p smashedWith: Error.
)
public testPromiseContagion = (
	| p |
	p:: (self <-: signalError) <-: doesNotExist.
	assert: [p isPromise].
	
	assert: p smashedWith: Error.  (* Not MessageNotUnderstood *)
)
public testResolveAfterWhen = (
	| r p |
	r:: Resolver new.
	p:: r promise.
	p:: p whenResolved: [:v | assert: v equals: #foo. 1].
	r resolve: #foo.
		
	assert: p resolvesTo: 1.
)
public testResolveBeforeWhen = (
	| r p |
	r:: Resolver new.
	p:: r promise.
	r resolve: #foo.
	p:: p whenResolved: [:v | assert: v equals: #foo. 1].
		
	assert: p resolvesTo: 1.
)
public testUnresolved = (
	| r p |
	r:: Resolver new.
	p:: r promise.
	
	deny: [p isResolved].
)
public testWhenResolvedError = (
	| r p |
	r:: Resolver new.
	p:: r promise
		whenResolved: [:v | Error signal: 'Something']
		whenSmashed: [:e | fail].
	assert: [p isPromise].
	r resolve: 21.
	
	assert: p smashedWith: Error.
)
public testWhenResolvedValue = (
	| r p |
	r:: Resolver new.
	p:: r promise
		whenResolved: [:v | v * 2]
		whenSmashed: [:e | fail].
	assert: [p isPromise].
	r resolve: 21.
	
	assert: p resolvesTo: 42.
)
public testWhenSmashedError = (
	| r p |
	r:: Resolver new.
	p:: r promise
		whenResolved: [:v | halt]
		whenSmashed: [:e | doesNotExist].
	assert: [p isPromise].
	r smash: Error new.
	
	assert: p smashedWith: MessageNotUnderstood.
)
public testWhenSmashedValue = (
	| r p |
	r:: Resolver new.
	p:: r promise
		whenResolved: [:v | halt]
		whenSmashed: [:e | 42].
	assert: [p isPromise].
	r smash: Error new.
	
	assert: p resolvesTo: 42.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
) : (
)
