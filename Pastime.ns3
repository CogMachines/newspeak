Newspeak3
'Actors'
class Pastime usingPlatform: platform usingDispatcher: d = (
(*Actor Futures. The way they were meant to be.*)|
	private MutableArrayList = platform collections MutableArrayList.

	private dispatcher = d.
|)
(
class Bender = (
(* A future consists of a Promise and a Resolver, which are the two facets of the Future object in the 
capability-based security model and POLA as described by Mark Miller. The Promise represents the 'use facet' and the Resolver the 'control facet. *)|

	public resolution <Object | Exception>
	
	(* unresolved, resolved, smashed *)
	public state <Symbol> ::= #unresolved.
	
	(*A list of messages pending delivery upon promise resolution.
	There are two kinds of messages:
	- Chained messages have a known receiver (a closure) and selector (value:), but unknown argument (the resolution). 
	Chained messages are listeners registered via whenResolved: [block].
	- Pipelined messages have an unknown receiver (the resolution), but known selector and arguments.
	Pipelined messages are messages eventually-sent to the promise before its resolution and intended for its resolution.*)
	public pendingMessages <List[PromiseMessage]> ::= MutableArrayList new.
	
	public promise = Promise for: self.
	public resolver = Resolver for: self.
|)
('as yet unclassified'
public doResolve: r <Object> type: t <Symbol> = (
	| exceptionHandled ::= false. |
	resolution: r.
	state: t. (* resolved / smashed *)

	(* Forward all buffered messages. *)
	pendingMessages do: [ :msg <PromiseMessage> | msg dispatch: [ exceptionHandled: true. ]. ].
	pendingMessages: nil.

	(* Re-signal unahndled exceptions. *)
	(t = 'smashed' and: [ exceptionHandled not ]) ifTrue: [ r passForDebug ].
)
public invokeWhen: whenHandler <[]> catch: catchHandler <[] | nil> resolver: resolver <Resolver | nil> catchListener: cl <[]> = (
	state == #resolved ifTrue: [
		postMessageTo: whenHandler selector: 'valueWithPossibleArgument:' args: { resolution } resolver: resolver.
		^self.
	].
	state == #smashed ifTrue: [
		(*Note: we notify the catchListener (cl) if the exception is handled to allow unhandled exceptions to be resignalled.
		See also the Promise`doResolve:type: method, where unhandled exceptions are signalled.
		See also the Promise`ChainMesage`dispatch: method, which passes through the catchListener.*)
		catchHandler isNil
			(*- Eventual-send the error to the exception handler*)
			ifFalse: [ postMessageTo: catchHandler selector: 'valueWithPossibleArgument:' args: { resolution } resolver: resolver. cl value. ]
			(*- Rethrow the exception by passing it along the chain. Note: the resolver is guaranteed to be near.*)
			ifTrue: [ resolver isNil ifFalse: [ resolver smash: resolution. cl value. ] ].
		^self.
	].
	Error signal: 'Invalid state: ', state.
)
public postMessage: selector <String> args: args <{}> resolver: resolver <Resolver | nil> = (
	state == #resolved ifTrue: [
		postMessageTo: resolution selector: selector args: args resolver: resolver.
		^self
	].
	state == #smashed ifTrue: [
		(* Note: the resolver is always near *)
		resolver isNil ifFalse: [ resolver smash: resolution ].
		^self
	].
	state == #unresolved ifTrue: [
		pendingMessages add: (PipelineMessage selector: selector args: args resolver: resolver bender: self).
		^self
	].
	Error signal: 'Invalid state: ',state.
)) : ()
class ChainMessage when: w <[]> catch: c <[] | nil> resolver: r <Resolver | nil> bender: b = PromiseMessage resolver: r bender: b (
(*Holds a chained listener to be notified with the resolution of the Promise upon resolution.*)|
	private whenHandler = w.
	private catchHandler = c.
|)
('as yet unclassified'
dispatch: catchListener <[]> = (
	bender invokeWhen: whenHandler catch: catchHandler resolver: bender resolver catchListener: catchListener.
)
isChainMessage = (
	^true.
)) : ()
class PipelineMessage selector: s <String> args: a <{}> resolver: r <Resolver | nil> bender: b = PromiseMessage resolver: r bender: b (
(*Holds a pipelined message to be delivered to the resolution of the Promise upon resolution.*)|
	private selector = s.
	private args = a.
|)
('as yet unclassified'
dispatch: catchListener <[]> = (
	| state = bender state. | 
	state == 'resolved' ifTrue: [
		(*The resolution is guaranteed NOT to be a Promise.*)
		postMessageTo: bender resolution selector: selector args: args resolver: resolver.
		^self.
	].
	state == 'smashed' ifTrue: [
		(*Conceptually this would involve an eventual-send to a broken ref stored in the resolution slot 
		that would in turn signal an Error and smash the resolver.
		Here we short-circuit that and smash the resolver directly.*)
		(*Note: the resolver is guaranteed to be near.*)
		resolver isNil ifFalse: [ resolver smash: bender resolution ].
		^self.
	].
	Error signal: 'Invalid state: ', state.
)
isPipelineMessage = (
	^true.
)) : ()
class Promise for: b = (
(* A Promise is an unresolved eventual reference that buffers 
messages eventual-sent to it and eventually-sends them upon resolution. *)|
	private bender <Bender> = b.
|)
('accessing'
protected doesNotUnderstand: msg <MessageMirror> ^ <Object> = (
	| state = bender state. |
	state == #resolved ifTrue: [ ^msg sendTo: bender resolution ].
	state == #smashed ifTrue: [
		| sel |
		(* For debugger inspection support: ignore is* messages, like Object does. *)
		sel: msg selector.
		sel isUnary ifTrue: [(sel startsWith: 'is') ifTrue: [^false]].
		^Error signal: 'Promise smashed with: ', bender resolution.
	].
	state == #unresolved ifTrue: [
		| sel |
		(* For debugger inspection support: ignore is* messages, like Object does. *)
		sel: msg selector.
		sel isUnary ifTrue: [(sel startsWith: 'is') ifTrue: [^false]].
		^Error signal: 'Cannot immediate-send ', msg, ' to an eventual reference. Promises only accept eventual-sends'.
	].
	Error signal: 'Illegal state: ', state.
)
public whenResolved: whenHandler <[]> ^ <Promise> = (
	^self whenResolved: whenHandler catch: nil.
)
public whenResolved: whenHandler <[]> catch: catchHandler <[] | nil> ^ <Promise> = (
	| future = Bender new. |
	self whenResolved: whenHandler catch: catchHandler resolver: future resolver.
	^future promise
)'as yet unclassified'
public , other <Promise> ^ <PromiseGroup> = (
	| state = bender state. |
	state == #resolved ifTrue: [ ^bender resolution , other ].
	state == #smashed ifTrue: [ Error signal: 'Promise smashed with: ', bender resolution ].
	state == #unresolved ifTrue: [ ^PromiseGroup for: other head: (PromiseGroup for: self) ].
	Error signal: 'Illegal state: ', state.
)
public ESEND = (
	^dispatcher mirrors EventualSendProxy for: self
)
whenResolved: whenHandler <[]> catch: catchHandler <[] | nil> resolver: resolver <Resolver | nil> = (
	bender state == 'unresolved'
		ifTrue: [ bender pendingMessages add: (ChainMessage when: whenHandler catch: catchHandler resolver: resolver bender: bender) ]
		ifFalse: [ bender invokeWhen: whenHandler catch: catchHandler resolver: resolver catchListener: []. ].
)) : ()
class PromiseGroup for: p head: h <PromiseGroup | nil> = (
(*A PromiseGroup represents a combined promise for a list of promises that is lazily initialized.*)|
	private previous <PromiseGroup | nil> = h.
	private promise <Promise> = p.
	private lazyAll <Promise> (*lazily initialized*)
|)
('as yet unclassified'
, other <Promise> = (
	^PromiseGroup for: other head: self.
)
all = (
	(lazyAll == nil) ifTrue: [
		| future = Bender new. counter ::= 0. |
		do: [ :it |
			counter:: counter + 1.
			it whenResolved: [ 
				((counter:: counter - 1) = 0) ifTrue: [ future resolver resolve: self. ].
			] catch: [ :ex |
				future resolver smash: ex.
			].
		].
		lazyAll:: future promise.
	].
	^lazyAll
)
do: block = (
	| it ::= self. |
	[ it == nil ] whileFalse: [
		block value: it promise.
		it:: it previous.
	].
)
doesNotUnderstand: msg <MessageMirror> ^ <Object> = (
	^msg sendTo: all.
)) : ('as yet unclassified'
for: p <Promise> = (
	^PromiseGroup for: p head: nil.
))
class PromiseMessage resolver: r <Resolver | nil> bender: b = (
(*An abstract class represeting a pending message buffered in an unresolved Promise.*)|
	
	(* Whose resolver? *)
	protected resolver = r.
	
	(* The future for which this message is chained/pipelined. *)
	protected bender = b.
|)
('as yet unclassified'
dispatch: catchListener <[]> = (
	subclassResponsibility.
)) : ()
class Resolver for: b<Bender> = (
(*A Resolver represents the authority to resolve a Promise and is the control facet of the promise's eventual resolution.*)|
	private bender = b.
|)
('accessing'
resolve: resolution <Object> ^ <Boolean> = (
	| unresolved = bender state == #unresolved. |
	unresolved ifTrue: [
		(isPromise: resolution) ifTrue: [
			(*Detect divergence.*)
			resolution == bender promise ifTrue: [ Error signal: 'Attempting to resolve a promise to itself.' ].
			resolution whenResolved: [ :finalResolution | resolve: finalResolution ] catch: [ :error | smash: error ] resolver: nil.
		]
		ifFalse: [
			bender doResolve: resolution type: #resolved.
		].
	].
	^unresolved.
)
smash: error <Error> ^ <Boolean> = (
	| unresolved = bender state == #unresolved. |
	unresolved ifTrue: [
		bender doResolve: error type: #smashed.
	].
	^unresolved.
)) : ()'as yet unclassified'
isBrokenRef: ref <Object> = (
	^(isPromise: ref) && [ref state == 'smashed'].
)
unwrapPromise: o <Object> ^ <Object> = (
	(*Smashed promises are broken refs and should NOT be unwrapped.*)
	#BOGUS. (* Accessing private slot #bender. *)
	((isPromise: o) and: [ o bender state == 'resolved' ])
		ifTrue: [ ^o bender resolution ] 
		ifFalse: [ ^o ].
)'private'
isPromise: o <Object> = (
	(*Check the class instead of asking the object in order to prevent user code from emulating Promises.*)
	^o class == Promise.
)
postMessageTo: receiver <Object> selector: selector <String> args: args <{}> resolver: resolver <Resolver | nil> = (
	(* Note: resolver is always near. *)
	#BOGUS. (* Accessing private slot #bender. *)
	(isPromise: receiver)
		ifTrue: [ receiver bender postMessage: selector args: args resolver: resolver. ]
		ifFalse: [ dispatcher postMessageTo: receiver selector: selector args: args resolver: resolver. ].
)) : ()