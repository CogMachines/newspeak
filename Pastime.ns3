Newspeak3
'Actors'
class Pastime usingPlatform: platform usingDispatcher: d = (
(*Actor Futures. The way they were meant to be.*)|
private MutableArrayList = platform collections MutableArrayList.
private dispatcher = d.
|)
(
class ChainMessage when: w <[]> catch: c <[] | nil> targetResolver: r sourceFuture: f = PromiseMessage targetResolver: r sourceFuture: f (
(*Holds a chained listener to be notified with the resolution of the Promise upon resolution.*)|
	private whenHandler = w.
	private catchHandler = c.
|)
('as yet unclassified'
dispatch: catchListener <[]> = (
	sourceFuture
		invokeWhen: whenHandler
		catch: catchHandler
		resolver: targetResolver
		catchListener: catchListener
)
isChainMessage = (
	^true.
)) : ()
class Future withResolver: r = (
(* A future consists of a Promise and a Resolver, which are the two facets of the Future object in the 
capability-based security model based upon the POLA as described by Mark Miller. The Promise represents the 'use facet' and the Resolver the 'control facet'.

The future used for actors/asynchrony is a 'push future'. The future used for simultaneous slots/laziness is a 'pull future'. *)|
	public resolution <Object | Exception>
	
	(* unresolved, resolved, smashed *)
	public state <Symbol> ::= #unresolved.
	
	(*A list of messages pending delivery upon promise resolution.
	There are two kinds of messages:
	- Chained messages have a known receiver (a closure) and selector (value:), but unknown argument (the resolution). 
	Chained messages are listeners registered via whenResolved: [block].
	- Pipelined messages have an unknown receiver (the resolution), but known selector and arguments.
	Pipelined messages are messages eventually-sent to the promise before its resolution and intended for its resolution.*)
	public pendingMessages <List[PromiseMessage]> ::= MutableArrayList new.
	
	public promise = Promise for: self.
	public resolver = r.
|)
('as yet unclassified'
public doResolve: r <Object> type: t <Symbol> = (
	| exceptionHandled ::= false. |
	resolution: r.
	state: t. (* resolved / smashed *)

	(* Forward all buffered messages. *)
	pendingMessages do: [ :msg <PromiseMessage> | msg dispatch: [ exceptionHandled: true. ]. ].
	pendingMessages: nil.

	(* Re-signal unahndled exceptions. *)
	(t = 'smashed' and: [ exceptionHandled not ]) ifTrue: [ r passForDebug ].
)
public invokeWhen: whenHandler <[]> catch: catchHandler <[] | nil> resolver: resolver <Resolver | nil> catchListener: cl <[]> = (
	state == #resolved ifTrue: [
		postMessageTo: whenHandler selector: 'valueWithPossibleArgument:' args: { resolution } resolver: resolver.
		^self.
	].
	state == #smashed ifTrue: [
		(*Note: we notify the catchListener (cl) if the exception is handled to allow unhandled exceptions to be resignalled.
		See also the Promise`doResolve:type: method, where unhandled exceptions are signalled.
		See also the Promise`ChainMesage`dispatch: method, which passes through the catchListener.*)
		catchHandler isNil
			(*- Eventual-send the error to the exception handler*)
			ifFalse: [ postMessageTo: catchHandler selector: 'valueWithPossibleArgument:' args: { resolution } resolver: resolver. cl value. ]
			(*- Rethrow the exception by passing it along the chain. Note: the resolver is guaranteed to be near.*)
			ifTrue: [ resolver isNil ifFalse: [ resolver smash: resolution. cl value. ] ].
		^self.
	].
	Error signal: 'Invalid state: ', state.
)
public postMessage: selector <String> args: args <{}> resolver: resolver <Resolver | nil> = (
	state == #resolved ifTrue: [
		postMessageTo: resolution selector: selector args: args resolver: resolver.
		^self
	].
	state == #smashed ifTrue: [
		(* Note: the resolver is always near *)
		resolver isNil ifFalse: [ resolver smash: resolution ].
		^self
	].
	state == #unresolved ifTrue: [
		pendingMessages add: (PipelineMessage selector: selector args: args targetResolver: resolver sourceFuture: self).
		^self
	].
	Error signal: 'Invalid state: ',state.
)) : ()
class PipelineMessage selector: s <String> args: a <{}> targetResolver: r sourceFuture: f = PromiseMessage targetResolver: r sourceFuture: f (
(*Holds a pipelined message to be delivered to the resolution of the Promise upon resolution.*)|
	private selector = s.
	private args = a.
|)
('as yet unclassified'
dispatch: catchListener <[]> = (
	| state = sourceFuture state. | 
	state == #resolved ifTrue: [
		(*The resolution is guaranteed NOT to be a Promise.*)
		postMessageTo: sourceFuture resolution selector: selector args: args resolver: targetResolver.
		^self.
	].
	state == 'smashed' ifTrue: [
		(*Conceptually this would involve an eventual-send to a broken ref stored in the resolution slot 
		that would in turn signal an Error and smash the resolver.
		Here we short-circuit that and smash the resolver directly.*)
		(*Note: the resolver is guaranteed to be near.*)
		targetResolver isNil ifFalse: [ targetResolver smash: sourceFuture resolution ].
		^self.
	].
	Error signal: 'Invalid state: ', state.
)
isPipelineMessage = (
	^true.
)) : ()
class Promise for: f = (
(* A Promise is an unresolved eventual reference that buffers messages eventual-sent to it and eventually-sends them upon resolution.

add whenComplete: / ensure: ?
Allow querying isResolved/Smashed/Unresolved?
Allow synchronous access to resolution if resolved? *)|
	private future <Future> = f.
|)
('accessing'
protected doesNotUnderstand: msg <MessageMirror> ^ <Object> = (
	| state = future state. |
	state == #resolved ifTrue: [ ^msg sendTo: future resolution ].
	state == #smashed ifTrue: [
		| sel |
		(* For debugger inspection support: ignore is* messages, like Object does. *)
		sel: msg selector.
		sel isUnary ifTrue: [(sel startsWith: 'is') ifTrue: [^false]].
		^Error signal: 'Promise smashed with: ', future resolution.
	].
	state == #unresolved ifTrue: [
		| sel |
		(* For debugger inspection support: ignore is* messages, like Object does. *)
		sel: msg selector.
		sel isUnary ifTrue: [(sel startsWith: 'is') ifTrue: [^false]].
		^Error signal: 'Cannot immediate-send ', msg, ' to an eventual reference. Promises only accept eventual-sends'.
	].
	Error signal: 'Illegal state: ', state.
)
public whenResolved: onValue <[]> ^ <Promise> = (
	^self whenResolved: onValue whenSmashed: nil.
)'as yet unclassified'
public , other <Promise> ^ <PromiseGroup> = (
	| state = future state. |
	state == #resolved ifTrue: [ ^future resolution , other ].
	state == #smashed ifTrue: [ Error signal: 'Promise smashed with: ', future resolution ].
	state == #unresolved ifTrue: [ ^PromiseGroup for: other head: (PromiseGroup for: self) ].
	Error signal: 'Illegal state: ', state.
)
public ESEND = (
	^dispatcher mirrors EventualSendProxy for: self
)
public isPromise ^<Boolean> = (
	^true
)
public whenResolved: onValue <[]> whenSmashed: onError <[] | nil> ^ <Promise> = (
	| chainedResolver = Resolver new. |
	self whenResolved: onValue whenSmashed: onError resolver: chainedResolver.
	^chainedResolver promise
)
whenResolved: onValue <[]> whenSmashed: onError <[] | nil> resolver: resolver <Resolver | nil> = (
	future state == #unresolved
		ifTrue: [ future pendingMessages add: (ChainMessage when: onValue catch: onError targetResolver: resolver sourceFuture: future) ]
		ifFalse: [ future invokeWhen: onValue catch: onError resolver: resolver catchListener: []. ].
)) : ()
class PromiseGroup for: p head: h <PromiseGroup | nil> = (
(*A PromiseGroup represents a combined promise for a list of promises that is lazily initialized.*)|
	private previous <PromiseGroup | nil> = h.
	private promise <Promise> = p.
	private lazyAll <Promise> (*lazily initialized*)
|)
('as yet unclassified'
, other <Promise> = (
	^PromiseGroup for: other head: self.
)
all = (
	(lazyAll == nil) ifTrue: [
		| resolver = Resolver new. counter ::= 0. |
		do: [ :it |
			counter:: counter + 1.
			it whenResolved: [ 
				((counter:: counter - 1) = 0) ifTrue: [ resolver resolve: self. ].
			] whenSmashed: [ :ex |
				resolver smash: ex.
			].
		].
		lazyAll:: resolver promise.
	].
	^lazyAll
)
do: block = (
	| it ::= self. |
	[ it == nil ] whileFalse: [
		block value: it promise.
		it:: it previous.
	].
)
doesNotUnderstand: msg <MessageMirror> ^ <Object> = (
	^msg sendTo: all.
)) : ('as yet unclassified'
for: p <Promise> = (
	^PromiseGroup for: p head: nil.
))
class PromiseMessage targetResolver: r sourceFuture: f = (
(*An abstract class represeting a pending message buffered in an unresolved Promise.*)|
	
	(* Resolver for the promise which is the result of the pipelined/chained message. *)
	protected targetResolver = r.
	
	(* The future on which the pipelined/chained message is waiting. *)
	protected sourceFuture = f.
|)
('as yet unclassified'
dispatch: catchListener <[]> = (
	subclassResponsibility.
)) : ()
public class Resolver = (
(*A Resolver represents the authority to resolve a Promise and is the control facet of the promise's eventual resolution.*)|
	private future = Future withResolver: self.
|)
('accessing'
public resolve: resolution <Object> ^ <Boolean> = (
	| unresolved = future state == #unresolved. |
	unresolved ifTrue: [
		(isPromise: resolution) ifTrue: [
			(*Detect divergence.*)
			resolution == future promise ifTrue: [ Error signal: 'Attempting to resolve a promise to itself.' ].
			resolution
				whenResolved: [ :finalResolution | resolve: finalResolution ]
				whenSmashed: [ :error | smash: error ] resolver: nil.
		]
		ifFalse: [
			future doResolve: resolution type: #resolved.
		].
	] ifFalse: [halt].
	^unresolved.
)
public smash: error <Error> ^ <Boolean> = (
	| unresolved = future state == #unresolved. |
	unresolved ifTrue: [
		future doResolve: error type: #smashed.
	] ifFalse: [halt].
	^unresolved.
)'as yet unclassified'
public isResolver ^<Boolean> = (
	^true
)
public promise ^<Promise> = (
	^future promise
)) : ()'as yet unclassified'
isBrokenRef: ref <Object> = (
	^(isPromise: ref) and: [ref state == 'smashed'].
)
unwrapPromise: o <Object> ^ <Object> = (
	(*Smashed promises are broken refs and should NOT be unwrapped.*)
	#BOGUS. (* Accessing private slot #future. *)
	((isPromise: o) and: [ o future state == #resolved ])
		ifTrue: [ ^o future resolution ] 
		ifFalse: [ ^o ].
)'private'
isPromise: o <Object> = (
	(*Check the class instead of asking the object in order to prevent user code from emulating Promises.*)
	^Promise == o class
)
postMessageTo: receiver <Object> selector: selector <String> args: args <{}> resolver: resolver <Resolver | nil> = (
	(* Note: resolver is always near. *)
	#BOGUS. (* Accessing private slot #future. *)
	(isPromise: receiver)
		ifTrue: [ receiver future postMessage: selector args: args resolver: resolver. ]
		ifFalse: [ dispatcher postMessageTo: receiver selector: selector args: args resolver: resolver. ].
)) : ()