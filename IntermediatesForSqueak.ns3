Newspeak3
'Mirrors'
class IntermediatesForSqueak usingPlatform: p = (
(* The output of the compiler and the mutable internals of a mirror builder.

Synthetics: slot accessors, nested class slots, nested class accessor, instance initializers, factories


* The LowLevelMirrors module defines a mirror library at the level of abstraction of the virtual machine - in this case, Squeak.  Ideally, the high level mirror library will depend on the low level mirror API, and be largely isolated from the details of Squeak.


   Copyright 2008 Cadence Design Systems, Inc.
   Copyright 2011 Ryan Macnak
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
 *)|
private List = p collections OrderedCollection.
private Map = p collections Dictionary.

private Smalltalk = p squeak Smalltalk.
private CompiledMethod = p squeak CompiledMethod.
private CompiledMethodTrailer = p squeak CompiledMethodTrailer.
private AdditionalMethodState = p squeak AdditionalMethodState.
private EncoderForNewsqueakV4 = p squeak EncoderForNewsqueakV4.
|) (
public class IntermediateClassDeclaration = (|
simpleNameX
public qualifiedName
public headerSource
public factoryName
public comment
public category
public instanceSide = IntermediateMixin for: self isMeta: false.
public classSide = IntermediateMixin for: self isMeta: true.
|) (
'as yet unclassified'
public printOn: stream = (
	stream nextPutAll: 'IntermediateClassDeclaration:'; nextPutAll: qualifiedName.
)
public simpleName= (
	^simpleNameX
)
public simpleName: n = (
	(n includes: $`) ifTrue: [halt].
	simpleNameX: n
)
) : (
)
public class IntermediateMethod = (|
public method <CompiledMethod>
public debugInfo
public maxStack <Integer>
public maxLocals <Integer>
public argCount <Integer>
public literals <OrderedCollection[Object]>
public bytes <OrderedCollection[Byte]> ::= List new. 
public selector <Symbol>
public klass <Class>
public source <String>
public pragmas
public accessModifier <Symbol>

public metadata = Map new.

public category
public isSlotAccessor ::= false.
public isSuperConstructor ::= false.
public isNestedClassAccessor ::= false.
public isConstructor ::= false.
public isSynthetic ::= false.
public isSubinitializer ::= false.
|) (
'as yet unclassified'
public bci ^<Integer> = (
	^bytes size
)
public byte: b <Integer> = (
	assert: [0 <= b and: [b <= 255]] message: 'Bytecode out of range'.
	bytes add: b  
)
public byteAt: index <Integer> ^<Integer> = (
	^bytes at: index
)
public byteAt: index <Integer> put: datum <Integer> = (
	bytes at: index put: datum  
)
cleanup = (
	literals:: nil.
	bytes:: nil
)
public compiledMethod ^<CompiledMethod> = (
	| properties <MethodProperties> offset <Integer> |
	method isNil ifFalse: [^method].

	assert: [argCount <= maxLocals] message: ''.
		
	method:: instantiateMethodV4.
		
	(1 to: literals size)
		with: literals asOrderedCollection
		do: [:i :lit | method literalAt: i put: lit]. 

	method selector: selector.
	(pragmas isNil or: [pragmas isEmpty]) ifFalse:
		[properties:: AdditionalMethodState forMethod: method selector: selector.
		pragmas do: [:p | properties:: properties copyWith: p].
		method properties: properties].

	isSubinitializer ifTrue:
		[method properties isNil ifTrue: 
			[properties:: MethodProperties new selector: selector.
		      method properties: properties].
			method properties at: #isSubinitializer put: true.
			(metadata includesKey: #hasBody)
				ifTrue: [method properties at: #hasBody put: (metadata at: #hasBody)]].
			
	method literalAt: literals size + 2 put: klass name -> klass.
	(* association pointing at the mixin that declared this method (aka method class) *)

	(* Pointer for each literal, plus the header, the selector or method properties, and the method class association. *)
	offset:: (literals size + 3) * 4.
	1 to: bytes size do:
		[:i | method basicAt: i + offset put: (bytes at: i)].

	setSourceAndCategory.
	cleanup.
		
	^method
)
public compiledMethodSize ^ <Integer> = (
	(* 3 = header + properties/selector + method class assocation *)
	^((literals size + 3) * Smalltalk wordSize) + bytes size	
)
instantiateMethodV4 ^<CompiledMethod> = (
	| header cmethod |	
	header:: EncoderForNewsqueakV4 basicNew
		computeMethodHeaderForNumArgs: argCount
		numTemps: maxLocals
		numLits: literals size + 2
		primitive: 0
		accessModifier: accessModifier.
		
	cmethod:: CompiledMethodTrailer empty
		createMethod: bytes size
		class: CompiledMethod
		header: header.
		
	cmethod needsFrameSize: 
		(maxStack min: CompiledMethod fullFrameSize - maxLocals). (*Suppress warning about frame too big, which apparently is not checked in the constructor used by instantiateMethodV3 and is actually exceeded in some Newspeak code.*)
	
	^cmethod
)
public printOn: stream = (
	stream nextPutAll: 'IntermediateMethod:'; nextPutAll: simpleName.
)
setSourceAndCategory = (
	(* This is horrible, but in Squeak access to source is via the compiled method, which stores the information in itself. To make matters worse, the class and category are required. *)
	| cat <String> |
	assert: [klass isNil not] message: 'Missing methodMixin'.
	assert: [category isNil == isSynthetic] message: 'Category should be missing IFF synthetic'.
	isSynthetic ifTrue: [^self (* No source to save *)].
	assert: [category isNil not] message: 'Missing category'.
	method putSource: source fromParseNode: nil class: klass category: category inFile: 2 priorMethod: nil.
)
public simpleName = (
	^selector
)
) : (
)
public class IntermediateMixin for: d isMeta: m = (|
public declaration = d.
public isMeta = m.
public slots = List new.
public methods = List new.
public nestedClasses = List new.
|) (
'as yet unclassified'
public printOn: stream = (
	stream nextPutAll: 'IntermediateMixin:'; nextPutAll: declaration qualifiedName.
	isMeta ifTrue: [stream nextPutAll: ' class'].
)
) : (
)
public class IntermediateSlotDeclaration = (|
public name
public isMutable
public accessModifier
|) (
'as yet unclassified'
public generateGetterForSlot: n <Integer> ^<IntermediateMethod> = (
	| method = IntermediateMethod new. |
	method selector: name asSymbol.
      method accessModifier: accessModifier.
      method method: (CompiledMethod newGetterForSlot: n accessModifier: accessModifier).
	method method selector: method selector.
	method isSynthetic: true; isSlotAccessor: true.
	(name endsWith: '`slot') ifTrue: [method isNestedClassAccessor: true].
	^method
)
public generateInitializerForSlot: n <Integer> ^<IntermediateMethod> = (
	| method = IntermediateMethod new. |
	method selector: initializerName.
      method accessModifier: #private.
      method method: (CompiledMethod newSetterForSlot: n accessModifier: #private).
	method method selector: method selector.
	method isSynthetic: true; isSlotAccessor: true.
	(name endsWith: '`slot') ifTrue: [method isNestedClassAccessor: true].
	^method
)
public generateSetterForSlot: n <Integer> ^<IntermediateMethod> = (
	| method = IntermediateMethod new. |
	method selector: setterName.
      method accessModifier: accessModifier.
      method method: (CompiledMethod newSetterForSlot: n accessModifier: accessModifier).
	method method selector: method selector.
	method isSynthetic: true; isSlotAccessor: true.
	(name endsWith: '`slot') ifTrue: [method isNestedClassAccessor: true].
	^method
)
initializerName ^<Symbol>= (
	^('init`', name, ':') asSymbol
)
public printOn: stream = (
	stream nextPutAll: 'IntermediateSlotDeclaration:'; nextPutAll: simpleName.
)
setterName ^<Symbol>= (
	(* Yuck! This is a copy of Compiler#setterSelectorFor: *)
	^((isMutable ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), name, ':') asSymbol
)
public simpleName = (
	^name
)
) : (
)
) : (
)
