Newspeak3'Newspeak3'class Newspeak3AST usingLib: platform = NewspeakObject ("   Copyright 2008 Cadence Design Systems, Inc.      Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|         OrderedCollection = platform collections OrderedCollection. |)(class SlotDefAST = AST  (| slotDecl <SlotDeclarationAST> initializer <ExpressionAST> accessModifier |)('as yet unclassified'isSlotDefNode = ( ^ true )type ^ <TypeAST> = (	  ^slotDecl type)'accessing'isMutable ^ <Boolean> = (self subclassResponsibility)isMutableSlot ^ <Boolean> = (self subclassResponsibility)name ^ <Symbol> = (    ^slotDecl name  )'visiting'apply: visitor = (^visitor slotDefNode: self))class AST = ("An abstract syntax tree. An AST knows where in the source code the corresponding construct is.  The slots start and end are indices into the source code marking that position.In some cases, the corresponding construct may be associated with tokens that are not strictly part of the abstract syntax. For example, in (foo) the parentheses are not part of the abstract syntax but foo is. Nonetheless, it may be useful to know where the parens are, since they are strongly associated withthe AST. We use the slots concStart and concEnd for that purpose."| startPosition ::= 0.  endPosition ::= 0. concStart <Integer> concEnd <Integer> |)('as yet unclassified'end ^ <Integer> = (	^endPosition)end: i <Integer> = (	endPosition: i)isAST ^ <Boolean> = (	^true)isClassDeclarationNode = (	^ false.)isLeaf ^ <Boolean> = (	^false)left: leftmostSubtree <AST>  = ("For any non-leaf AST, its concrete start is either the stored concretestart value (if there is one, that is, it isn't nil) or else the concrete start of its leftmost subtree.The start of an AST is  the concrete start of its leftmost subtreeunless it has no subtrees; then it is the stored value.  Only the parser knows which subtree is  the leftmost, as this depends on the concrete syntax. The parser may this routine, which sets the indices in the tree."	concStart ifNil:[concStart: leftmostSubtree concreteStart]. 	start = 0 ifTrue:[startPosition: concStart].)name = (	#BOGUS yourself.	"Quirky behavior from Squeak's Object"	^self printString)right: rightmostSubtree <AST> = ("For any non-leaf AST, its concrete end is either the stored concreteend value (if there is one, that is, it isn't nil) or else the concrete end of its rightmost subtree. The end of an AST is the concrete end of its rightmost subtree,unless it has no subtrees; then it is the stored value. Only the parser knows which subtree is the rightmost, as this depends on the concrete syntax. The parser calls this routine, which sets the indices in the tree."	concEnd ifNil:[concEnd: rightmostSubtree concreteEnd]. 	end = 0 ifTrue:[endPosition: concEnd].)start ^ <Integer> = (	^startPosition)start: i <Integer> = (	startPosition: i)'source positioning'concreteEnd ^ <Integer> = ("To be used by leaf nodes; they will typically only have a stored concrete end if it was set by the parser (usually due to surrounding parens), though the AST copier might set it regardless"^ concEnd isNil ifTrue:[self end] ifFalse:[concEnd] )concreteEnd: i <Integer> = (	concEnd:: i)concreteStart ^ <Integer> = ("To be used by leaf nodes; they will typically only have a stored concrete start if it was set by the parser (usually due to surrounding parens), though the AST copier might set it regardless"^ concStart isNil ifTrue:[self start] ifFalse:[concStart])concreteStart: i <Integer> = (	concStart:: i)'testing'isArrayNode = (^false)isAssignmentNode = (^false)isBlockNode = (^false)isCascadedSendNode = (^false)isCharNode = (^false)isClassNode = (^false)isCodeBodyNode = (^false)isExpressionNode = (^false)isLiteralNode = (^false)isMessageNode = (^false)isMessagePatternNode = (^false)isMethodNode = (^false)isNormalSendNode = (^false)isNumberNode = (^false)isReturnStatNode = (^false)isSendNode = (^false)isSideNode = (^false)isStringNode = (^false)isSymbolNode = (^false)isTupleNode = (^false)isVarDeclNode = (^false)isVariableNode = (^false)'protected'assert: c = (	self assert: c message: ''.)'visiting'apply: aTool = (    ^self subclassResponsibility  ))class AssignmentAST = AST (| var <VariableAST> expr <AST> |)('testing'isAssignmentNode = (^true)isExpressionNode = (^true)'visiting'apply: aTool = (    ^aTool assignmentNode: self.  )'initialization'to: aVar <VariableAST> assign: anExpr <AST> = (  self assert:[aVar isVariableNode].  self assert:[anExpr isExpressionNode].  self var: aVar; expr: anExpr.  start: var start.  end: anExpr end.))class NSSideAST = SideAST  (| nestedClasses <List[ClassDeclarationAST]> |)()class KeywordPatternAST = PatternAST (|	keywords <TupleAST>	patterns <TupleAST>|)('as yet unclassified'apply: tool = (	^ tool keywordPatternNode: self.)isKeywordPatternNode = (	^ true))class KeywordPatternPairAST = AST (|	keyword <Symbol>	pattern|)('as yet unclassified'isKeywordPatternPairNode = (	^ true))class NormalSendAST = SendAST (| recv <ExpressionAST> |)('visiting'apply: aTool = (  ^aTool normalSendNode: self  )'testing'isNormalSendNode = (^true)'initialization'to: anExpression <ExpressionAST> send: aMessage <MessageAST>= (  self assert:[anExpression isExpressionNode].  self assert:[aMessage isMessageNode].  self recv: anExpression; msg: aMessage))class CascadedSendAST = SendAST (| prevSend <SendAST> |)('initialization'to: aSend <SendAST> cascade: aMessage <MessageAST>  = (  self assert:[aSend isSendNode].  self assert:[aMessage isMessageNode].  self prevSend: aSend; msg: aMessage)'visiting'apply: aTool = (  ^aTool cascadedSendNode: self.)'testing'isCascadedSendNode = (^true)'accessing'recv ^ <ExpressionAST> = (^self prevSend recv))class SymbolAST = LiteralAST ()('visiting'apply: aTool = (^aTool symbolNode: self)'testing'isSymbolNode = (^true))class CodeBodyAST = AST (	|	parameters <List[ParameterAST]>	temporaries <List[TemporaryAST]>	statements <List[StatementAST]>	isSeq <Boolean>	|)('as yet unclassified'isExpressionNode = (	#BOGUS. "Added for expansion of setter::exp to (t:=exp. setter:exp. t).  This might not play well with expectations in the rest of the compiler?  --Ryan"	^true)'initialization'parameters: pars <List[ParameterAST]> temporaries: temps <List[TemporaryAST]> statements: stats <List[StatementAST]> = ("  self assert:[pars isCollection].  self assert:[temps isCollection].  self assert:[stats isCollection]." "cf. parameters:temporaries:"  self parameters: pars; temporaries: temps; statements: stats)temporaries: temps <List[TemporaryAST]> statements: stats <List[StatementAST]> = ("  self assert:[ temps isCollection ].  self assert:[ stats isCollection ]." "these have to go for the sake of js compilation (isArray does not work, as NS Collection does not understand it"  self parameters: OrderedCollection new; temporaries: temps; statements: stats)'testing'isCodeBodyNode = (^true)'visiting'apply: aTool = ( ^aTool codeBodyNode: self.))class PatternAST = LiteralAST (||)('as yet unclassified'isPatternNode = (	^ true))class TypePatternAST = AST (| formals |)('as yet unclassified'apply: aTool  = (	^aTool typePatternNode: self)isTypeNode = (	^ true))class WildcardPatternAST = PatternAST (||)('as yet unclassified'apply: tool = (	^ tool wildcardPatternNode: self)isWildcardPatternNode = (	^ true))class SendAST send: aMsg  = AST (| msg <MessageAST> = aMsg. |"assert:[ aMsg isMessageNode].")('testing'isExpressionNode = (^true)isSendNode = (^true)recv ^ <ExpressionAST> = (  ^self subclassResponsibility))class HeaderProxy = AST ("The purpose of this class is to allow languages that do not yet have the class header cleanly separated in their grammar to have a separate object representing their header. It supports a subset of the protocol of ClassHeaderAST, that is sufficient for the headers of such languages. It implements this protocol by forwarding messages to a ClassAST node which it keeps in its declaration instance variable."| declaration |)('header emulation'category = (^self declaration category)category: c = (^self declaration category: c)classComment = (^self declaration instanceSide classComment)connections = (	^[declaration instanceSide connections]		on: MessageNotUnderstood		do: [:ex| ex return: nil])constructor = (	^[declaration constructor]		on: MessageNotUnderstood		do: [:ex| ex return: nil])end = (^self declaration end)instanceSide = (^declaration instanceSide)interfaces = (	^[declaration instanceSide interfaces]		on: MessageNotUnderstood		do: [:ex| ex return: nil])name = (^self declaration name)slots = (	^self instanceSide vars)start = (^self declaration start)superConstructorCall = (	^[declaration superConstructorCall]		on: MessageNotUnderstood		do: [:ex| ex return: nil])superclassName = (^self declaration superclassName)vars = (	^declaration instanceSide vars)'testing'headerDeclarationEndsWithClosingParenthesis = (	^false)'visiting'apply: visitor = (^visitor classHeaderNode: self))class NamespaceAST = AST  (| name body exports |)()class FalseVisitor = ASTTool ("A visitor that returns false for all nodes.  This is useful when one needs to extend the set of AST types with a new type, and want to be able to determin eif an object is an instance of the new type. Instead of changing AST to support yet another isX predicate, we define a visitor that answers true when visitimg the new type, and false otherwise. It's easy to define such a visitor by extending this class.")('as yet unclassified'assignmentNode: node <AssignmentAST> ^ <Boolean>= (	^false)blockNode: aNode <BlockAST> ^ <Boolean> = (  ^false)cascadedSendNode: aNode <CascadedSendAST>  ^ <Boolean> = (  ^false)charNode: aNode <CharAST> ^ <Boolean> = (  ^false)classNode: aNode <ClassAST> ^ <Boolean> = (  ^false)codeBodyNode: aNode <CodeBodyAST> ^ <Boolean> = (  ^false)keywordPatternNode: aNode <KeywordPatternAST> ^<Boolean> = (	^false)literalPatternNode: aNode <LiteralPatternAST> ^<Boolean> = (	^false)messageNode: aNode <MessageAST> ^ <Boolean> = (  ^false)messagePatternNode: aNode <MessagePatternAST> ^ <Boolean> = (  ^false)methodNode: aNode <MethodAST> ^ <Boolean> = (  ^false)mixinApplication: node <MixinApplicationAST> ^ <Boolean> = (  ^false)normalSendNode: aNode <NormalSendAST> ^ <Boolean> = (  ^false)numberNode: aNode <NumberAST> ^ <Boolean> = (  ^false)returnStatNode: aNode <ReturnStatAST> ^ <Boolean> = (  ^false)setterSendNode: aNode <SetterSendAST>  ^ <Boolean> = (  ^false)sideNode: aNode <SideAST> ^ <Boolean> = (  ^false)stringNode: aNode <StringAST> ^ <Boolean> = (  ^false)symbolNode: aNode <SymbolAST> ^ <Boolean> = (  ^false)tupleNode: aNode <TupleAST> ^ <Boolean> = (  ^false)varDeclNode: aNode <VarDeclAST> ^ <Boolean> = (  ^false)variableNode: aNode <VariableAST> ^ <Boolean> = (  ^false)variablePatternNode: aNode <VariablePatternAST> ^<Boolean> = (	^false)wildcardPatternNode: aNode <WildcardPatternAST> ^<Boolean> = (	^false))class NamespaceExprAST = AST  (| fullName expr |)() : ('instance creation'name: fn expression: e = (   ^self new initialize fullName: fn; expr: e  ))class BlockAST = AST (| body <CodeBodyAST>  |)('testing'isBlockNode = ( ^true)isExpressionNode = (^true)'visiting'apply: aTool = (  ^aTool blockNode: self.)'accessing'parameters ^ <List[ParameterAST]> = (  ^body parameters))class MessagePatternAST = AST (| selector <Symbol> parameters <List[ParameterAST]> returnType <TypeAST> typePattern <TypePatternAST> |)('as yet unclassified'isLeaf ^ <Boolean> = (	^parameters isEmpty)'testing'isMessagePatternNode = (^true)'initialization'selector: s <Symbol> parameters: p <List[ParameterAST]> = (  self selector: s; parameters: p)selector: s <Symbol> parameters: p <List[ParameterAST]> returnType: t <TypeAST> = (  self selector: s; parameters: p; returnType: t)selector: s <Symbol> parameters: p <List[ParameterAST]> returnType: t  <TypeAST> typePattern: tp <TypePatternAST> = (  self selector: s; parameters: p; returnType: t; typePattern: tp)selector: s <Symbol> returnType: t <TypeAST> = (  self selector: s; returnType: t)'visiting'apply: aTool = (    ^aTool messagePatternNode: self.  )'source positioning'concreteEnd = (     self typePattern isNil ifFalse:[^self typePattern concreteEnd].     self returnType isNil ifFalse:[^self returnType concreteEnd].     self parameters isEmpty ifFalse:[^self parameters last concreteEnd].     ^super concreteEnd  ))class LiteralPatternAST = PatternAST (|	literal <LiteralAST>|)('as yet unclassified'apply: tool = (	^ tool literalPatternNode: self.)isLiteralPatternNode = (	^ true))class MessageAST = AST (| sel <Symbol> args <List[ExpressionAST]> |)('as yet unclassified'isLeaf ^ <Boolean> = (	^args isEmpty)'testing'isMessageNode = (^true)'visiting'apply: aTool = (    ^aTool messageNode: self.  )'initialization'send: aSelector <Symbol> with: arguments <List[ExpressionAST]> = ("    self assert:[aSelector isSymbol].    self assert:[arguments isCollection]."    self sel: aSelector; args: arguments  ))class ClassAST = AST ("The AST for a class definition"| name <Symbol>superclassName <Symbol>instanceSide <SideAST>classSide <SideAST>category <CategoryAST>|)('accessing'classComment ^ <String> = (  "Hack, to get NS1 working with latest multi-language framework. This method, and this AST node, should  go away once we stop using NS1"    ^self instanceSide classComment  )hdr = (^HeaderProxy new declaration: self)'initialization'forClass: n  <Symbol> super: s <Symbol> instSide: b <SideAST>classSide: cb <SideAST> = (  self name:n; superclassName: s; instanceSide: b; classSide: cb)'visiting'apply: aTool = (    ^aTool classNode: self.  )'testing'isClassNode = (^true))class SideAST = AST ("An AST for one side of a class"| vars <Collection[Symbol]> categories <Collection[String]> classComment <String> |)('accessing'nestedClasses ^ <Collection[ClassDeclarationAST]> = (	"Answer the nested classes for this AST.  This default answers an	 empty set since it serves for languages without nested classes."	^{})varNames ^ <Collection[Symbol]> = (	^vars collect: [:var | var name])'testing'isSideNode = (^true)'initialize'vars: vs <Collection[Symbol]> cats: cs <Collection[String]> = (  self vars: vs; categories: cs)'visiting'apply: aTool = (  ^aTool sideNode: self.))class ReturnStatAST = AST (| expr <ExpressionAST> |)('visiting'apply: aTool = (    ^aTool returnStatNode: self.  )'testing'isReturnStatNode = (^true))class SetterSendAST to: r <ExpressionAST> send: m <MessageAST> start: s <integer> end: e <Integer>  = SendAST send: m (|recv  <ExpressionAST> ::= r.|  assert:[r isExpressionNode]   message: 'Receiver of setter send should be an expression' .  start: s.  end: e.  "assert:[m isMessageNode]   message: 'Message of setter send should a MessageAST'.  msg: m.")('as yet unclassified'apply: aTool = (  ^aTool setterSendNode: self.)isSetterSendNode = (^true))class CategoryAST = AST (| name <String> methods <List[MethodAST]> |)('as yet unclassified'apply: aTool <ASTTool> = (	^aTool categoryNode: self))class ImmutableSlotDefAST = SlotDefAST  ()('accessing'isMutable ^ <Boolean> = (  ^false)isMutableSlot ^ <Boolean> = (  ^false))class ASTCopier = ASTTool  ("A visitor that copies an NS2 AST. Subclasses can override selected methods to produce altered copies.")('as yet unclassified'categoryNode: node = (	^ CategoryAST new		name: node name;		methods: (node methods collect: [ :m | m apply: self ]).)classHeaderNode: node = (	^ ClassHeaderAST new		name: node name;		constructor: (node constructor apply: self);		superclassName: node superclassName;		superConstructorCall: (node superConstructorCall apply: self);		slots: (node slots collect: [ :slt | slt apply: self ]);		isSeq: node isSeq;		classComment: node classComment;		category: node category;		initExprs: (node initExprs collect: [ :ie | ie apply: self ]))genericInvocationNode: aNode = ( ^GenericInvocationAST new generic: (aNode generic apply: self);                                               arguments: (aNode arguments collect:[:a | a apply: self]);                                               start: aNode start; end: aNode end;                                               concreteStart: aNode concreteStart; 								concreteEnd: aNode concreteEnd)setterSendNode: aNode <SetterSendAST> ^ <SetterSendAST>= ( ^(SetterSendAST to: (aNode recv apply: self) send: (aNode msg apply: self)	start: aNode start end: aNode end)	concreteStart: aNode concreteStart; concreteEnd: aNode concreteEnd)'node traversal'arrayNode: aNode = (  ^ArrayAST new elements: (aNode elements collect:[:e | e  apply: self]); 	start: aNode start; end: aNode end; 	concreteStart: aNode concreteStart; concreteEnd: aNode concreteEnd)assignmentNode: aNode  <AssignmentAST> ^ <AssignmentNode> = (  ^AssignmentAST new to: (aNode var apply: self) send: (aNode expr apply: self); 	start: aNode start; end: aNode end; 	concreteStart: aNode concreteStart; concreteEnd: aNode concreteEnd)binaryTypeOpNode: aNode = ( ^BinaryTypeOpAST new lOperand: (aNode lOperand apply: self);                                         operator: aNode operator;                                         rOperand: (aNode rOperand apply: self);                                         start: aNode start; end: aNode end; 							concreteStart: aNode concreteStart; 							concreteEnd: aNode concreteEnd)blockNode: aNode <BlockAST> ^ <BlockAST> = (  ^BlockAST new body: (aNode body apply: self);  	start: aNode start; end: aNode end; 	concreteStart: aNode concreteStart; concreteEnd: aNode concreteEnd)cascadedSendNode: aNode <CascadedSendAST> ^  <CascadedSendAST> = ( ^CascadedSendAST new to: (aNode prevSend apply: self) cascade: (aNode msg apply: self);                                     start: aNode start; end: aNode end; 						concreteStart: aNode concreteStart; 						concreteEnd: aNode concreteEnd)charNode: aNode <CharAST> = (^self literalNode: aNode)classNode: aNode = (  ^ClassDeclarationAST new hdr: (aNode hdr apply: self);                               instanceSide: (aNode instanceSide apply: self);                               classSide: (aNode classSide apply: self);                               start: aNode start; end: aNode end; 					concreteStart: aNode concreteStart; 					concreteEnd: aNode concreteEnd)codeBodyNode: aNode = (  ^CodeBodyAST new parameters: (aNode parameters collect:[:p | p apply: self])                                temporaries: (aNode temporaries collect:[:t | t apply: self])                                statements:(aNode statements collect:[:s | s apply: self]);					  isSeq: aNode isSeq;                                start: aNode start; end: aNode end; 					concreteStart: aNode concreteStart; 					concreteEnd: aNode concreteEnd)messageNode: aNode  <MessageAST> ^  <MessageAST> = ( ^MessageAST new send: aNode sel with: (aNode args collect:[:a | a apply: self]);                              start: aNode start; end: aNode end; 					concreteStart: aNode concreteStart; 					concreteEnd: aNode concreteEnd)messagePatternNode: aNode  <MessagePatternAST> ^ <MessagePatternAST> = (  ^MessagePatternAST new selector: aNode selector                                          parameters: (aNode parameters collect:[:p | p apply: self])                                          returnType: (aNode returnType isNil ifTrue:[nil] ifFalse:[aNode returnType apply: self])                                          typePattern: (aNode typePattern isNil ifTrue:[nil] ifFalse:[aNode typePattern apply: self]);                                          start: aNode start; end: aNode end;                                          concreteStart: aNode concreteStart; 							concreteEnd: aNode concreteEnd)methodNode: aNode  <MethodAST> = (  ^MethodAST new pattern: (aNode pattern apply: self)                             body: (aNode body apply: self)                             visibility: aNode visibility;                             start: aNode start; end: aNode end; 					concreteStart: aNode concreteStart; 					concreteEnd: aNode concreteEnd)mixinApplication: node <MixinApplicationAST> = (	^MixinApplicationAST new		mixinExpr: (node mixinExpr apply: self);		superclassExpr: (node superclassExpr apply: self);		start: node start;		end: node end; 		concreteStart: node concreteStart; concreteEnd: node concreteEnd)normalSendNode: aNode <NormalSendAST> ^ <NormalSendAST>= ( ^NormalSendAST new to: (aNode recv apply: self) send: (aNode msg apply: self); 	start: aNode start; end: aNode end; 	concreteStart: aNode concreteStart; concreteEnd: aNode concreteEnd)numberNode: aNode = (  ^self literalNode: aNode)returnStatNode: aNode <ReturnStatAST> ^ <ReturnStatAST> = ( ^ReturnStatAST new expr: (aNode expr apply: self); 	start: aNode start; end: aNode end; 	concreteStart: aNode concreteStart; concreteEnd: aNode concreteEnd)sideNode: aNode <SideAST> ^ <SideAST> = (  ^ NSSideAST new 		vars: (aNode vars collect:[:v | v apply: self])            cats:  (aNode categories collect:[: c | c apply: self]);		nestedClasses: (aNode nestedClasses collect: [ :nc | nc apply: self ]);            start: aNode start; end: aNode end; 				concreteStart: aNode concreteStart; 				concreteEnd: aNode concreteEnd)slotDefNode: aNode = (	| slotDefClass |	slotDefClass:: aNode isMutable 						ifTrue: [ MutableSlotDefAST ] 						ifFalse: [ ImmutableSlotDefAST ].	^ slotDefClass new slotDecl: (aNode slotDecl apply: self);                            	initializer: (aNode initializer apply: self);                            	start: aNode start; end: aNode end; 					concreteStart: aNode concreteStart; 					concreteEnd: aNode concreteEnd)stringNode: aNode <StringAST> ^ <StringAST> = (  ^self literalNode: aNode)symbolNode: aNode = (   ^self literalNode: aNode)tupleNode: aNode <TupleAST> ^  <TupleAST> = (  ^TupleAST new elements: (aNode elements collect:[:e | e apply: self]); 		start: aNode start; end: aNode end; 		concreteStart: aNode concreteStart; concreteEnd: aNode concreteEnd)typeIdNode: aNode = (^TypeIdAST new name: aNode getName; 	start: aNode start; end: aNode end; 	concreteStart: aNode concreteStart; concreteEnd: aNode concreteEnd)typePatternNode: aNode = (^TypePatternAST new formals: ( aNode formals collect:[:f | f apply: self]); 	start: aNode start; end: aNode end; 	concreteStart: aNode concreteStart; concreteEnd: aNode concreteEnd)unaryTypeOpNode: aNode = ( ^UnaryTypeOpAST new operand: (aNode operand apply: self);                                        operator: aNode operator;                                        start: aNode start; end: aNode end; 							concreteStart: aNode concreteStart; 							concreteEnd: aNode concreteEnd)varDeclNode: aNode<VarDeclAST> ^ <VarDeclAST> = (   ^VarDeclAST name: aNode name type: (aNode type isNil ifTrue:[nil] ifFalse:[aNode type apply: self]))variableNode: aNode <VariableAST> ^ <VariableAST> = (  ^VariableAST new name: aNode name; start: aNode start; end: aNode end; 	concreteStart: aNode concreteStart; concreteEnd: aNode concreteEnd		              )'private'literalNode: aNode = (^aNode class new val: aNode val; start: aNode start; end: aNode end; 	concreteStart: aNode concreteStart; concreteEnd: aNode concreteEnd))class ASTTool = ()('as yet unclassified'setterSendNode: aNode <SetterSendAST> = (	self subclassResponsibility)'node traversal'blockNode: aNode <BlockAST> = (self subclassResponsibility)cascadedSendNode: aNode <CascadedSendAST> = (self subclassResponsibility)charNode: aNode <CharAST> = (self subclassResponsibility)classNode: aNode <ClassAST> = (self subclassResponsibility)codeBodyNode: aNode <CodeBodyAST> = (self subclassResponsibility)messageNode: aNode <MessageAST> = (self subclassResponsibility)messagePatternNode: aNode <MessagePatternAST> = (self subclassResponsibility)methodNode: aNode <MethodAST> = (self subclassResponsibility)mixinApplication: node <MixinApplicationAST> = (	self subclassResponsibility)normalSendNode: aNode <NormalSendAST> = (self subclassResponsibility)numberNode: aNode <NumberAST> = (self subclassResponsibility)returnStatNode: aNode <ReturnStatAST> = (self subclassResponsibility)sideNode: aNode <SideAST> = (self subclassResponsibility)stringNode: aNode <StringAST> = (self subclassResponsibility)symbolNode: aNode <SymbolAST> = (self subclassResponsibility)tupleNode: aNode <TupleAST> = (self subclassResponsibility)varDeclNode: aNode <VarDeclAST> = (self subclassResponsibility)variableNode: aNode <VariableAST> = ("can only be a pseudo variable : self or _here"self subclassResponsibility))class NumberAST = LiteralAST ()('visiting'apply: aTool = (    ^ aTool numberNode: self)'testing'isNumberNode = (^true))class TypeIdAST = AST (| name <Symbol> |)('as yet unclassified'isTypeNode = (	^ true)'visiting'apply: visitor = (^visitor typeIdNode: self)'accessing'getName ^ <Symbol> = (	^ name  ))class CharAST = LiteralAST ()('visiting'apply: aTool = (     ^ aTool charNode: self  )'testing'isCharNode = (^true))class GenericInvocationAST = AST (| generic <TypeIdAST> arguments <List[TypeAST]> | )('as yet unclassified'apply: aTool  = (	^aTool genericInvocationNode: self)isTypeNode = (	^ true))class TupleAST = ArrayAST ()('testing'isArrayNode = (^false)isTupleNode = ( ^ true)'visiting'apply: aTool = (^aTool tupleNode: self))class VarDeclAST name: aName type: aType = AST (| name  <Symbol> = aName.  type <TypeAST> = aType. |)('as yet unclassified'isTemporaryAST ^ <Boolean> = (	^false)'visiting'apply: aTool = (    ^aTool varDeclNode: self  )'testing'isVarDeclNode = (^true)'source positioning'concreteEnd ^ <Integer> = (  self type isNil ifFalse:[^self type concreteEnd].  ^super concreteEnd.))class ArrayAST = AST (| elements <List[ExpressionAST]> |)('testing'isArrayNode = (^true)isExpressionNode = (^true)'visiting'apply: aTool = (^ aTool arrayNode: self))class VariablePatternAST = PatternAST (|	variableName <Symbol>|)('as yet unclassified'apply: aTool = (	^ aTool variablePatternNode: self.)isVariablePatternNode = (	^ true))class MutableSlotDefAST = SlotDefAST  ()('accessing'isMutable ^ <Boolean> = (^true)isMutableSlot ^ <Boolean> = (^true))class LiteralAST = AST (| val <Object> |)('as yet unclassified'isLeaf ^ <boolean> = (	^true)'testing'isExpressionNode = (^true)isLiteralNode = (^true))class ASTTraverser = ASTTool (""||)('as yet unclassified'blockNode: node <BlockAST> = (		node body apply: self)cascadedSendNode: node <CascadedSendAST> = (	node prevSend apply: self.	node msg apply: self.)charNode: node <CharAST> = (	"Leaf")keywordPatternNode: aNode <KeywordPatternAST> = (	#BOGUS yourself.	"Leaf?")literalPatternNode: node <LiteralPatternAST> = (	node literal apply: self)messageNode: node <MessageAST> = (		node args do: [:each | each apply: self].)mixinClassNode: node <MixinClassNode> = (	"Leaf?")normalSendNode: node <NormalSendAST> = (	node recv apply: self.	node msg apply: self.)numberNode: node <NumberAST> = (	"Leaf")returnStatNode: node <ReturnStatAST> = (	node expr apply: self.)setterSendNode: node <SetterSendAST> = (	node recv apply: self.	node msg apply: self.)stringNode: node <StringAST> = (	"Leaf")symbolNode: node <SymbolAST> = (	"Leaf")tupleNode: node <TupleAST> = (	node elements do: [:each | each apply: self])variablePatternNode: node <VariablePatternAST> = (	#BOGUS yourself.	"Leaf?")wildcardPatternNode: aNode <WildcardPatternAST> = (	"Leaf"))class ClassHeaderAST = AST (| name <Symbol>constructor <MessagePatternAST>superclassName <Symbol>superConstructorCall <MessageAST>slots <List[SlotDefAST]>isSeq <Boolean>classComment <String>category <CategoryAST>initExprs <List[ExpressionAST]> |)('visiting'apply: visitor = (^visitor classHeaderNode: self)'testing'headerDeclarationEndsWithClosingParenthesis = (^true))class MethodAST = AST (| pattern <MessagePatternAST> body <CodeBodyAST> visibility <Symbol> |)('accessing'selector ^ <Symbol> = ("Answer the value of selector"^ self pattern selector   )'visiting'apply: aTool = (    ^aTool methodNode: self.  )'initialization'pattern: p <MessagePatternAST> body: b <CodeBodyAST> visibility: v <Symbol> = (  self assert:[p isMessagePatternNode].  self assert:[b isCodeBodyNode].  self pattern: p; body: b;   visibility: v)'testing'isMethodNode = (^true))class StringAST = LiteralAST ()('testing'isStringNode = (^true)'visiting'apply: aTool = (^aTool stringNode: self))class UnaryTypeOpAST = AST (| operand <TypeAST> operator <Symbol>  |)('as yet unclassified'apply: aTool  = (	^aTool unaryTypeOpNode: self))class VariableAST = AST (| name <Symbol>  |)('testing'isExpressionNode = (^true)isVariableNode = (^true)'visiting'apply: aTool = (    ^aTool variableNode: self.  ))class ClassDeclarationAST = AST  (| hdr <ClassHeaderAST> instanceSide <SideAST> classSide <SideAST> |)('as yet unclassified'apply: aTool  <ASTTool >  = (	^aTool classNode: self)isClassDeclarationNode = (	^ true.)'header emulation'category ^ <CategoryAST> = (^hdr category)classComment ^ <String> = (^hdr classComment)name ^ <Symbol> = (^hdr name)superclassName ^ <Symbol> = (^hdr superclassName))class BinaryTypeOpAST = AST (| lOperand <TypeAST> rOperand <TypeAST> operator <Symbol> |)('as yet unclassified'apply: aTool <ASTVisitor>  = (	^aTool binaryTypeOpNode: self))class MixinApplicationAST = AST  (| mixinExpr <NormalSendAST> superclassExpr <NormalSendAST> |)('visiting'apply: visitor = (	^visitor mixinApplication: self  )'testing'isExpressionNode = (^true)))