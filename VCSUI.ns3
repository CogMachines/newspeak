Newspeak3

'StructuredVCS'



class VCSUI usingPlatform: p vcs: vcs ide: ide = NewspeakObject  ("The actual source control application"|

FileDirectory = p FileDirectory.
SmalltalkImage = p SmalltalkImage.

Set = p Set.
OrderedCollection = p OrderedCollection.
Color = p brazil Color.
Gradient = p brazil plumbing Gradient.
hopscotch = p hopscotch.
Subject = hopscotch core Subject.
Presenter = hopscotch core Presenter.
RowComposer = hopscotch composers RowComposer.
ColumnComposer = hopscotch composers ColumnComposer.
BlankFragment = hopscotch fragments BlankFragment.
TextEditorFragment = hopscotch fragments TextEditorFragment.
SeparatorItem = hopscotch SeparatorItem.
Menu = hopscotch Menu.
MenuItem = hopscotch MenuItem.
EditableLinePresenter = hopscotch fragments EditableLinePresenter.
ProgrammingPresenter = ide tools ProgrammingPresenter. 
HopscotchImages = p Hopscotch HopscotchImages.

vcs = vcs.
logger = Delay computation: [vcs core logger].
sourceMirrors = vcs sourceMirrors.
WordMerger = vcs diffing WordMerger.
ClassSourceMirror = vcs sourceMirrors ClassSourceMirror.





backgroundColor = Color white.
frameColor ::= Color gray: 0.5.

presenters = Presenters new.

SourceControlPresenter = presenters SourceControlPresenter.
LocalRepositoryPresenter = presenters LocalRepositoryPresenter.
RemoteRepositoryPresenter = presenters RemoteRepositoryPresenter.

LocalHistorianPresenter = presenters LocalHistorianPresenter.
RemoteHistorianPresenter = presenters RemoteHistorianPresenter.

IncomingOutgoingPresenter = presenters IncomingOutgoingPresenter.

HistorianRelationPresenter = presenters HistorianRelationPresenter.

ImageBasedChangePresenter = presenters ImageBasedChangePresenter.
MergeHistorianPresenter = presenters MergeHistorianPresenter.

LogPresenter = presenters LogPresenter.
VersionPresenter = presenters VersionPresenter.

mainSubjectLazy
|)

(



class MainSubject onModel: m = Subject onModel: m (
""
|
|
)

('as yet unclassified'

createPresenter = (	^MainPresenter onSubject: self)



title = (	^'VCS')



)



class SourceControlSubject onModel: model = Subject onModel: model (|
title = 'New Source Control'.
	mergingUI = MergingUI new.
	
	
|)

(



class LocalRepositorySubject onModel: model = Subject onModel: model (|

|model refresh)

(



class MergeHistoriansSubject onModel: model = Subject onModel: model (|
cachedMergeSubjects

version = newVersion.
|)

('as yet unclassified'

createPresenter = (	^ MergeHistorianPresenter onSubject: self)



destinationHistorian = (	^ model second)



mergeDestinationName = (	^ destinationHistorian name)



mergeIfFail: failBlock = (	version		mirrors: (mergingUI presentMirrorsOf: mergeSubjects ifFail: failBlock);		message: 'Merged from ', sourceHistorian name.	destinationHistorian commit: version.	"While we usually do not load the version created by a commit (as not all changes may have been committed), we do so in this case to bring external changes into the image"	loadIfImageHistorian: destinationHistorian)



mergeSourceName = (	^ sourceHistorian name)



mergeSubjects = (	cachedMergeSubjects = nil ifTrue: [ | diffs |		diffs:: destinationHistorian version diffsFrom: sourceHistorian version.		cachedMergeSubjects:: diffs collect: [:each | mergeSubjectOn: each]].	^ cachedMergeSubjects)



newVersion = (	| v |	v:: repository createNewVersion.	v parents: {sourceHistorian version. destinationHistorian version}.	^ v)



sourceHistorian = (	^ model first)



) : (

'as yet unclassified'

merging: sourceHistorian into: destinationHistorian = (	^ MergeHistoriansSubject		onModel: {sourceHistorian. destinationHistorian})



)



class LogSubject onModel: model = Subject onModel: model (|
|)

('as yet unclassified'

createPresenter = (	^ LogPresenter onSubject: self)



versions = (	^ model logStream contents collect: [:each |		VersionSubject onModel: each])



)



class RemoteHistorianSubject onModel: model = HistorianSubject onModel: model (|
|)

('as yet unclassified'

createPresenter = (	^ RemoteHistorianPresenter onSubject: self)



isTracked = (	^ model isTracked)



trackAs: name = (	model trackAs: name)



)



class HistorianSubject onModel: model = Subject onModel: model (|
|)

('as yet unclassified'

name = (	^ model name)



)



class RemoteRepositorySubject onModel: model = Subject onModel: model (|
|)

('as yet unclassified'

createPresenter = (	^ RemoteRepositoryPresenter onSubject: self)



historianSubjects = (	^ model historians collect: [:each |		RemoteHistorianSubject onModel: each])



name = (	^ model name)



)



class ImageBasedChangeSubject onModel: model = Subject onModel: model (|
	cachedMergeSubjects
	cachedVersion
	newlyAddedMirrors = Set new.
|)

('as yet unclassified'

addMirror: mirror = (	newlyAddedMirrors add: mirror.	clearCaches)



buildVersion = (	| v 	nilsAndMirrors |	v:: historian repository createNewVersion.		"Determines the classes in the image that correspond to the classes in the historian. I'm not sure how this can be extended to properly support renames, without having to check all classes in the image for possible correspondence. We could try to use renaming information provided by the external system."	nilsAndMirrors:: historian version mirrors collect: [:each |		logger			log: 'Loading mirror corresponding to ', each name			around: [				sourceMirrors					mirrorForClassInImageCorrespondingTo: each					ifPresent: [:it | it]					ifAbsent: [nil]]].	v mirrors: newlyAddedMirrors, (nilsAndMirrors reject: [:each | nil = each]).	v parents: {historian version}.	^ v)



changedDiffSubjects = (	^ mergeSubjects reject: [:each | each mergeModel isEquals])



clearCaches = (	cachedVersion:: nil.	cachedMergeSubjects:: nil.)



commit: message = (	version		mirrors: (mergingUI presentMirrorsOf: mergeSubjects ifFail: [logger error: 'unexpected']);		message: message.	historian commit: version.)



createPresenter = (	^ ImageBasedChangePresenter onSubject: self)



hasChanges = (	^ version diffsFromFirstParent anySatisfy: [:each |		each isEquals not])



historian = (	^ model)



historianName = (	^ historian name)



mergeSubjects= (	nil = cachedMergeSubjects ifTrue: [		cachedMergeSubjects:: version diffsFromFirstParent collect: [:each |			diffSubjectOn: each]].	^ cachedMergeSubjects)



revertImage = (	historian loadIntoImage)



unversionedImageMirrors = (	^ (sourceMirrors imageMirrorsNotCorrespondingTo: version mirrors, newlyAddedMirrors) 		sort: [:a :b | a name < b name])



version = (	nil = cachedVersion ifTrue: [		cachedVersion:: buildVersion].	^ cachedVersion)



)



class LocalHistorianSubject onModel: model = HistorianSubject onModel: model (|

	public trackedHistorianAccessor = TrackedHistorianAccessor new.
|)

(



class IncomingOutgoingSubject onModel: otherHistorian = Subject onModel: otherHistorian (|

|)

('as yet unclassified'

createPresenter = (	^ IncomingOutgoingPresenter onSubject: self)



incomingVersionSubjects = (	| versions |	versions:: historian versionsIncomingFrom: otherHistorian.	^ versions collect: [:each | VersionSubject onModel: each])



otherHistorian = (	^ model)



otherHistorianName = (	^ otherHistorian name)



outgoingVersionSubjects = (	| versions |	versions:: otherHistorian versionsIncomingFrom: historian.	^ versions collect: [:each | VersionSubject onModel: each])



)



class TrackedHistorianAccessor = (
"Accessing a tracked historian can be slow. Funnel all access to it through this accessor to make it possibly slow commands explicit."|
	private cachedTrackingState
	private cachedTrackedHistorian
|)

('as yet unclassified'

computeTrackedHistorian = (	cachedTrackedHistorian:: historian		trackedHistorianifPresent: [:tr |			cachedTrackingState:: #tracked.			tr]		ifAbsent: [cachedTrackingState:: #untracked.]		ifError: [cachedTrackingState:: #error])



errorAccessingTrackingHistorian = (	^ trackingState = #error)



isTracking = (	^ trackingState = #tracked)



trackedHistorian = (	nil = cachedTrackedHistorian ifTrue: [computeTrackedHistorian].	^ cachedTrackedHistorian)



trackingState = (	nil = cachedTrackingState ifTrue: [computeTrackedHistorian].	^ cachedTrackingState)



)



class HistorianRelationSubject onModel: oh = Subject onModel: oh (
"Allows interacting with other historians"|

|)

('as yet unclassified'

canForwardOtherHistorian = (	^ otherHistorian canForwardTo: historian)



canForwardToOtherHistorian = (	^ historian canForwardTo: otherHistorian)



canMerge = (	^ historian canMergeWith: otherHistorian)



createPresenter = (	^ HistorianRelationPresenter onSubject: self)



forwardOtherHistorian = (	otherHistorian setTo: historian version ifFail: [logger error: 'Could not forward historian'].	loadIfImageHistorian: otherHistorian)



forwardToOtherHistorian = (	historian setTo: otherHistorian version ifFail: [logger error: 'Could not forward historian'].	loadIfImageHistorian: historian)



historianIsImageHistorian = (	^ historian = imageHistorian)



incomingVersionSubjects = (	| versions |	versions:: historian versionsIncomingFrom: otherHistorian.	^ versions collect: [:each | VersionSubject onModel: each])



mergeFromOtherHistorianSubject = (	^ MergeHistoriansSubject merging: otherHistorian into: historian)



mergeIntoOtherHistorianSubject = (	^ MergeHistoriansSubject merging: historian into: otherHistorian)



otherHistorian = (	^ model)



otherHistorianAndRepositoryName = (	^ otherHistorian repository = repository		ifTrue: ['local ', otherHistorian name]		ifFalse: [otherHistorian name, ' on ', otherHistorian repository name])



otherHistorianIsImageHistorian = (	^ otherHistorian = imageHistorian)



outgoingVersionSubjects = (	| versions |	versions:: otherHistorian versionsIncomingFrom: historian.	^ versions collect: [:each | VersionSubject onModel: each])



runActionOn: receiver = (	canMerge ifTrue: [		^ receiver merge].	canForwardToOtherHistorian ifTrue: [		^ receiver forwardToOther].	canForwardOtherHistorian ifTrue: [		^ receiver forwardOther].	^ receiver inSynch)



)'as yet unclassified'

cloneAs: cloneName ifFail: failBlock = (	^ model cloneAs: cloneName ifFail: failBlock)



createPresenter = (	^ LocalHistorianPresenter onSubject: self)



deleteHistorianIfFail: failBlock = (	model deleteIfFail: failBlock)



historian = (	^ model)



historianRelationSubjects = (	^ Array streamContents: [:stream |		trackedHistorianAccessor isTracking ifTrue: [stream nextPut: (HistorianRelationSubject onModel: trackedHistorianAccessor trackedHistorian)].		imageHistorian = historian ifFalse: [			stream nextPut: (HistorianRelationSubject onModel: imageHistorian)]])



isImageHistorian = (	^ model = imageHistorian)



loadIntoImage = (	model loadIntoImage)



shareNamesAndActionOf: remoteRepository = (	"We could put this into shareNamesAndActions if we had closures"	^ {remoteRepository name.		[model shareTo: remoteRepository]})



shareNamesAndActions = (	^ remoteRepositories collect: [:each |		shareNamesAndActionOf: each])



)



class VersionSubject onModel: model = Subject onModel: model (|
|)

('as yet unclassified'

author = (	^ model author)



createPresenter = (	^ VersionPresenter onSubject: self)



internalId = (	^ model internalId)



isParentOfImage = (	^ model isParentOfImage)



loadIntoImage = (	model loadIntoImage)



message = (	^ model message)



unequaldiffsFromPrevious = (	| diffsFromPrevious |	diffsFromPrevious:: model diffsFromFirstParent collect: [:each | diffSubjectOn: each].	^ diffsFromPrevious reject: [:each | each isEquals])



)'as yet unclassified'

createPresenter = (	^ LocalRepositoryPresenter onSubject: self)



imageHistorian = (	^ model imageHistorian)



loadIfImageHistorian: historian = (	"Before this, we had a historian check whether it is the image historian on setTo:ifFail:. It turns out, that there are cases where it's desirable to change a historian's version without changing the code in the image, for example when doing partial commits.	The new strategy is to have callers of setTo: distinguish the two cases. Ideally we wouldn't distinguish 'commit' and 'setTo'. Then we could offer a 'updatingImageSet:to:ifFail:"	imageHistorian = historian ifTrue: [		imageHistorian loadIntoImage])



localHistorianSubjects = (	^ model historians collect: [:each | LocalHistorianSubject onModel: each].)



logSubject = (	^ LogSubject onModel: repository)



modifiedInImageSubject = (	^ ImageBasedChangeSubject		onModel: model imageHistorian.)



remoteRepositories = (	^ model remoteRepositories)



remoteRepositorySubjects = (	^ remoteRepositories collect: [:each | RemoteRepositorySubject onModel: each].)



repository = (	^ model)



repositoryName = (	^ model repositoryId)



repositoryType = (	^ model repositoryType)



)'as yet unclassified'

= other = (	^self class = other class and: [self model = other model])



createPresenter = (	^ SourceControlPresenter onSubject: self)



diffSubjectOn: diff = (	"TODO: dispatch on the kind of diff"	^ mergingUI ClassMirrorMergeSubject diffSubjectOn: diff)



hash = (	^model hash)



mergeSubjectOn: diff = (	"TODO: dispatch on the kind of diff"	^ mergingUI ClassMirrorMergeSubject mergeSubjectOn: diff)



modifiedLocalRepositorySubjects = (	^ model collect: [:each | LocalRepositorySubject onModel: each])



shutdown = (	"If our model is simply some repositories we don't really own VCS and thus shouldn't be allowed to shut it down, should we?"	[vcs shutdown] ifError:[])



sourceControlSubject = (	^ self)



)



class MergingUI = (
"A Hopscotch-based UI for displaying and merging 2 or 3 Newspeak source mirrors.

MergeSubjects have access to different versions of the object to be presented. If set to #diff mode, their presenters only show differences between the objects. If set to #merge mode, their presenters also provide tools to choose how to merge.

Several specializations of MergeSubject exist that allow diffing/merging different kinds of objects. A MirrorMergeSubject merges 2 or 3 Newspeak mirrors, represented as a TreeDiff. Specializations exists for different kinds of mirrors. A TextMergeSubject allows diffing/merging plaing strings.

The UIs for diffing and merging are very similar, with the merging UI adding some features to the diffing UI. One could think of implementing the two functionalities as two sets of classes (e.g. ClassMirrorDiffSubject/Presenter and ClassMirrorMergeSubject/Presenter). It seems to be easier with only one set of classes, though. Presenter methods usually have to add new UI elements for the merging case. Currently they can simply do so by adding using ifMerging:. Using one set of classes, the mode becomes part of the model."|
|)

(



class MethodMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|


|)

('as yet unclassified'

definition = (	"Don't show the category unless it was actually changed"	^ subject category isChange		ifFalse: [subject mergedSource presenter]		ifTrue: [column: {			subject category presenter.			subject mergedSource presenter}])



)



class TextMergeSubject onModel: model = MergeSubject onModel: model (|
	title
	manualMergeResult = merger automaticMergedOut.
	verificationBlock
|)

('as yet unclassified'

createPresenter = (	^ TextMergePresenter onSubject: self)



defaultResult = (	merger anyChanged ifFalse: [		^ #commonAncestorSource].	merger rightChanged ifTrue: [		^ #ourSource].	merger leftChanged ifTrue: [		^ #theirSource].	^ #manualMerge)



finalMerge = (	currentSelection =  #manualMerge ifTrue: [		storeManualMerge: manualMergeResult ifFail: [halt].		^ manualMergeResult].	currentSelection =  #ourSource ifTrue: [		^ merger rightOut].	currentSelection =  #theirSource ifTrue: [		^ merger leftOut].	currentSelection =  #commonAncestorSource ifTrue: [		^ merger ancestorOut].	error: 'unknown side')



isAddition = (	^ merger isAddition)



isConflict = (	^ merger bothChanged)



isDeletion = (	^ merger isDeletion)



isEquals = (	^ merger anyChanged not)



merger = (	^ mergeModel)



storeManualMerge: mergeResult ifFail: failBlock = (	verificationBlock = nil ifFalse: [		verificationBlock value: mergeResult value: failBlock].	manualMergeResult:: mergeResult.)



)



class MethodMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (|
mergedSource = textMergeSubjectFor: #source title: title verificationBlock: [:source :failBlock | createMirrorFrom: source ifFail: failBlock].
category = textMergeSubjectFor: #category title: 'Category of ', title.
cachedMirror

|)

('as yet unclassified'

createMirrorFrom: source ifFail: failBlock = (	| newMirror |		newMirror::  sourceMirrors		methodMirrorForStream: source asString readStream		ifError: failBlock.	newMirror category: category finalMerge asString.	^ newMirror)



createPresenter = (	^ MethodMirrorMergePresenter onSubject: self)



mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (	removedAfterMerge ifTrue: [^ removedBlock value].	cachedMirror ifNil: [		cachedMirror:: createMirrorFrom: mergedSource finalMerge ifFail: failBlock].	presentBlock value: cachedMirror)



removedAfterMerge = (	^ mergedSource finalMerge isEmpty)



textMergeSubjects = (	^ {mergedSource. category})



title = (	^ super title)



)



class ClassMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (""|
category = textMergeSubjectFor: #category title: 'Category'.
accessModifier = textMergeSubjectFor: #accessModifier title: 'Access Modifier'.
name = textMergeSubjectFor: #name title: 'Name'.
constructor = textMergeSubjectFor: #constructor title: 'Constructor'.
superclassClause = textMergeSubjectFor: #superclassClause title: 'Superclass Clause'.
classComment = textMergeSubjectFor: #classComment title: 'Comment'.
slotsSource = textMergeSubjectFor: #slotsSource title: 'Slots'.
initExpressions = textMergeSubjectFor: #initExpressions title: 'Init Expressions'.
classes = create: self class for: #classes.
instanceMethods = create: MethodMirrorMergeSubject for: #instanceMethods.
classMethods = create: MethodMirrorMergeSubject for: #classMethods.
|)

('as yet unclassified'

canLoadTheirs = (	^ treeDiff anyNode isToplevel)



create: klass for: nodeType = (	^ Delay computation: [		| treeDiffs |		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].		treeDiffs collect: [:each | klass onModel: {each. mode. self}]])



createPresenter = (	^ ClassMirrorMergePresenter onSubject: self)



loadTheirs = (	treeDiff left installAsToplevelClass.)



manualMergeMirrorIfFail: failBlock = (	^ ClassSourceMirror new		category: category finalMerge asString;		accessModifier: accessModifier finalMerge asString;		name: name finalMerge asString;		constructor: constructor finalMerge asString;		superclassClause: superclassClause finalMerge asString;		classComment: classComment finalMerge asString;		slotsSource: slotsSource finalMerge asString;		initExpressions: initExpressions finalMerge asString;		classes: (presentMirrorsOf: classes ifFail: failBlock);		instanceMethods: (presentMirrorsOf: instanceMethods ifFail: failBlock);		classMethods: (presentMirrorsOf: classMethods ifFail: failBlock);		yourself)



mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (	removedAfterMerge ifTrue: [^ removedBlock value].	currentSelection =  #manualMerge ifTrue: [		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].	currentSelection =  #ourSource ifTrue: [		^ presentBlock value: treeDiff right].	currentSelection =  #theirSource ifTrue: [		^ presentBlock value: treeDiff left].	currentSelection =  #commonAncestorSource ifTrue: [		^ presentBlock value: treeDiff ancestor].	failBlock value: 'Unknown side')



mirrorMergeSubjects = (	^ {classes. instanceMethods. classMethods})



textMergeSubjects = (	^ {category. accessModifier. name. constructor. superclassClause. classComment. slotsSource. initExpressions})



unequalClassMethodSubjects = (	^ classMethods reject: [:each | each treeDiff isEquals])



unequalClassSubjects = (	^ classes reject: [:each | each treeDiff isEquals])



unequalInstanceMethodSubjects = (	^ instanceMethods reject: [:each | each treeDiff isEquals])



) : (

'as yet unclassified'

diffSubjectOn: treeDiff = (	^ onModel: treeDiff withMode: #diff)



mergeSubjectOn: treeDiff = (	^ onModel: treeDiff withMode: #merge)



onModel: treeDiff withMode: mode = (	^(treeDiff anyNode isPackageMirror 		ifTrue: [PackageMirrorMergeSubject]		ifFalse: [ClassMirrorMergeSubject])			onModel: {treeDiff. mode. nil})



)



class MergePresenter onSubject: subject = BasePresenter onSubject: subject (|
|)

('as yet unclassified'

colorIndicatingSelectionStatusForSide: side = (	^ subject currentSelection = side 		ifTrue: [Color black]		ifFalse: [Color gray])



elasticTextDisplay: text = (	^ (textDisplay: text) width: 0 elasticity: 1)



headingDefinition = (	^row: {		headingForSide: #theirSource labeled: 'theirs'.		halfColumnSeparator.		ifConflict: [			headingForSide: #commonAncestorSource labeled: 'common ancestor'].		link: '?' action: [self inspect].		halfColumnSeparator.		headingForSide: #ourSource labeled: 'ours'})



headingForSide: side labeled: sideLabel = (		^ (h4: (row: {		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).		smallBlank.		linkToSelectSide: side})) width:0 elasticity: 1)



headingLabel = (	subject isAddition ifTrue: [^subject title, ' was added'].	subject isDeletion ifTrue: [^subject title, ' was removed'].	^subject title)



ifConflict: block = (	^ subject isConflict		ifTrue: block		ifFalse: [nothing])



ifMerging: block = (	^ subject isMerge		ifTrue: block		ifFalse: [nothing])



linkToSelectSide: side = (	^ side = subject currentSelection		ifTrue: [nothing]		ifFalse: [			link: 'select' action: [				chooseSide: side]])



textDiffPresenterFor: merger = (	merger anyChanged ifFalse: [^ nil].	^ row: {		elasticTextDisplay: merger leftOut.		halfColumnSeparator.		merger bothChanged			ifTrue: [elasticTextDisplay: merger ancestorOut]			ifFalse: [nothing].		halfColumnSeparator.		elasticTextDisplay: merger rightOut}.)



)



class SmalltalkClassMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (""|
category = textMergeSubjectFor: #category title: 'Category'.
name = textMergeSubjectFor: #name title: 'Name'.
superclassName = textMergeSubjectFor: #superclassName title: 'Superclass'.
classComment = textMergeSubjectFor: #classComment title: 'Comment'.

instanceVariables = textMergeSubjectFor: #instanceVariablesString title: 'Slots'.
classInstanceVariables = textMergeSubjectFor: #classInstanceVariablesString title: 'Class Slots'.


instanceMethods = create: MethodMirrorMergeSubject for: #instanceMethods.
classMethods = create: MethodMirrorMergeSubject for: #classMethods.
|)

('as yet unclassified'

canLoadTheirs = (	^true)



create: klass for: nodeType = (	^ Delay computation: [		| treeDiffs |		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].		treeDiffs collect: [:each | klass onModel: {each. mode. self}]])



createPresenter = (	^ SmalltalkClassMirrorMergePresenter onSubject: self)



mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (	removedAfterMerge ifTrue: [^ removedBlock value].	currentSelection =  #manualMerge ifTrue: [		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].	currentSelection =  #ourSource ifTrue: [		^ presentBlock value: treeDiff right].	currentSelection =  #theirSource ifTrue: [		^ presentBlock value: treeDiff left].	currentSelection =  #commonAncestorSource ifTrue: [		^ presentBlock value: treeDiff ancestor].	failBlock value: 'Unknown side')



mirrorMergeSubjects = (	^ {instanceMethods. classMethods})



textMergeSubjects = (	^ {category. name. superclassName. classComment. instanceVariables. classInstanceVariables.})



unequalClassMethodSubjects = (	^ classMethods reject: [:each | each treeDiff isEquals])



unequalInstanceMethodSubjects = (	^ instanceMethods reject: [:each | each treeDiff isEquals])



)



class SmalltalkClassMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|)

('as yet unclassified'

chooseSide: side = (	subject chooseSide: side.	toggle collapse.	updateHolders.)



classHeadingLabeled: labels = (	^ (h3: (row: labels)) width: 0 elasticity: 1)



definition = (	headerHolder:: holder: nil.	updateHolders.	toggle::		heading: [headerHolder]		details: [detailsDefinition]		initiallyExpanded: subject interestingChange .	^(row: {		toggle width: 0 elasticity: 1.		columnSeparator}) color: backgroundColor.)



detailsDefinition = (	| subjects |	^ column: {		subject category presenter.		subject name presenter.		subject superclassName presenter.		subject classComment presenter.		subject instanceVariables presenter.		subject classInstanceVariables presenter.		sortedPresenters: subject unequalInstanceMethodSubjects			labeledIfNotEmpty: 'Instance methods'.		sortedPresenters: subject unequalClassMethodSubjects			labeledIfNotEmpty: 'Class methods'})



headingForSide: side labeled: sideLabel = (		^ classHeadingLabeled: {		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).		label: ' [', sideLabel, ']'.		smallBlank.		linkToSelectSide: side.		filler.		(side = #ourSource)			ifTrue: [revertSourceLink]			ifFalse: [nothing]})



revertSourceLink = (	^ (subject isMerge not and: [subject canLoadTheirs])		ifTrue: [				link: 'revert' action: [					refreshSCAfter: [subject loadTheirs]]]		ifFalse: [nothing])



sortedPresenters: subjects = (	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])		collect: [:each | each presenter]))



sortedPresenters: presenters  labeledIfNotEmpty: label = (	^ presenters isEmpty		ifTrue: [nothing]		ifFalse: [			column: {				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.				sortedPresenters: presenters}]	)



updateHolders = (	headerHolder content: headingDefinition)



)



class ClassMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|)

('as yet unclassified'

chooseSide: side = (	subject chooseSide: side.	toggle collapse.	updateHolders.)



classHeadingLabeled: labels = (	^ (h3: (row: labels)) width: 0 elasticity: 1)



definition = (	headerHolder:: holder: nil.	updateHolders.	toggle::		heading: [headerHolder]		details: [detailsDefinition]		initiallyExpanded: subject interestingChange .	^(row: {		toggle width: 0 elasticity: 1.		columnSeparator}) color: backgroundColor.)



detailsDefinition = (	| subjects |	^ column: {		subject category presenter.		subject accessModifier presenter.		subject name presenter.		subject constructor presenter.		subject superclassClause presenter.		subject classComment presenter.		subject slotsSource presenter.		subject initExpressions presenter.		sortedPresenters: subject unequalClassSubjects.		sortedPresenters: subject unequalInstanceMethodSubjects			labeledIfNotEmpty: 'Instance methods'.		sortedPresenters: subject unequalClassMethodSubjects			labeledIfNotEmpty: 'Class methods'})



headingForSide: side labeled: sideLabel = (		^ classHeadingLabeled: {		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).		label: ' [', sideLabel, ']'.		smallBlank.		linkToSelectSide: side.		filler.		(side = #ourSource)			ifTrue: [revertSourceLink]			ifFalse: [nothing]})



revertSourceLink = (	^ (subject isMerge not and: [subject canLoadTheirs])		ifTrue: [				link: 'revert' action: [					refreshSCAfter: [subject loadTheirs]]]		ifFalse: [nothing])



sortedPresenters: subjects = (	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])		collect: [:each | each presenter]))



sortedPresenters: presenters  labeledIfNotEmpty: label = (	^ presenters isEmpty		ifTrue: [nothing]		ifFalse: [			column: {				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.				sortedPresenters: presenters}]	)



updateHolders = (	headerHolder content: headingDefinition)



)



class PackageMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (""|

name = textMergeSubjectFor: #name title: 'Name'.
classes = create: SmalltalkClassMirrorMergeSubject for: #classes.
extendedClasses = create: ExtendedClassMirrorMergeSubject for: #extendedClasses.

|)

('as yet unclassified'

canLoadTheirs = (	^true)



create: klass for: nodeType = (	^ Delay computation: [		| treeDiffs |		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].		treeDiffs collect: [:each | klass onModel: {each. mode. self}]])



createPresenter = (	^ PackageMirrorMergePresenter onSubject: self)



loadTheirs = (	treeDiff left installAsToplevelClass.)



mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (	removedAfterMerge ifTrue: [^ removedBlock value].	currentSelection =  #manualMerge ifTrue: [		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].	currentSelection =  #ourSource ifTrue: [		^ presentBlock value: treeDiff right].	currentSelection =  #theirSource ifTrue: [		^ presentBlock value: treeDiff left].	currentSelection =  #commonAncestorSource ifTrue: [		^ presentBlock value: treeDiff ancestor].	failBlock value: 'Unknown side')



mirrorMergeSubjects = (	^ {classes. extendedClasses})



textMergeSubjects = (	^ {name})



unequalClassSubjects = (	^ classes reject: [:each | each treeDiff isEquals])



unequalExtendedClassSubjects = (	^ extendedClasses reject: [:each | each treeDiff isEquals])



)



class MergeSubject onModel: model = Subject onModel: model ("A merge subjects hold the state of an tree diff or text being merged or diffed
"|
	currentSelection = defaultResult.
|)

('as yet unclassified'

childChoseSide: side = (	currentSelection = side ifFalse: [		currentSelection: #manualMerge].	nil = parentSubject ifFalse: [		parentSubject childChoseSide: currentSelection])



chooseSide: side = (	currentSelection: side.	childChoseSide: side)



defaultResult = (	subclassResponsibility)



isChange = (	^ (self isAddition or: [self isDeletion or: [self isEquals]]) not)



isMerge = (	mode = #merge ifTrue: [^true].	mode = #diff ifTrue: [^false].	halt.)



mergeModel = (	^ model first)



mode = (	^ model second)



parentSubject = (	^ model third)



)



class TextMergePresenter onSubject: subject = MergePresenter onSubject: subject (|
theToggle
theHolder
|)

('as yet unclassified'

chooseSide: side = (	subject chooseSide: side.	updateHolders.	theToggle collapse)



definition = (	subject isEquals		ifTrue: [^ nothing].	theHolder:: holder: nil. 	updateHolders.	subject isMerge ifTrue: [		"Don't show our changes by default"		subject currentSelection = #ourSource ifTrue: [			theToggle collapse]].	^ theHolder)



details = (	^ column: {		textDiffPresenterFor: subject merger.		ifMerging: [manualMergeEditor]})



manualMergeEditor = (	^		heading: [			row: {				(label: 'Manual merge') color: (colorIndicatingSelectionStatusForSide: #manualMerge).				smallBlank.				linkToSelectSide: #manualMerge}]		details: [mergeEditor]		initiallyExpanded: subject currentSelection = #manualMerge.)



mergeEditor  = (	| editor |	editor:: TextEditorFragment new		text: subject manualMergeResult;		acceptResponse: [ | failed |			failed:: false.			subject				storeManualMerge: editor textBeingAccepted				ifFail: [:msg :pos |					failed:: true.					editor showMessage: msg].			failed ifFalse: [editor defaultAcceptResponse]].	^ editor)



updateHolders = (	theToggle:: heading: [headingDefinition]					detailsExpanded: [details].	theHolder content: (		column: {			row: {				theToggle width: 0 elasticity: 1.				columnSeparator}}))



)



class ExtendedClassMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (""|

name = textMergeSubjectFor: #name title: 'Name'.
instanceMethods = create: MethodMirrorMergeSubject for: #instanceMethods.
classMethods = create: MethodMirrorMergeSubject for: #classMethods.
|)

('as yet unclassified'

canLoadTheirs = (	^false)



create: klass for: nodeType = (	^ Delay computation: [		| treeDiffs |		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].		treeDiffs collect: [:each | klass onModel: {each. mode. self}]])



createPresenter = (	^ ExtendedClassMirrorMergePresenter onSubject: self)



mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (	removedAfterMerge ifTrue: [^ removedBlock value].	currentSelection =  #manualMerge ifTrue: [		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].	currentSelection =  #ourSource ifTrue: [		^ presentBlock value: treeDiff right].	currentSelection =  #theirSource ifTrue: [		^ presentBlock value: treeDiff left].	currentSelection =  #commonAncestorSource ifTrue: [		^ presentBlock value: treeDiff ancestor].	failBlock value: 'Unknown side')



mirrorMergeSubjects = (	^ {instanceMethods. classMethods})



textMergeSubjects = (	^ {name})



title = (	^'*', super title)



unequalClassMethodSubjects = (	^ classMethods reject: [:each | each treeDiff isEquals])



unequalInstanceMethodSubjects = (	^ instanceMethods reject: [:each | each treeDiff isEquals])



)



class ExtendedClassMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|)

('as yet unclassified'

chooseSide: side = (	subject chooseSide: side.	toggle collapse.	updateHolders.)



classHeadingLabeled: labels = (	^ (h3: (row: labels)) width: 0 elasticity: 1)



definition = (	headerHolder:: holder: nil.	updateHolders.	toggle::		heading: [headerHolder]		details: [detailsDefinition]		initiallyExpanded: subject interestingChange .	^(row: {		toggle width: 0 elasticity: 1.		columnSeparator}) color: backgroundColor.)



detailsDefinition = (	| subjects |	^ column: {		subject name presenter.		sortedPresenters: subject unequalInstanceMethodSubjects			labeledIfNotEmpty: 'Instance methods'.		sortedPresenters: subject unequalClassMethodSubjects			labeledIfNotEmpty: 'Class methods'})



headingForSide: side labeled: sideLabel = (		^ classHeadingLabeled: {		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).		label: ' [', sideLabel, ']'.		smallBlank.		linkToSelectSide: side.		filler.		(side = #ourSource)			ifTrue: [revertSourceLink]			ifFalse: [nothing]})



revertSourceLink = (	^ (subject isMerge not and: [subject canLoadTheirs])		ifTrue: [				link: 'revert' action: [					refreshSCAfter: [subject loadTheirs]]]		ifFalse: [nothing])



sortedPresenters: subjects = (	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])		collect: [:each | each presenter]))



sortedPresenters: presenters  labeledIfNotEmpty: label = (	^ presenters isEmpty		ifTrue: [nothing]		ifFalse: [			column: {				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.				sortedPresenters: presenters}]	)



updateHolders = (	headerHolder content: headingDefinition)



)



class PackageMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|)

('as yet unclassified'

chooseSide: side = (	subject chooseSide: side.	toggle collapse.	updateHolders.)



classHeadingLabeled: labels = (	^ (h3: (row: labels)) width: 0 elasticity: 1)



definition = (	headerHolder:: holder: nil.	updateHolders.	toggle::		heading: [headerHolder]		details: [detailsDefinition]		initiallyExpanded: subject interestingChange .	^(row: {		toggle width: 0 elasticity: 1.		columnSeparator}) color: backgroundColor.)



detailsDefinition = (	| subjects |	^ column: {		subject name presenter.		sortedPresenters: subject unequalClassSubjects.		sortedPresenters: subject unequalExtendedClassSubjects.	})



headingForSide: side labeled: sideLabel = (		^ classHeadingLabeled: {		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).		label: ' [', sideLabel, ']'.		smallBlank.		linkToSelectSide: side.		filler.		(side = #ourSource)			ifTrue: [revertSourceLink]			ifFalse: [nothing]})



revertSourceLink = (	^ (subject isMerge not and: [subject canLoadTheirs])		ifTrue: [				link: 'revert' action: [					refreshSCAfter: [subject loadTheirs]]]		ifFalse: [nothing])



sortedPresenters: subjects = (	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])		collect: [:each | each presenter]))



sortedPresenters: presenters  labeledIfNotEmpty: label = (	^ presenters isEmpty		ifTrue: [nothing]		ifFalse: [			column: {				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.				sortedPresenters: presenters}]	)



updateHolders = (	headerHolder content: headingDefinition)



)



class MirrorMergeSubject onModel: model <TreeDiff> = MergeSubject onModel: model (|

|)

('as yet unclassified'

defaultResult = (	treeDiff changeInfo isEquals ifTrue: [		^ #ourSource].	treeDiff changeInfo isLeft ifTrue: [		^ #theirSource].	treeDiff changeInfo isRight ifTrue: [		^ #ourSource].	^ #manualMerge)



interestingChange = (	"I this a change that should be shown by default?"	^ (isEquals or: [		isAddition or: [			isDeletion or: [				(isMerge and: [treeDiff changeInfo isRight])					or: ["Hide top-level classes in general unless we're merging"						isMerge not and: [treeDiff anyNode isToplevel]]]]]) not)



isAddition = (	^ treeDiff changeInfo isAddition)



isConflict = (	^ treeDiff changeInfo isConflict)



isDeletion = (	^ treeDiff changeInfo isDeletion)



isEquals = (	^ treeDiff isEquals)



mirrorMergeSubjects = (	^ {})



removedAfterMerge = (	currentSelection = #manualMerge ifTrue: [		^ false].	currentSelection = #ourSource ifTrue: [		^ nil = treeDiff right].	currentSelection = #theirSource ifTrue: [		^ nil = treeDiff left].	currentSelection = #commonAncestorSource ifTrue: [		^ nil = treeDiff ancestor].	error: 'unknown selection')



sortKey = (	^ {treeDiff nodeType. treeDiff name})



textMergeSubjectFor: selector = (	^ textMergeSubjectFor: selector title: selector)



textMergeSubjectFor: selector title: title = (	^ textMergeSubjectFor: selector title: title verificationBlock: nil )



textMergeSubjectFor: selector title: title verificationBlock: verificationBlock = (	^ Delay computation: [		| lar wordMerger |		lar:: treeDiff leftAncestorRightCollect: [:each | each perform: selector].		wordMerger:: WordMerger on: lar.		(TextMergeSubject onModel: {wordMerger. mode. self})			title: title;			verificationBlock: verificationBlock;			yourself])



textMergeSubjects = (	^ {})



title = (	^ treeDiff name)



treeDiff = (	^ mergeModel)



)



class MirrorMergePresenter onSubject: subject = MergePresenter onSubject: subject (|
	
|)

()'accessing'

blank: size color: color = (	^(ColumnComposer definitions: {RowComposer definitions: {BlankFragment size: size}}) color: color)



vblank: size color: color = (	^(RowComposer definitions: {ColumnComposer definitions: {BlankFragment size: size}}) color: color)



'private'

presentMirrorsOf: mergeSubjects ifFail: failBlock = (	| survivingElements |	^ Array streamContents: [:stream |		mergeSubjects do: [:each |			each				mirrorIfPresent: [:it | stream nextPut: it]				ifRemoved: []				ifFail: failBlock]])



)



class BasePresenter onSubject: subject = ProgrammingPresenter onSubject: subject (
"Provides UI elements common for source control's presenters"|
|)

('actions'

refreshSCAfter: block = (	sendUp refreshSCAfter: block )



'combinators'

h1: body = (	^ majorHeadingBlock: body)



h2: body = (	^ (padded: body with: {10. 5. 5. 5.})		color: h2Color)



h3: body = (	^ minorHeadingBlock: body)



h4: body = (	^ (padded: body with: {10. 0. 0. 0}) color: minorHeadingColor)



listPresentersOf: subjects inIncrementsOf: limit = (	| versionPresenters |	versionPresenters:: (subjects first: (subjects size min: limit))		collect: [:each | each presenter].	^ column: (		subjects size > limit			ifTrue: [				versionPresenters,				{(remainingDefinitionFor: (subjects allButFirst: limit) limit: limit)}]			ifFalse: [versionPresenters]))



remainingDefinitionFor: subjects limit: limit = (	| restHolder |	restHolder:: holder: (		link: '...'		action: [			restHolder content: (listPresentersOf: subjects inIncrementsOf: limit)]).	^ restHolder)



'accessing'

h2Color = (	^ Gradient 		from: (Color h: 240 s: 0.04 v: 0.88) 		to: (Color h: 240 s: 0.04 v: 0.86))



mediumHeadingColor = (	^ Gradient 		from: (Color h: 240 s: 0.04 v: 0.88) 		to: (Color h: 240 s: 0.04 v: 0.86))



)



class MainPresenter onSubject: s = BasePresenter onSubject: s (
""
|
	hgRepoField = TextEditorFragment new.
|
	hgRepoField acceptResponse: [respondToHgRepo]
)

('as yet unclassified'

definition = (	^column: {		h1: (label: 'VCS Repositories').		mediumBlank.		label: 'List open repositories here'.		mediumBlank.		row: {			label: 'Open Mercurial Repository at '.			TextEditorFragment new				text: 'relative/path';				acceptResponse: [:editor | 					editor defaultAcceptResponse.					openHgRepoAt: editor text asString].		}.		row: {			label: 'Open Git Repository at '.			TextEditorFragment new				text: 'relative/path';				acceptResponse: [:editor | 					editor defaultAcceptResponse.					openGitRepoAt: editor text asString].		}.		row: {			label: 'Open Subversion Repository at '.			TextEditorFragment new				text: 'relative/path';				acceptResponse: [:editor | 					editor defaultAcceptResponse.					openSvnRepoAt: editor text asString].		}.	})



openHgRepoAt: path = (	| repository |"	repository:: vcs hg Backend new LocalRepository onRepositoryId:		((FileDirectory on: SmalltalkImage current imagePath) / path) pathName."	enterSubject: (vcs ui SourceControlSubject onModel: {}).)



)



class Presenters  =  ()

(



class MergeHistorianPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)

('as yet unclassified'

definition = (	| unequalMergeSubjects |	unequalMergeSubjects:: subject mergeSubjects reject: [:each | each isEquals].	^ column: {		h1: (row: {			label: 'Merge ', subject mergeSourceName, ' into ', subject mergeDestinationName.			filler.			link: 'Commit Merge' action: [				refreshSCAfter: [					subject mergeIfFail: [halt]]]}).		column: (unequalMergeSubjects	collect: [:each | each presenter])})



)



class RemoteHistorianPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)

('as yet unclassified'

definition = (	^ h4: (			row: {				smallBlank.				label: subject name.				filler.				row: links}))



links = (	^ {		subject isTracked			ifTrue: [(label: 'is tracked') color: Color gray]			ifFalse: [link: 'track' action: [					refreshSCAfter: [subject trackAs: subject name]]]})



)



class HistorianRelationPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)

('as yet unclassified'

definition = (	^ column: {		h4: (subject runActionOn: self).		IncomingOutgoingPresenter onSubject: subject})



forwardOther = (	^ link: 'Forward ', otherHistorianAndRepositoryName		action: [			refreshSCAfter: [subject forwardOtherHistorian]])



forwardToOther = (	^ link: 'Forward to ', otherHistorianAndRepositoryName		action: [			refreshSCAfter: [subject forwardToOtherHistorian]])



inSynch = (	^ (label: 'In sync with ', otherHistorianAndRepositoryName) color: Color gray)



merge = (	"Allow merging only into image historian"	subject historianIsImageHistorian ifTrue: [		^ link: 'Merge from ', otherHistorianAndRepositoryName		action: [			sendUp repositoryEnterSubject:				subject mergeFromOtherHistorianSubject]].	subject otherHistorianIsImageHistorian ifTrue: [		^ link: 'Merge into ', otherHistorianAndRepositoryName		action: [			sendUp repositoryEnterSubject:				subject mergeIntoOtherHistorianSubject]].	^ (label: 'Out of sync') color: Color gray)



otherHistorianAndRepositoryName = (	^ subject otherHistorianAndRepositoryName)



)



class UnversionedClassesPresenter onSubject: subject <ImageBasedChangeSubject> = BasePresenter onSubject: subject ("Allows adding unversioned classes to the current image based change"|
	private unversionedImageMirrors = subject unversionedImageMirrors.|)

('as yet unclassified'

definition = (	^ unversionedImageMirrors isEmpty		ifTrue: [nothing]		ifFalse: [			heading: header			details: [column: (unversionedImageMirrors collect: [:each | mirrorEntry: each])]])



header = (	^ h3: ( row: {		label: 'Unversioned Classes'.		largeBlank.		link:  'Add All' action: [			unversionedImageMirrors do: [:each | subject addMirror: each actualMirror].			refreshImageBasedChangePresenter].		filler}))



mirrorEntry: mirror = (	^ row: {		addButtonWithAction: [			subject addMirror: mirror actualMirror.			refreshImageBasedChangePresenter].		mediumBlank.		label: mirror name})



refreshImageBasedChangePresenter = (	sendUp refreshImageBasedChangePresenter)



)



class ImageBasedChangePresenter onSubject: subject = BasePresenter onSubject: subject (|
commitFragmentHolder
definitionHolder
|)

('as yet unclassified'

beforeCommitFragment = (	^ h2: (row: {			smallBlank.			label: 'Modified in Image' asText allBold.			filler.			link: 'revert' action: [				refreshSCAfter: [subject revertImage]].			smallBlank.			link: 'commit'				action: [commitFragmentHolder content: commitFragment]}).)



cleanDefinition = (	^ column: {		h2:: row: {smallBlank. label: 'No Changes in Image' asText allBold. filler}.		unversionedClassesPresenter})



commitFragment = (	^ column: {		h2: (row: {			label: ('Commit to ', subject historianName) asText allBold}).		TextEditorFragment new			text: 'Enter Commit Message ...';			acceptResponse: [:editor |				editor defaultAcceptResponse.				refreshSCAfter: [subject commit: editor text asString]];			cancelResponse: [:editor |				editor defaultCancelResponse.				commitFragmentHolder content: beforeCommitFragment]})



definition = (	definitionHolder:: holder: [definitionHolderContents].	^ definitionHolder)



definitionHolderContents = (	^ column: {		subject hasChanges			ifTrue: [dirtyDefinition]			ifFalse: [cleanDefinition]})



dirtyDefinition = (	commitFragmentHolder:: holder: beforeCommitFragment.	^ column: {		commitFragmentHolder.		unversionedClassesPresenter.		hackStoreMergeHeader.		column: (subject changedDiffSubjects collect: [:each | each presenter])})



hackStoreMergeHeader = (	"As long as we have not implemented stores and store diffs, use this to show the header that would usually be displayed by the StoreMergePresenter"	^row: {	BlankFragment size: 13.		(h2: (label: 'Historian' asText allBold)) width: 0 elasticity: 1.		BlankFragment size: 12.		(h2: (label: 'Image' asText allBold)) width: 0 elasticity: 1.		BlankFragment size: 12})



linkForLog: showLog = (	^ showLog		ifTrue: [link: 'Log' action: [					changesOrLogHolder content: subject logSubject presenter.					changesOrLogLinkHolder contents: (linkForLog: showLog not)]]		ifFalse: [link: 'Changes' action: [					changesOrLogHolder content: changesPresenter.					changesOrLogLinkHolder contents: (linkForLog: showLog not)]])



refreshImageBasedChangePresenter = (	definitionHolder content: definitionHolderContents.)



unversionedClassesPresenter = (	^ UnversionedClassesPresenter onSubject: subject.)



)



class RemoteRepositoryPresenter onSubject: subject = BasePresenter onSubject: subject (|
	|)

('as yet unclassified'

deferredHistorianPresenters = ("	| historianPresentersHolder |	historianPresentersHolder:: holder: ((label: 'synching ...') color: Color gray).	forkAndRemember: [historianPresentersHolder content: (column: historianPresenters)].	^ historianPresentersHolder"	"There is some problem with forking. See deferredActionTrackedHistorian"	^ initially: (label: 'synching ...') deferred: [column: historianPresenters])



definition = (	^ heading: (h3: (label: subject name))	details: deferredHistorianPresenters)



historianPresenters = (	^ subject historianSubjects collect: [:each | each presenter])



)



class TextMergePresenter onSubject: subject = MergePresenter onSubject: subject (|
theToggle
theHolder
|)

('as yet unclassified'

chooseSide: side = (	subject chooseSide: side.	updateHolders.	theToggle collapse)



definition = (	subject isEquals		ifTrue: [^ nothing].	theHolder:: holder: nil. 	updateHolders.	subject isMerge ifTrue: [		"Don't show our changes by default"		subject currentSelection = #ourSource ifTrue: [			theToggle collapse]].	^ theHolder)



details = (	^ column: {		textDiffPresenterFor: subject merger.		ifMerging: [manualMergeEditor]})



manualMergeEditor = (	^		heading: [			row: {				(label: 'Manual merge') color: (colorIndicatingSelectionStatusForSide: #manualMerge).				smallBlank.				linkToSelectSide: #manualMerge}]		details: [mergeEditor]		initiallyExpanded: subject currentSelection = #manualMerge.)



mergeEditor  = (	| editor |	editor:: TextEditorFragment new		text: subject manualMergeResult;		acceptResponse: [ | failed |			failed:: false.			subject				storeManualMerge: editor textBeingAccepted				ifFail: [:msg :pos |					failed:: true.					editor showMessage: msg].			failed ifFalse: [editor defaultAcceptResponse]].	^ editor)



updateHolders = (	theToggle:: heading: [headingDefinition]					detailsExpanded: [details].	theHolder content: (		column: {			row: {				theToggle width: 0 elasticity: 1.				columnSeparator}}))



)



class LocalRepositoryPresenter onSubject: subject = BasePresenter onSubject: subject (|
changesNotification
messagesContainer
inspectionHolder
statusOrLogHolder
statusOrLogLinkHolder
|)

('as yet unclassified'

definition = (	messagesContainer:: OrderedCollection new.	statusOrLogLinkHolder:: holder: (linkForLog: true).	statusOrLogHolder:: holder: repositoryStatusPresenter.	^column: {		h1:: row: {			presentTitle.			filler.			statusOrLogLinkHolder}.		statusOrLogHolder	})



linkForLog: showLog = (	^ showLog		ifTrue: [link: 'Log' action: [					statusOrLogHolder content: subject logSubject presenter.					statusOrLogLinkHolder content: (linkForLog: showLog not)]]		ifFalse: [link: 'Status' action: [					statusOrLogHolder content: repositoryStatusPresenter.					statusOrLogLinkHolder content: (linkForLog: showLog not)]])



presentAge = (	"subject isRecent ifTrue: [		^(link: '[active]' action: [confirm: 'New version published to server within the last week.' ifConfirmed:[]]) tinyFont color: Color gray		].	subject isOld ifTrue: [		^(link: '[dormant]' action: [confirm: 'Latest published version is more than 30 days old.' ifConfirmed:[]]) tinyFont color: Color gray		]."	^label: '')



presentLocalHistorians = (	| localHistorianSubjects |	localHistorianSubjects:: subject localHistorianSubjects.	^ column: {		h2:( row: {			label: 'Current Local Historian' asText allBold.			filler}).		CurrentLocalHistorianPresenter onSubject: (localHistorianSubjects detect: [:each | each isImageHistorian]).		h2:( row: {			label: 'Other Local Historians' asText allBold.			filler}).		list: ((localHistorianSubjects reject: [:each | each isImageHistorian]) collect: [:each | each presenter])})



presentModifiedInImage = (	^ subject modifiedInImageSubject presenter)



presentRemoteRepositories = (	^ column: {		h2:( row: {			label: 'Remote Repositories' asText allBold.			filler}).		list: (subject remoteRepositorySubjects collect: [:each |			each presenter])})



presentTitle = (	| prefix repositoryName |	prefix:: 'Repository [', subject repositoryType, ']: '.	repositoryName:: ('...', (subject repositoryName last: 16)).	^ row: {		label:  prefix asText. 		label: repositoryName asText allBold	})



repositoryEnterSubject: newSubject = (	statusOrLogHolder content: newSubject presenter.	statusOrLogLinkHolder content: nothing.)



repositoryStatusPresenter = (	^ column: {		presentModifiedInImage.		presentLocalHistorians.		presentRemoteRepositories})



)



class SourceControlPresenter onSubject: subject = BasePresenter onSubject: subject (|
helpHolder
status
deferredContent
inspectionHolder
modifiedList
updatedList
|)

('as yet unclassified'

definition = (	helpHolder:: list.	status:: holder: [(label: 'refreshing...') tinyFont].	deferredContent:: holder: [(label: '') tinyFont].	refreshSCAfter: [].	^column: {		helpHolder.		list: [presentLoadImageIfOld].		presentAddRepositories.		"heading: [label: 'Documentation'] details: [presentDocumentation]."		blank: 10.		deferredContent.	})



noticeAbandonment = (	"There is probably a better way to determine when to shut down source control"	subject shutdown)



openHgRepoAt: path = (	| repository |	repository:: vcs hg Backend new LocalRepository onRepositoryId:		((FileDirectory on: SmalltalkImage current imagePath) / path) pathName.	subject model add: repository.	refreshSCAfter: [].)



presentAddRepositories = (	^row: {			label: 'Open Mercurial Repository at '.			TextEditorFragment new				text: 'relative/path';				acceptResponse: [:editor | 					editor defaultAcceptResponse.					openHgRepoAt: editor text asString].		}.)



presentDocumentation = (	^{		row: {			filler.			(link: 'close help' action: [respondToCloseHelp]) tinyFont.		}.		textDisplay: 'Source Control provides an overview of what changes you have made and what others have made available. TBD'.	})



presentHelp = (	^(link: '[?]' action: [respondToHelp]) tinyFont)



presentLoadImageIfOld = (	| ageInDays |	inspectionHolder:: holder: [nothing].	^true		ifTrue: [{row: {status. filler. inspectionHolder. smallBlank. presentHelp}}]	"	ifFalse:			[ageInDays:: NsBoot ageInDays.			ageInDays < 90 ifTrue:				[ | link |				link:: link: 'get latest nightly boot image' action: [respondToDownloadNewImage].				link tinyFont.				ageInDays < 1 ifTrue: [link color: Color gray].				ageInDays > 2 ifTrue: [link color: Color red].				^{row: {status. filler. link. smallBlank. inspectionHolder. smallBlank. presentHelp. smallBlank. advanced}}].			{				row: {status. filler. inspectionHolder. smallBlank. presentHelp. smallBlank. advanced}.				(column: {					blank: 50.					centered: (label: 'This image is more than ' asText, (ageInDays printString, ' days old.') asText allBold).					largeBlank.					centered: (button: 'Download New Image' action: [respondToDownloadNewImage]).					blank: 50					}				) color: (Color h:0 s: 0.6 v: 0.9).				mediumBlank			}]")



presentRepositories = (	| localRepositorySubjects |	localRepositorySubjects:: subject modifiedLocalRepositorySubjects collect:		[ :ea  | ea presenter].	^ list: localRepositorySubjects)



refreshSCAfter: block = (	[		schedule: visual action: [			status content: (label: 'performing action...') tinyFont.			deferredContent content: nothing].		showWaitCursorWhile: [			block value].		schedule: visual action: [			deferredContent content: presentRepositories.			status content: (label: '') tinyFont]]	forkAt: 30 named: 'Refreshing: ', subject title)



respondToCloseHelp = (	helpHolder setPresenters: {})



respondToHelp = (	helpHolder setPresenters: presentDocumentation)



)



class VersionPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)

('as yet unclassified'

definition = (	| toggle |	toggle:: 		heading: (row: {			link: subject message action: [toggle toggle].			mediumBlank.			(label: '[', subject author, ']') color: Color gray.			mediumBlank.			subject isParentOfImage				ifTrue: [					row: {						label: '(current)' asText allBold.						mediumBlank}]				ifFalse: [nothing].			link: 'load' action: [loadIntoImage]})		details: [			| unequalDiffSubjects |			column: {				label: subject internalId asString.				column: (subject unequaldiffsFromPrevious collect: [:each | 					each presenter])}].	^ toggle)



loadIntoImage = (	refreshSCAfter: [subject loadIntoImage])



)



class LocalHistorianPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)

(



class EditableClonePresenter onSubject: s = EditableLinePresenter onSubject: s (|
|)

('as yet unclassified'

definitionText = (	^ 'enter name')



respondToAccept = (	sendUp refreshSCAfter: [		cloneAs: editor text asString ifFail: [			"We could show a error message somehow"			^ self].		leaveEditState])



viewerDefinition = (	^ (link: 'clone' asText action: [enterEditState]))



)



class ChooseShareDestinationPresenter onSubject: subject = BasePresenter onSubject: subject ()

('as yet unclassified'

definition = (	^link: 'share' action: [showMenu])



shareActionFor: action = (	^ [ refreshSCAfter: [action value]])



shareMenu = (	| menu |	menu:: Menu forVisual: visual.	subject shareNamesAndActions do:		[:each |		menu add: 			(MenuItem 				label: each first				action: (shareActionFor: each second))].	^menu)



showMenu = (	openMenu: shareMenu)



viewerDefinition = (	^link: 'share' action: [showMenu])



)'as yet unclassified'

actionCloneHistorian = (	^ EditableClonePresenter onSubject: subject)



actionDeleteHistorian = (	^		imageButton: {			HopscotchImages default cancel16px.			HopscotchImages default cancel16pxOver.			HopscotchImages default cancel16pxDown}		action: [			refreshSCAfter: [subject deleteHistorianIfFail: [unexpected]]])



actionLoadHistorian = (	^ subject isImageHistorian		ifTrue: [			nothing]		ifFalse: [			link: 'load'				action: [					refreshSCAfter: [subject loadIntoImage]]])



actionShareHistorian = (	^ subject trackedHistorianAccessor isTracking		ifTrue: [nothing]		ifFalse: [ChooseShareDestinationPresenter onSubject: subject])



arrangeContent = (	"Can be arranged differently in subclass"	^ self		heading: heading		details: details)



cloneAs: forkName ifFail: failBlock = (	^ subject cloneAs: forkName ifFail: failBlock.)



definition = (	| resultHolder |	resultHolder:: holder: (label: 'synching ...').	forkAndRemember: [		resultHolder content: arrangeContent].	^ resultHolder)



details = (	^ column: {		infoTrackedHistorian.		column: (subject historianRelationSubjects collect: [:each |					each presenter])})



heading = (	^ h3: (		row: {			smallBlank.			label: subject name.			filler.			row: links}))



infoTrackedHistorian = (	^ subject trackedHistorianAccessor errorAccessingTrackingHistorian		ifTrue: [(label: 'Cannot access tracked historian') color: Color red]		ifFalse: [nothing])



links = (	^ {actionLoadHistorian.		smallBlank.		actionCloneHistorian.		smallBlank.		actionShareHistorian.		smallBlank.		actionDeleteHistorian.})



)



class IncomingOutgoingPresenter onSubject: subject = BasePresenter onSubject: subject (|
	cachedPresenters
|)

('as yet unclassified'

definition = (	^ column: presenters)



ifNotEmptyStreamPresentersFor: subjects labeled: label to: stream = (	^ subjects isEmpty ifFalse: [		stream nextPut: (column: {			h4: (label: label).			listPresentersOf: subjects inIncrementsOf: 25})])



isEmpty = (	^ presenters isEmpty)



presenters = (	^Array streamContents: [:stream |		self			ifNotEmptyStreamPresentersFor: subject incomingVersionSubjects			labeled: 'Coming in from ', subject otherHistorianAndRepositoryName			to: stream.		self			ifNotEmptyStreamPresentersFor: subject outgoingVersionSubjects			labeled: 'Going out to ', subject otherHistorianAndRepositoryName			to: stream])



)



class LogPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)

('as yet unclassified'

definition = (	^ listPresentersOf: subject versions  inIncrementsOf: 25)



)



class CurrentLocalHistorianPresenter onSubject: subject = LocalHistorianPresenter onSubject: subject (|
|)

('as yet unclassified'

arrangeContent = (	^ column: {		heading.		details		})



heading = (	^ super heading)



))'as yet unclassified'

forkAndRemember: b= (	vcs core forkAndRemember: b)



mainSubject = (	mainSubjectLazy ifNil: [		mainSubjectLazy:: SourceControlSubject onModel: OrderedCollection new.	].	^mainSubjectLazy )



'actions'

refreshUi = (	"Project uiProcess isActiveProcess ifTrue: [	World doOneCycle]")



schedule: visual action: action = (	visual desktop ifNotNil: [ :dt | dt scheduleUIAction: action fixTemps].	refreshUi)



'accessing'

columnSeparator = (	^ BlankFragment size: 12)



halfColumnSeparator = (	^ BlankFragment size: 6)



)