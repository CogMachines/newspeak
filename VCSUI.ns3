Newspeak3
'StructuredVCS'
class VCSUI usingPlatform: p vcs: vcs ide: ide = NewspeakObject ("The actual source control application

Copyright (c) 2010-2011 Matthias Kleine

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ''Software''), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
"|

FileDirectory = p FileDirectory.
SmalltalkImage = p SmalltalkImage.

ExternalLauncher = p ExternalLauncher.
UIManager = p UIManager.
FileStream = p FileStream.


Set = p Set.
OrderedCollection = p OrderedCollection.
Color = p brazil Color.
Gradient = p brazil plumbing Gradient.
hopscotch = p hopscotch.
Subject = hopscotch core Subject.
Presenter = hopscotch core Presenter.
RowComposer = hopscotch composers RowComposer.
ColumnComposer = hopscotch composers ColumnComposer.
BlankFragment = hopscotch fragments BlankFragment.
TextEditorFragment = hopscotch fragments TextEditorFragment.
SeparatorItem = hopscotch SeparatorItem.
Menu = hopscotch Menu.
MenuItem = hopscotch MenuItem.
EditableLinePresenter = hopscotch fragments EditableLinePresenter.
ProgrammingPresenter = ide tools ProgrammingPresenter. 
HopscotchImages = p Hopscotch HopscotchImages.

vcs = vcs.
logger = Delay computation: [vcs core logger].
sourceMirrors = vcs sourceMirrors.
WordMerger = vcs diffing WordMerger.
ClassSourceMirror = vcs sourceMirrors ClassSourceMirror.

STPackageSourceMirror = Delay computation: [vcs stSourceMirrors STPackageSourceMirror].
STClassSourceMirror = Delay computation: [vcs stSourceMirrors STClassSourceMirror].
STExtensionClassSourceMirror = Delay computation: [vcs stSourceMirrors STExtensionClassSourceMirror].



backgroundColor = Color white.
frameColor ::= Color gray: 0.5.

presenters = Presenters new.

SourceControlPresenter = presenters SourceControlPresenter.
LocalRepositoryPresenter = presenters LocalRepositoryPresenter.
RemoteRepositoryPresenter = presenters RemoteRepositoryPresenter.

LocalHistorianPresenter = presenters LocalHistorianPresenter.
RemoteHistorianPresenter = presenters RemoteHistorianPresenter.

IncomingOutgoingPresenter = presenters IncomingOutgoingPresenter.

HistorianRelationPresenter = presenters HistorianRelationPresenter.

ImageBasedChangePresenter = presenters ImageBasedChangePresenter.
MergeHistorianPresenter = presenters MergeHistorianPresenter.

LogPresenter = presenters LogPresenter.
VersionPresenter = presenters VersionPresenter.

theModel ::= OrderedCollection new.
|)
(
class BasePresenter onSubject: subject = ProgrammingPresenter onSubject: subject (
"Provides UI elements common for source control's presenters"|
|)
('accessing'
h2Color = (

	^ Gradient 
		from: (Color h: 240 s: 0.04 v: 0.88) 
		to: (Color h: 240 s: 0.04 v: 0.86)
)
mediumHeadingColor = (

	^ Gradient 
		from: (Color h: 240 s: 0.04 v: 0.88) 
		to: (Color h: 240 s: 0.04 v: 0.86)
)'actions'
refreshSCAfter: block = (

	sendUp refreshSCAfter: block 
)'as yet unclassified'
deferred: block initially: fragment = (
	^(deferred: block) initialContent: fragment
)
removeButtonWithAction: aBlock = (
	^imageButton: {
		HopscotchImages default cancel16px.
		HopscotchImages default cancel16pxOver.
		HopscotchImages default cancel16pxDown}
	action: aBlock
)'combinators'
h1: body = (

	^ majorHeadingBlock: body
)
h2: body = (

	^ (padded: body with: {10. 5. 5. 5.})
		color: h2Color
)
h3: body = (

	^ minorHeadingBlock: body
)
h4: body = (

	^ (padded: body with: {10. 0. 0. 0}) color: minorHeadingColor
)
listPresentersOf: subjects inIncrementsOf: limit = (

	| versionPresenters |
	versionPresenters:: (subjects first: (subjects size min: limit))
		collect: [:each | each presenter].
	^ column: (
		subjects size > limit
			ifTrue: [
				versionPresenters,
				{(remainingDefinitionFor: (subjects allButFirst: limit) limit: limit)}]
			ifFalse: [versionPresenters])
)
remainingDefinitionFor: subjects limit: limit = (

	| restHolder |
	restHolder:: holder: (
		link: '...'
		action: [
			restHolder content: (listPresentersOf: subjects inIncrementsOf: limit)]).
	^ restHolder
))
class MergingUI = (
"A Hopscotch-based UI for displaying and merging 2 or 3 Newspeak source mirrors.

MergeSubjects have access to different versions of the object to be presented. If set to #diff mode, their presenters only show differences between the objects. If set to #merge mode, their presenters also provide tools to choose how to merge.

Several specializations of MergeSubject exist that allow diffing/merging different kinds of objects. A MirrorMergeSubject merges 2 or 3 Newspeak mirrors, represented as a TreeDiff. Specializations exists for different kinds of mirrors. A TextMergeSubject allows diffing/merging plaing strings.

The UIs for diffing and merging are very similar, with the merging UI adding some features to the diffing UI. One could think of implementing the two functionalities as two sets of classes (e.g. ClassMirrorDiffSubject/Presenter and ClassMirrorMergeSubject/Presenter). It seems to be easier with only one set of classes, though. Presenter methods usually have to add new UI elements for the merging case. Currently they can simply do so by adding using ifMerging:. Using one set of classes, the mode becomes part of the model."|
|)
(
class ClassMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|)
('as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	toggle collapse.
	updateHolders.
)
classHeadingLabeled: labels = (

	^ (h3: (row: labels)) width: 0 elasticity: 1
)
definition = (

	headerHolder:: holder: nil.
	updateHolders.
	toggle::
		heading: [headerHolder]
		details: [detailsDefinition]
		initiallyExpanded: subject interestingChange .

	^(row: {
		toggle width: 0 elasticity: 1.
		columnSeparator}) color: backgroundColor.
)
detailsDefinition = (

	| subjects |
	^ column: {
		subject category presenter.
		subject accessModifier presenter.
		subject name presenter.
		subject constructor presenter.
		subject superclassClause presenter.
		subject classComment presenter.
		subject slotsSource presenter.
		subject initExpressions presenter.
		sortedPresenters: subject unequalClassSubjects.
		sortedPresenters: subject unequalInstanceMethodSubjects
			labeledIfNotEmpty: 'Instance methods'.
		sortedPresenters: subject unequalClassMethodSubjects
			labeledIfNotEmpty: 'Class methods'}
)
headingForSide: side labeled: sideLabel = (
	
	^ classHeadingLabeled: {
		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).
		label: ' [', sideLabel, ']'.
		smallBlank.
		linkToSelectSide: side.
		filler.
		(side = #ourSource)
			ifTrue: [revertSourceLink]
			ifFalse: [nothing]}
)
revertSourceLink = (

	^ (subject isMerge not and: [subject canLoadTheirs])
		ifTrue: [
				link: 'revert' action: [
					refreshSCAfter: [subject loadTheirs]]]
		ifFalse: [nothing]
)
sortedPresenters: presenters  labeledIfNotEmpty: label = (

	^ presenters isEmpty
		ifTrue: [nothing]
		ifFalse: [
			column: {
				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.
				sortedPresenters: presenters}]	
)
sortedPresenters: subjects = (

	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])
		collect: [:each | each presenter])
)
updateHolders = (

	headerHolder content: headingDefinition
))
class ClassMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (""|
category = textMergeSubjectFor: #category title: 'Category'.
accessModifier = textMergeSubjectFor: #accessModifier title: 'Access Modifier'.
name = textMergeSubjectFor: #name title: 'Name'.
constructor = textMergeSubjectFor: #constructor title: 'Constructor'.
superclassClause = textMergeSubjectFor: #superclassClause title: 'Superclass Clause'.
classComment = textMergeSubjectFor: #classComment title: 'Comment'.
slotsSource = textMergeSubjectFor: #slotsSource title: 'Slots'.
initExpressions = textMergeSubjectFor: #initExpressions title: 'Init Expressions'.
classes = create: self class for: #classes.
instanceMethods = create: MethodMirrorMergeSubject for: #instanceMethods.
classMethods = create: MethodMirrorMergeSubject for: #classMethods.
|)
('as yet unclassified'
canLoadTheirs = (

	^ treeDiff anyNode isToplevel
)
create: klass for: nodeType = (

	^ Delay computation: [
		| treeDiffs |
		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].
		treeDiffs collect: [:each | klass onModel: {each. mode. self}]]
)
createPresenter = (

	^ ClassMirrorMergePresenter onSubject: self
)
loadTheirs = (

	treeDiff left installAsToplevelClass.
)
manualMergeMirrorIfFail: failBlock = (

	^ ClassSourceMirror new
		category: category finalMerge asString;
		accessModifier: accessModifier finalMerge asString;
		name: name finalMerge asString;
		constructor: constructor finalMerge asString;
		superclassClause: superclassClause finalMerge asString;
		classComment: classComment finalMerge asString;
		slotsSource: slotsSource finalMerge asString;
		initExpressions: initExpressions finalMerge asString;
		classes: (presentMirrorsOf: classes ifFail: failBlock);
		instanceMethods: (presentMirrorsOf: instanceMethods ifFail: failBlock);
		classMethods: (presentMirrorsOf: classMethods ifFail: failBlock);
		yourself
)
mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	currentSelection =  #manualMerge ifTrue: [
		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].
	currentSelection =  #ourSource ifTrue: [
		^ presentBlock value: treeDiff right].
	currentSelection =  #theirSource ifTrue: [
		^ presentBlock value: treeDiff left].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ presentBlock value: treeDiff ancestor].
	failBlock value: 'Unknown side'
)
mirrorMergeSubjects = (

	^ {classes. instanceMethods. classMethods}
)
textMergeSubjects = (

	^ {category. accessModifier. name. constructor. superclassClause. classComment. slotsSource. initExpressions}
)
unequalClassMethodSubjects = (

	^ classMethods reject: [:each | each treeDiff isEquals]
)
unequalClassSubjects = (

	^ classes reject: [:each | each treeDiff isEquals]
)
unequalInstanceMethodSubjects = (

	^ instanceMethods reject: [:each | each treeDiff isEquals]
)) : ('as yet unclassified'
diffSubjectOn: treeDiff = (
	^ onModel: treeDiff withMode: #diff
)
mergeSubjectOn: treeDiff = (

	^ onModel: treeDiff withMode: #merge
)
onModel: treeDiff withMode: mode = (

	^(treeDiff anyNode isPackageMirror 
		ifTrue: [PackageMirrorMergeSubject]
		ifFalse: [ClassMirrorMergeSubject])
			onModel: {treeDiff. mode. nil}
))
class ExtendedClassMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|)
('as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	toggle collapse.
	updateHolders.
)
classHeadingLabeled: labels = (

	^ (h3: (row: labels)) width: 0 elasticity: 1
)
definition = (

	headerHolder:: holder: nil.
	updateHolders.
	toggle::
		heading: [headerHolder]
		details: [detailsDefinition]
		initiallyExpanded: subject interestingChange .

	^(row: {
		toggle width: 0 elasticity: 1.
		columnSeparator}) color: backgroundColor.
)
detailsDefinition = (

	| subjects |
	^ column: {
		subject name presenter.
		sortedPresenters: subject unequalInstanceMethodSubjects
			labeledIfNotEmpty: 'Instance methods'.
		sortedPresenters: subject unequalClassMethodSubjects
			labeledIfNotEmpty: 'Class methods'}
)
headingForSide: side labeled: sideLabel = (
	
	^ classHeadingLabeled: {
		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).
		label: ' [', sideLabel, ']'.
		smallBlank.
		linkToSelectSide: side.
		filler.
		(side = #ourSource)
			ifTrue: [revertSourceLink]
			ifFalse: [nothing]}
)
revertSourceLink = (

	^ (subject isMerge not and: [subject canLoadTheirs])
		ifTrue: [
				link: 'revert' action: [
					refreshSCAfter: [subject loadTheirs]]]
		ifFalse: [nothing]
)
sortedPresenters: presenters  labeledIfNotEmpty: label = (

	^ presenters isEmpty
		ifTrue: [nothing]
		ifFalse: [
			column: {
				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.
				sortedPresenters: presenters}]	
)
sortedPresenters: subjects = (

	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])
		collect: [:each | each presenter])
)
updateHolders = (

	headerHolder content: headingDefinition
))
class ExtendedClassMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (""|

name = textMergeSubjectFor: #name title: 'Name'.
instanceMethods = create: MethodMirrorMergeSubject for: #instanceMethods.
classMethods = create: MethodMirrorMergeSubject for: #classMethods.
|)
('as yet unclassified'
canLoadTheirs = (

	^false
)
create: klass for: nodeType = (

	^ Delay computation: [
		| treeDiffs |
		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].
		treeDiffs collect: [:each | klass onModel: {each. mode. self}]]
)
createPresenter = (

	^ ExtendedClassMirrorMergePresenter onSubject: self
)
manualMergeMirrorIfFail: failBlock = (

	^ExtendedClassSourceMirror new
		name: name finalMerge asString;
		instanceMethods: (presentMirrorsOf: instanceMethods ifFail: failBlock);
		classMethods: (presentMirrorsOf: classMethods ifFail: failBlock);
		yourself
)
mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	currentSelection =  #manualMerge ifTrue: [
		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].
	currentSelection =  #ourSource ifTrue: [
		^ presentBlock value: treeDiff right].
	currentSelection =  #theirSource ifTrue: [
		^ presentBlock value: treeDiff left].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ presentBlock value: treeDiff ancestor].
	failBlock value: 'Unknown side'
)
mirrorMergeSubjects = (

	^ {instanceMethods. classMethods}
)
textMergeSubjects = (

	^ {name}
)
title = (
	^'*', super title
)
unequalClassMethodSubjects = (

	^ classMethods reject: [:each | each treeDiff isEquals]
)
unequalInstanceMethodSubjects = (

	^ instanceMethods reject: [:each | each treeDiff isEquals]
))
class MergePresenter onSubject: subject = BasePresenter onSubject: subject (|
|)
('as yet unclassified'
colorIndicatingSelectionStatusForSide: side = (

	^ subject currentSelection = side 
		ifTrue: [Color black]
		ifFalse: [Color gray]
)
elasticTextDisplay: text = (

	^ (textDisplay: text) width: 0 elasticity: 1
)
headingDefinition = (
	^row: {
		headingForSide: #theirSource labeled: 'theirs'.
		halfColumnSeparator.
		ifConflict: [
			headingForSide: #commonAncestorSource labeled: 'common ancestor'].
		"link: '?' action: [self inspect]."
		halfColumnSeparator.
		headingForSide: #ourSource labeled: 'ours'}
)
headingForSide: side labeled: sideLabel = (
	
	^ (h4: (row: {
		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).
		smallBlank.
		linkToSelectSide: side})) width:0 elasticity: 1
)
headingLabel = (

	subject isAddition ifTrue: [^subject title, ' was added'].
	subject isDeletion ifTrue: [^subject title, ' was removed'].
	^subject title
)
ifConflict: block = (

	^ subject isConflict
		ifTrue: block
		ifFalse: [nothing]
)
ifMerging: block = (

	^ subject isMerge
		ifTrue: block
		ifFalse: [nothing]
)
linkToSelectSide: side = (

	^ side = subject currentSelection
		ifTrue: [nothing]
		ifFalse: [
			link: 'select' action: [
				chooseSide: side]]
)
textDiffPresenterFor: merger = (

	merger anyChanged ifFalse: [^ nil].
	^ row: {
		elasticTextDisplay: merger leftOut.
		halfColumnSeparator.
		merger bothChanged
			ifTrue: [elasticTextDisplay: merger ancestorOut]
			ifFalse: [nothing].
		halfColumnSeparator.
		elasticTextDisplay: merger rightOut}.
))
class MergeSubject onModel: model = Subject onModel: model ("A merge subjects hold the state of an tree diff or text being merged or diffed
"|
	currentSelection = defaultResult.
|)
('as yet unclassified'
childChoseSide: side = (

	currentSelection = side ifFalse: [
		currentSelection: #manualMerge].
	nil = parentSubject ifFalse: [
		parentSubject childChoseSide: currentSelection]
)
chooseSide: side = (

	currentSelection: side.
	childChoseSide: side
)
defaultResult = (

	subclassResponsibility
)
isChange = (

	^ (self isAddition or: [self isDeletion or: [self isEquals]]) not
)
isMerge = (

	mode = #merge ifTrue: [^true].
	mode = #diff ifTrue: [^false].
	halt.
)
mergeModel = (

	^ model first
)
mode = (

	^ model second
)
parentSubject = (

	^ model third
))
class MethodMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|


|)
('as yet unclassified'
definition = (

	"Don't show the category unless it was actually changed"
	^ subject category isChange
		ifFalse: [subject mergedSource presenter]
		ifTrue: [column: {
			subject category presenter.
			subject mergedSource presenter}]
))
class MethodMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (|
mergedSource = textMergeSubjectFor: #source title: title verificationBlock: [:source :failBlock | createMirrorFrom: source ifFail: failBlock].
category = textMergeSubjectFor: #category title: 'Category of ', title.
cachedMirror

|)
('as yet unclassified'
createMirrorFrom: source ifFail: failBlock = (

	| newMirror |
	
	newMirror::  sourceMirrors
		methodMirrorForStream: source asString readStream
		ifError: failBlock.
	newMirror category: category finalMerge asString.
	^ newMirror
)
createPresenter = (

	^ MethodMirrorMergePresenter onSubject: self
)
mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	cachedMirror ifNil: [
		cachedMirror:: createMirrorFrom: mergedSource finalMerge ifFail: failBlock].
	presentBlock value: cachedMirror
)
removedAfterMerge = (

	^ mergedSource finalMerge isEmpty
)
textMergeSubjects = (

	^ {mergedSource. category}
)
title = (

	^ super title
))
class MirrorMergePresenter onSubject: subject = MergePresenter onSubject: subject (|
	
|)
()
class MirrorMergeSubject onModel: model <TreeDiff> = MergeSubject onModel: model (|

|)
('as yet unclassified'
defaultResult = (

	treeDiff changeInfo isEquals ifTrue: [
		^ #ourSource].
	treeDiff changeInfo isLeft ifTrue: [
		^ #theirSource].
	treeDiff changeInfo isRight ifTrue: [
		^ #ourSource].
	^ #manualMerge
)
interestingChange = (

	"I this a change that should be shown by default?"
	^ (isEquals or: [
		isAddition or: [
			isDeletion or: [
				(isMerge and: [treeDiff changeInfo isRight])
					or: ["Hide top-level classes in general unless we're merging"
						isMerge not and: [treeDiff anyNode isToplevel]]]]]) not
)
isAddition = (

	^ treeDiff changeInfo isAddition
)
isConflict = (

	^ treeDiff changeInfo isConflict
)
isDeletion = (

	^ treeDiff changeInfo isDeletion
)
isEquals = (

	^ treeDiff isEquals
)
mirrorMergeSubjects = (

	^ {}
)
removedAfterMerge = (

	currentSelection = #manualMerge ifTrue: [
		^ false].
	currentSelection = #ourSource ifTrue: [
		^ nil = treeDiff right].
	currentSelection = #theirSource ifTrue: [
		^ nil = treeDiff left].
	currentSelection = #commonAncestorSource ifTrue: [
		^ nil = treeDiff ancestor].
	error: 'unknown selection'
)
sortKey = (

	^ {treeDiff nodeType. treeDiff name}
)
textMergeSubjectFor: selector = (

	^ textMergeSubjectFor: selector title: selector
)
textMergeSubjectFor: selector title: title = (

	^ textMergeSubjectFor: selector title: title verificationBlock: nil 
)
textMergeSubjectFor: selector title: title verificationBlock: verificationBlock = (

	^ Delay computation: [
		| lar wordMerger |
		lar:: treeDiff leftAncestorRightCollect: [:each | each perform: selector].
		wordMerger:: WordMerger on: lar.
		(TextMergeSubject onModel: {wordMerger. mode. self})
			title: title;
			verificationBlock: verificationBlock;
			yourself]
)
textMergeSubjects = (

	^ {}
)
title = (

	^ treeDiff name
)
treeDiff = (

	^ mergeModel
))
class PackageMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|)
('as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	toggle collapse.
	updateHolders.
)
classHeadingLabeled: labels = (

	^ (h3: (row: labels)) width: 0 elasticity: 1
)
definition = (

	headerHolder:: holder: nil.
	updateHolders.
	toggle::
		heading: [headerHolder]
		details: [detailsDefinition]
		initiallyExpanded: subject interestingChange .

	^(row: {
		toggle width: 0 elasticity: 1.
		columnSeparator}) color: backgroundColor.
)
detailsDefinition = (

	| subjects |
	^ column: {
		subject name presenter.
		sortedPresenters: subject unequalClassSubjects.
		sortedPresenters: subject unequalExtendedClassSubjects.
	}
)
headingForSide: side labeled: sideLabel = (
	
	^ classHeadingLabeled: {
		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).
		label: ' [', sideLabel, ']'.
		smallBlank.
		linkToSelectSide: side.
		filler.
		(side = #ourSource)
			ifTrue: [revertSourceLink]
			ifFalse: [nothing]}
)
revertSourceLink = (

	^ (subject isMerge not and: [subject canLoadTheirs])
		ifTrue: [
				link: 'revert' action: [
					refreshSCAfter: [subject loadTheirs]]]
		ifFalse: [nothing]
)
sortedPresenters: presenters  labeledIfNotEmpty: label = (

	^ presenters isEmpty
		ifTrue: [nothing]
		ifFalse: [
			column: {
				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.
				sortedPresenters: presenters}]	
)
sortedPresenters: subjects = (

	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])
		collect: [:each | each presenter])
)
updateHolders = (

	headerHolder content: headingDefinition
))
class PackageMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (""|

name = textMergeSubjectFor: #name title: 'Name'.
classes = create: SmalltalkClassMirrorMergeSubject for: #classes.
extendedClasses = create: ExtendedClassMirrorMergeSubject for: #extendedClasses.

|)
('as yet unclassified'
canLoadTheirs = (
	^true
)
create: klass for: nodeType = (

	^ Delay computation: [
		| treeDiffs |
		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].
		treeDiffs collect: [:each | klass onModel: {each. mode. self}]]
)
createPresenter = (

	^ PackageMirrorMergePresenter onSubject: self
)
loadTheirs = (

	treeDiff left installAsToplevelClass.
)
manualMergeMirrorIfFail: failBlock = (

	^ SmalltalkPackageSourceMirror new
		name: name finalMerge asString;
		classes: (presentMirrorsOf: classes ifFail: failBlock);
		extendedClasses: (presentMirrorsOf: extendedClasses ifFail: failBlock);
		yourself
)
mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	currentSelection =  #manualMerge ifTrue: [
		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].
	currentSelection =  #ourSource ifTrue: [
		^ presentBlock value: treeDiff right].
	currentSelection =  #theirSource ifTrue: [
		^ presentBlock value: treeDiff left].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ presentBlock value: treeDiff ancestor].
	failBlock value: 'Unknown side'
)
mirrorMergeSubjects = (

	^ {classes. extendedClasses}
)
textMergeSubjects = (

	^ {name}
)
unequalClassSubjects = (

	^ classes reject: [:each | each treeDiff isEquals]
)
unequalExtendedClassSubjects = (

	^ extendedClasses reject: [:each | each treeDiff isEquals]
))
class SmalltalkClassMirrorMergePresenter onSubject: subject = MirrorMergePresenter onSubject: subject (|
	toggle
	headerHolder
|)
('as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	toggle collapse.
	updateHolders.
)
classHeadingLabeled: labels = (

	^ (h3: (row: labels)) width: 0 elasticity: 1
)
definition = (

	headerHolder:: holder: nil.
	updateHolders.
	toggle::
		heading: [headerHolder]
		details: [detailsDefinition]
		initiallyExpanded: subject interestingChange .

	^(row: {
		toggle width: 0 elasticity: 1.
		columnSeparator}) color: backgroundColor.
)
detailsDefinition = (

	| subjects |
	^ column: {
		subject category presenter.
		subject name presenter.
		subject superclassName presenter.
		subject classComment presenter.
		subject instanceVariables presenter.
		subject classInstanceVariables presenter.

		sortedPresenters: subject unequalInstanceMethodSubjects
			labeledIfNotEmpty: 'Instance methods'.
		sortedPresenters: subject unequalClassMethodSubjects
			labeledIfNotEmpty: 'Class methods'}
)
headingForSide: side labeled: sideLabel = (
	
	^ classHeadingLabeled: {
		(label: headingLabel asText allBold) color: (colorIndicatingSelectionStatusForSide: side).
		label: ' [', sideLabel, ']'.
		smallBlank.
		linkToSelectSide: side.
		filler.
		(side = #ourSource)
			ifTrue: [revertSourceLink]
			ifFalse: [nothing]}
)
revertSourceLink = (

	^ (subject isMerge not and: [subject canLoadTheirs])
		ifTrue: [
				link: 'revert' action: [
					refreshSCAfter: [subject loadTheirs]]]
		ifFalse: [nothing]
)
sortedPresenters: presenters  labeledIfNotEmpty: label = (

	^ presenters isEmpty
		ifTrue: [nothing]
		ifFalse: [
			column: {
				(padded: (label: label) with: {10. 0. 0. 0.}) color: minorHeadingColor.
				sortedPresenters: presenters}]	
)
sortedPresenters: subjects = (

	^ column: ((subjects asSortedCollection: [:a :b | a sortKey asString < b sortKey asString])
		collect: [:each | each presenter])
)
updateHolders = (

	headerHolder content: headingDefinition
))
class SmalltalkClassMirrorMergeSubject onModel: model <TreeDiff> = MirrorMergeSubject onModel: model (""|
category = textMergeSubjectFor: #category title: 'Category'.
name = textMergeSubjectFor: #name title: 'Name'.
superclassName = textMergeSubjectFor: #superclassName title: 'Superclass'.
classComment = textMergeSubjectFor: #classComment title: 'Comment'.

instanceVariables = textMergeSubjectFor: #instanceVariablesString title: 'Instance Variables'.
classInstanceVariables = textMergeSubjectFor: #classInstanceVariablesString title: 'Class Instance Variables'.
classPoolVariables = textMergeSubjectFor: #classPoolVariablesString title: 'Class Pool Variables'.
sharedPoolVariables = textMergeSubjectFor: #sharedPoolVariablesString title: 'Shared Pool Variables'.

instanceMethods = create: MethodMirrorMergeSubject for: #instanceMethods.
classMethods = create: MethodMirrorMergeSubject for: #classMethods.
|)
('as yet unclassified'
canLoadTheirs = (

	^true
)
create: klass for: nodeType = (

	^ Delay computation: [
		| treeDiffs |
		treeDiffs:: treeDiff children select: [:each | each nodeType = nodeType].
		treeDiffs collect: [:each | klass onModel: {each. mode. self}]]
)
createPresenter = (

	^ SmalltalkClassMirrorMergePresenter onSubject: self
)
manualMergeMirrorIfFail: failBlock = (

	^SmalltalkClassSourceMirror new
		category: category finalMerge asString;
		name: name finalMerge asString;
		superclassName: superclassName finalMerge asString;
		classComment: classComment finalMerge asString;
		instanceVariables: instanceVariables finalMerge asString;
		classInstanceVariables: classInstanceVariables finalMerge asString;
		classPoolVariables: classPoolVariables finalMerge asString;
		sharedPoolVariables: sharedPoolVariables finalMerge asString;
		instanceMethods: (presentMirrorsOf: instanceMethods ifFail: failBlock);
		classMethods: (presentMirrorsOf: classMethods ifFail: failBlock);
		yourself
)
mirrorIfPresent: presentBlock ifRemoved: removedBlock ifFail: failBlock = (

	removedAfterMerge ifTrue: [^ removedBlock value].
	currentSelection =  #manualMerge ifTrue: [
		^ presentBlock value: (manualMergeMirrorIfFail: failBlock)].
	currentSelection =  #ourSource ifTrue: [
		^ presentBlock value: treeDiff right].
	currentSelection =  #theirSource ifTrue: [
		^ presentBlock value: treeDiff left].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ presentBlock value: treeDiff ancestor].
	failBlock value: 'Unknown side'
)
mirrorMergeSubjects = (

	^ {instanceMethods. classMethods}
)
textMergeSubjects = (

	^ {category. name. superclassName. classComment. instanceVariables. classInstanceVariables. classPoolVariables . sharedPoolVariables }
)
unequalClassMethodSubjects = (

	^ classMethods reject: [:each | each treeDiff isEquals]
)
unequalInstanceMethodSubjects = (

	^ instanceMethods reject: [:each | each treeDiff isEquals]
))
class TextMergePresenter onSubject: subject = MergePresenter onSubject: subject (|
theToggle
theHolder
|)
('as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	updateHolders.
	theToggle collapse
)
definition = (

	subject isEquals
		ifTrue: [^ nothing].
	theHolder:: holder: nil. 
	updateHolders.
	subject isMerge ifTrue: [
		"Don't show our changes by default"
		subject currentSelection = #ourSource ifTrue: [
			theToggle collapse]].
	^ theHolder
)
details = (

	^ column: {
		textDiffPresenterFor: subject merger.
		ifMerging: [manualMergeEditor]}
)
manualMergeEditor = (

	^
		heading: [
			row: {
				(label: 'Manual merge') color: (colorIndicatingSelectionStatusForSide: #manualMerge).
				smallBlank.
				linkToSelectSide: #manualMerge}]
		details: [mergeEditor]
		initiallyExpanded: subject currentSelection = #manualMerge.
)
mergeEditor  = (

	| editor |

	editor:: TextEditorFragment new
		text: subject manualMergeResult;
		acceptResponse: [ | failed |
			failed:: false.
			subject
				storeManualMerge: editor textBeingAccepted
				ifFail: [:msg :pos |
					failed:: true.
					editor showMessage: msg].
			failed ifFalse: [editor defaultAcceptResponse]].
	^ editor
)
updateHolders = (

	theToggle:: heading: [headingDefinition]
					detailsExpanded: [details].
	theHolder content: (
		column: {
			row: {
				theToggle width: 0 elasticity: 1.
				columnSeparator}})
))
class TextMergeSubject onModel: model = MergeSubject onModel: model (|
	title
	manualMergeResult = merger automaticMergedOut.
	verificationBlock
|)
('as yet unclassified'
createPresenter = (

	^ TextMergePresenter onSubject: self
)
defaultResult = (

	merger anyChanged ifFalse: [
		^ #commonAncestorSource].
	merger rightChanged ifTrue: [
		^ #ourSource].
	merger leftChanged ifTrue: [
		^ #theirSource].
	^ #manualMerge
)
finalMerge = (

	currentSelection =  #manualMerge ifTrue: [
		storeManualMerge: manualMergeResult ifFail: [halt].
		^ manualMergeResult].
	currentSelection =  #ourSource ifTrue: [
		^ merger rightOut].
	currentSelection =  #theirSource ifTrue: [
		^ merger leftOut].
	currentSelection =  #commonAncestorSource ifTrue: [
		^ merger ancestorOut].
	error: 'unknown side'
)
isAddition = (

	^ merger isAddition
)
isConflict = (

	^ merger bothChanged
)
isDeletion = (

	^ merger isDeletion
)
isEquals = (

	^ merger anyChanged not
)
merger = (

	^ mergeModel
)
storeManualMerge: mergeResult ifFail: failBlock = (

	verificationBlock = nil ifFalse: [
		verificationBlock value: mergeResult value: failBlock].
	manualMergeResult:: mergeResult.
))'accessing'
blank: size color: color = (
	^(ColumnComposer definitions: {RowComposer definitions: {BlankFragment size: size}}) color: color
)
vblank: size color: color = (
	^(RowComposer definitions: {ColumnComposer definitions: {BlankFragment size: size}}) color: color
)'private'
presentMirrorsOf: mergeSubjects ifFail: failBlock = (

	| survivingElements |
	^ Array streamContents: [:stream |
		mergeSubjects do: [:each |
			each
				mirrorIfPresent: [:it | stream nextPut: it]
				ifRemoved: []
				ifFail: failBlock]]
))
class Presenters = ()
(
class CurrentLocalHistorianPresenter onSubject: subject = LocalHistorianPresenter onSubject: subject (|
|)
('as yet unclassified'
arrangeContent = (

	^ column: {
		heading.
		details
		}
)
heading = (

	^ super heading
))
class HistorianRelationPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)
('as yet unclassified'
definition = (

	^ column: {
		h4: (subject runActionOn: self).
		IncomingOutgoingPresenter onSubject: subject}
)
forwardOther = (

	^ link: 'Forward ', otherHistorianAndRepositoryName
		action: [
			refreshSCAfter: [subject forwardOtherHistorian]]
)
forwardToOther = (

	^ link: 'Forward to ', otherHistorianAndRepositoryName
		action: [
			refreshSCAfter: [subject forwardToOtherHistorian]]
)
inSynch = (

	^ (label: 'In sync with ', otherHistorianAndRepositoryName) color: Color gray
)
merge = (

	"Allow merging only into image historian"
	subject historianIsImageHistorian ifTrue: [
		^ link: 'Merge from ', otherHistorianAndRepositoryName
		action: [
			sendUp repositoryEnterSubject:
				subject mergeFromOtherHistorianSubject]].
	subject otherHistorianIsImageHistorian ifTrue: [
		^ link: 'Merge into ', otherHistorianAndRepositoryName
		action: [
			sendUp repositoryEnterSubject:
				subject mergeIntoOtherHistorianSubject]].
	^ (label: 'Out of sync') color: Color gray
)
otherHistorianAndRepositoryName = (

	^ subject otherHistorianAndRepositoryName
))
class ImageBasedChangePresenter onSubject: subject = BasePresenter onSubject: subject (|
commitFragmentHolder
definitionHolder
|)
('as yet unclassified'
beforeCommitFragment = (

	^ h2: (row: {
			smallBlank.
			label: 'Modified in Image' asText allBold.
			filler.
			link: 'revert' action: [
				refreshSCAfter: [subject revertImage]].
			smallBlank.
			link: 'commit'
				action: [commitFragmentHolder content: commitFragment]}).
)
cleanDefinition = (

	^ column: {
		h2:: row: {smallBlank. label: 'No Changes in Image' asText allBold. filler}.
		unversionedClassesPresenter}
)
commitFragment = (

	^ column: {
		h2: (row: {
			label: ('Commit to ', subject historianName) asText allBold}).
		TextEditorFragment new
			text: 'Enter Commit Message ...';
			acceptResponse: [:editor |
				editor defaultAcceptResponse.
				refreshSCAfter: [subject commit: editor text asString]];
			cancelResponse: [:editor |
				editor defaultCancelResponse.
				commitFragmentHolder content: beforeCommitFragment]}
)
definition = (

	definitionHolder:: holder: [definitionHolderContents].
	^ definitionHolder
)
definitionHolderContents = (

	^ column: {
		subject hasChanges
			ifTrue: [dirtyDefinition]
			ifFalse: [cleanDefinition]}
)
dirtyDefinition = (

	commitFragmentHolder:: holder: beforeCommitFragment.
	^ column: {
		commitFragmentHolder.
		unversionedClassesPresenter.
		hackStoreMergeHeader.
		column: (subject changedDiffSubjects collect: [:each | each presenter])}
)
hackStoreMergeHeader = (

	"As long as we have not implemented stores and store diffs, use this to show the header that would usually be displayed by the StoreMergePresenter"
	^row: {
	BlankFragment size: 13.
		(h2: (label: 'Historian' asText allBold)) width: 0 elasticity: 1.
		BlankFragment size: 12.
		(h2: (label: 'Image' asText allBold)) width: 0 elasticity: 1.
		BlankFragment size: 12}
)
linkForLog: showLog = (

	^ showLog
		ifTrue: [link: 'Log' action: [
					changesOrLogHolder content: subject logSubject presenter.
					changesOrLogLinkHolder contents: (linkForLog: showLog not)]]
		ifFalse: [link: 'Changes' action: [
					changesOrLogHolder content: changesPresenter.
					changesOrLogLinkHolder contents: (linkForLog: showLog not)]]
)
refreshImageBasedChangePresenter = (

	definitionHolder content: definitionHolderContents.
)
unversionedClassesPresenter = (

	^ UnversionedClassesPresenter onSubject: subject.
))
class IncomingOutgoingPresenter onSubject: subject = BasePresenter onSubject: subject (|
	cachedPresenters
|)
('as yet unclassified'
definition = (

	^ column: presenters
)
ifNotEmptyStreamPresentersFor: subjects labeled: label to: stream = (

	^ subjects isEmpty ifFalse: [
		stream nextPut: (column: {
			h4: (label: label).
			listPresentersOf: subjects inIncrementsOf: 25})]
)
isEmpty = (

	^ presenters isEmpty
)
presenters = (

	^Array streamContents: [:stream |
		self
			ifNotEmptyStreamPresentersFor: subject incomingVersionSubjects
			labeled: 'Coming in from ', subject otherHistorianAndRepositoryName
			to: stream.
		self
			ifNotEmptyStreamPresentersFor: subject outgoingVersionSubjects
			labeled: 'Going out to ', subject otherHistorianAndRepositoryName
			to: stream]
))
class LocalHistorianPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)
(
class ChooseShareDestinationPresenter onSubject: subject = BasePresenter onSubject: subject ()
('as yet unclassified'
definition = (

	^link: 'share' action: [showMenu]
)
shareActionFor: action = (

	^ [ refreshSCAfter: [action value]]
)
shareMenu = (

	| menu |
	menu:: Menu forVisual: visual.
	subject shareNamesAndActions do:
		[:each |
		menu add: 
			(MenuItem 
				label: each first
				action: (shareActionFor: each second))].
	^menu
)
showMenu = (

	openMenu: shareMenu
)
viewerDefinition = (

	^link: 'share' action: [showMenu]
))
class EditableClonePresenter onSubject: s = EditableLinePresenter onSubject: s (|
|)
('as yet unclassified'
definitionText = (

	^ 'enter name'
)
respondToAccept = (

	sendUp refreshSCAfter: [
		cloneAs: editor text asString ifFail: [
			"We could show a error message somehow"
			^ self].
		leaveEditState]
)
viewerDefinition = (

	^ (link: 'clone' asText action: [enterEditState])
))'as yet unclassified'
actionCloneHistorian = (

	^ EditableClonePresenter onSubject: subject
)
actionDeleteHistorian = (

	^
		imageButton: {
			HopscotchImages default cancel16px.
			HopscotchImages default cancel16pxOver.
			HopscotchImages default cancel16pxDown}
		action: [
			refreshSCAfter: [subject deleteHistorianIfFail: [unexpected]]]
)
actionLoadHistorian = (

	^ subject isImageHistorian
		ifTrue: [
			nothing]
		ifFalse: [
			link: 'load'
				action: [
					refreshSCAfter: [subject loadIntoImage]]]
)
actionShareHistorian = (

	^ subject trackedHistorianAccessor isTracking
		ifTrue: [nothing]
		ifFalse: [ChooseShareDestinationPresenter onSubject: subject]
)
arrangeContent = (

	"Can be arranged differently in subclass"
	^ self
		heading: heading
		details: details
)
cloneAs: forkName ifFail: failBlock = (

	^ subject cloneAs: forkName ifFail: failBlock.
)
definition = (

	| resultHolder |
	resultHolder:: holder: (label: 'synching ...').
	forkAndRemember: [
		resultHolder content: arrangeContent].
	^ resultHolder
)
details = (

	^ column: {
		infoTrackedHistorian.
		column: (subject historianRelationSubjects collect: [:each |
					each presenter])}
)
heading = (

	^ h3: (
		row: {
			smallBlank.
			label: subject name.
			filler.
			row: links})
)
infoTrackedHistorian = (

	^ subject trackedHistorianAccessor errorAccessingTrackingHistorian
		ifTrue: [(label: 'Cannot access tracked historian') color: Color red]
		ifFalse: [nothing]
)
links = (

	^ {actionLoadHistorian.
		smallBlank.
		actionCloneHistorian.
		smallBlank.
		actionShareHistorian.
		smallBlank.
		actionDeleteHistorian.}
))
class LocalRepositoryPresenter onSubject: subject = BasePresenter onSubject: subject (|
deferredContent = holder: nothing.
changesNotification
messagesContainer
inspectionHolder
statusOrLogHolder
statusOrLogLinkHolder
|)
('as yet unclassified'
actualDefinition = (

	messagesContainer:: OrderedCollection new.
	statusOrLogLinkHolder:: holder: (linkForLog: true).
	statusOrLogHolder:: holder: repositoryStatusPresenter.
	
	^column: {
		h1:: row: {
			presentTitle.
			filler.
			statusOrLogLinkHolder}.
		statusOrLogHolder
	}
)
definition = (
	^deferredContent
)
linkForLog: showLog = (

	^ showLog
		ifTrue: [link: 'Log' action: [
					statusOrLogHolder content: subject logSubject presenter.
					statusOrLogLinkHolder content: (linkForLog: showLog not)]]
		ifFalse: [link: 'Status' action: [
					statusOrLogHolder content: repositoryStatusPresenter.
					statusOrLogLinkHolder content: (linkForLog: showLog not)]]
)
noticeImminentExposure = (
	refreshSCAfter: []
)
presentAge = (
	"subject isRecent ifTrue: [
		^(link: '[active]' action: [confirm: 'New version published to server within the last week.' ifConfirmed:[]]) tinyFont color: Color gray
		].
	subject isOld ifTrue: [
		^(link: '[dormant]' action: [confirm: 'Latest published version is more than 30 days old.' ifConfirmed:[]]) tinyFont color: Color gray
		]."
	^label: ''
)
presentLocalHistorians = (

	| localHistorianSubjects |
	localHistorianSubjects:: subject localHistorianSubjects.
	^ column: {
		h2:( row: {
			label: 'Current Local Historian' asText allBold.
			filler}).
		CurrentLocalHistorianPresenter onSubject: (localHistorianSubjects detect: [:each | each isImageHistorian]).
		h2:( row: {
			label: 'Other Local Historians' asText allBold.
			filler}).
		list: ((localHistorianSubjects reject: [:each | each isImageHistorian]) collect: [:each | each presenter])}
)
presentModifiedInImage = (

	^ subject modifiedInImageSubject presenter
)
presentRemoteRepositories = (

	^ column: {
		h2:( row: {
			label: 'Remote Repositories' asText allBold.
			filler}).
		list: (subject remoteRepositorySubjects collect: [:each |
			each presenter])}
)
presentTitle = (

	| prefix repositoryName |
	prefix:: 'Repository [', subject repositoryType, ']: '.
	repositoryName:: ('...', (subject repositoryName last: 16)).
	^ row: {
		label:  prefix asText. 
		label: repositoryName asText allBold
	}
)
refreshSCAfter: block = (

	deferredContent content: (label: 'performing action...') tinyFont.
	[showWaitCursorWhile: [
		block value.
		shell desktop scheduleUIAction: [deferredContent content: actualDefinition].
	]
	]forkAt: 30 named: 'Refreshing: ', subject title
)
repositoryEnterSubject: newSubject = (

	statusOrLogHolder content: newSubject presenter.
	statusOrLogLinkHolder content: nothing.
)
repositoryStatusPresenter = (

	^ column: {
		presentModifiedInImage.
		presentLocalHistorians.
		presentRemoteRepositories}
))
class LogPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)
('as yet unclassified'
definition = (

	^ listPresentersOf: subject versions  inIncrementsOf: 25
))
class MergeHistorianPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)
('as yet unclassified'
definition = (

	| unequalMergeSubjects |
	unequalMergeSubjects:: subject mergeSubjects reject: [:each | each isEquals].
	^ column: {
		h1: (row: {
			label: 'Merge ', subject mergeSourceName, ' into ', subject mergeDestinationName.
			filler.
			link: 'Commit Merge' action: [
				refreshSCAfter: [
					subject mergeIfFail: [halt]]]}).
		column: (unequalMergeSubjects	collect: [:each | each presenter])}
))
class RemoteHistorianPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)
('as yet unclassified'
definition = (

	^ h4: (
			row: {
				smallBlank.
				label: subject name.
				filler.
				row: links})
)
links = (

	^ {
		subject isTracked
			ifTrue: [(label: 'is tracked') color: Color gray]
			ifFalse: [link: 'track' action: [
					refreshSCAfter: [subject trackAs: subject name]]]}
))
class RemoteRepositoryPresenter onSubject: subject = BasePresenter onSubject: subject (|
	|)
('as yet unclassified'
deferredHistorianPresenters = (
"
	| historianPresentersHolder |
	historianPresentersHolder:: holder: ((label: 'synching ...') color: Color gray).
	forkAndRemember: [historianPresentersHolder content: (column: historianPresenters)].
	^ historianPresentersHolder"
	"There is some problem with forking. See deferredActionTrackedHistorian"
	^ initially: (label: 'synching ...') deferred: [column: historianPresenters]
)
definition = (

	^ heading: (h3: (label: subject name))
	details: deferredHistorianPresenters
)
historianPresenters = (

	^ subject historianSubjects collect: [:each | each presenter]
))
class SourceControlPresenter onSubject: subject = BasePresenter onSubject: subject (|
"helpHolder
status
deferredContent
inspectionHolder
modifiedList
updatedList"
addHolder
reposHolder
|)
('as yet unclassified'
createLocalHgRepoAt: relPath <String> = (

	| path hg uiusername repository |

	#BOGUS. "This logic belongs somewhere else!"

	path:: ((FileDirectory on: SmalltalkImage current imagePath) / relPath) pathName.

	hg:: ExternalLauncher for: 'hg'.
	hg otherUnixLocations: {'/opt/local/bin'. '/usr/local/bin'}.
	hg otherWindowsLocations: {'c:\cygwin\bin'}.

	"hg init path"
	hg 
		runWith: {'init'. path} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | self error: stderr contents].

	uiusername:: UIManager default
			request: 'Please provide your Mercurial username'
			initialAnswer: 'Full Name <email@company.com>'.

	"setup hgrc"
	(FileStream forceNewFileNamed: ((FileDirectory on: path) / '.hg' / 'hgrc') pathName) nextPutAll: 
'[ui]
username=',uiusername,'
[extensions]
bookmarks=
[newspeak]
current_historian=main
'; flush; close.

	""
	(FileStream forceNewFileNamed: ((FileDirectory on: path) / '.hgignore') pathName)
		flush; close. 

	hg 
		runWith: {'--cwd'. path. 'bookmark'. 'main'} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | self error: stderr contents].

	hg 
		runWith: {'--cwd'. path. 'add'. '.hgignore'} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | self error: stderr contents].
	
	hg 
		runWith: {'--cwd'. path. 'commit'. '-m'. 'Initial commit.'} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | self error: stderr contents].

	repository:: vcs hg Backend new LocalRepository onRepositoryId: path.

	subject model add: repository.
	self refresh.
)
definition = (

	^column: {
		majorHeadingBlock: (row: {
			label: 'MemoryHole Repositories' asText allBold.
			filler.
			addButtonWithAction: [addHolder content: presentAddRepositories].
		}).
		mediumBlank.
		addHolder:: holder: nothing.
		reposHolder:: holder: [presentRepositories].
	}
)
openLocalHgRepoAt: path = (

	| repository |

	repository:: vcs hg Backend new LocalRepository onRepositoryId:
		((FileDirectory on: SmalltalkImage current imagePath) / path) pathName.

	subject model add: repository.
	self refresh.
)
openRemoteHgRepoAt: url <String> = (

	| path hg uiusername username password repository |

	assert: [url startsWith: 'https://'] message: 'Convient support for https only at the moment.  Setup ssh yourself.'.

	path:: url copyFrom: (url lastIndexOf: $/)+1 to: url size.
	path:: ((FileDirectory on: SmalltalkImage current imagePath) / path) pathName.

	hg:: ExternalLauncher for: 'hg'.
	hg otherUnixLocations: {'/opt/local/bin'. '/usr/local/bin'}.
	hg otherWindowsLocations: {'c:\cygwin\bin'}.

	"hg init path"
	hg 
		runWith: {'init'. path} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | self error: stderr contents].

	uiusername:: UIManager default
			request: 'Please provide your Mercurial username'
			initialAnswer: 'Full Name <email@company.com>'.

	username:: UIManager default
			request: 'Please provide your BitBucket, etc username'
			initialAnswer: 'wsmith'.

	password:: UIManager default
			request: 'Please provide your BitBucket, etc password'
			initialAnswer: 'downwithbigbrother'.

	"setup hgrc"
	(FileStream forceNewFileNamed: ((FileDirectory on: path) / '.hg' / 'hgrc') pathName) nextPutAll: 
'[paths]
default=',url,'
[ui]
username=',uiusername,'
[extensions]
bookmarks=
[auth]
bb1.schemes=https
bb1.prefex=',url,'
bb1.password=',password,'
bb1.username=',username,'
[newspeak]
current_historian=main
[newspeak_tracking_historian]
main=main
[newspeak_tracking_repository]
main=',url,'
'; flush; close.

	"hg --cwd path pull -B"
	hg 
		runWith: {'--cwd'. path. 'pull'. '-B'. 'main'} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | self error: stderr contents].
	
	hg 
		runWith: {'--cwd'. path. 'update'.} 
		ifSuccess: [:stdout :stderr | ] 
		ifFailure: [:stdout :stderr | self error: stderr contents].

	repository:: vcs hg Backend new LocalRepository onRepositoryId: path.

	subject model add: repository.
	self refresh.
)
presentAddRepositories = (
	^column: {
		row: {
			label: 'Clone and open remote Mercurial repository at '.
			TextEditorFragment new
				text: 'https://bitbucket.org/username/repository';
				acceptResponse: [:editor | 
					editor defaultAcceptResponse.
					openRemoteHgRepoAt: editor text asString.
					addHolder content: nothing].
		}.
		row: {
			label: 'Open local Mercurial repository at '.
			TextEditorFragment new
				text: 'path/relativeTo/imageDirectory';
				acceptResponse: [:editor | 
					editor defaultAcceptResponse.
					openLocalHgRepoAt: editor text asString.
					addHolder content: nothing].
		}.
		row: {
			label: 'Create new local Mercurial repository at '.
			TextEditorFragment new
				text: 'path/relativeTo/imageDirectory';
				acceptResponse: [:editor | 
					editor defaultAcceptResponse.
					createLocalHgRepoAt: editor text asString.
					addHolder content: nothing].
		}.
		"row: {
			label: 'Open Git Repository at '.
			TextEditorFragment new
				text: 'relative/path';
				acceptResponse: [:editor | 
					editor defaultAcceptResponse.
					openGitRepoAt: editor text asString].
		}."
	}
)
presentDocumentation = (
	^{
		row: {
			filler.
			(link: 'close help' action: [respondToCloseHelp]) tinyFont.
		}.
		textDisplay: 'Source Control provides an overview of what changes you have made and what others have made available. TBD'.
	}
)
presentHelp = (
	^(link: '[?]' action: [respondToHelp]) tinyFont
)
presentRepositories = (
	^list: (subject modifiedLocalRepositorySubjects collect: [:ea <LocalRepositorySubject> |		
		row: {
			smallBlank.
			link: ea title action: [enterSubject: ea].
			filler.
			removeButtonWithAction: [confirm: 'Remove Repository' ifConfirmed: [subject removeRepository: ea model. self refresh]].
			smallBlank.
		}
	])
)
respondToCloseHelp = (
	helpHolder setPresenters: {}
)
respondToHelp = (
	helpHolder setPresenters: presentDocumentation
))
class TextMergePresenter onSubject: subject = MergePresenter onSubject: subject (|
theToggle
theHolder
|)
('as yet unclassified'
chooseSide: side = (

	subject chooseSide: side.
	updateHolders.
	theToggle collapse
)
definition = (

	subject isEquals
		ifTrue: [^ nothing].
	theHolder:: holder: nil. 
	updateHolders.
	subject isMerge ifTrue: [
		"Don't show our changes by default"
		subject currentSelection = #ourSource ifTrue: [
			theToggle collapse]].
	^ theHolder
)
details = (

	^ column: {
		textDiffPresenterFor: subject merger.
		ifMerging: [manualMergeEditor]}
)
manualMergeEditor = (

	^
		heading: [
			row: {
				(label: 'Manual merge') color: (colorIndicatingSelectionStatusForSide: #manualMerge).
				smallBlank.
				linkToSelectSide: #manualMerge}]
		details: [mergeEditor]
		initiallyExpanded: subject currentSelection = #manualMerge.
)
mergeEditor  = (

	| editor |

	editor:: TextEditorFragment new
		text: subject manualMergeResult;
		acceptResponse: [ | failed |
			failed:: false.
			subject
				storeManualMerge: editor textBeingAccepted
				ifFail: [:msg :pos |
					failed:: true.
					editor showMessage: msg].
			failed ifFalse: [editor defaultAcceptResponse]].
	^ editor
)
updateHolders = (

	theToggle:: heading: [headingDefinition]
					detailsExpanded: [details].
	theHolder content: (
		column: {
			row: {
				theToggle width: 0 elasticity: 1.
				columnSeparator}})
))
class UnversionedClassesPresenter onSubject: subject <ImageBasedChangeSubject> = BasePresenter onSubject: subject ("Allows adding unversioned classes to the current image based change"|
	private unversionedImageMirrors = subject unversionedImageMirrors.|)
('as yet unclassified'
definition = (

	^ unversionedImageMirrors isEmpty
		ifTrue: [nothing]
		ifFalse: [
			heading: header
			details: [column: (unversionedImageMirrors collect: [:each | mirrorEntry: each])]]
)
header = (

	^ h3: ( row: {
		label: 'Unversioned Classes'.
		largeBlank.
		link:  'Add All' action: [
			unversionedImageMirrors do: [:each | subject addMirror: each actualMirror].
			refreshImageBasedChangePresenter].
		filler})
)
mirrorEntry: mirror = (

	^ row: {
		addButtonWithAction: [
			subject addMirror: mirror actualMirror.
			refreshImageBasedChangePresenter].
		mediumBlank.
		label: mirror name}
)
refreshImageBasedChangePresenter = (

	sendUp refreshImageBasedChangePresenter
))
class VersionPresenter onSubject: subject = BasePresenter onSubject: subject (|
|)
('as yet unclassified'
definition = (

	| toggle |
	toggle:: 
		heading: (row: {
			link: subject message action: [toggle toggle].
			mediumBlank.
			(label: '[', subject author, ']') color: Color gray.
			mediumBlank.
			subject isParentOfImage
				ifTrue: [
					row: {
						label: '(current)' asText allBold.
						mediumBlank}]
				ifFalse: [nothing].
			link: 'load' action: [loadIntoImage]})
		details: [
			| unequalDiffSubjects |
			column: {
				label: subject internalId asString.
				column: (subject unequaldiffsFromPrevious collect: [:each | 
					each presenter])}].
	^ toggle
)
loadIntoImage = (

	refreshSCAfter: [subject loadIntoImage]
)))
class SourceControlSubject onModel: model = Subject onModel: model (|
	title = 'MemoryHole'.
	mergingUI = MergingUI new.
	
	
|)
(
class LocalRepositorySubject onModel: model = Subject onModel: model (|

|model refresh)
(
class HistorianSubject onModel: model = Subject onModel: model (|
|)
('as yet unclassified'
name = (

	^ model name
))
class ImageBasedChangeSubject onModel: model = Subject onModel: model (|
	cachedMergeSubjects
	cachedVersion
	newlyAddedMirrors = Set new.
|)
('as yet unclassified'
addMirror: mirror = (

	newlyAddedMirrors add: mirror.
	clearCaches
)
buildVersion = (

	| v 	nilsAndMirrors |
	v:: historian repository createNewVersion.
	
	"Determines the classes in the image that correspond to the classes in the historian. I'm not sure how this can be extended to properly support renames, without having to check all classes in the image for possible correspondence. We could try to use renaming information provided by the external system."
	nilsAndMirrors:: historian version mirrors collect: [:each |
		logger
			log: 'Loading mirror corresponding to ', each name
			around: [
				sourceMirrors
					mirrorForClassInImageCorrespondingTo: each
					ifPresent: [:it | it]
					ifAbsent: [nil]]].
	v mirrors: newlyAddedMirrors, (nilsAndMirrors reject: [:each | nil = each]).
	v parents: {historian version}.
	^ v
)
changedDiffSubjects = (

	^ mergeSubjects reject: [:each | each mergeModel isEquals]
)
clearCaches = (

	cachedVersion:: nil.
	cachedMergeSubjects:: nil.
)
commit: message = (

	version
		mirrors: (mergingUI presentMirrorsOf: mergeSubjects ifFail: [logger error: 'unexpected']);
		message: message.
	historian commit: version.
)
createPresenter = (
	^ ImageBasedChangePresenter onSubject: self
)
hasChanges = (

	^ version diffsFromFirstParent anySatisfy: [:each |
		each isEquals not]
)
historian = (

	^ model
)
historianName = (

	^ historian name
)
mergeSubjects= (

	nil = cachedMergeSubjects ifTrue: [
		cachedMergeSubjects:: version diffsFromFirstParent collect: [:each |
			diffSubjectOn: each]].
	^ cachedMergeSubjects
)
revertImage = (

	historian loadIntoImage
)
unversionedImageMirrors = (

	^ (sourceMirrors imageMirrorsNotCorrespondingTo: version mirrors, newlyAddedMirrors) 
		sort: [:a :b | a name < b name]
)
version = (

	nil = cachedVersion ifTrue: [
		cachedVersion:: buildVersion].
	^ cachedVersion
))
class LocalHistorianSubject onModel: model = HistorianSubject onModel: model (|

	public trackedHistorianAccessor = TrackedHistorianAccessor new.
|)
(
class HistorianRelationSubject onModel: oh = Subject onModel: oh (
"Allows interacting with other historians"|

|)
('as yet unclassified'
canForwardOtherHistorian = (

	^ otherHistorian canForwardTo: historian
)
canForwardToOtherHistorian = (

	^ historian canForwardTo: otherHistorian
)
canMerge = (

	^ historian canMergeWith: otherHistorian
)
createPresenter = (

	^ HistorianRelationPresenter onSubject: self
)
forwardOtherHistorian = (

	otherHistorian setTo: historian version ifFail: [logger warn: 'Could not forward historian'].
	loadIfImageHistorian: otherHistorian
)
forwardToOtherHistorian = (

	historian setTo: otherHistorian version ifFail: [logger error: 'Could not forward historian'].
	loadIfImageHistorian: historian
)
historianIsImageHistorian = (

	^ historian = imageHistorian
)
incomingVersionSubjects = (

	| versions |
	versions:: historian versionsIncomingFrom: otherHistorian.
	^ versions collect: [:each | VersionSubject onModel: each]
)
mergeFromOtherHistorianSubject = (

	^ MergeHistoriansSubject merging: otherHistorian into: historian
)
mergeIntoOtherHistorianSubject = (

	^ MergeHistoriansSubject merging: historian into: otherHistorian
)
otherHistorian = (

	^ model
)
otherHistorianAndRepositoryName = (

	^ otherHistorian repository = repository
		ifTrue: ['local ', otherHistorian name]
		ifFalse: [otherHistorian name, ' on ', otherHistorian repository name]
)
otherHistorianIsImageHistorian = (

	^ otherHistorian = imageHistorian
)
outgoingVersionSubjects = (

	| versions |
	versions:: otherHistorian versionsIncomingFrom: historian.
	^ versions collect: [:each | VersionSubject onModel: each]
)
runActionOn: receiver = (

	canMerge ifTrue: [
		^ receiver merge].
	canForwardToOtherHistorian ifTrue: [
		^ receiver forwardToOther].
	canForwardOtherHistorian ifTrue: [
		^ receiver forwardOther].
	^ receiver inSynch
))
class IncomingOutgoingSubject onModel: otherHistorian = Subject onModel: otherHistorian (|

|)
('as yet unclassified'
createPresenter = (

	^ IncomingOutgoingPresenter onSubject: self
)
incomingVersionSubjects = (

	| versions |
	versions:: historian versionsIncomingFrom: otherHistorian.
	^ versions collect: [:each | VersionSubject onModel: each]
)
otherHistorian = (

	^ model
)
otherHistorianName = (

	^ otherHistorian name
)
outgoingVersionSubjects = (

	| versions |
	versions:: otherHistorian versionsIncomingFrom: historian.
	^ versions collect: [:each | VersionSubject onModel: each]
))
class TrackedHistorianAccessor = (
"Accessing a tracked historian can be slow. Funnel all access to it through this accessor to make it possibly slow commands explicit."|
	private cachedTrackingState
	private cachedTrackedHistorian
|)
('as yet unclassified'
computeTrackedHistorian = (

	cachedTrackedHistorian:: historian
		trackedHistorianifPresent: [:tr |
			cachedTrackingState:: #tracked.
			tr]
		ifAbsent: [cachedTrackingState:: #untracked.]
		ifError: [cachedTrackingState:: #error]
)
errorAccessingTrackingHistorian = (

	^ trackingState = #error
)
isTracking = (

	^ trackingState = #tracked
)
trackedHistorian = (

	nil = cachedTrackedHistorian ifTrue: [computeTrackedHistorian].
	^ cachedTrackedHistorian
)
trackingState = (

	nil = cachedTrackingState ifTrue: [computeTrackedHistorian].
	^ cachedTrackingState
))'as yet unclassified'
cloneAs: cloneName ifFail: failBlock = (

	^ model cloneAs: cloneName ifFail: failBlock
)
createPresenter = (

	^ LocalHistorianPresenter onSubject: self
)
deleteHistorianIfFail: failBlock = (

	model deleteIfFail: failBlock
)
historian = (

	^ model
)
historianRelationSubjects = (

	^ Array streamContents: [:stream |
		trackedHistorianAccessor isTracking ifTrue: [stream nextPut: (HistorianRelationSubject onModel: trackedHistorianAccessor trackedHistorian)].
		imageHistorian = historian ifFalse: [
			stream nextPut: (HistorianRelationSubject onModel: imageHistorian)]]
)
isImageHistorian = (

	^ model = imageHistorian
)
loadIntoImage = (

	model loadIntoImage
)
shareNamesAndActionOf: remoteRepository = (

	"We could put this into shareNamesAndActions if we had closures"
	^ {remoteRepository name.
		[model shareTo: remoteRepository]}
)
shareNamesAndActions = (

	^ remoteRepositories collect: [:each |
		shareNamesAndActionOf: each]
))
class LogSubject onModel: model = Subject onModel: model (|
|)
('as yet unclassified'
createPresenter = (

	^ LogPresenter onSubject: self
)
versions = (

	^ model logStream contents collect: [:each |
		VersionSubject onModel: each]
))
class MergeHistoriansSubject onModel: model = Subject onModel: model (|
cachedMergeSubjects

version = newVersion.
|)
('as yet unclassified'
createPresenter = (

	^ MergeHistorianPresenter onSubject: self
)
destinationHistorian = (

	^ model second
)
mergeDestinationName = (

	^ destinationHistorian name
)
mergeIfFail: failBlock = (

	version
		mirrors: (mergingUI presentMirrorsOf: mergeSubjects ifFail: failBlock);
		message: 'Merged from ', sourceHistorian name.
	destinationHistorian commit: version.
	"While we usually do not load the version created by a commit (as not all changes may have been committed), we do so in this case to bring external changes into the image"
	loadIfImageHistorian: destinationHistorian
)
mergeSourceName = (

	^ sourceHistorian name
)
mergeSubjects = (

	cachedMergeSubjects = nil ifTrue: [ | diffs |
		diffs:: destinationHistorian version diffsFrom: sourceHistorian version.
		cachedMergeSubjects:: diffs collect: [:each | mergeSubjectOn: each]].
	^ cachedMergeSubjects
)
newVersion = (

	| v |
	v:: repository createNewVersion.
	v parents: {sourceHistorian version. destinationHistorian version}.
	^ v
)
sourceHistorian = (

	^ model first
)) : ('as yet unclassified'
merging: sourceHistorian into: destinationHistorian = (

	^ MergeHistoriansSubject
		onModel: {sourceHistorian. destinationHistorian}
))
class RemoteHistorianSubject onModel: model = HistorianSubject onModel: model (|
|)
('as yet unclassified'
createPresenter = (

	^ RemoteHistorianPresenter onSubject: self
)
isTracked = (

	^ model isTracked
)
trackAs: name = (

	model trackAs: name
))
class RemoteRepositorySubject onModel: model = Subject onModel: model (|
|)
('as yet unclassified'
createPresenter = (

	^ RemoteRepositoryPresenter onSubject: self
)
historianSubjects = (

	^ model historians collect: [:each |
		RemoteHistorianSubject onModel: each]
)
name = (

	^ model name
))
class VersionSubject onModel: model = Subject onModel: model (|
|)
('as yet unclassified'
author = (

	^ model author
)
createPresenter = (

	^ VersionPresenter onSubject: self
)
internalId = (

	^ model internalId
)
isParentOfImage = (

	^ model isParentOfImage
)
loadIntoImage = (

	model loadIntoImage
)
message = (

	^ model message
)
unequaldiffsFromPrevious = (

	| diffsFromPrevious |
	diffsFromPrevious:: model diffsFromFirstParent collect: [:each | diffSubjectOn: each].
	^ diffsFromPrevious reject: [:each | each isEquals]
))'as yet unclassified'
= other = (
	^class = other class and: [model = other model]
)
createPresenter = (

	^ LocalRepositoryPresenter onSubject: self
)
hash = (
	^model hash
)
imageHistorian = (

	^ model imageHistorian
)
loadIfImageHistorian: historian = (

	"Before this, we had a historian check whether it is the image historian on setTo:ifFail:. It turns out, that there are cases where it's desirable to change a historian's version without changing the code in the image, for example when doing partial commits.
	The new strategy is to have callers of setTo: distinguish the two cases. Ideally we wouldn't distinguish 'commit' and 'setTo'. Then we could offer a 'updatingImageSet:to:ifFail:"
	imageHistorian = historian ifTrue: [
		imageHistorian loadIntoImage]
)
localHistorianSubjects = (

	^ model historians collect: [:each | LocalHistorianSubject onModel: each].
)
logSubject = (

	^ LogSubject onModel: repository
)
modifiedInImageSubject = (

	^ ImageBasedChangeSubject
		onModel: model imageHistorian.
)
remoteRepositories = (

	^ model remoteRepositories
)
remoteRepositorySubjects = (

	^ remoteRepositories collect: [:each | RemoteRepositorySubject onModel: each].
)
repository = (

	^ model
)
repositoryName = (

	^ model repositoryId
)
repositoryType = (

	^ model repositoryType
)
title = (
	^'[',repositoryType,'] ',repositoryName
))'as yet unclassified'
= other = (
	^self class = other class and: [self model = other model]
)
createPresenter = (

	^ SourceControlPresenter onSubject: self
)
diffSubjectOn: diff = (

	"TODO: dispatch on the kind of diff"
	^ mergingUI ClassMirrorMergeSubject diffSubjectOn: diff
)
hash = (
	^model hash
)
mergeSubjectOn: diff = (

	"TODO: dispatch on the kind of diff"
	^ mergingUI ClassMirrorMergeSubject mergeSubjectOn: diff
)
modifiedLocalRepositorySubjects = (

	^ model collect: [:each | LocalRepositorySubject onModel: each]
)
removeRepository: r = (
	model remove: r.
)
shutdown = (

	"If our model is simply some repositories we don't really own VCS and thus shouldn't be allowed to shut it down, should we?"
	[vcs shutdown] ifError:[]
)
sourceControlSubject = (

	^ self
)) : ()'accessing'
columnSeparator = (

	^ BlankFragment size: 12
)
halfColumnSeparator = (

	^ BlankFragment size: 6
)'as yet unclassified'
forkAndRemember: b= (
	vcs core forkAndRemember: b
)
mainSubject = (
	^SourceControlSubject onModel: theModel
)) : ()