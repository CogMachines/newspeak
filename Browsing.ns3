Newspeak3
'HopscotchIDE'
class Browsing usingPlatform: p ide: ide = (
(* Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2011 Ryan Macnak and other contributors.
Copyright 2012 Cadence Design Systems, Inc.
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)||
	private Dictionary = p collections Dictionary.
	private OrderedCollection = p collections OrderedCollection.
	private Set = p collections Set.
	private Menu = p brazil menus Menu.
	private MenuItem = p brazil menus MenuItem.
	private SeparatorItem = p brazil menus SeparatorItem.
	private EditableLinePresenter = p hopscotch fragments EditableLinePresenter.
	private OutlineItem = p hopscotch outline OutlineItem.
	private Subject = p hopscotch core Subject.
	private MethodMirror = p mirrors MethodMirror.
	private ClassDeclarationMirror = p mirrors ClassDeclarationMirror.
	private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	private Color = p graphics Color.
	
	private MethodReference = p squeak MethodReference.
	private PackageOrganizer = p squeak PackageOrganizer.
	private Smalltalk = p squeak Smalltalk.
	private SystemNavigation = p squeak SystemNavigation.
	private HopscotchImages = p squeak HopscotchImages.
	private SHTextStylerST80 = p squeak SHTextStylerST80.
	private SystemOrganization = p squeak SystemOrganization.
	
	ide = ide.
	systemScope = ide systemScope.
	IDEWindow = ide tools IDEWindow.
	DefinitionListPresenter = ide tools DefinitionListPresenter.
	ProgrammingPresenter = ide tools ProgrammingPresenter.
	ExemplarMethodPresenter = ide tools ExemplarMethodPresenter.	
	PackageSubject = ide browsingMisc PackageSubject.
	NSMethodSubject = ide browsingNS NSMethodSubject.
	InitializerMethodSubject = ide browsingNS InitializerMethodSubject.
	GlobalReferencesSubject = ide browsingST GlobalReferencesSubject.
	MethodInheritanceSubject = ide browsingST MethodInheritanceSubject.
	STMethodSubject = ide browsingST STMethodSubject.
	CodeEditorFragment = ide tools CodeEditorFragment.
	DefinitionResidue = ide tools DefinitionResidue.
	DefinitionTemplate = ide tools DefinitionTemplate.
	private Root = ide namespacing Root.
	||) (
public class AssortedMethodsPresenter onSubject: s = DefinitionListPresenter onSubject: s (
(* The subject is a collection of MethodSubjects that can come from diverse sources (in the sense that they do not have to belong to the same class). The presenter displays them as a column of expandable method presenters and takes care of reasonably handling the various creation and deletion requests coming from them.  I group my methods by their containing package.

Slots
	title	<String>	The title to use for the presenter
	methodPresenters <OrderedCollection[ExpandableMethodPresenter]> Because the method presenters are grouped by package, if we need to expand or collapse those presenters, we only want to expand or collapse the method presenters.  The group heading is not expandable (or collapsable). *)|
	public title::= 'Assorted Methods'.
	methodPresenters ::= OrderedCollection new.
|) (
'accessing'
methodsGroupedByPackage = (

	| packages |
	packages:: Dictionary new.
	subject methodSubjects do: 
		[:aSubject |
		(packageOfMethod: aSubject) ifNotNil:
			[:aPackage |
			(packages 
				at: aPackage packageName 
				ifPresent: [:e|]
				ifAbsentPut: [OrderedCollection new]) add: aSubject]].
	^packages
)
'actions'
collapseAll = (
respondToCollapse:  methodPresenters
)
expandAll = (
respondToExpand:  methodPresenters
)
respondToCollapse: presenters = (

	majorUpdate: [presenters do: [:each | each collapse]]
)
respondToExpand: presenters = (

	majorUpdate: [presenters do: [:each | each expand]]
)
'as yet unclassified'
compileMethod: source <String> inPresenter: requestor <Presenter> ifCompiledAsSame: successResponse <[]> ifCompiledAsNew: successNewResponse <[]|[:Object]> ifFailed: failureResponse <[]|[:Object]> = (

	requestor subject
		compileNewSource: source
		ifSuccess: successResponse
		ifNewMethod: 
			[:newSelector | | newReference newPresenter |
			newReference:: MethodReference 
				class: requestor subject implementingClass
				selector: newSelector.
			newPresenter:: ExpandableMethodPresenter
				onSubject: (MethodSubject onMethod: newReference).
			suffixes add: newPresenter.
			successNewResponse value.
			(suffixes detectPresenter:
				[:some |
				some subject methodReference = newReference]) 
				expand]
		ifFailure: failureResponse
)
contentPresenters = (

	^Array streamContents: 
		[:stream | | groups |
		groups:: methodsGroupedByPackage.
		(groups keys asArray copyWithout: nil) sort do:
			[:packageName | | presenters gm |
			presenters:: OrderedCollection new.
			gm:: methodPresentersGroupedByEnclosingClass: (groups at: packageName).
			stream nextPut: 
				(minorHeadingBlock: 
					(row: {
						link: packageName asText allBold action: [browsePackage: packageName].
						filler.
						expandButtonWithAction: [respondToExpand: presenters].
						blank: 3.
						collapseButtonWithAction: [respondToCollapse: presenters].
					})).
			stream nextPut: mediumBlank.
			(gm values asSortedList: [:a :b | a size < b size]) do:
				[:v |  | moduleOrClass |
				presenters addAll: v.
				moduleOrClass:: v first subject enclosingClasses last.
				(* Only show when it is above a threshold *)
				v size > 2 ifTrue:
					[stream nextPut: smallBlank.
					stream nextPut: (row: {link: moduleOrClass name asText action: [browseClass: moduleOrClass]})].
				stream nextPutAll: v].
			methodPresenters addAll: presenters.
			stream nextPut: mediumBlank]]
)
packageOfMethod: method <MethodSubject> ^<PackageSubject> = (

	| registry mirror implementingClass package |
	registry:: PackageOrganizer default.
	implementingClass:: method implementingClass.
	implementingClass ifNil: [^nil].
	mirror:: ClassDeclarationMirror reflecting: implementingClass theNonMetaClass mixin.
	[mirror enclosingClass notNil]
		whileTrue: [mirror: mirror enclosingClass].

	package:: implementingClass language isNewspeakLanguage3 not
		ifTrue: [registry packageOfMethod: method model ifNone: []]
		ifFalse: [registry packageOfClass: mirror reflectee definingClass ifNone: []].
	^package = nil
		ifTrue: [PackageSubject onModel: method implementingClass theNonMetaClass category]
		ifFalse: [PackageSubject onModel: package packageName]
)
'private'
methodPresentersGroupedByEnclosingClass: methodSubjects = (
	| groupedMethods |
	groupedMethods:: Dictionary new.
	methodSubjects do:
		[:aSubject | |methods|
		(* sadly there is no #at:ifAbsentPut: *)
		methods:: groupedMethods
			at: aSubject enclosingClasses last name
			ifPresent: [:oc | oc]
			ifAbsentPut: [OrderedCollection new].
		methods add: (newExpandableMethodPresenter: aSubject)].
	^groupedMethods
)
newExpandableMethodPresenter: s <MethodSubject> = (	
	^s createPresenter
		showClassName: true;
		showClassLink: true
)
'requests'
deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (

	| requestorSubject source residue |
	requestorSubject:: presenter subject.
	source:: requestorSubject source.
	requestorSubject
		deleteMethodIfSuccess:
			[residue:: DefinitionResidue new
				caption: 'Deleted method ', requestorSubject selector;
				definitionText: source;
				restoreResponse: 
					[methodResidueAccepted: residue.
					suffixes remove: residue];
				forgetResponse: [suffixes remove: residue].
			suffixes add: residue.
			content remove: presenter.
			successResponse value]
		ifFailure: failureResponse value
)
) : (
)
public class AssortedMethodsSubject onModel: m = Subject onModel: m (|
	public title ::= 'Assorted Methods'.
|) (
'as yet unclassified'
public methodSubjects = (
	^model
)
'protected'
public createPresenter = (
	^(AssortedMethodsPresenter onSubject: self) title: title
)
'restricted'
public refreshmentSubject = (
	^super refreshmentSubject
		title: title;
		yourself
)
) : (
)
class ClassMethodsPresenter onSubject: s = DefinitionListPresenter onSubject: s (
(* The subject is a class subject. Displays methods of the class as expandable entries and supports compilation and other requests. Another similar presenter is an AssortedMethodsPresenter, but that one displays a collection of methods which do not necessarily belong to the same class, such as all senders of a selector. *)| presenterCreationBlock groupedByCategory::= true. subclassResponsibilitiesList seeAllLinkHolder showingPartialList::=true. |) (
'actions'
addMethodTemplate = (

	addMethodTemplate: ''
)
addMethodTemplate: src = (

	prefixes add:
		(DefinitionTemplate new
			initialText: src;
			caption: 'Adding new method:';
			acceptResponse:
				[:template | 
				createMethodFromTemplate: template];
			cancelResponse: 
				[:template | prefixes remove: template])
)
collapseAll = (

	majorUpdate:
		[content presenters do: [:each | each collapse]]
)
expandAll = (

	majorUpdate:
		[content presenters do: [:each | each expand]]
)
restoreMethodResidue: aResidue = (

	| newSelector |
	newSelector:: subject 
		compile: aResidue definitionText 
		classified: aResidue extraData.
	refreshContentList.
	newSelector notNil ifTrue:
		[suffixes remove: aResidue.
		(content detectPresenter: [:some | some subject selector = newSelector]) 
			expand]
)
switchSortOrder = (

	groupedByCategory: groupedByCategory not.
	majorUpdate: [content presenters: retrievePresenters].
	notifyOfPossibleOutlineChange
)
'as yet unclassified'
addMethodIn: cls proposedSource: src = (
subject classObject == cls ifTrue:
	[addMethodTemplate: src]
)
maybePartialSubjectListByCategory ^<Collection[MethodSubject]> = (
	(* Retrieve the subjects to show--not more than initialSizeLimit elements if there are too many--sorted by method category. Set the showingPartialList flag according to whether the result is a full list or not. *)


	| result |
	result:: OrderedCollection new: initialSizeLimit.
	subject sortedCategories do:
		[:each |
		(subject methodSubjectsInCategory: each) do:
			[:eachSubject |
			result add: eachSubject.
			result size >= initialSizeLimit ifTrue:
				[showingPartialList:: true.
				^result]]].
	showingPartialList:: false.
	^result
)
maybePartialSubjectListBySelector ^<Collection[MethodSubject]> = (
	(* Retrieve the subjects to show--not more than initialSizeLimit elements if there are too many--sorted by selector. Set the showingPartialList flag according to whether the result is a full list or not. *)

	| subjects |
	subjects:: (subject methodSubjects) select: 
		[:some | some methodCategoryOrNil notNil].
	subjects:: subjects asSortedCollection: [:a :b | a selector < b selector].
	showingPartialList:: subjects size > initialSizeLimit.
	^showingPartialList 
		ifTrue: [subjects copyFrom: 1 to: initialSizeLimit]
		ifFalse: [subjects]
)
retrieveAllSubjects = (

	showingPartialList:: false.
	^groupedByCategory
		ifTrue:
			[ | result |
			result:: OrderedCollection new: initialSizeLimit.
			subject sortedCategories do:
				[:each |
				result addAll: (subject methodSubjectsInCategory: each)].
			result]
		ifFalse:
			[ | subjects |
			subjects:: (subject methodSubjects) select: 
				[:some | some methodCategoryOrNil notNil].
			subjects asSortedCollection: [:a :b | a selector < b selector]]
)
'definition'
definition = (
^
	column: {
		minorClassHeadingBlock: (
			row: {
				label: (subject classIsMeta
					ifTrue: ['Class methods']
					ifFalse: ['Instance methods']).
				largeBlank.
				addButtonWithAction: [addMethodTemplate].
				filler.
				expandButtonWithAction: [expandAll].
				blank: 3.
				collapseButtonWithAction: [collapseAll].
				blank: 3.
				reorderButtonWithAction: [switchSortOrder].
				}).
		prefixes:: list.
		content:: list.
		suffixes:: list.
		seeAllLinkHolder:: holder: nothing.
		deferred: 
			[subclassResponsibilitiesList:: list: subclassResponsibilitiesPresenters].
	}
)
presenterForSubclassResponsibility: aReference = (

	| toggle |
	toggle:: 
		collapsed:
			((link: aReference methodSymbol, ' (unimplemented subclass responsibility)'
			action: [toggle toggle]) color: Color lightGray)
		expanded:
			[DefinitionTemplate new
				caption: 'Subclass responsibility from ', aReference actualClass name, '>>', aReference methodSymbol;
				initialText: aReference source;
				acceptResponse: [:t | createMethodForSubclassResponsibility: t]].
	^toggle
)
subclassResponsibilitiesPresenters = (

	^(subject retrieveUnimplementedAbstractMethods 
		asSortedList: [:a :b | a methodSymbol < b methodSymbol])
			collect: [:each | presenterForSubclassResponsibility: each]
)
'initialize-release'
public presenterClass: aClass = (

	presenterCreationBlock:: [:each | aClass onSubject: each]
)
'notices'
noticeSubstanceCreation = (

	refreshContentList
)
'parameters'
initialSizeLimit ^<Integer> = (
	(* At most this many methods are displayed at first. *)

	^60
)
'private'
loadFullContentList = (

	showingPartialList:: false.
	majorUpdate: [content presenters: retrievePresenters].
	refreshSeeAllHolder
)
refreshContentList = (

	content presenters: retrievePresenters.
	refreshSeeAllHolder
)
refreshSeeAllHolder = (

	seeAllLinkHolder content:
		(showingPartialList 
			ifTrue:
				[row: { 
					mediumBlank. 
					(link: 'show all methods...' action: [loadFullContentList])
						tinyFont
					}]
			ifFalse:
				[nothing])
)
retrieveAllPresenters = (

	^retrieveAllSubjects collect: presenterCreationBlock
)
retrievePresenters = (

	^showingPartialList
		ifTrue: [retrieveSubjects collect: presenterCreationBlock]
		ifFalse: [retrieveAllSubjects collect: presenterCreationBlock]
)
retrieveSubjects = (

	^groupedByCategory
		ifTrue: [maybePartialSubjectListByCategory]
		ifFalse: [maybePartialSubjectListBySelector]
)
'requests'
compileMethod: source <String> inPresenter: requestor <Presenter> ifCompiledAsSame: successResponse <Block> ifCompiledAsNew: successNewResponse <Block> ifFailed: failureResponse <Block> = (

	| newPresenter |
	requestor subject
		compileNewSource: source
		ifSuccess: successResponse
		ifNewMethod: 
			[:newSelector |
			successNewResponse value.
			loadFullContentList.
			newPresenter:: 
					content detectPresenter: 
						[:some | some subject selector = newSelector].
			newPresenter
				expand;
				requestVisibility]
		ifFailure: failureResponse
)
createMethodForSubclassResponsibility: template <DefinitionTemplate> = (

	| newSelector newPresenter |
	newSelector:: subject compile: template text.
	loadFullContentList.
	newSelector notNil ifTrue:
		[subclassResponsibilitiesList remove: template parent.
		newPresenter:: 
			content detectPresenter: 
				[:some | some subject selector = newSelector].
		newPresenter
			expand;
			requestVisibility]
)
createMethodFromTemplate: template <DefinitionTemplate> = (

	| newSelector newPresenter |
	newSelector:: subject compile: template text.
	loadFullContentList.
	newSelector notNil ifTrue:
		[prefixes remove: template.
		newPresenter:: 
			content detectPresenter: 
				[:some | some subject selector = newSelector].
		newPresenter
			expand;
			requestVisibility]
)
deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (

	| requestorSubject source category residue |
	requestorSubject:: presenter subject.
	source:: requestorSubject source.
	category:: requestorSubject methodCategory.
	requestorSubject
		deleteMethodIfSuccess:
			[residue:: DefinitionResidue new
				caption: requestorSubject selector, ' (deleted method)';
				definitionText: source;
				extraData: category;
				restoreResponse: 
					[restoreMethodResidue: residue.
					suffixes remove: residue];
				forgetResponse: [suffixes remove: residue].
			loadFullContentList.
			suffixes add: residue.
			successResponse value]
		ifFailure: failureResponse
)
recategorizeMethodIn: presenter <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (

	| newName |
	newName:: newCategoryName withBlanksTrimmed.
	newName isEmpty ifTrue: [^failureResponse value].
	presenter subject
		changeCategoryTo: newName asSymbol
		ifSuccess: 
			[loadFullContentList.
			presenter requestVisibility.
			successResponse value]
		ifFailure: failureResponse
)
) : (
)
class ClassMethodsSubject onModel: m = Subject onModel: m (
(* The model is the class object. (Used for Smalltalk and NS1 classes). Represents the perspective of looking at the list of mehods of the class. *)|  |) (
'accessing'
public classIsMeta = (

	^classObject isMeta
)
classObject = (

	^model
)
public compile: source = (

	^classObject compile: source
)
public compile: source <String> classified: categoryName <Symbol> = (

	^classObject compile: source classified: categoryName
)
public createPresenter = (

	^ClassMethodsPresenter onSubject: self
)
public retrieveUnimplementedAbstractMethods ^<Collection[MethodReference]> = (
	(* Answer a collection of MethodReferences to abstract methods of superclasses that the class would need to implement in order to be concrete. *)

	^model superclass
		ifNil: [Array new]
		ifNotNil:
			[:superclass | | result |
			result:: OrderedCollection new.
			addAbstractMethodsOf: superclass notIn: model selectors to: result.
			result]
)
public sortedCategories ^<Collection[Symbol]> = (
	(* Answer a collection of category names found in the class, sorted with initialization first and private categories last. *)

	| categories init privateCategories unclassified lineup |
	categories:: classObject organization categories asSet.
	init:: categories select: [:each | 'init*' match: each].
	categories:: categories difference: init.
	privateCategories:: categories select: [:each | 'private*' match: each].
	categories:: categories difference: privateCategories.
	(categories includes: #'as yet unclassified')
		ifTrue:
			[unclassified:: {#'as yet unclassified'}.
			categories remove: #'as yet unclassified']
		ifFalse:
			[unclassified:: {}].
	lineup:: OrderedCollection new: categories size.
	lineup 
		addAll: unclassified;
		addAll: init asSortedCollection;
		addAll: categories asSortedCollection;
		addAll: privateCategories asSortedCollection.
	^lineup
)
'as yet unclassified'
methodSubjectForSelector: selector <Symbol> ^ <MethodSubject> = (

	^MethodSubject
		onMethod: (MethodReference class: classObject selector: selector)
)
methodSubjects = (

	^classObject selectors collect:
		[:each | methodSubjectForSelector: each]
)
public methodSubjectsInCategory: categoryName <Symbol> ^<Collection[MethodSubject]> = (

	^(classObject organization listAtCategoryNamed: categoryName)
		asSortedCollection
			collect: [:each | methodSubjectForSelector: each]
)
'private'
addAbstractMethodsOf: aClass notIn: selectorSet to: resultCollection = (

	| implementedHere |
	implementedHere:: Set new.
	aClass selectorsAndMethodsDo:
		[:eachSelector :eachMethod |
		(selectorSet includes: eachSelector) ifFalse:
			[eachMethod isAbstract
				ifTrue: [resultCollection add: 
							(MethodReference class: aClass selector: eachSelector)]
				ifFalse: [implementedHere add: eachSelector]]].
	aClass superclass ifNotNil: 
		[:superclass |
		addAbstractMethodsOf: superclass
		notIn: (selectorSet union: implementedHere)
		to: resultCollection]
)
) : (
)
public class ClassSubject onModel: m = Subject onModel: m (
(* Represents a view of a class in the system. This is an abstract class. Concrete subclasses will implement class access in terms appropriate to the language of the class. The model they will use will again depend on the language. The one thing we assume about the model is that it behaves ''properly'' with respect to #= (and #hash), so that a ClassSubject can rely on the model for its own equality comparison. *)|  |) (
'accessing'
public = anotherSubject = (

	^(anotherSubject class = self class)
		and: [anotherSubject model = model]
)
public classOrMirror ^<Behavior | ClassDeclarationMirror> = (
	^model
)
public hash = (

	^model hash
)
'as yet unclassified'
public classCommentText ^<String> = (

	subclassResponsibility
)
public classCommentText: newComment <String> = (

	subclassResponsibility
)
classDefinition = (

	subclassResponsibility
)
classLanguage = (

	^model language
)
public className = (

	subclassResponsibility
)
public classUiDescription = (
	^ide languageUiDescriptionRegistry descriptionFor: classLanguage
)
public isAbstract = (
	(* Answer true if any methods are marked as abstract. *)
	^false
)
public isRecentlyVisited ^<Boolean> = (
	(* Answer true if the class is known to Hopscotch to be recently visited. Some presenters highlight such classes. *)

	^ide defaultPopularityRecord classVisits 
		includes: implementationClass
)
public methodCount = (

	subclassResponsibility
)
public totalSubclassCount = (

	subclassResponsibility
)
) : (
)
class EditableClassNamePresenter onSubject: s = EditableLinePresenter onSubject: s (
(* The subject is an STClassSubject. The presenter displays the name of the class and allows to edit it. *)|  |) (
'actions'
respondToAccept = (

	| oldName newName referencesToFix |
	newName:: editor text asString asSymbol.
	(Smalltalk includesKey: newName) ifTrue:
		[^nil].
	oldName:: subject className.
	subject model rename: newName.
	leaveEditState.
	flag: #bogus. (* Get rid of Smalltalk and SystemNavigation dependencies below *)
	referencesToFix:: SystemNavigation default allCallsOn: (Smalltalk associationAt: newName).
	referencesToFix notEmpty ifTrue:
		[enterSubject: (GlobalReferencesSubject onModel: newName)]
)
'as yet unclassified'
definitionText = (

	^subject className
)
viewerDefinition = (

	^link: [definitionText asText allBold]
		action: [sendUp browseClassOrMirror: subject model].
)
) : (
)
public class EditableNSClassNamePresenter onSubject: s = EditableClassNamePresenter onSubject: s (
(*  *)|  |) (
'as yet unclassified'
browseClassMirror: aMirror = (

	ide defaultPopularityRecord rememberClassVisit: aMirror reflectee.
	enterSubject:: ide browsingNS classSubjectOn: aMirror.
)
respondToAccept = (

	| oldName newName builder klass |

	newName:: editor text asString asSymbol.
	oldName:: subject className. (* simple? *)

	newName = oldName ifTrue: [^leaveEditState].

	builder:: ClassDeclarationBuilder reflecting: subject model reflectee.

	builder enclosingClass ifNil: [ (* Top level class *)
		(Root includesKey: newName) ifTrue: 
			[Error signal: 'A top level class already exists with the name ', newName].
	].

	builder header name: newName.
	builder install.

	builder enclosingClass ifNil: [ (* Top level class *)
		klass:: Smalltalk removeKey: oldName.
		klass setName: newName.
		Root at: newName put: klass.
		SystemOrganization classify: newName under: klass category.
		SystemOrganization removeMissingClasses.
	].

	leaveEditState.
)
) : (
)
public class ExpandableMethodPresenter onSubject: s = MethodPresenter onSubject: s (
(* The subject is an STMethodSubject or a similar thing. Displays as a line with the selector (optionally prepended with the class name if the showClassName slot is set to true), expandable into a full editor. *)| showClassName::=false. showClassLink::=false. inspectionHolder headingAfterLeftHolder |) (
''
linkToBrowseEnclosingClass: klass <Behavior | Mixin> = (
	^(link: klass simpleName
		action: [browseClass: klass])
		color: secondaryTextColor
)
nestingInformationLine = (
	| enclosingClasses rowElements |
	enclosingClasses:: subject enclosingClasses.
	rowElements:: OrderedCollection new.
	enclosingClasses do:
		[:each |
		rowElements add: ((label: ' in ') color: tertiaryTextColor).
		rowElements add: (linkToBrowseEnclosingClass: each)].
	^row: rowElements asArray
)
selectorAndContainment = (
	^row: {
		(link: subject selector
			action: [substance userToggle]
			dragSubject: subject
			withImage: HopscotchImages default hsExpandImage) color: actionLinkColor.
		showClassName 
			ifTrue: [nestingInformationLine]
			ifFalse: [nothing].
		}
)
'actions'
public collapse = (
	^substance collapse
)
public expand = (

	^substance expand
)
goToMessages = (

	| messagesAndActions messageItems classItems |
	messagesAndActions:: OrderedCollection new.
	messagesAndActions add:
		subject selector -> [browseSelector: subject selector].
	messageItems:: referencesMenuMessageItems.
	classItems:: referencesMenuClassItems.
	messageItems isEmpty not ifTrue:
		[messagesAndActions 
			add: #separator;
			addAll: messageItems].
	classItems isEmpty not ifTrue:
		[messagesAndActions 
			add: #separator;
			addAll: classItems].
	openMenuWithLabelsAndActions: messagesAndActions
)
toggle = (

	^substance toggle
)
'as yet unclassified'
accessModifierIcon = (
	^ image: (iconForAccessModifier: subject accessModifier)
)
addOutlineItemsTo: parentItem = (
parentItem addChild:
	((OutlineItem onModel: self)
		text: subject selector)
)
categoryLink ^ <Fragment> = (
	^subject isSynthetic 
	    ifTrue: [(label: subject methodCategory) tinyFont color: Color gray]
	    ifFalse: [MethodCategoryPresenter onSubject: subject]
)
expandedMethod ^ <Fragment> = (
	^	[column: {
			methodHeading color: methodHeadingColor.
			methodDetails.
			}
		].	
)
methodActionsMenu = (

	| labelsAndActions <Array[Tuple[String, []]]>  |
	labelsAndActions::  {
		'Delete #', subject selector -> [respondToDelete].
		(* 'Versions' -> [respondToVersions]. *)
		(* 'Pretty Print' -> [respondToPrettyPrint]. *)
		#separator.
		'Inspect Compiled Method' -> [respondToInspectCompiledMethod].
		'Inspect Mirror' -> [inspect: subject model].
		#separator.
		'Inspect Presenter' -> [respondToInspectPresenter].
		}.
	^menuWithLabelsAndActions: labelsAndActions
)
methodDetails = (
	^super definition
)
parentClassSubject = (
^sendUp deliveryOptional parentClassSubjectDo: [:s | ^s]
)
respondToInspectCompiledMethod = (

	inspect: subject compiledMethod
)
respondToOutlineSelection = (
substance expand.
super respondToOutlineSelection
)
respondToRunTest = (
	self unimplemented. (* Does this make sense for Minitest? *)
)
respondToVersions = (
| cls |
cls:: subject implementingClass.
(* VersionsBrowser browseVersionsForClass: cls selector: subject selector. *)
enterSubject: (ide methodVersioning MethodHistorySubject onSelector: subject selector ofClass: cls)
)
sendersOfSubjectPresenter = (

	| count text |
	count:: subject usageCount.
	count = 0 ifTrue: [text:: 'no senders'].
	count = 1 ifTrue: [text:: '1 sender'].
	count > 1 ifTrue: [text:: count printString, ' senders'].
	^(link: text action: [browseSelector: subject selector]) 
		tinyFont color: secondaryTextColor
)
'definition'
definition = (
	| toggler |
	inspectionHolder:: holder: [nothing].
	toggler::
		collapsed: methodHeading
		expanded: expandedMethod.
	toggler onUserToggled: [toggler isExpanded ifTrue: [requestVisibility]].
	^toggler
)
inheritanceLinkWithIcon: image = (

	^linkImage: image action: 
		[enterSubject: subject asMethodInheritanceSubject]
)
methodHeading = (
	inspectionHolder:: holder: [nothing].
	headingAfterLeftHolder:: holder: [nothing].
	^row: {
		accessModifierIcon.
		smallBlank.
		(selectorAndContainment) compressibility: 1.
		mediumBlank.
		deferred: [overrideIcon].
		blank: 2.
		deferred: 
			[subject isSubclassResponsibility 
				ifTrue: 
					[image: HopscotchImages default tinySubclassResponsibilityImage]
				ifFalse: [nothing]].
		smallBlank.
		deferred: 
			[sendersOfSubjectPresenter].
		smallBlank.
		headingAfterLeftHolder.
		filler compressibility: 0.
		categoryLink.
		largeBlank.
		inspectionHolder.
		smallBlank.
		itemReferencesMenuButtonWithAction: [goToMessages].
		smallBlank.
		dropDownMenu: [methodActionsMenu].
	}
)
'private'
overrideIcon = (

	^isAnOverride 
		ifTrue:
			[isOverridden
				ifTrue: [inheritanceLinkWithIcon: HopscotchImages default itemBothOverride]
				ifFalse: [inheritanceLinkWithIcon: HopscotchImages default itemSuperOverride]]
		ifFalse:
			[isOverridden
				ifTrue: [inheritanceLinkWithIcon: HopscotchImages default itemSubOverride]
				ifFalse: [nothing]]
)
referencesMenuClassItems = (

	| items |
	items:: OrderedCollection new.
	subject variableBindingKeys asSortedList do:
		[:eachKey |
		(eachKey notNil and: [eachKey ~= subject className]) ifTrue:
			[items add:
				eachKey -> [browseClassNamed: eachKey]]].
	^items
)
referencesMenuMessageItems = (

	| items |
	items:: OrderedCollection new.
	subject messages asSortedList do:
		[:selector |
		selector == subject selector ifFalse:
			[items add:
				selector -> [browseSelector: selector]]].
	^items
)
refreshSource = (
(* Only refresh if we have the editor, i.e. we are expanded. *)

editor ifNotNil: [super refreshSource]
)
'requests'
recategorizeMethodIn: presenter <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (
	(* When the category is changed, both my expanded and collapsed state presenters need refreshing to reflect the new name. Here we effectively intercept category change requests from children to do so on success. *)

	sendUp
		recategorizeMethodIn: presenter
		under: newCategoryName
		ifSuccess: [refresh. successResponse value]
		ifFailed: failureResponse
)
'testing'
public isAnOverride = (

	^subject isAnOverrideIn: parentClassSubject
)
public isExpanded = (
	^substance isExpanded
)
public isOverridden = (

	^subject isOverriddenIn: parentClassSubject
)
) : (
)
class MethodCategoryPresenter onSubject: s = EditableLinePresenter onSubject: s (
(* The subject is an STMethodSubject (or a similar thing). The presenter displays the category of the method and allows to edit it. *)|  |) (
'actions'
changeCategoryTo: aSymbol = (

	sendUp
		recategorizeMethodIn: self
		under: aSymbol asString
		ifSuccess: [refresh]
		ifFailed: []
)
respondToAccept = (

	sendUp
		recategorizeMethodIn: self
		under: editor text asString
		ifSuccess: [leaveEditState]
		ifFailed: []
)
respondToClick = (
	(* Display a menu of appropriate categories. *)

	openMenu: 
		(buildCategoryChangeMenuWithNames:
			assembleListOfUsefulNames)
)
'definition'
viewerDefinition = (

	^(link: [subject methodCategory] action: [respondToClick])
		tinyFont color: Color gray.

(* The definition below will make this look almost like a drop-down.
	^row: {
		(link: [subject methodCategory] action: [respondToClick])
			tinyFont color: Color gray.
		blank: 3.
		linkImage: HopscotchImages default itemMenuImage
			action: [respondToClick]
		}
*)
)
'private'
assembleListOfUsefulNames = (
	(* Display a menu of appropriate categories. *)

	| names init pprivate result |
	names:: subject allMethodCategories copy remove: subject methodCategory ifAbsent:[]; yourself.
	result:: OrderedCollection new: names size.
	init:: names select: [:each | 'init*' match: each].
	names:: names reject: [:ea | init includes: ea].
	pprivate:: names select: [:each | 'private*' match: each].
	names:: names reject: [:ea | pprivate includes: ea].
	result
		addAll: init asSortedList;
		addAll: names asSortedList;
		addAll: pprivate asSortedList.
	^result
)
buildCategoryChangeMenuWithNames: names = (

	| menu |
	menu:: Menu forVisual: visual.
	names do:
		[:each |
		menu add: 
			(MenuItem 
				label: each 
				action: [changeCategoryTo: each])].
	menu add: SeparatorItem new.
	menu add:
		(MenuItem label: 'Enter Another Name' action: [enterEditState]).
	^menu
)
definitionText = (

	^subject methodCategory
)
) : (
)
class MethodPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(*  *)| editor |) (
'actions'
respondToAccept = (
	(* The user has just clicked the Save button in the editor. *)

	subject source asString = editor text asString ifFalse:
		[editor setText: subject source.
		^editor showMessage: 'Method changed after editing started. Click Save again to clobber those other changes.'].
	sendUp
		compileMethod: editor textBeingAccepted asString
		inPresenter: self
		ifCompiledAsSame:
			[editor defaultAcceptResponse]
		ifCompiledAsNew:
			[editor text: subject source.
			editor defaultCancelResponse]
		ifFailed:
			[:message | editor showMessage: message]
)
respondToDelete = (

	sendUp
		deleteMethodInPresenter: self
		ifSuccess: []
		ifFailure: []
)
'definition'
definition = (

	editor:: CodeEditorFragment new
		text: (subject source ifNil: ['<No source>']);
		acceptResponse: 
			[respondToAccept];
		cancelResponse:
			[editor text: subject source.
			editor leaveEditState]. 
	editor colorizerBlock: [:text | subject colorizeMethodSource: text].
	^editor
)
'private'
indicateMethodAsDeleted = (

	parent 
		replaceChild: self 
		with: ((label: subject selector, ' has been deleted') color: Color gray)
)
'restricted'
public refresh = (
subject isValid
	ifTrue: 
		[refreshSource.
		super refresh]
	ifFalse: 
		[indicateMethodAsDeleted]
)
refreshSource = (
| newSource |
newSource:: subject source.
newSource = editor text ifFalse:
	[editor isInEditState
		ifTrue:
			[editor showMessage: 'Warning: the method changed after editing started']
		ifFalse:
			[editor text: newSource]]
)
'testing'
isInEditState ^<Boolean> = (
	(* True if the editor is now in the edit state and presumably has unsaved changes. *)

	^editor isInEditState
)
) : (
)
public class MethodSubject onModel: m = Subject onModel: m (
(*  *)|  |) (
'accessing'
public allMethodCategories ^<Collection[Symbol]> = (
(* Answer a collection of all category names used in the implementor class, plus some common names. *)

| names |
names:: Set new.
names
	add: #'initialize-release';
	add: #accessing;
	add: #actions;
	add: #notifications; 
	add: #parameters;
	add: #private;
	add: #restricted; 
	add: #testing.
^names
)
classAndSelectorString = (
|	cs = className subStrings: '`'.
	legibleClassName = cs reverse reduce: [ :m :o | m, ' in ', o]. | 
	^ selector asString, ' in ', legibleClassName.
)
public implementingClass = (

	subclassResponsibility
)
public messages ^<Collection[Symbol]> = (
	(* Selectors of messages sent by the subject. *)
	subclassResponsibility
)
public methodCategory ^<String> = (

	subclassResponsibility
)
public selector ^<Symbol> = (
	(* Answer the selector of the presented method. *)

	subclassResponsibility
)
public source ^<String> = (
	(* Answer the source of the presented method. *)

	subclassResponsibility
)
public usageCount = (
	^(systemScope allLiteralReferences at: selector ifAbsent: [^0]) size
)
'actions'
public changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (

	subclassResponsibility
)
public compileNewSource: source <String> ifSuccess: successBlock ifNewMethod: newBlock1arg ifFailure: failureBlock = (

	subclassResponsibility
)
public deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (

	implementingClass removeSelector: selector.
	successBlock value (* always succeed *)
)
'as yet unclassified'
public accessModifier = (
	^ model accessModifier
)
asMethodInheritanceSubject = (

	^MethodInheritanceSubject onModel: model
)
public className = (

	^implementingClass simpleName
)
public enclosingClasses ^<List[Behavior]> = (
	^{implementingClass}
)
exemplar = (
	subclassResponsibility
)
public isSynthetic = (
	^false
)
methodReference = (
	^MethodReference class: implementingClass selector: selector
)
public variableBindingKeys	^<Collection[Symbol]> = (
(* Selectors of messages sent by the subject. *) 

subclassResponsibility
)
'private'
public colorizeMethodSource: sourceText = (
	(* Subclasses may override this to perform source colorization. *)

	| styler <SHTextStyler>|
	styler:: SHTextStylerST80 new
		classOrMetaClass: implementingClass.
	styler privateStyle: sourceText. 
	^sourceText
)
public createPresenter = (

	^ExpandableMethodPresenter onSubject: self
)
'testing'
public isAnOverride = (
(* True if one of the superclasses has a method with the same selector. *)

subclassResponsibility
)
public isAnOverrideIn: classSubject <ClassSubject | nil> = (
	(* True if one of the superclasses has a method with the same selector. *)
	^isAnOverride
)
public isOverridden = (
	(* True if one of the subclasses has a method with the same selector. *)
	subclassResponsibility
)
public isOverriddenIn: classSubject <ClassSubject | nil> = (
(* True if one of the subclasses has a method with the same selector. *)

^isOverridden
)
public isSubclassResponsibility = (
	(* Subclasses may override this if they are capable enough to figure out if their subject declares a subclass responsbility. *)

	^false
)
public isValid ^<Boolean> = (
	subclassResponsibility
)
) : (
'as yet unclassified'
public onMethod: mref <MethodReference | MethodMirror> ^<MethodSubject> = (
	| cls |
        #TODO yourself. (* need to ensure that squeak creates the right objects  *)
	([mref isMethodMirror] ifError: [false]) ifTrue: [
		(mref reflectee isSynthetic) 
			ifTrue: [^SyntheticMethodSubject onModel: mref].
		cls:: mref definingMixin reflectee definingClass.
		(cls language isNewspeakLanguage3)
			ifFalse: [^STMethodSubject onModel: (MethodReference class: cls selector: mref simpleName)].
		(mref reflectee properties includesKey: #isSubinitializer) 
			ifTrue: [^InitializerMethodSubject onModel: mref].
		^NSMethodSubject onModel: mref].

	([mref isClassHeaderMirror] ifError: [false])
		ifTrue: [^InitializerMethodSubject onModel: mref initializer].

	cls:: mref actualClass.
	cls isNil 
		ifTrue: [^STMethodSubject onModel: mref].
	(mref compiledMethod properties includesKey: #isSubinitializer)
		ifTrue: [^InitializerMethodSubject onModel:  (MethodMirror reflecting: mref compiledMethod)].
	mref compiledMethod isSynthetic
		ifTrue: [^SyntheticMethodSubject onModel: mref].
	cls language isNewspeakLanguage3
		ifTrue: [^NSMethodSubject onModel: (MethodMirror reflecting: mref compiledMethod)].
	^STMethodSubject onModel: mref.
)
)
public class SelectorPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(*  *)|  |) (
'as yet unclassified'
implementorsPart = (

	^floatingHeader: (
		column: {
			majorHeadingBlock: (
				row: {
					label: subject selector asText allBold.
					label: ' implementors'.
				}).
			blank: 10.
		}
	)
	body: (
		column: {
			row: {
				blank: 10.
				elastic: (AssortedMethodsSubject onModel: subject implementorSubjects) presenter.
			}.
			blank: 10.
		}	
	)
)
sendersPart = (

	^floatingHeader: (
		column: {
			majorHeadingBlock: (
				row: {
					label: subject selector asText allBold.
					label: ' senders'.
				}).
			blank: 10.
		})
		body: (
			column: {
				row: {
					blank: 10.
					elastic: (AssortedMethodsSubject onModel: subject senderSubjects) presenter.
				}.
				blank: 10.
			}
		)
	)
'definition'
definition = (
^
	column: {
		implementorsPart.
		sendersPart
	}
)
) : (
)
public class SelectorSubject onModel: m = Subject onModel: m asSymbol (
(* Holds onto a selector (a Symbol) and retrieves its senders and implementors. *)|  |) (
'accessing'
public selector = (

	^model
)
public title = (

	^model printString
)
'as yet unclassified'
public = other = (
	^self class = other class and: [self model = other model]
)
public hash = (
	^model hash
)
public implementorSubjects ^ <Collection[MethodSubject]> = (
	(* Answer a collection of senders of our subject, as MethodSubjects. *)

	^implementors collect: [ :each <MethodReference> |
		MethodSubject onMethod: each]
)
public senderSubjects ^ <Collection[MethodSubject]> = (
	(* Answer a collection of senders of our subject, as MethodSubjects. *)

	^senders collect: [ :each <MethodReference> |
		MethodSubject onMethod: each]
)
'presentation'
public createPresenter = (

	^SelectorPresenter onSubject: self
)
'private'
implementors = (
	(* Answer a collection of implementors of our selector (as MethodReferences). *)

	| themST themNS |
	themST:: Array streamContents:
		[ :s |
		systemScope smalltalkImplementorsOf: model do:
			[ :cls <Class> :sel <Symbol> |
			s nextPut: (MethodReference class: cls selector: sel)]].
	
	themNS:: Array streamContents: [:stm |
		systemScope newspeakImplementorsOf: model do: [:mirror | stm nextPut: mirror]].
	
	^themST, themNS
)
isReference: a lessThan: b = (

	| aClass bClass |
	aClass:: a classSymbol.
	bClass:: b classSymbol.
	aClass < bClass ifTrue: [^true].
	aClass > bClass ifTrue: [^false].
	^a methodSymbol < b methodSymbol
)
senders = (
	(* Answer a collection of senders of our selector (as MethodReferences). *)

	| them themNS |
	them:: Array streamContents:
				[ :s |
				systemScope smalltalkSendersOf: model do:
					[ :cls <Class> :sel <Symbol> |
					s nextPut: (MethodReference class: cls selector: sel)]].
	them:: them asSet asArray sort: [:a :b | isReference: a lessThan: b].
	themNS:: Array streamContents: [:stm |
		systemScope newspeakSendersOf: model do: [:mirror | stm nextPut: mirror]].
	
	^them, themNS
)
) : (
)
public class SyntaxErrorNotificationHandler = (|
	public text
	public failureBlock
|) (
'as yet unclassified'
bindingOf: variableName = (
failureBlock valueWithPossibleArgument: variableName, ' is undefined'
)
notify: garbledErrorMessage <String> at: position <Integer> in: source <ReadStream> = (
| errorMessage |
errorMessage:: (garbledErrorMessage endsWith: ' ->')
	ifTrue: [garbledErrorMessage allButLast: 3]
	ifFalse: [garbledErrorMessage].
failureBlock valueWithPossibleArgument: errorMessage
)
selectFrom: start to: end = (
halt
)
public selectionInterval = (
	^nil
)
) : (
)
class SyntheticMethodSubject onModel: m = MethodSubject onModel: m () (
'as yet unclassified'
public changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
   failureBlock value: 'Cannot change category of synthetic method'
)
public colorizeMethodSource: sourceText = (
(* Nothing to colorize - displayed source is just a message saying this is an accessor *) 
	^sourceText
)
public compileNewSource: source <String> ifSuccess: successBlock ifNewMethod: newBlock1arg ifFailure: failureBlock = (
  (* do nothing *)
)
compiledMethod = (
	^model compiledMethod
)
public deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (
   failureBlock value
)
public implementingClass = (
	^model actualClass
)
public isAnOverride ^ <Boolean> = (
(* True if one of the superclasses has a method with the same selector. *)
   ^false
)
public isOverridden ^ <Boolean> = (
	(* True if one of the subclasses has a method with the same selector. *)
	^false
)
public isSynthetic ^ <Boolean> = (
	^true
)
public isValid ^ <Boolean> = (
   ^true
)
public messages	^<Collection[Symbol]> = (
(* Selectors of messages sent by the subject. *) 
 ^{}
)
public methodCategory ^<String> = (
	^'<synthetic method>'
)
methodCategoryOrNil ^<String> = (
	^'<synthetic method>'
)
public selector ^ <Symbol> = (
	^model methodSymbol
)
public source ^ <String> = (
	^'Synthetic  method: no source available'
)
public variableBindingKeys	^<Collection[Symbol]> = (
(* Selectors of messages sent by the subject. *) 
 ^{}
)
) : (
)
class UnsortedMethodsPresenter onSubject: s = AssortedMethodsPresenter onSubject: s (
(* My subject is a collection of methods and I display them unsorted, in other words not grouped by package. *)|  |) (
'as yet unclassified'
contentPresenters = (

	^Array streamContents: 
		[:stream | 
		methodPresenters:: subject collect: [:each | newExpandableMethodPresenter: each].
		stream nextPutAll: methodPresenters]
)
) : (
)
) : (
)
