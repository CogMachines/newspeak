Newspeak3
'HopscotchIDE'
class Browsing usingPlatform: p ide: ide = (
(* Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2011 Ryan Macnak and other contributors.
Copyright 2012 Cadence Design Systems, Inc.
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)||
	private Dictionary = p collections Dictionary.
	private OrderedCollection = p collections OrderedCollection.
	private Set = p collections Set.
	private Menu = p brazil menus Menu.
	private MenuItem = p brazil menus MenuItem.
	private SeparatorItem = p brazil menus SeparatorItem.
	private EditableLinePresenter = p hopscotch fragments EditableLinePresenter.
	private OutlineItem = p hopscotch outline OutlineItem.
	private Subject = p hopscotch core Subject.
	private MethodMirror = p mirrors MethodMirror.
	private ClassDeclarationMirror = p mirrors ClassDeclarationMirror.
	private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	private Color = p graphics Color.
	
	private MethodReference = p blackMarket System MethodReference.
	private PackageOrganizer = p blackMarket Smalltalk at: #PackageOrganizer.
	private Smalltalk = p blackMarket Smalltalk.
	private SystemNavigation = p blackMarket System SystemNavigation.
	private HopscotchImages = p blackMarket Hopscotch HopscotchImages.
	private SHTextStylerST80 = p blackMarket Shout SHTextStylerST80.
	private blackMarket = p blackMarket.
	
	ide = ide.
	systemScope = ide systemScope.
	IDEWindow = ide tools IDEWindow.
	DefinitionListPresenter = ide tools DefinitionListPresenter.
	ProgrammingPresenter = ide tools ProgrammingPresenter.
	ExemplarMethodPresenter = ide tools ExemplarMethodPresenter.	
	PackageSubject = ide browsingMisc PackageSubject.
	NSClassSubject = ide browsingNS3 ClassSubject.
	NSMethodSubject = ide browsingNS3 MethodSubject.
	InitializerMethodSubject = ide browsingNS3 InitializerMethodSubject.
	GlobalReferencesSubject = ide browsingST GlobalReferencesSubject.
	MethodInheritanceSubject = ide browsingST MethodInheritanceSubject.
	STMethodSubject = ide browsingST STMethodSubject.
	CodeEditorFragment = ide tools CodeEditorFragment.
	DefinitionResidue = ide tools DefinitionResidue.
	DefinitionTemplate = ide tools DefinitionTemplate.
	||)
(
class AssortedMethodsPresenter onSubject: s = DefinitionListPresenter onSubject: s (
(* The subject is a collection of MethodSubjects that can come from diverse sources (in the sense that they do not have to belong to the same class). The presenter displays them as a column of expandable method presenters and takes care of reasonably handling the various creation and deletion requests coming from them.  I group my methods by their containing package.

Slots
	title	<String>	The title to use for the presenter
	methodPresenters <OrderedCollection[ExpandableMethodPresenter]> Because the method presenters are grouped by package, if we need to expand or collapse those presenters, we only want to expand or collapse the method presenters.  The group heading is not expandable (or collapsable). *)| title::= 'Assorted Methods'.
 methodPresenters ::= OrderedCollection new. |)
('accessing'
methodsGroupedByPackage = (

	| packages |
	packages:: Dictionary new.
	subject model do: 
		[:aSubject |
		(packageOfMethod: aSubject) ifNotNil:
			[:aPackage |
			(packages 
				at: aPackage packageName 
				ifPresent: [:e|]
				ifAbsentPut: [OrderedCollection new]) add: aSubject]].
	^packages
)'actions'
collapseAll = (
respondToCollapse:  methodPresenters
)
expandAll = (
respondToExpand:  methodPresenters
)
respondToCollapse: presenters = (

	majorUpdate: [presenters do: [:each | each collapse]]
)
respondToExpand: presenters = (

	majorUpdate: [presenters do: [:each | each expand]]
)'as yet unclassified'
compileMethod: source <String> inPresenter: requestor <Presenter> ifCompiledAsSame: successResponse <[]> ifCompiledAsNew: successNewResponse <[]|[:Object]> ifFailed: failureResponse <[]|[:Object]> = (

	requestor subject
		compileNewSource: source
		ifSuccess: successResponse
		ifNewMethod: 
			[:newSelector | | newReference newPresenter |
			newReference:: MethodReference 
				class: requestor subject implementingClass
				selector: newSelector.
			newPresenter:: ExpandableMethodPresenter
				onSubject: (MethodSubject onMethod: newReference).
			suffixes add: newPresenter.
			successNewResponse value.
			(suffixes detectPresenter:
				[:some |
				some subject methodReference = newReference]) 
				expand]
		ifFailure: failureResponse
)
contentPresenters = (

	^Array streamContents: 
		[:stream | | groups |
		groups:: methodsGroupedByPackage.
		(groups keys asArray copyWithout: nil) sort do:
			[:packageName | | presenters gm |
			presenters:: OrderedCollection new.
			gm:: methodPresentersGroupedByEnclosingClass: (groups at: packageName).
			stream nextPut: 
				(minorHeadingBlock: 
					(row: {
						link: packageName asText allBold action: [browsePackage: packageName].
						filler.
						expandButtonWithAction: [respondToExpand: presenters].
						blank: 3.
						collapseButtonWithAction: [respondToCollapse: presenters].
					})).
			stream nextPut: mediumBlank.
			(gm values asSortedList: [:a :b | a size < b size]) do:
				[:v |  | moduleOrClass |
				presenters addAll: v.
				moduleOrClass:: v first subject enclosingClasses last.
				(* Only show when it is above a threshold *)
				v size > 2 ifTrue:
					[stream nextPut: smallBlank.
					stream nextPut: (row: {link: moduleOrClass name asText action: [browseClass: moduleOrClass]})].
				stream nextPutAll: v].
			methodPresenters addAll: presenters.
			stream nextPut: mediumBlank]]
)
packageOfMethod: method <MethodSubject> ^<PackageSubject> = (

	| registry mirror implementingClass package |
	registry:: PackageOrganizer default.
	implementingClass:: method implementingClass.
	implementingClass ifNil: [^nil].
	mirror:: ClassDeclarationMirror reflecting: implementingClass theNonMetaClass mixin.
	[mirror enclosingClass notNil]
		whileTrue: [mirror: mirror enclosingClass].

	package:: implementingClass language isNewspeakLanguage3 not
		ifTrue: [registry packageOfMethod: method model ifNone: []]
		ifFalse: [registry packageOfClass: mirror reflectee definingClass ifNone: []].
	^package = nil
		ifTrue: [PackageSubject onModel: method implementingClass theNonMetaClass category]
		ifFalse: [PackageSubject onModel: package packageName]
)'private'
methodPresentersGroupedByEnclosingClass: methodSubjects = (
	| groupedMethods |
	groupedMethods:: Dictionary new.
	methodSubjects do:
		[:aSubject | |methods|
		(* sadly there is no #at:ifAbsentPut: *)
		methods:: groupedMethods
			at: aSubject enclosingClasses last name
			ifPresent: [:oc | oc]
			ifAbsentPut: [OrderedCollection new].
		methods add: (newExpandableMethodPresenter: aSubject)].
	^groupedMethods
)
newExpandableMethodPresenter: s <MethodSubject> = (	
	^s createPresenter
		showClassName: true;
		showClassLink: true
)'requests'
deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (

	| requestorSubject source residue |
	requestorSubject:: presenter subject.
	source:: requestorSubject source.
	requestorSubject
		deleteMethodIfSuccess:
			[residue:: DefinitionResidue new
				caption: 'Deleted method ', requestorSubject selector;
				definitionText: source;
				restoreResponse: 
					[methodResidueAccepted: residue.
					suffixes remove: residue];
				forgetResponse: [suffixes remove: residue].
			suffixes add: residue.
			content remove: presenter.
			successResponse value]
		ifFailure: failureResponse value
)) : ()
class AssortedMethodsSubject onModel: m = Subject onModel: m (
(*  *)|
	title ::= 'Assorted Methods'.
|)
('protected'
createPresenter = (
^(AssortedMethodsPresenter onSubject: self) title: title
)'restricted'
refreshmentSubject = (
	^super refreshmentSubject
		title: title;
		yourself
)) : ()
class ClassMessagesSurveyor new = Object (
(*  *)| focusClassX 
messagesFromSuperclasses::= Set new: 200.
messagesFromSubclasses::= Set new: 200.
 |)
('accessing'
focusClass = (
^focusClassX
)
focusClass: aClass = (

	focusClassX:: aClass.
	findSuperclassMessages.
	findSubclassMessages
)
subclassesImplement: aSymbol = (

	^messagesFromSubclasses includes: aSymbol
)
superclassesImplement: aSymbol = (

	^messagesFromSuperclasses includes: aSymbol
)'private'
findSubclassMessages = (

	focusClassX allSubclassesDo:
		[:each | messagesFromSubclasses addAll: each selectors]
)
findSuperclassMessages = (

	focusClassX allSuperclassesDo:
		[:each | messagesFromSuperclasses addAll: each selectors]
)) : ()
class ClassMethodsPresenter onSubject: s = DefinitionListPresenter onSubject: s (
(* The subject is a class subject. Displays methods of the class as expandable entries and supports compilation and other requests. Another similar presenter is an AssortedMethodsPresenter, but that one displays a collection of methods which do not necessarily belong to the same class, such as all senders of a selector. *)| presenterCreationBlock groupedByCategory::= true. subclassResponsibilitiesList seeAllLinkHolder showingPartialList::=true. |)
('actions'
addMethodTemplate = (

	addMethodTemplate: ''
)
addMethodTemplate: src = (

	prefixes add:
		(DefinitionTemplate new
			initialText: src;
			caption: 'Adding new method:';
			acceptResponse:
				[:template | 
				createMethodFromTemplate: template];
			cancelResponse: 
				[:template | prefixes remove: template])
)
collapseAll = (

	majorUpdate:
		[content presenters do: [:each | each collapse]]
)
expandAll = (

	majorUpdate:
		[content presenters do: [:each | each expand]]
)
restoreMethodResidue: aResidue = (

	| newSelector |
	newSelector:: subject 
		compile: aResidue definitionText 
		classified: aResidue extraData.
	refreshContentList.
	newSelector notNil ifTrue:
		[suffixes remove: aResidue.
		(content detectPresenter: [:some | some subject selector = newSelector]) 
			expand]
)
switchSortOrder = (

	groupedByCategory: groupedByCategory not.
	majorUpdate: [content presenters: retrievePresenters].
	notifyOfPossibleOutlineChange
)'as yet unclassified'
addMethodIn: cls proposedSource: src = (
subject classObject == cls ifTrue:
	[addMethodTemplate: src]
)
maybePartialSubjectListByCategory ^<Collection[MethodSubject]> = (
	(* Retrieve the subjects to show--not more than initialSizeLimit elements if there are too many--sorted by method category. Set the showingPartialList flag according to whether the result is a full list or not. *)


	| result |
	result:: OrderedCollection new: initialSizeLimit.
	subject sortedCategories do:
		[:each |
		(subject methodSubjectsInCategory: each) do:
			[:eachSubject |
			result add: eachSubject.
			result size >= initialSizeLimit ifTrue:
				[showingPartialList:: true.
				^result]]].
	showingPartialList:: false.
	^result
)
maybePartialSubjectListBySelector ^<Collection[MethodSubject]> = (
	(* Retrieve the subjects to show--not more than initialSizeLimit elements if there are too many--sorted by selector. Set the showingPartialList flag according to whether the result is a full list or not. *)

	| subjects |
	subjects:: (subject methodSubjects) select: 
		[:some | some methodCategoryOrNil notNil].
	subjects:: subjects asSortedCollection: [:a :b | a selector < b selector].
	showingPartialList:: subjects size > initialSizeLimit.
	^showingPartialList 
		ifTrue: [subjects copyFrom: 1 to: initialSizeLimit]
		ifFalse: [subjects]
)
retrieveAllSubjects = (

	showingPartialList:: false.
	^groupedByCategory
		ifTrue:
			[ | result |
			result:: OrderedCollection new: initialSizeLimit.
			subject sortedCategories do:
				[:each |
				result addAll: (subject methodSubjectsInCategory: each)].
			result]
		ifFalse:
			[ | subjects |
			subjects:: (subject methodSubjects) select: 
				[:some | some methodCategoryOrNil notNil].
			subjects asSortedCollection: [:a :b | a selector < b selector]]
)'definition'
definition = (
^
	column: {
		minorClassHeadingBlock: (
			row: {
				label: (subject classIsMeta
					ifTrue: ['Class methods']
					ifFalse: ['Instance methods']).
				largeBlank.
				addButtonWithAction: [addMethodTemplate].
				filler.
				expandButtonWithAction: [expandAll].
				blank: 3.
				collapseButtonWithAction: [collapseAll].
				blank: 3.
				reorderButtonWithAction: [switchSortOrder].
				}).
		[prefixes:: list.						prefixes] value.
		[content:: list.						content] value.
		[suffixes:: list. 						suffixes] value.
		[seeAllLinkHolder:: holder: nothing. 	seeAllLinkHolder] value.
		deferred: 
			[subclassResponsibilitiesList:: list: subclassResponsibilitiesPresenters.
			subclassResponsibilitiesList].
	}
)
presenterForSubclassResponsibility: aReference = (

	| toggle |
	toggle:: 
		collapsed:
			((link: aReference methodSymbol, ' (unimplemented subclass responsibility)'
			action: [toggle toggle]) color: Color lightGray)
		expanded:
			[DefinitionTemplate new
				caption: 'Subclass responsibility from ', aReference actualClass name, '>>', aReference methodSymbol;
				initialText: aReference source;
				acceptResponse: [:t | createMethodForSubclassResponsibility: t]].
	^toggle
)
subclassResponsibilitiesPresenters = (

	^(subject retrieveUnimplementedAbstractMethods 
		asSortedList: [:a :b | a methodSymbol < b methodSymbol])
			collect: [:each | presenterForSubclassResponsibility: each]
)'initialize-release'
presenterClass: aClass = (

	presenterCreationBlock:: [:each | aClass onSubject: each]
)'notices'
noticeSubstanceCreation = (

	refreshContentList
)'parameters'
initialSizeLimit ^<Integer> = (
	(* At most this many methods are displayed at first. *)

	^60
)'private'
loadFullContentList = (

	showingPartialList:: false.
	majorUpdate: [content presenters: retrievePresenters].
	refreshSeeAllHolder
)
refreshContentList = (

	content presenters: retrievePresenters.
	refreshSeeAllHolder
)
refreshSeeAllHolder = (

	seeAllLinkHolder content:
		(showingPartialList 
			ifTrue:
				[row: { 
					mediumBlank. 
					(link: 'show all methods...' action: [loadFullContentList])
						tinyFont
					}]
			ifFalse:
				[nothing])
)
retrieveAllPresenters = (

	^retrieveAllSubjects collect: presenterCreationBlock
)
retrievePresenters = (

	^showingPartialList
		ifTrue: [retrieveSubjects collect: presenterCreationBlock]
		ifFalse: [retrieveAllSubjects collect: presenterCreationBlock]
)
retrieveSubjects = (

	^groupedByCategory
		ifTrue: [maybePartialSubjectListByCategory]
		ifFalse: [maybePartialSubjectListBySelector]
)'requests'
compileMethod: source <String> inPresenter: requestor <Presenter> ifCompiledAsSame: successResponse <Block> ifCompiledAsNew: successNewResponse <Block> ifFailed: failureResponse <Block> = (

	| newPresenter |
	requestor subject
		compileNewSource: source
		ifSuccess: successResponse
		ifNewMethod: 
			[:newSelector |
			successNewResponse value.
			loadFullContentList.
			newPresenter:: 
					content detectPresenter: 
						[:some | some subject selector = newSelector].
			newPresenter
				expand;
				requestVisibility]
		ifFailure: failureResponse
)
createMethodForSubclassResponsibility: template <DefinitionTemplate> = (

	| newSelector newPresenter |
	newSelector:: subject compile: template text.
	loadFullContentList.
	newSelector notNil ifTrue:
		[subclassResponsibilitiesList remove: template parent.
		newPresenter:: 
			content detectPresenter: 
				[:some | some subject selector = newSelector].
		newPresenter
			expand;
			requestVisibility]
)
createMethodFromTemplate: template <DefinitionTemplate> = (

	| newSelector newPresenter |
	newSelector:: subject compile: template text.
	loadFullContentList.
	newSelector notNil ifTrue:
		[prefixes remove: template.
		newPresenter:: 
			content detectPresenter: 
				[:some | some subject selector = newSelector].
		newPresenter
			expand;
			requestVisibility]
)
deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (

	| requestorSubject source category residue |
	requestorSubject:: presenter subject.
	source:: requestorSubject source.
	category:: requestorSubject methodCategory.
	requestorSubject
		deleteMethodIfSuccess:
			[residue:: DefinitionResidue new
				caption: requestorSubject selector, ' (deleted method)';
				definitionText: source;
				extraData: category;
				restoreResponse: 
					[restoreMethodResidue: residue.
					suffixes remove: residue];
				forgetResponse: [suffixes remove: residue].
			loadFullContentList.
			suffixes add: residue.
			successResponse value]
		ifFailure: failureResponse
)
recategorizeMethodIn: presenter <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (

	| newName |
	newName:: newCategoryName withBlanksTrimmed.
	newName isEmpty ifTrue: [^failureResponse value].
	presenter subject
		changeCategoryTo: newName asSymbol
		ifSuccess: 
			[loadFullContentList.
			presenter requestVisibility.
			successResponse value]
		ifFailure: failureResponse
)) : ()
class ClassMethodsSubject onModel: m = Subject onModel: m (
(* The model is the class object. (Used for Smalltalk and NS1 classes). Represents the perspective of looking at the list of mehods of the class. *)|  |)
('accessing'
classIsMeta = (

	^classObject isMeta
)
classObject = (

	^model
)
compile: source = (

	^classObject compile: source
)
compile: source <String> classified: categoryName <Symbol> = (

	^classObject compile: source classified: categoryName
)
createPresenter = (

	^ClassMethodsPresenter onSubject: self
)
retrieveUnimplementedAbstractMethods ^<Collection[MethodReference]> = (
	(* Answer a collection of MethodReferences to abstract methods of superclasses that the class would need to implement in order to be concrete. *)

	^model superclass
		ifNil: [Array new]
		ifNotNil:
			[:superclass | | result |
			result:: OrderedCollection new.
			addAbstractMethodsOf: superclass notIn: model selectors to: result.
			result]
)
sortedCategories ^<Collection[Symbol]> = (
	(* Answer a collection of category names found in the class, sorted with initialization first and private categories last. *)

	| categories init privateCategories unclassified lineup |
	categories:: classObject organization categories asSet.
	init:: categories select: [:each | 'init*' match: each].
	categories:: categories difference: init.
	privateCategories:: categories select: [:each | 'private*' match: each].
	categories:: categories difference: privateCategories.
	(categories includes: #'as yet unclassified')
		ifTrue:
			[unclassified:: {#'as yet unclassified'}.
			categories remove: #'as yet unclassified']
		ifFalse:
			[unclassified:: {}].
	lineup:: OrderedCollection new: categories size.
	lineup 
		addAll: unclassified;
		addAll: init asSortedCollection;
		addAll: categories asSortedCollection;
		addAll: privateCategories asSortedCollection.
	^lineup
)'as yet unclassified'
methodSubjectForSelector: selector <Symbol> ^ <MethodSubject> = (

	^MethodSubject
		onMethod: (MethodReference class: classObject selector: selector)
)
methodSubjects = (

	^classObject selectors collect:
		[:each | methodSubjectForSelector: each]
)
methodSubjectsInCategory: categoryName <Symbol> ^<Collection[MethodSubject]> = (

	^(classObject organization listAtCategoryNamed: categoryName)
		asSortedCollection
			collect: [:each | methodSubjectForSelector: each]
)'private'
addAbstractMethodsOf: aClass notIn: selectorSet to: resultCollection = (

	| implementedHere |
	implementedHere:: Set new.
	aClass selectorsAndMethodsDo:
		[:eachSelector :eachMethod |
		(selectorSet includes: eachSelector) ifFalse:
			[eachMethod isAbstract
				ifTrue: [resultCollection add: 
							(MethodReference class: aClass selector: eachSelector)]
				ifFalse: [implementedHere add: eachSelector]]].
	aClass superclass ifNotNil: 
		[:superclass |
		addAbstractMethodsOf: superclass
		notIn: (selectorSet union: implementedHere)
		to: resultCollection]
)) : ()
class ClassSubject onModel: m = Subject onModel: m (
(* Represents a view of a class in the system. This is an abstract class. Concrete subclasses will implement class access in terms appropriate to the language of the class. The model they will use will again depend on the language. The one thing we assume about the model is that it behaves ''properly'' with respect to #= (and #hash), so that a ClassSubject can rely on the model for its own equality comparison. *)|  |)
('accessing'
= anotherSubject = (

	^(anotherSubject class = self class)
		and: [anotherSubject model = model]
)
hash = (

	^model hash
)'as yet unclassified'
classCommentText ^<String> = (

	subclassResponsibility
)
classCommentText: newComment <String> = (

	subclassResponsibility
)
classDefinition = (

	subclassResponsibility
)
classLanguage = (

	^model language
)
className = (

	subclassResponsibility
)
classUiDescription = (
^ide languageUiDescriptionRegistry descriptionFor: classLanguage
)
isAbstract = (
(* Answer true if any methods are marked as abstract. *)

^false
)
isRecentlyVisited ^<Boolean> = (
	(* Answer true if the class is known to Hopscotch to be recently visited. Some presenters highlight such classes. *)

	^ide defaultPopularityRecord classVisits 
		includes: className
)
methodCount = (

	subclassResponsibility
)
totalSubclassCount = (

	subclassResponsibility
)) : ()
class EditableClassNamePresenter onSubject: s = EditableLinePresenter onSubject: s (
(* The subject is an STClassSubject. The presenter displays the name of the class and allows to edit it. *)|  |)
('actions'
browseClassOrMirror: aClassOrMirror = (

	aClassOrMirror isBehavior
		ifTrue: [browseClass: aClassOrMirror]
		ifFalse: [browseClassMirror: aClassOrMirror]
)
respondToAccept = (

	| oldName newName referencesToFix |
	newName:: editor text asString asSymbol.
	(Smalltalk includesKey: newName) ifTrue:
		[^nil].
	oldName:: subject className.
	subject model rename: newName.
	leaveEditState.
	flag: #bogus. (* Get rid of Smalltalk and SystemNavigation dependencies below *)
	referencesToFix:: SystemNavigation default allCallsOn: (Smalltalk associationAt: newName).
	referencesToFix notEmpty ifTrue:
		[enterSubject: (GlobalReferencesSubject onModel: newName)]
)'as yet unclassified'
browseClass: aClass = (

	| theClass |
	theClass::  aClass theNonMetaClass mixin definingClass.
	ide defaultPopularityRecord
		rememberClassVisit: theClass name.
	sendUp 
		ifUndelivered: [IDEWindow openOnClass: theClass];
		navigatorDo:
			[:navigator |
			navigator enterSubject: 
				(subjectForClass: theClass)]
)
definitionText = (

	^subject className
)
viewerDefinition = (

	^link: [definitionText asText allBold]
		action: [browseClassOrMirror: subject model].
)) : ()
class EditableNSClassNamePresenter onSubject: s = EditableClassNamePresenter onSubject: s (
(*  *)|  |)
('as yet unclassified'
browseClassMirror: aMirror = (

	ide defaultPopularityRecord rememberClassVisit: aMirror name.
	enterSubject:: ide browsingNS3 ClassSubject onModel: aMirror.
)
respondToAccept = (

	| oldName newName builder klass |

	newName:: editor text asString asSymbol.
	oldName:: subject className. (* simple? *)

	newName = oldName ifTrue: [^leaveEditState].

	builder:: ClassDeclarationBuilder reflecting: subject model reflectee.

	builder enclosingClass ifNil: [ (* Top level class *)
		(Smalltalk includesKey: newName) ifTrue: 
			[Error signal: 'A top level class already exists with the name ', newName].
	].

	builder header name: newName.
	builder install.

	builder enclosingClass ifNil: [ (* Top level class *)
		klass:: Smalltalk removeKey: oldName.
		klass setName: newName.
		Smalltalk at: newName put: klass.
		blackMarket SystemOrganization classify: newName under: klass category.
		blackMarket SystemOrganization removeMissingClasses.
	].

	leaveEditState.
)) : ()
class ExpandableMethodPresenter onSubject: s = MethodPresenter onSubject: s (
(* The subject is an STMethodSubject or a similar thing. Displays as a line with the selector (optionally prepended with the class name if the showClassName slot is set to true), expandable into a full editor. *)| showClassName::=false. showClassLink::=false. inspectionHolder headingAfterLeftHolder |)
(''
linkToBrowseEnclosingClass: klass <Behavior | Mixin> = (
	^(link: klass simpleName
		action: [browseClass: klass])
		color: secondaryTextColor
)
nestingInformationLine = (
	| enclosingClasses rowElements |
	enclosingClasses:: subject enclosingClasses.
	rowElements:: OrderedCollection new.
	enclosingClasses do:
		[:each |
		rowElements add: ((label: ' in ') color: tertiaryTextColor).
		rowElements add: (linkToBrowseEnclosingClass: each)].
	^row: rowElements asArray
)
selectorAndContainment = (
	^row: {
		(link: subject selector
			action: [substance userToggle]
			dragSubject: subject
			withImage: HopscotchImages default hsExpandImage) color: actionLinkColor.
		showClassName 
			ifTrue: [nestingInformationLine]
			ifFalse: [nothing].
		}
)'actions'
collapse = (
	^substance collapse
)
expand = (

	^substance expand
)
goToMessages = (

	| messagesAndActions messageItems classItems |
	messagesAndActions:: OrderedCollection new.
	messagesAndActions add:
		subject selector -> [browseSelector: subject selector].
	messageItems:: referencesMenuMessageItems.
	classItems:: referencesMenuClassItems.
	messageItems isEmpty not ifTrue:
		[messagesAndActions 
			add: #separator;
			addAll: messageItems].
	classItems isEmpty not ifTrue:
		[messagesAndActions 
			add: #separator;
			addAll: classItems].
	openMenuWithLabelsAndActions: messagesAndActions
)
toggle = (

	^substance toggle
)'as yet unclassified'
accessModifierIcon = (
	^ image: (iconForAccessModifier: subject accessModifier)
)
addOutlineItemsTo: parentItem = (
parentItem addChild:
	((OutlineItem onModel: self)
		text: subject selector)
)
categoryLink ^ <Fragment> = (
	^subject isSynthetic 
	    ifTrue: [(label: subject methodCategory) tinyFont color: Color gray]
	    ifFalse: [MethodCategoryPresenter onSubject: subject]
)
expandedMethod ^ <Fragment> = (
	^	[column: {
			methodHeading color: methodHeadingColor.
			methodDetails.
			}
		].	
)
methodActionsMenu = (

	| labelsAndActions <Array[Tuple[String, []]]>  |
	labelsAndActions::  {
		'Delete #', subject selector -> [respondToDelete].
		(* 'Versions' -> [respondToVersions]. *)
		(* 'Pretty Print' -> [respondToPrettyPrint]. *)
		#separator.
		'Inspect Presenter' -> [respondToInspectPresenter].
		'Inspect Compiled Method' -> [respondToInspectCompiledMethod].
		}.
	^menuWithLabelsAndActions: labelsAndActions
)
methodDetails = (
	^super definition
)
parentClassSubject = (
^sendUp deliveryOptional parentClassSubjectDo: [:s | ^s]
)
respondToInspectCompiledMethod = (

	inspect: subject compiledMethod
)
respondToOutlineSelection = (
substance expand.
super respondToOutlineSelection
)
respondToRunTest = (
	self unimplemented. (* Does this make sense for Minitest? *)
)
respondToVersions = (
| cls |
cls:: subject implementingClass.
(* VersionsBrowser browseVersionsForClass: cls selector: subject selector. *)
enterSubject: (ide methodVersioning MethodHistorySubject onSelector: subject selector ofClass: cls)
)
sendersOfSubjectPresenter = (

	| count text |
	count:: subject usageCount.
	count = 0 ifTrue: [text:: 'no senders'].
	count = 1 ifTrue: [text:: '1 sender'].
	count > 1 ifTrue: [text:: count printString, ' senders'].
	^(link: text action: [browseSelector: subject selector]) 
		tinyFont color: secondaryTextColor
)'definition'
definition = (
	| toggler |
	inspectionHolder:: holder: [nothing].
	toggler::
		collapsed: methodHeading
		expanded: expandedMethod.
	toggler onUserToggled: [toggler isExpanded ifTrue: [requestVisibility]].
	^toggler
)
inheritanceLinkWithIcon: image = (

	^linkImage: image action: 
		[enterSubject: subject asMethodInheritanceSubject]
)
methodHeading = (
	inspectionHolder:: holder: [nothing].
	headingAfterLeftHolder:: holder: [nothing].
	^row: {
		accessModifierIcon.
		smallBlank.
		(selectorAndContainment) compressibility: 1.
		mediumBlank.
		deferred: [overrideIcon].
		blank: 2.
		deferred: 
			[subject isSubclassResponsibility 
				ifTrue: 
					[image: HopscotchImages default tinySubclassResponsibilityImage]
				ifFalse: [nothing]].
		smallBlank.
		deferred: 
			[sendersOfSubjectPresenter].
		smallBlank.
		headingAfterLeftHolder.
		filler compressibility: 0.
		categoryLink.
		largeBlank.
		inspectionHolder.
		smallBlank.
		itemReferencesMenuButtonWithAction: [goToMessages].
		smallBlank.
		dropDownMenu: [methodActionsMenu].
	}
)'private'
overrideIcon = (

	^isAnOverride 
		ifTrue:
			[isOverridden
				ifTrue: [inheritanceLinkWithIcon: HopscotchImages default itemBothOverride]
				ifFalse: [inheritanceLinkWithIcon: HopscotchImages default itemSuperOverride]]
		ifFalse:
			[isOverridden
				ifTrue: [inheritanceLinkWithIcon: HopscotchImages default itemSubOverride]
				ifFalse: [nothing]]
)
referencesMenuClassItems = (

	| items |
	items:: OrderedCollection new.
	subject variableBindingKeys asSortedList do:
		[:eachKey |
		(eachKey notNil and: [eachKey ~= subject className]) ifTrue:
			[items add:
				eachKey -> [browseClassNamed: eachKey]]].
	^items
)
referencesMenuMessageItems = (

	| items |
	items:: OrderedCollection new.
	subject messages asSortedList do:
		[:selector |
		selector == subject selector ifFalse:
			[items add:
				selector -> [browseSelector: selector]]].
	^items
)
refreshSource = (
(* Only refresh if we have the editor, i.e. we are expanded. *)

editor ifNotNil: [super refreshSource]
)'requests'
recategorizeMethodIn: presenter <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (
	(* When the category is changed, both my expanded and collapsed state presenters need refreshing to reflect the new name. Here we effectively intercept category change requests from children to do so on success. *)

	sendUp
		recategorizeMethodIn: presenter
		under: newCategoryName
		ifSuccess: [refresh. successResponse value]
		ifFailed: failureResponse
)'testing'
isAnOverride = (

	^subject isAnOverrideIn: parentClassSubject
)
isExpanded = (

	^substance isExpanded
)
isOverridden = (

	^subject isOverriddenIn: parentClassSubject
)) : ()
class MethodCategoryPresenter onSubject: s = EditableLinePresenter onSubject: s (
(* The subject is an STMethodSubject (or a similar thing). The presenter displays the category of the method and allows to edit it. *)|  |)
('actions'
changeCategoryTo: aSymbol = (

	sendUp
		recategorizeMethodIn: self
		under: aSymbol asString
		ifSuccess: [refresh]
		ifFailed: []
)
respondToAccept = (

	sendUp
		recategorizeMethodIn: self
		under: editor text asString
		ifSuccess: [leaveEditState]
		ifFailed: []
)
respondToClick = (
	(* Display a menu of appropriate categories. *)

	openMenu: 
		(buildCategoryChangeMenuWithNames:
			assembleListOfUsefulNames)
)'definition'
viewerDefinition = (

	^(link: [subject methodCategory] action: [respondToClick])
		tinyFont color: Color gray.

(* The definition below will make this look almost like a drop-down.
	^row: {
		(link: [subject methodCategory] action: [respondToClick])
			tinyFont color: Color gray.
		blank: 3.
		linkImage: HopscotchImages default itemMenuImage
			action: [respondToClick]
		}
*)
)'private'
assembleListOfUsefulNames = (
	(* Display a menu of appropriate categories. *)

	| names init pprivate result |
	names:: subject allMethodCategories copy remove: subject methodCategory ifAbsent:[]; yourself.
	result:: OrderedCollection new: names size.
	init:: names select: [:each | 'init*' match: each].
	names:: names reject: [:ea | init includes: ea].
	pprivate:: names select: [:each | 'private*' match: each].
	names:: names reject: [:ea | pprivate includes: ea].
	result
		addAll: init asSortedList;
		addAll: names asSortedList;
		addAll: pprivate asSortedList.
	^result
)
buildCategoryChangeMenuWithNames: names = (

	| menu |
	menu:: Menu forVisual: visual.
	names do:
		[:each |
		menu add: 
			(MenuItem 
				label: each 
				action: [changeCategoryTo: each])].
	menu add: SeparatorItem new.
	menu add:
		(MenuItem label: 'Enter Another Name' action: [enterEditState]).
	^menu
)
definitionText = (

	^subject methodCategory
)) : ()
class MethodPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(*  *)| editor |)
('actions'
respondToAccept = (
	(* The user has just clicked the Save button in the editor. *)

	subject source asString = editor text asString ifFalse:
		[editor setText: subject source.
		^editor showMessage: 'Method changed after editing started. Click Save again to clobber those other changes.'].
	sendUp
		compileMethod: editor textBeingAccepted asString
		inPresenter: self
		ifCompiledAsSame:
			[editor defaultAcceptResponse]
		ifCompiledAsNew:
			[editor text: subject source.
			editor defaultCancelResponse]
		ifFailed:
			[:message | editor showMessage: message]
)
respondToDelete = (

	sendUp
		deleteMethodInPresenter: self
		ifSuccess: []
		ifFailure: []
)'definition'
definition = (

	editor:: CodeEditorFragment new
		text: subject source;
		acceptResponse: 
			[respondToAccept];
		cancelResponse:
			[editor text: subject source.
			editor leaveEditState]. 
	editor colorizerBlock: [:text | subject colorizeMethodSource: text].
	^editor
)'private'
indicateMethodAsDeleted = (

	parent 
		replaceChild: self 
		with: ((label: subject selector, ' has been deleted') color: Color gray)
)'restricted'
refresh = (
subject isValid
	ifTrue: 
		[refreshSource.
		super refresh]
	ifFalse: 
		[indicateMethodAsDeleted]
)
refreshSource = (
| newSource |
newSource:: subject source.
newSource = editor text ifFalse:
	[editor isInEditState
		ifTrue:
			[editor showMessage: 'Warning: the method changed after editing started']
		ifFalse:
			[editor text: newSource]]
)'testing'
isInEditState ^<Boolean> = (
	(* True if the editor is now in the edit state and presumably has unsaved changes. *)

	^editor isInEditState
)) : ()
class MethodSubject onModel: m = Subject onModel: m (
(*  *)|  |)
('accessing'
allMethodCategories ^<Collection[Symbol]> = (
(* Answer a collection of all category names used in the implementor class, plus some common names. *)

| names |
names:: Set new.
names
	add: #'initialize-release';
	add: #accessing;
	add: #actions;
	add: #notifications; 
	add: #parameters;
	add: #private;
	add: #restricted; 
	add: #testing.
^names
)
classAndSelectorString = (
|	cs = className subStrings: '`'.
	legibleClassName = cs reverse reduce: [ :m :o | m, ' in ', o]. | 
	^ selector asString, ' in ', legibleClassName.
)
implementingClass = (

	subclassResponsibility
)
messages	^<Collection[Symbol]> = (
(* Selectors of messages sent by the subject. *) 

subclassResponsibility
)
methodCategory ^<String> = (

	subclassResponsibility
)
selector ^<Symbol> = (
	(* Answer the selector of the presented method. *)

	subclassResponsibility
)
source ^<String> = (
	(* Answer the source of the presented method. *)

	subclassResponsibility
)
usageCount = (
^(systemScope allLiteralReferences at: selector ifAbsent: [^0]) size
)'actions'
changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (

	subclassResponsibility
)
compileNewSource: source <String> ifSuccess: successBlock ifNewMethod: newBlock1arg ifFailure: failureBlock = (

	subclassResponsibility
)
deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (

	implementingClass removeSelector: selector.
	successBlock value (* always succeed *)
)'as yet unclassified'
accessModifier = (
	^ model accessModifier
)
asMethodInheritanceSubject = (

	^MethodInheritanceSubject onModel: model
)
className = (

	^implementingClass simpleName
)
enclosingClasses ^<List[Behavior]> = (
	^{implementingClass}
)
exemplar = (
	subclassResponsibility
)
isSynthetic = (
	^false
)
methodReference = (
	^MethodReference class: implementingClass selector: selector
)
variableBindingKeys	^<Collection[Symbol]> = (
(* Selectors of messages sent by the subject. *) 

subclassResponsibility
)'private'
colorizeMethodSource: sourceText = (
	(* Subclasses may override this to perform source colorization. *)

	| styler <SHTextStyler>|
	styler:: SHTextStylerST80 new
		classOrMetaClass: implementingClass.
	styler privateStyle: sourceText. 
	^sourceText
)
createPresenter = (

	^ExpandableMethodPresenter onSubject: self
)'testing'
isAnOverride = (
(* True if one of the superclasses has a method with the same selector. *)

subclassResponsibility
)
isAnOverrideIn: classSubject <ClassSubject | nil> = (
(* True if one of the superclasses has a method with the same selector. *)

^isAnOverride
)
isOverridden = (
(* True if one of the subclasses has a method with the same selector. *)

subclassResponsibility
)
isOverriddenIn: classSubject <ClassSubject | nil> = (
(* True if one of the subclasses has a method with the same selector. *)

^isOverridden
)
isSubclassResponsibility = (
	(* Subclasses may override this if they are capable enough to figure out if their subject declares a subclass responsbility. *)

	^false
)
isValid ^<Boolean> = (
subclassResponsibility
)) : ('as yet unclassified'
on: mref <MethodReference> ^<MethodSubject> = (
  halt. (* if you hit this, the caller should change to use onMethod: *)
  ^onMethod: mref.
)
onMethod: mref <MethodReference> ^<MethodSubject> = (
| cls mirror methodMirror |
cls:: mref actualClass.
cls isNil ifTrue: [
	assert:[false] message: 'nil class in method ref'. 
	^STMethodSubject onModel: mref
	]. (* does this ever happen? *)
(mref compiledMethod properties includesKey: #isSubinitializer)
	ifTrue:[^InitializerMethodSubject onModel:  (MethodMirror reflecting: mref compiledMethod)
		].
(mref compiledMethod isSynthetic (*and:[(mref compiledMethod properties includesKey: #isSubinitializer) not] *))
    ifTrue: [^SyntheticMethodSubject onModel: mref
	].(* a class accessor *)
^cls language isNewspeakLanguage3
	ifTrue: [NSMethodSubject onModel: (MethodMirror reflecting: mref compiledMethod)]
	ifFalse: [STMethodSubject onModel: mref].
))
class SelectorPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(*  *)|  |)
('as yet unclassified'
implementorsPart = (

	^floatingHeader: (
		column: {
			majorHeadingBlock: (
				row: {
					label: subject selector asText allBold.
					label: ' implementors'.
				}).
			blank: 10.
		}
	)
	body: (
		column: {
			row: {
				blank: 10.
				elastic: (AssortedMethodsSubject onModel: subject implementorSubjects) presenter.
			}.
			blank: 10.
		}	
	)
)
sendersPart = (

	^floatingHeader: (
		column: {
			majorHeadingBlock: (
				row: {
					label: subject selector asText allBold.
					label: ' senders'.
				}).
			blank: 10.
		})
		body: (
			column: {
				row: {
					blank: 10.
					elastic: (AssortedMethodsSubject onModel: subject senderSubjects) presenter.
				}.
				blank: 10.
			}
		)
	)'definition'
definition = (
^
	column: {
		implementorsPart.
		sendersPart
	}
)) : ()
class SelectorSubject onModel: m = Subject onModel: m (
(* Holds onto a selector (a Symbol) and retrieves its senders and implementors. *)|  |)
('accessing'
selector = (

	^model
)
title = (

	^model printString
)'as yet unclassified'
= other = (
	^self class = other class and: [self model = other model]
)
hash = (
	^model hash
)
implementorSubjects ^ <Collection[MethodSubject]> = (
	(* Answer a collection of senders of our subject, as MethodSubjects. *)

	^implementors collect: [ :each <MethodReference> |
		MethodSubject onMethod: each]
)
senderSubjects ^ <Collection[MethodSubject]> = (
	(* Answer a collection of senders of our subject, as MethodSubjects. *)

	^senders collect: [ :each <MethodReference> |
		MethodSubject onMethod: each]
)'presentation'
createPresenter = (

	^SelectorPresenter onSubject: self
)'private'
implementors = (
	(* Answer a collection of implementors of our selector (as MethodReferences). *)

	^Array streamContents:
		[ :s |
		systemScope allImplementorsOf: model do:
			[ :cls <Class> :sel <Symbol> |
			s nextPut: (MethodReference class: cls selector: sel)]]
)
isReference: a lessThan: b = (

	| aClass bClass |
	aClass:: a classSymbol.
	bClass:: b classSymbol.
	aClass < bClass ifTrue: [^true].
	aClass > bClass ifTrue: [^false].
	^a methodSymbol < b methodSymbol
)
senders = (
	(* Answer a collection of senders of our selector (as MethodReferences). *)

	| them |
	them:: Array streamContents:
				[ :s |
				systemScope allSendersOf: model do:
					[ :cls <Class> :sel <Symbol> |
					s nextPut: (MethodReference class: cls selector: sel)]].
	them:: them sort: [:a :b | isReference: a lessThan: b].
	(* now check for duplicates *)
	1 to: them size - 1 do:
		[:i|
		(them at: i) = (them at: i + 1) ifTrue:
			[^Array streamContents:
				[:s| | prev |
				s nextPut: (prev:: them first).
				them do:
					[:ref|
					ref ~= prev ifTrue:
						[s nextPut: (prev: ref)]]]]].
	^them
)) : ()
class SyntaxErrorNotificationHandler new = Object (
(*  *)| text failureBlock |)
('as yet unclassified'
bindingOf: variableName = (
failureBlock valueWithPossibleArgument: variableName, ' is undefined'
)
notify: garbledErrorMessage <String> at: position <Integer> in: source <ReadStream> = (
| errorMessage |
errorMessage:: (garbledErrorMessage endsWith: ' ->')
	ifTrue: [garbledErrorMessage allButLast: 3]
	ifFalse: [garbledErrorMessage].
failureBlock valueWithPossibleArgument: errorMessage
)
selectFrom: start to: end = (
halt
)
selectionInterval = (
^nil
)) : ()
class SyntheticMethodSubject onModel: m = MethodSubject onModel: m (
(* Describe the class in this comment. *)|
	slot1
	slot2
|)
('as yet unclassified'
changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
   failureBlock value: 'Cannot change category of synthetic method'
)
colorizeMethodSource: sourceText = (
(* Nothing to colorize - displayed source is just a message saying this is an accessor *) 
	^sourceText
)
compileNewSource: source <String> ifSuccess: successBlock ifNewMethod: newBlock1arg ifFailure: failureBlock = (
  (* do nothing *)
)
compiledMethod = (
	^model compiledMethod
)
deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (
   failureBlock value
)
implementingClass = (
	^model actualClass
)
isAnOverride ^ <Boolean> = (
(* True if one of the superclasses has a method with the same selector. *)
   ^false
)
isOverridden ^ <Boolean> = (
(* True if one of the subclasses has a method with the same selector. *)
   ^false
)
isSynthetic ^ <Boolean> = (
	^true
)
isValid ^ <Boolean> = (
   ^true
)
messages	^<Collection[Symbol]> = (
(* Selectors of messages sent by the subject. *) 
 ^{}
)
methodCategory ^<String> = (
	^'<synthetic method>'
)
methodCategoryOrNil ^<String> = (
	^'<synthetic method>'
)
selector ^ <Symbol> = (
	^model methodSymbol
)
source ^ <String> = (
	^'Synthetic  method: no source available'
)
variableBindingKeys	^<Collection[Symbol]> = (
(* Selectors of messages sent by the subject. *) 
 ^{}
)) : ()
class UnsortedMethodsPresenter onSubject: s = AssortedMethodsPresenter onSubject: s (
(* My subject is a collection of methods and I display them unsorted, in other words not grouped by package. *)|  |)
('as yet unclassified'
contentPresenters = (

	^Array streamContents: 
		[:stream | 
		methodPresenters:: subject collect: [:each | newExpandableMethodPresenter: each].
		stream nextPutAll: methodPresenters]
)) : ()) : ()