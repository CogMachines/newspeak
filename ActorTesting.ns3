Newspeak3
'Actors'
class ActorTesting usingPlatform: p actors: a minitest: m = (|
	private TestContext = m TestContext.
	private Semaphore = p squeak Semaphore.
	private Timer = p time Timer.
	private actors = a.
|)
(
class ActorTests = TestContext (|
|)
(
class Math = (|
|)
('as yet unclassified'
factorial: n <Integer> ^ <Integer> = (
	n = 0 ifTrue: [ ^1 ]. 
	^(self ESEND factorial: n - 1) ESEND * n
)
fibonacci: n = (
	n = 0 ifTrue: [ ^0 ].
	n = 1 ifTrue: [ ^1 ].
	^(self ESEND fibonacci: n - 1) ESEND + (self ESEND fibonacci: n - 2)
)
isPositive: n = (
	^n > 0
)) : ()
class Ping = (|
other
|)
('as yet unclassified'
pong: n sum: m = (
	n <= 0 ifTrue: [^m].
	^other ESEND ping: n - 1 sum: n + m
)
start = (
	^other ESEND ping: 10 sum: 0
)) : ()
class Pong = (|
other
|)
('as yet unclassified'
ping: n sum: m = (
	^other ESEND pong: n - 1 sum: n + m
)) : ()'as yet unclassified'
testFactorial = (
	|
	math = (actors createActorFromValue: Math) <-: new.
	result
	|
	result:: waitFor: (math <-: factorial: 9).
	assert: [result = 362880].
)
testFibonacci = (
	|
	math = (actors createActorFromValue: Math) <-: new.
	result
	|
	result:: waitFor: (math <-: fibonacci: 9).
	assert: [result = 34].
)
testIfTrue = (
	|
	math = (actors createActorFromValue: Math) <-: new.
	tookTruePath ::= false.
	result
	|
	result:: waitFor: ((math <-: isPositive: 9) <-: ifTrue: [tookTruePath:: true. 7]).
	assert: [result = 7].
	assert: [tookTruePath].
)
testPingPong = (
	|
	ping = (actors createActorFromValue: Ping) <-: new.
	pong = (actors createActorFromValue: Pong) <-: new.
	result
	|
	ping ESEND other: pong.
	pong ESEND other: ping.
	result:: waitFor: ping ESEND start.
	assert: [result = 55].
)
testPromiseGroup = (
	| mathClass = actors createActor: Math mixin. math r2 r3 r4 g1 g2 |
	math:: mathClass <-: new.
	r2:: math <-: factorial: 2.
	r3:: math <-: factorial: 3.
	g1:: r2, r3.
	r4:: math <-: factorial: 4.
	g2:: r2, r3, r4.
	waitFor: g1.
	assert: [r2 + r3 = 8].
	waitFor: g2.
	assert: [ r2 + r3 + r4 = 32].
)
testTimer = (
	| result |
	(* Creating an actor this way is cheating. Closures are not value objects. *)
	result:: waitFor: (actors createActorFromValue: [
		| bender ticks repeating |
		bender:: actors pastime Bender new.
		ticks:: 0.
		repeating:: Timer every: 20 do: [ticks:: ticks + 1].
		Timer after: 50 do: [repeating cancel. bender resolver resolve: ticks].
		bender promise
	]) <-: value.
	assert: [result = 2].
)
waitFor: promise = (
	|
	timedOut ::= true.
	resolution
	sem = Semaphore new.
	|
	promise whenResolved: 
		[:r |
		resolution: r.
		timedOut:: false.
		sem signal].
	sem waitTimeoutMSecs: 200.
	timedOut ifTrue: [failWithMessage: 'Timed out'].
	^resolution
)) : ('as yet unclassified'
TEST_CONTEXT = (
))) : ()