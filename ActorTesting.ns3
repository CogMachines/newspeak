Newspeak3
'Actors'
class ActorTesting usingPlatform: p actors: a minitest: m = (|
	private TestContext = m TestContext.
	private Semaphore = p squeak Semaphore.
	private Timer = p time Timer.
	private actors = a.
|)
(
class ActorTests = TestContext (|
(*
PromiseKind = { NearEsend, FarEsend, PromiseEsend, WhenClause, UserPromise }
PromiseState = { Unresolved, Resolved, Smashed }
PromiseResolution = { Value, PromiseKind x PromiseState, Exception }
For each PromiseKind, test turn result is PromiseResolution.

Test FIFO delivery order.
Test FIFO fail stop.
*)
|)
(
class Bob meet: a = (| private alice = a. |)
('as yet unclassified'
answerFarRef = (
	^alice
)
answerNearRef = (
	^self
)
answerValue = (
	^42
)
raiseException = (
	^Error signal
)) : ()
class Math = (|
|)
('as yet unclassified'
factorial: n <Integer> ^ <Integer> = (
	n = 0 ifTrue: [ ^1 ]. 
	^(self <-: factorial: n - 1) <-: * n
)
fibonacci: n = (
	n = 0 ifTrue: [ ^0 ].
	n = 1 ifTrue: [ ^1 ].
	^(self <-: fibonacci: n - 1) <-: + (self <-: fibonacci: n - 2)
)
isPositive: n = (
	^n > 0
)) : ()
class Ping = (|
other
|)
('as yet unclassified'
pong: n sum: m = (
	n <= 0 ifTrue: [^m].
	^other <-: ping: n - 1 sum: n + m
)
start = (
	^other <-: ping: 10 sum: 0
)) : ()
class Pong = (|
other
|)
('as yet unclassified'
ping: n sum: m = (
	^other <-: pong: n - 1 sum: n + m
)) : ()'as yet unclassified'
assert: promise resolvedWith: expectedResolution = (
	|
	state ::= #unresolved.
	actualResolution
	sem = Semaphore new.
	|
	promise
		whenResolved: [:r | state:: #resolved. actualResolution:: r. sem signal]
		catch: [:e | state:: #smashed. actualResolution:: e. sem signal].
	sem waitTimeoutMSecs: 800.
	state = #unresolved
		ifTrue: [^failWithMessage: 'Timed out'].
	state = #resolved
		ifTrue: [^assert: actualResolution equals: expectedResolution].
	state = #smashed
		ifTrue: [^failWithMessage: 'Promise smashed with: ', actualResolution printString].
	failWithMessage: 'Invalid state blocking on a promise: ', state.
)
assert: promise smashedWith: expectedErrorClass = (
	|
	state ::= #unresolved.
	actualResolution
	sem = Semaphore new.
	|
	promise
		whenResolved: [:r | state:: #resolved. actualResolution:: r. sem signal]
		catch: [:e | state:: #smashed. actualResolution:: e. sem signal].
	sem waitTimeoutMSecs: 300.
	state = #unresolved
		ifTrue: [^failWithMessage: 'Timed out: ', promise printString].
	state = #resolved
		ifTrue: [^failWithMessage: 'Promise resolved with: ', actualResolution printString].
	state = #smashed
		ifTrue: [^assert: actualResolution class equals: expectedErrorClass].
	failWithMessage: 'Invalid state blocking on a promise: ', state.
)
createActorFromMixin: m = (
	^actors createActor: m
)
testFactorial = (
	|
	math = (actors createActorFromValue: Math) <-: new.
	|
	assert: (math <-: factorial: 9) resolvedWith: 362880.
)
testFibonacci = (
	|
	math = (actors createActorFromValue: Math) <-: new.
	result
	|
	(* result:: waitFor: (math <-: fibonacci: 9).
	assert: [result = 34]. *)
)
testIfTrue = (
	|
	math = (actors createActorFromValue: Math) <-: new.
	tookTruePath ::= false.
	result
	|
	result:: waitFor: ((math <-: isPositive: 9) <-: ifTrue: [tookTruePath:: true. 7]).
	assert: [result = 7].
	assert: [tookTruePath].
)
testPingPong = (
	|
	ping = (actors createActorFromValue: Ping) <-: new.
	pong = (actors createActorFromValue: Pong) <-: new.
	result
	|
	ping <-: other: pong.
	pong <-: other: ping.
	assert: (ping <-: start) resolvedWith: 55.
)
testPromiseGroup = (
	| mathClass = actors createActor: Math mixin. math r2 r3 r4 g1 g2 |
	math:: mathClass <-: new.
	r2:: math <-: factorial: 2.
	r3:: math <-: factorial: 3.
	g1:: r2, r3.
	r4:: math <-: factorial: 4.
	g2:: r2, r3, r4.
	waitFor: g1.
	assert: [r2 + r3 = 8].
	waitFor: g2.
	assert: [ r2 + r3 + r4 = 32].
)
testTimer = (
	| result |
	(* Creating an actor this way is cheating. Closures are not value objects. *)
	result:: waitFor: (actors createActorFromValue: [
		| future ticks repeating |
		future:: actors pastime Future new.
		ticks:: 0.
		repeating:: Timer every: 20 do: [ticks:: ticks + 1].
		Timer after: 50 do: [repeating cancel. future resolver resolve: ticks].
		future promise
	]) <-: value.
	assert: [result = 2].
)
testTurnResultsInException = (
	|
	bob = (createActorFromMixin: Bob mixin) <-: meet: self.
	|
	assert: (bob <-: raiseException) smashedWith: Error.
)
testTurnResultsInNearRef= (
	|
	bobP <Promise[Bob]> = (createActorFromMixin: Bob mixin) <-: meet: self.
	r
	|
	r:: bobP 
		whenResolved: [:bob <FarRef[Bob]> | (bob <-: answerNearRef) 
		whenResolved: [:bob2 <FarRef[Bob]> | assert: bob2 equals: bob ]].
	assert: r resolvedWith: nil.
)
testTurnResultsInValue = (
	|
	bob = (createActorFromMixin: Bob mixin) <-: meet: self.
	|
	assert: (bob <-: answerValue) resolvedWith: 42.
)
waitFor: promise = (
	|
	timedOut ::= true.
	resolution
	sem = Semaphore new.
	|
	promise whenResolved: 
		[:r |
		resolution: r.
		timedOut:: false.
		sem signal].
	sem waitTimeoutMSecs: 200.
	timedOut ifTrue: [failWithMessage: 'Timed out'].
	^resolution
)) : ('as yet unclassified'
TEST_CONTEXT = (
))) : ()