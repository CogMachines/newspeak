Newspeak3
'Actors'
class ProcessPoolDispatcherForSqueak usingPlatform: platform pastime: past mirrors: m poolSize: s <Integer> = (
(*A simple actor system dispatcher backed by a pool of Squeak Processes.
Each actor is pinned to a process from the pool, and actors are allocated to 
processes in a round-robin fashion.*)|
	private Processor = platform squeak Processor.
	private Exception = platform squeak Exception.
	private Halt = platform squeak Halt.
	private UnhandledError = platform squeak UnhandledError.
	private Monitor = platform squeak Monitor.

	private MutableArrayList = platform collections MutableArrayList.

	private pastime = past.
	Resolver = past Resolver.
	Promise = past Promise.
	
	private mirrors = m.
	private poolSize = s.
	private uiActor <Actor> = UIActor usingBrazil: platform brazil.
	private exceptionFilter = AnythingButHalt new.
	private eventLoopCounter <Integer> ::= 0.
	private eventLoops <Collection[EventLoop]>
|) (
class ActorBase = () (
'as yet unclassified'
public eventualSendTo: receiver <Object> selector: selector <Symbol> arguments: args <Array> ^<Promise> = (
	| resolver = pastime Resolver new. |
	postMessageTo: receiver selector: selector arguments: args resolver: resolver.
	^resolver promise
)
public postMessageTo: receiver <Object> selector: selector <Symbol> arguments: args <Array> resolver: resolver = (
	| targetActor message |
	(isPromise: receiver) ifTrue:
		[^receiver future postMessage: selector args: args resolver: resolver].

	(isFarReference: receiver) 
		ifTrue: 
			[targetActor:: receiver actor.
			message:: ActorMessageToFarRef 
				selector: selector
				args: (wrapArgs: args from: self to: targetActor)
				resolver: (nil == resolver ifFalse: [FarReference to: resolver inActor: self])
				receiver: receiver]
		ifFalse:
			[targetActor:: self.
			message:: ActorMessageToNearRef
				selector: selector
				args: args 
				resolver: resolver
				receiver: receiver
				inActor: self].

	targetActor postMessage: message.
	Processor yield.
)
) : (
)
class ActorException cause: c <Exception> = (
(*A wrapper exception class that can pass through as a value object.*)|
	private cause = c.
|) (
'as yet unclassified'
doesNotUnderstand: msg <MessageMirror> ^ <Object> = (
	^msg sendTo: cause. (*direct proxy to underlying exception for now.*)
)
public isValueObject = (
	^true.
)
public passForDebug = (
	#ACCESSBOGUS.
	(* The debugger demands that a context to be debugged belong to the active process. Here we create a new Process and stick in the context that triggered the exception. We then invoke defaultAction, which will start an UnhandledError that will eventually create a debugger. *)
	[thisContext privSender: cause signalerContext.
	cause defaultAction] fork.
)
) : (
)
class ActorMessage selector: s <String> args: a <{}> resolver: r <Resolver | FarReference[Resolver] | nil> = EventLoopMessage (
(*An abstract class that knows how to dispatch eventual-sends.*)|
	private selector = s.
	private args = a.
	private resolver = r.
|) (
'as yet unclassified'
public dispatchMessage = (
	| result tryContext |
	[
		tryContext:: thisContext.
		result:: receiverNearRef perform: selector withArguments: args.
	] on: exceptionFilter do: [ :error |
		resolver isNil ifFalse: [
			
			(* Insert 'Processor terminateActive' beneath the dispatch of this message so if one continues passed the exception in the debugger it eventually terminates cleanly. *)
			tryContext privSender: terminateContext.
				
			currentActor postMessageTo: resolver 
				selector: 'smash:' 
				arguments: { ActorException cause: error }
				resolver: nil
		] ifTrue: [
			error pass. (*Let unhandled exceptions surface.*)
		].
		(* Arrange to return from our home context, while leaving the stack above the home context intact. We MUST NOT use an NLR because we do not want to trigger any of the handler contexts between this context and its home context. In effect, this is like an unguarded NLR. *)
		thisContext privSender: thisContext home sender.
	].
	resolver isNil ifFalse: [
		currentActor postMessageTo: resolver selector: 'resolve:' arguments: { result } resolver: nil.
	].
)
receiverNearRef = (
	subclassResponsibility
)
terminateContext = (
	^[Processor terminateActive] asContext
)
) : (
)
class ActorMessageToFarRef selector: s <String> args: a <{}> resolver: r <FarReference[Resolver] | nil>
	receiver: receiver <FarReference> = ActorMessage selector: s args: a resolver: r (
(*A message whose receiver is a far reference. Both the receiver's actor and near-ref are stored in the FarReference and do not need to be duplicated.*)|
	private receiverFarRef = receiver.
|) (
'as yet unclassified'
public receiverActor = (
	^receiverFarRef actor
)
receiverNearRef = (
	^receiverFarRef target
)
) : (
)
class ActorMessageToNearRef selector: s <String> args: a <{}> resolver: r <Resolver | nil>
	receiver: receiver <Object> inActor: actor = ActorMessage selector: s args: a resolver: r (
(*A message whose receiver is a near reference. Must also hold the actor reference.*)|
	receiverActor = actor.
	receiverNearRef = receiver.
|) (
) : (
)
class AnythingButHalt = (
(*Filters out Halt exceptions in order to pass those through for debugging.*)|
|) (
'as yet unclassified'
public handles: e <Exception> = (
	(*We cannot define this as a class method and then simply use the class object,
	since ContextPart`isInterestedIn: treats Newspeak class objects specially,
	and does the equivalent of an isInstanceOf: check instead of sending the handles:
	message.*)
	(*Halt gets wrapped in UnhandledError and resignaled, so we must skip UnhandledError as well.*)
	^(e isKindOf: Halt) not and: [ (e isKindOf: UnhandledError) not].
)
) : (
)
class EventLoop index: i <Integer> = (
(*The dispatcher's event loop background process carrying out the execution of one or more actors.*)|
	private index <Integer> = i.
	private messageQueue <SharedQueue2[EventLoopMessage]> = SimpleSharedQueue new.
	private process <Process>
	private running <Boolean> ::= false.
	currentActor <Actor>
|) (
public class Actor = ActorBase (
(*An actor class that is stateless and as lightweight as possible.*)|
|) (
'as yet unclassified'
pendingMessages = (
	^messageQueue select: [ :m | m receiverActor == self ].
)
public postMessage: message <ActorMessage> = (
	messageQueue nextPut: message.
)
) : (
)
class ShutdownMessage = EventLoopMessage (
(*A dummy message that shuts down the event loop process upon receipt.*)|
|) (
'as yet unclassified'
public dispatchMessage = (
	running: false.
)
public receiverActor = (
	^nil.
)
) : (
)
'as yet unclassified'
eventualSendProxyFor: target = (
	^mirrors EventualSendProxy for: target.
)
private launchEventLoop: relaunchCount <Integer> = (
	| proc = [ runEventLoop: relaunchCount ] newProcess. |

	proc name: 'ProcessPoolDispatcherForSqueak Event Loop #', index, '.', relaunchCount.
	proc priority: Processor userBackgroundPriority.
	process: proc.
	running: true.
	proc instVarAt: 7 put: self.
	proc resume.
)
private runEventLoop: relaunchCount <Integer> = (
	[
		[ running ] whileTrue: [
			| message <EventLoopMessage> = messageQueue next. |
			currentActor: message receiverActor.
			message dispatchMessage.
			currentActor: nil.
		].
		process: nil.
		messageQueue removeAll. (*TODO warn about dropped messages somewhere?*)
	] ensure: [
		(*If an exception passed through, or we the process is being terminated, but the dispatcher is still running, relaunch the event loop.*)
		running ifTrue: [ launchEventLoop: relaunchCount + 1 ]
	].
)
public startEventLoop = (
	running ifFalse: [ launchEventLoop: 0. ] ifTrue: [ Error signal: 'EventLoop already running.' ]
)
public stopEventLoop ^ <Boolean> = (
	running ifTrue: [ messageQueue nextPut: ShutdownMessage new. ].
	^running.
)
) : (
)
class EventLoopMessage = (
(*An abstract class for event loop messages.*)|
|) (
'as yet unclassified'
public dispatchMessage = (
	subclassResponsibility
)
public receiverActor = (
	subclassResponsibility
)
) : (
)
class FarReference to: t inActor: a = (
(*A far reference is one that crosses actor boundaries. It knows about its actor and target object.*)|
	public (* BOGUS *) target = t.
	public (* BOGUS *) actor = a.
|#ACCESSBOGUS) (
'as yet unclassified'
doesNotUnderstand: msg <MessageMirror> ^ <Object> = (
	| sel |
	(*For debugger inspection support: ignore is* messages, like Object does.*)
	sel: msg selector.
	sel isUnary ifTrue: [(sel startsWith: 'is') ifTrue: [^false]].

	Error signal: 'Cannot immediate-send ', msg, ' to an eventual reference. Far references only accept eventual-sends.'.
)
public isNil = (
	^false. (*far reference can never have a nil target. nil is a value object.*)
)
) : (
)
class SimpleSharedQueue = (
(*A simple shared queue derived from Squeak Smalltalk SharedQueue2 with the added ability to
query messages using select:. Querying messages is used by Actor to support reflecting on
the actor's message queue by ActorMirror.*)|
	private items = MutableArrayList new.
	private monitor = Monitor new.
|) (
'as yet unclassified'
public next = (
	monitor critical: [
		monitor waitWhile: [ items isEmpty ].
		^items removeFirst
	]
)
public nextPut: item = (
	monitor critical: [
		items addLast: item.
		monitor signal.
	].
	^item.
)
public removeAll = (
	monitor critical: [
		items removeAll
	].
)
public select: aBlock = (
	monitor critical: [
		^items select: aBlock.
	]
)
) : (
)
class UIActor usingBrazil: b = ActorBase (
(*Posts messages on the Brazil desktop UI event loop.*)|
	(*Store a reference to brazil, because the desktop object can be replaced 
	in the middle of a running session.*)
	private brazil = b.
	public pendingMessages = MutableArrayList new.
|) (
'as yet unclassified'
public postMessage: message <ActorMessage> = (
	(*Keep track of pending deliveries for reflection support in ActorMirror.*)
	pendingMessages addLast: message.
	(*Query the desktop object each time, because the desktop can be replaced 
	in the middle of a running session.*)
	brazil theDesktop scheduleUIAction: [
		pendingMessages removeFirst dispatchMessage.
	].
)
) : (
)
'actor-system'
isValueObject: o <Object> ^<Boolean> = (
	(*Quick and dirty hack for value objects - nil, numbers, strings, bools, chars, or self-proclaimed.*)
	(*Note: arrays are NOT value objects. If you need arrays as data, create a wrapper class.*)
	(*Value objects alone constitue at least one SJSU Master's theses in scope.*)
	nil == o ifTrue: [^true].
	true == o ifTrue: [^true].
	false == o ifTrue: [^true].
	o isString ifTrue: [^true].
	o isNumber ifTrue: [^true].
	o isCharacter ifTrue: [^true].
	^o isValueObject
)
wrapArgs: args <{}> from: srcActor <Actor> to: targetActor <Actor> ^ <{}> = (
	^args collect: [ :rawArg | | arg = pastime unwrapPromise: rawArg. |
		(*1) Handle far references*)
		(isFarReference: arg) ifTrue: [
			arg actor == targetActor 
				(*unwrap far reference to object in target actor's heap (far reference becomes near reference)*)
				ifTrue: [ arg target ]
				(*pass along far references to objects in other actors as-is (Granovetter introduction)*)
				ifFalse: [ arg ]
		]
		ifFalse: [
			(*2) Handle promises*)
			(pastime isPromise: arg) ifTrue: [
				(*The future lives in the target actor!
				The closures passed to arg also live in the target actor.
				The promise arg, however, lives in the source actor.
				Therefore we must pass the closures as far references.*)
				| targetResolver = pastime Resolver new. |
				(*Effectively an eventual-send from targetActor to arg whenResolved:catch: in source actor.*)
				(*TODO smashed promise will trigger extraneous message send here. can be optimized.*)
				(*TODO eventually we need a distinction between near and far unresolved promises. 
				this is the point where a near unresolved promise would be `serialized` as a far unresolved
				promise and a far unresolved promise to the target actor will deserialize as a near unresolved
				promise, just like we do for far references above. This kind of distinction enables true
				promise pipelining in the E sense as described by Mark Miller.*)
				arg whenResolved: (FarReference to: [ :r | targetResolver resolve: r ] inActor: targetActor)
					whenSmashed: (FarReference to: [ :e | targetResolver smash: e ] inActor: targetActor)
					resolver: nil.
				targetResolver promise.
			]
			ifFalse: [
				(*3) Handle value objects*)
				(isValueObject: arg)
					ifTrue: [ arg ] (*pass by value*)
					ifFalse: [ FarReference to: arg inActor: srcActor ] (*pass by far reference*)
			]
		]
	].
)
'as yet unclassified'
createActorFromValue: v <Value> ^ <EventualReference[Value]> = (
	| eventLoopIndex eventLoop clazz |
	(*1) Select the eventLoop to allocate the actor in.*)
	(*Note: I do not care about atomicity of the increment operation below enough to wrap it in a mutex.*)
	eventLoopIndex:: (eventLoopCounter:: (eventLoopCounter + 1) rem: poolSize) + 1.
	eventLoop:: eventLoops at: eventLoopIndex.

	(*2) Copy the value to the actor's heap and return an eventual reference to it.*)
	(*TODO ensure it really is a value object*)
	^FarReference to: v inActor: eventLoop Actor new.
)
isPromise: o <Object> ^<Boolean> = (
	(* Check the class instead of asking the object in order to prevent user code from emulating Promises. *)
	(* Should be vmmirror classOf: o *)
	^Promise == o class
)
'dispatcher'
createActor: mixin <Mixin> ^ <EventualReference[Class]> = (

	^createActorFromValue: (mixin apply: Object)
)
currentActor ^<Actor> = (
	^Processor currentActor
)
isFarReference: o <Object> ^<Boolean> = (
	(* Should be vmmirror classOf: o *)
	^FarReference == o class
)
startDispatcher = (
	eventLoops isNil ifFalse: [ Error signal: 'Dispatcher is already running.' ].
	eventLoops:: (1 to: poolSize) collect: [ :i | EventLoop index: i ].
	eventLoops do: [ :e | e startEventLoop ].
)
stopDispatcher ^ <Boolean> = (
	eventLoops isNil
		ifFalse: [ eventLoops do: [ :e | e stopEventLoop. ]. eventLoops: nil. ^true ]
		ifTrue: [ ^false ]
)
) : (
'as yet unclassified'
usingPlatform: platform pastime: past mirrors: mirrors = (
	(*Temporary hack until I learn how to compose modules.*)
	^self usingPlatform: platform pastime: past mirrors: mirrors poolSize: 9.
)
)
