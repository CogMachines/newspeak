Newspeak3
'Actors'
class ProcessPoolDispatcherForSqueak usingPlatform: platform pastime: past mirrors: m poolSize: s <Integer> = (
(*A simple actor system dispatcher backed by a pool of Squeak Processes.
Each actor is pinned to a process from the pool, and actors are allocated to 
processes in a round-robin fashion.*)|
	private Processor = platform squeak Processor.
	private Exception = platform blackMarket Exception.
	private Halt = platform blackMarket Halt.
	private UnhandledError = platform blackMarket UnhandledError.
	private Monitor = platform squeak Monitor.

	private MutableArrayList = platform collections MutableArrayList.

	private pastime = past.
	private mirrors = m.
	private poolSize = s.
	private uiActor <Actor> = UIActor usingBrazil: platform brazil.
	private exceptionFilter = AnythingButHalt new.
	private eventLoopCounter <Integer> ::= 0.
	private eventLoops <Collection[EventLoop]>
|)
(
class ActorException cause: c <Exception> = (
(*A wrapper exception class that can pass through as a value object.*)|
	private cause = c.
|)
('as yet unclassified'
doesNotUnderstand: msg <MessageMirror> ^ <Object> = (
	^msg sendTo: cause. (*direct proxy to underlying exception for now.*)
)
isValueObject = (
	^true.
)
passForDebug = (
	(* The debugger demands that a context to be debugged belong to the active process. Here we create a new Process and stick in the context that triggered the exception. We then invoke defaultAction, which will start an UnhandledError that will eventually create a debugger. *)
	[thisContext privSender: cause signalerContext.
	cause defaultAction] fork.
)) : ()
class ActorMessage selector: s <String> args: a <{}> resolver: r <Resolver | FarReference[Resolver] | nil> = EventLoopMessage (
(*An abstract class that knows how to dispatch eventual-sends.*)|
	private selector = s.
	private args = a.
	private resolver = r.
|)
('as yet unclassified'
dispatchMessage = (
	| result tryContext |
	[
		tryContext:: thisContext.
		result:: receiverNearRef perform: selector withArguments: args.
	] on: exceptionFilter do: [ :error |
		resolver isNil ifFalse: [
			
			(* Insert 'Processor terminateActive' beneath the dispatch of this message so if one continues passed the exception in the debugger it eventually terminates cleanly. *)
			tryContext privSender: terminateContext.
				
			postMessageTo: resolver 
				selector: 'smash:' 
				args: { ActorException cause: error }
				resolver: nil
		] ifTrue: [
			error pass. (*Let unhandled exceptions surface.*)
		].
		(* Arrange to return from our home context, while leaving the stack above the home context intact. We MUST NOT use an NLR because we do not want to trigger any of the handler contexts between this context and its home context. In effect, this is like an unguarded NLR. *)
		thisContext privSender: thisContext home sender.
	].
	resolver isNil ifFalse: [
		postMessageTo: resolver selector: 'resolve:' args: { result } resolver: nil.
	].
)
receiverNearRef = (
	subclassResponsibility
)
terminateContext = (
	^[Processor terminateActive] asContext
)) : ()
class ActorMessageToFarRef selector: s <String> args: a <{}> resolver: r <FarReference[Resolver] | nil>
	receiver: receiver <FarReference> = ActorMessage selector: s args: a resolver: r (
(*A message whose receiver is a far reference. Both the receiver's actor and near-ref are stored in the FarReference and do not need to be duplicated.*)|
	private receiverFarRef = receiver.
|)
('as yet unclassified'
receiverActor = (
	^receiverFarRef actor
)
receiverNearRef = (
	^receiverFarRef target
)) : ()
class ActorMessageToNearRef selector: s <String> args: a <{}> resolver: r <Resolver | nil>
	receiver: receiver <Object> inActor: actor = ActorMessage selector: s args: a resolver: r (
(*A message whose receiver is a near reference. Must also hold the actor reference.*)|
	receiverActor = actor.
	receiverNearRef = receiver.
|)
() : ()
class AnythingButHalt = (
(*Filters out Halt exceptions in order to pass those through for debugging.*)|
|)
('as yet unclassified'
handles: e <Exception> = (
	(*We cannot define this as a class method and then simply use the class object,
	since ContextPart`isInterestedIn: treats Newspeak class objects specially,
	and does the equivalent of an isInstanceOf: check instead of sending the handles:
	message.*)
	(*Halt gets wrapped in UnhandledError and resignaled, so we must skip UnhandledError as well.*)
	^(e isKindOf: Halt) not and: [ (e isKindOf: UnhandledError) not].
)) : ()
class EventLoop index: i <Integer> = (
(*The dispatcher's event loop background process carrying out the execution of one or more actors.*)|
	private index <Integer> = i.
	private messageQueue <SharedQueue2[EventLoopMessage]> = SimpleSharedQueue new.
	private process <Process>
	private running <Boolean> ::= false.
	currentActor <Actor>
|)
(
class Actor = (
(*An actor class that is stateless and as lightweight as possible.*)|
|)
('as yet unclassified'
pendingMessages = (
	^messageQueue select: [ :m | m receiverActor == self ].
)
postMessage: message <ActorMessage> = (
	messageQueue nextPut: message.
)) : ()
class ShutdownMessage = EventLoopMessage (
(*A dummy message that shuts down the event loop process upon receipt.*)|
|)
('as yet unclassified'
dispatchMessage = (
	running: false.
)
receiverActor = (
	^nil.
)) : ()'as yet unclassified'
eventualSendProxyFor: target = (
	^mirrors EventualSendProxy for: target.
)
private launchEventLoop: relaunchCount <Integer> = (
	| proc = [ runEventLoop: relaunchCount ] newProcess. |

	proc name: 'ProcessPoolDispatcherForSqueak Event Loop #', index, '.', relaunchCount.
	proc priority: Processor userBackgroundPriority.
	process: proc.
	running: true.
	proc instVarAt: 7 put: self.
	proc resume.
)
private runEventLoop: relaunchCount <Integer> = (
	[
		[ running ] whileTrue: [
			| message <EventLoopMessage> = messageQueue next. |
			currentActor: message receiverActor.
			message dispatchMessage.
			currentActor: nil.
		].
		process: nil.
		messageQueue removeAll. (*TODO warn about dropped messages somewhere?*)
	] ensure: [
		(*If an exception passed through, or we the process is being terminated, but the dispatcher is still running, relaunch the event loop.*)
		running ifTrue: [ launchEventLoop: relaunchCount + 1 ]
	].
)
startEventLoop = (
	running ifFalse: [ launchEventLoop: 0. ] ifTrue: [ Error signal: 'EventLoop already running.' ]
)
stopEventLoop ^ <Boolean> = (
	running ifTrue: [ messageQueue nextPut: ShutdownMessage new. ].
	^running.
)) : ()
class EventLoopMessage = (
(*An abstract class for event loop messages.*)|
|)
('as yet unclassified'
dispatchMessage = (
	subclassResponsibility
)
receiverActor = (
	subclassResponsibility
)) : ()
class FarReference to: t inActor: a = (
(*A far reference is one that crosses actor boundaries. It knows about its actor and target object.*)|
	target = t.
	actor = a.
|)
('as yet unclassified'
ESEND = (
	^mirrors EventualSendProxy for: self
)
doesNotUnderstand: msg <MessageMirror> ^ <Object> = (
	| sel |
	(*For debugger inspection support: ignore is* messages, like Object does.*)
	sel: msg selector.
	sel isUnary ifTrue: [(sel startsWith: 'is') ifTrue: [^false]].

	Error signal: 'Cannot immediate-send ', msg, ' to an eventual reference. Far references only accept eventual-sends.'.
)
isNil = (
	^false. (*far reference can never have a nil target. nil is a value object.*)
)) : ()
class SimpleSharedQueue = (
(*A simple shared queue derived from Squeak Smalltalk SharedQueue2 with the added ability to
query messages using select:. Querying messages is used by Actor to support reflecting on
the actor's message queue by ActorMirror.*)|
	private items = MutableArrayList new.
	private monitor = Monitor new.
|)
('as yet unclassified'
next = (
	monitor critical: [
		monitor waitWhile: [ items isEmpty ].
		^items removeFirst
	]
)
nextPut: item = (
	monitor critical: [
		items addLast: item.
		monitor signal.
	].
	^item.
)
removeAll = (
	monitor critical: [
		items removeAll
	].
)
select: aBlock = (
	monitor critical: [
		^items select: aBlock.
	]
)) : ()
class UIActor usingBrazil: b = (
(*Posts messages on the Brazil desktop UI event loop.*)|
	(*Store a reference to brazil, because the desktop object can be replaced 
	in the middle of a running session.*)
	private brazil = b.
	public pendingMessages = MutableArrayList new.
|)
('as yet unclassified'
postMessage: message <ActorMessage> = (
	(*Keep track of pending deliveries for reflection support in ActorMirror.*)
	pendingMessages addLast: message.
	(*Query the desktop object each time, because the desktop can be replaced 
	in the middle of a running session.*)
	brazil theDesktop scheduleUIAction: [
		pendingMessages removeFirst dispatchMessage.
	].
)) : ()'actor-system'
isValueObject: o <Object> ^ <Boolean> = (
	(*Quick and dirty hack for value objects - nil, numbers, strings, bools, chars, or self-proclaimed.*)
	(*Note: arrays are NOT value objects. If you need arrays as data, create a wrapper class.*)
	(*Value objects alone constitue at least one SJSU Master's theses in scope.*)
	^o == nil or: [ o isNumber or: [ o isString or: [ o == true or: [ o == false or: [ o isCharacter or: [ o isValueObject ] ] ] ] ] ]
)
postMessageTo: receiver <Object> selector: selector <String> args: args <{}> resolver: resolver <Resolver | nil> = (
	| srcActor = currentActor. targetActor message |
	(isFarReference: receiver)
		ifTrue: [
			targetActor: receiver actor.
			message:: ActorMessageToFarRef selector: selector args: (wrapArgs: args from: srcActor to: targetActor)
				resolver: (resolver isNil ifTrue: [ nil ] ifFalse: [ FarReference to: resolver inActor: srcActor ]) receiver: receiver ]
		ifFalse: [
			targetActor: srcActor.
			message:: ActorMessageToNearRef selector: selector args: args 
				resolver: resolver receiver: receiver inActor: srcActor ].
	targetActor postMessage: message.
	Processor yield.
)
wrapArgs: args <{}> from: srcActor <Actor> to: targetActor <Actor> ^ <{}> = (
	^args collect: [ :rawArg | | arg = pastime unwrapPromise: rawArg. |
		(*1) Handle far references*)
		(isFarReference: arg) ifTrue: [
			arg actor == targetActor 
				(*unwrap far reference to object in target actor's heap (far reference becomes near reference)*)
				ifTrue: [ arg target ]
				(*pass along far references to objects in other actors as-is (Granovetter introduction)*)
				ifFalse: [ arg ]
		]
		ifFalse: [
			(*2) Handle promises*)
			(pastime isPromise: arg) ifTrue: [
				(*The future lives in the target actor!
				The closures passed to arg also live in the target actor.
				The promise arg, however, lives in the source actor.
				Therefore we must pass the closures as far references.*)
				| targetResolver = pastime Resolver new. |
				(*Effectively an eventual-send from targetActor to arg whenResolved:catch: in source actor.*)
				(*TODO smashed promise will trigger extraneous message send here. can be optimized.*)
				(*TODO eventually we need a distinction between near and far unresolved promises. 
				this is the point where a near unresolved promise would be `serialized` as a far unresolved
				promise and a far unresolved promise to the target actor will deserialize as a near unresolved
				promise, just like we do for far references above. This kind of distinction enables true
				promise pipelining in the E sense as described by Mark Miller.*)
				arg whenResolved: (FarReference to: [ :r | targetResolver resolve: r ] inActor: targetActor)
					whenSmashed: (FarReference to: [ :e | targetResolver smash: e ] inActor: targetActor)
					resolver: nil.
				targetResolver promise.
			]
			ifFalse: [
				(*3) Handle value objects*)
				(isValueObject: arg)
					ifTrue: [ arg ] (*pass by value*)
					ifFalse: [ FarReference to: arg inActor: srcActor ] (*pass by far reference*)
			]
		]
	].
)'as yet unclassified'
createActorFromValue: v <Value> ^ <EventualReference[Value]> = (
	| eventLoopIndex eventLoop clazz |
	(*1) Select the eventLoop to allocate the actor in.*)
	(*Note: I do not care about atomicity of the increment operation below enough to wrap it in a mutex.*)
	eventLoopIndex:: (eventLoopCounter:: (eventLoopCounter + 1) rem: poolSize) + 1.
	eventLoop:: eventLoops at: eventLoopIndex.

	(*2) Copy the value to the actor's heap and return an eventual reference to it.*)
	(*TODO ensure it really is a value object*)
	^FarReference to: v inActor: eventLoop Actor new.
)'dispatcher'
createActor: mixin <Mixin> ^ <EventualReference[Class]> = (

	^createActorFromValue: (mixin apply: Object)
)
currentActor ^ <Actor> = (
	| activeProcess = Processor activeProcess. |
	eventLoops do: [ :e | e process == activeProcess ifTrue: [ ^e currentActor ] ].
	^uiActor (*use the UI actor as a fall-back for all non-actor Squeak Processes*).
)
isFarReference: o <Object> ^ <Boolean> = (
	(*Check the class instead of asking the object directly in order to prevent user code from emulating FarReference.*)
	^o class == FarReference
)
startDispatcher = (
	eventLoops isNil ifFalse: [ Error signal: 'Dispatcher is already running.' ].
	eventLoops:: (1 to: poolSize) collect: [ :i | EventLoop index: i ].
	eventLoops do: [ :e | e startEventLoop ].
)
stopDispatcher ^ <Boolean> = (
	eventLoops isNil
		ifFalse: [ eventLoops do: [ :e | e stopEventLoop. ]. eventLoops: nil. ^true ]
		ifTrue: [ ^false ]
)) : ('as yet unclassified'
usingPlatform: platform pastime: past mirrors: mirrors = (
	(*Temporary hack until I learn how to compose modules.*)
	^self usingPlatform: platform pastime: past mirrors: mirrors poolSize: 9.
))