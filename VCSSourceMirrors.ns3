Newspeak3
'StructuredVCS'
class VCSSourceMirrors usingPlatform: p vcs: vcs = (
(* Newspeak Source Mirrors for version control

Copyright (c) 2010-2011 Matthias Kleine

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ''Software''), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*)|
private Differencer = vcs diffing Differencer.
private imageMirrorCache = vcs imageMirrorCache.

private PackageInfo = p blackMarket PackageInfo.
private Dictionary = p blackMarket Collections Dictionary.
private OrderedCollection = p blackMarket Collections OrderedCollection.

private newspeakSourceMirrors = vcs newspeakSourceMirrors.
private smalltalkSourceMirrors = vcs smalltalkSourceMirrors.

(* Other fields *)
public mirrorLoader = MirrorLoader withClassDictionary: p blackMarket Smalltalk.
|)
(
class MirrorLoader withClassDictionary: d = (|
	private classDictionary = d.
|)
('as yet unclassified'
imageMirrorsNotCorrespondingTo: mirrors = (

	| classes packages |
	
	#BOGUS yourself. (* Please refactor me! *)

	classes:: classDictionary values select: [:each |
		each isBehavior 
		and: [(each language isNewspeakLanguage3 or: [each language isNewspeakLanguage2]) 
		and: [(each name includes: $`) not 
		and: [mirrors noneSatisfy: [:mirror | (* We shouldn't have this name-equality stuff here *)
			mirror isPackageMirror not and: [mirror name = each name or: [each name startsWith: 'AnObsolete']]]]]]].
	classes:: classes collect: [:each |
		NameOnlySourceMirror 
			named: each name , ' [module]'
			actualMirror: (Future computing: [imageMirrorCache at: each name , '.ns3' ifAbsentPut: [mirrorForClass: each]])].

	packages:: PackageInfo allPackages select: [:each |
		mirrors noneSatisfy: [:mirror | mirror isPackageMirror and: [mirror name = each name]]].
	packages:: packages collect: [:each |
		NameOnlySourceMirror
			named: each name , ' [package]'
			actualMirror: (Future computing: [imageMirrorCache at: each name , '.st' ifAbsentPut: [mirrorForPackage: each]])].

	^ classes , packages
)
installMirrorsAsToplevelClasses: newMirrors = (

	| changedMirrors |
	
	#BOGUS yourself. (* Why is the argument a dictionary? *)
	
	changedMirrors:: newMirrors values select: [:each |
		self
			mirrorForClassInImageCorrespondingTo: each
			ifPresent: [:it | (Differencer allEqual: {each. it}) not]
			ifAbsent: [true]].
		
	(* This installation is not atomic *)
	smalltalkSourceMirrors installMirrors: 
		(changedMirrors select: [:ea | ea languageIdentifier = 'Smalltalk']).

	(* This installation is atomic *)
	newspeakSourceMirrors installMirrors:
		(changedMirrors select: [:ea | ea languageIdentifier = 'Newspeak3']).
)
methodMirrorForStream: stream ifError: errorBlock = (

	#BOGUS yourself. (* Used by merging UI; consider refactoring. *)

	^newspeakSourceMirrors methodDeclCache mirrorForStream: stream ifError: errorBlock
)
mirrorForClass: aClass = (

	^newspeakSourceMirrors mirrorForClass: aClass
)
mirrorForClassInImageCorrespondingTo: mirror ifPresent: presentBlock ifAbsent: absentBlock = (

        | correspondingMirror |

	mirror isPackageMirror ifTrue: [
		correspondingMirror:: imageMirrorCache
			at: mirror filename
			ifAbsentPut: [ 
				|pkgInfo|
				pkgInfo:: PackageInfo allPackages 
					detect: [:e | e name = mirror name]
					ifNone: [^absentBlock value].
				mirrorForPackage: pkgInfo].
		^presentBlock value: correspondingMirror.
	].

        correspondingMirror:: imageMirrorCache
                at: mirror filename
                ifAbsentPut: [ | existingClass |
                        existingClass:: classDictionary
                                at: mirror name
                                ifAbsent: [^ absentBlock value].
                        mirrorForClass: existingClass].
        ^ presentBlock value: correspondingMirror.
)
mirrorForPackage: pkgInfo = (

	^smalltalkSourceMirrors mirrorForPackage: pkgInfo
)
mirrorForStream: stream = (

	(stream contents startsWith: 'Smalltalk') 
		ifTrue: [^smalltalkSourceMirrors mirrorForStream: stream].

	^newspeakSourceMirrors mirrorForStream: stream
)) : ()
class NameOnlySourceMirror named: n actualMirror: m = (
(* A way to put off actually constructing a source mirror, which might involve expensive parsing. *)|
	name = n.
	actualMirror <Delay[SourceMirror]> = m.
|)
() : ()
class SourceMirror = (|
|)
('as yet unclassified'
compareTo: other withAncestor: ancestor = (

	^ Differencer compare: self to: other withAncestor: ancestor
)
contents = (

	^ String streamContents: [:stream | streamTo: stream]
)
contentsEquals: other= (
	
	^ contents = other contents
)
correspondsHash = (

	^ name hash
)
correspondsTo: other = (

	^ name = other name
)
end = (
	
	^ yield end
)
source = (

	^ contents
)
start = (

	^ yield start
)) : ()
class StringMirror = (
(* Encapsulates functionality for some leaf elements, e.g. category or class comment *)|
	string
|)
('as yet unclassified'
children = (

	^ {}
)
contentsEquals: other = (

	^ string = other string
)
correspondsHash = (

	^ 42
)
correspondsTo: other = (

	^ true
)) : ()'as yet unclassified'
flatten: collection = (

	| result |
	result:: OrderedCollection new.
	collection do: [:each | result addAll: each].
	^ result
)
imageMirrorsNotCorrespondingTo: mirrors = (

	^ mirrorLoader imageMirrorsNotCorrespondingTo: mirrors
)
installMirrorsAsToplevelClasses: newMirrors = (

	mirrorLoader installMirrorsAsToplevelClasses: newMirrors
)
methodMirrorForStream: stream ifError: errorBlock = (

	^ mirrorLoader methodMirrorForStream: stream ifError: errorBlock
)
mirrorForClassInImageCorrespondingTo: mirror ifPresent: presentBlock ifAbsent: absentBlock = (

	^ mirrorLoader mirrorForClassInImageCorrespondingTo: mirror ifPresent: presentBlock ifAbsent: absentBlock
)
mirrorForStream: stream = (

	^ mirrorLoader mirrorForStream: stream
)) : ()