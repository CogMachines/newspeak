Newspeak3

'StructuredVCS'



class VCSSourceMirrors usingPlatform: p vcs: vcs = ("Newspeak Source Mirrors for version control

Copyright (c) 2010-2011 Matthias Kleine

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ''Software''), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
"|

"arguments"
private CombinatorialParser = p mirrors parserLib CombinatorialParser.
private TypedNS3Grammar = p mirrors grammar TypedNS3Grammar.
private Differencer = vcs diffing Differencer.
private imageMirrorCache = vcs imageMirrorCache.
private LanguageFileReader = p LanguageFileReader.

"Imports"

PackageInfo = p PackageInfo.

"Collections"
private Dictionary = p Collections Dictionary.
private OrderedCollection = p Collections OrderedCollection.

private Yield = p Yield Yield.
private ParentYield = p ParentYield.

"Nested classes"

private mirrors = Mirrors new.
SlotSourceMirror = mirrors SlotSourceMirror.
MethodSourceMirror = mirrors MethodSourceMirror.
ClassSourceMirror = mirrors ClassSourceMirror.

SmalltalkPackageSourceMirror = Delay computation: [vcs stSourceMirrors SmalltalkPackageSourceMirror].

SourceMirrorParser = Parsing new SourceMirrorParser.

"Other fields"
classDictionary = p Smalltalk.
public mirrorLoader = Loading new MirrorLoader classDictionary: classDictionary.
private newspeak3Compiler = p Language newspeak3 compiler new.
|)

(



class Mirrors = (|
|)

(



class MethodSourceMirror = SourceMirror (|
protected messagePattern
protected methodSource
protected category
protected accessModifier
private selector
|)

('as yet unclassified'

children = (	^ {})



contentsEquals: other = (	^ self methodSource = other methodSource and: [		self category = other category and: [			self accessModifier = other accessModifier]])



copy = (	"Should Newspeak have a default shallow copy built in?"	^ MethodSourceMirror new		messagePattern: messagePattern;		methodSource: methodSource;		category: category;		accessModifier: accessModifier;		selector: selector;		yourself)



correspondsHash = (	^ selector hash)



correspondsTo: other = (	^ self selector = other selector)



isMethodMirror = (	^ true)



name = (	^ messagePattern)



streamTo: stream = (	stream nextPutAll: methodSource)



)



class SourceMirror = (|
|)

('as yet unclassified'

compareTo: other withAncestor: ancestor = (	^ Differencer compare: self to: other withAncestor: ancestor)



contents = (	^ String streamContents: [:stream | streamTo: stream])



contentsEquals: other= (		^ contents = other contents)



correspondsHash = (	^ name hash)



correspondsTo: other = (	^ name = other name)



end = (		^ yield end)



source = (	^ contents)



start = (	^ yield start)



)



class SlotSourceMirror = SourceMirror (|
name
accessModifier
type
initializer
immutable
|)

('as yet unclassified'

children = (	^ {})



streamTo: stream = (	accessModifier ifNotNil: [:it | 		stream			nextPutAll: it;			nextPutAll: ' ' ].	stream nextPutAll: name.	type ifNotNil: [:it | 		stream			nextPut: $<;			nextPutAll: it;			nextPut: $>].	initializer ifNotNil: [:it | 		immutable			ifTrue: [stream nextPutAll: ' = ']			ifFalse: [stream nextPutAll: ' ::= '].		stream			nextPutAll: it;			nextPutAll: '.'].)



)



class ClassSourceMirror = SourceMirror (|
category
accessModifier
name
constructor
superclassClause
classComment
slotsSource
slots
initExpressions
classes
instanceMethods
classMethods
|)

('as yet unclassified'

children = (	^ Array streamContents: [:stream |		{#name. #category. #accessModifier. #constructor. #superclassClause. #classComment. #slotsSource. #initExpressions} do: [:each |			(self perform: each) ifNotNil: [:it | | stringMirror |				stringMirror:: StringMirror new					string: it;					yourself.				stream nextPut: each -> stringMirror]].		{#slots. #classes. #instanceMethods. #classMethods} do: [:each |			(self perform: each) ifNotNil: [:it |				stream nextPutAll: (it collect: [:el | each -> el])]]]	)



filename = (	^name, '.ns3')



installAsToplevelClass = (	installMirrorsAsToplevelClasses: {self})



isToplevel = (	flag: #BOGUS. "Class mirror should know whether it's a top-level class and decide to emit a file header based on that."	^ (category = nil or: [category isEmpty]) not)



languageIdentifier = (	^ 'Newspeak3')



streamCategory: cat to: stream = (	| categories sortedAssociations |	categories:: cat groupBy: [:each | each category] having: [:each | true].	sortedAssociations:: categories associations sortBy: [:a :b |		sortBlock value: a key value: b key].	sortedAssociations do: [:each |		stream			nextPut: $';			nextPutAll: each key;			nextPut: $'.		(each value sortBy: sortBlock) do: [:method |			stream cr.			method streamTo: stream]].)



streamClassBodyTo: stream = (	stream nextPut: $(.	(classes asOrderedCollection sortBy: sortBlock) do: [:each |		stream cr.		each streamTo: stream].	streamCategory: instanceMethods to: stream.	stream	nextPutAll: ')'.	classMethods ifNotNil: [:it |		stream nextPutAll: ' : ('.		streamCategory: classMethods to: stream.		stream nextPut: $).].)



streamClassCommentTo: stream = (	(nil = classComment or: [classComment isEmpty]) ifFalse: [ | first last |		first:: classComment findFirst: [:x | x = $"].		last:: classComment findLast: [:x | x = $"].				stream nextPutAll: (classComment copyFrom: 1 to: first).				classComment from: first + 1 to: last - 1 do: [:each |			stream nextPut: each.			each = $" ifTrue: [stream nextPut: $"]].				stream nextPutAll: (classComment copyFrom: last to: classComment size)].		)



streamClassHeaderTo: stream = (	stream		nextPutAll: 'class ';		nextPutAll: name.	constructor ifNotNil: [:it | 		stream			nextPutAll: ' ';			nextPutAll: constructor].	stream nextPutAll: ' ='.	superclassClause ifNotNil: [:it | 		stream			nextPutAll: ' ';			nextPutAll: superclassClause].	stream	nextPutAll: ' ('.	streamClassCommentTo: stream.	slotsSource ifNotNil: [:it |		stream nextPutAll: it].	"slots ifNotNil: [:it |		stream cr; nextPut: $|; cr.		slots			do: [:each |					each streamTo: stream.					stream cr].		stream			nextPut: $|;			cr]."	initExpressions ifNotNil: [:it |		stream nextPutAll: it].	stream		nextPut: $);		cr.)



streamFileHeaderTo: stream = (	isToplevel ifFalse: [		^ self].	stream		nextPutAll: languageIdentifier; cr;		nextPut: $';		nextPutAll: category;		nextPut: $';		cr.)



streamTo: stream = (	streamFileHeaderTo: stream.	streamClassHeaderTo: stream.	streamClassBodyTo: stream)



'private'

sortBlock = (	^ [:a :b | a name <= b name])



)



class StringMirror = (
"Encapsulates functionality for some leaf elements, e.g. category or class comment"|
	string
|)

('as yet unclassified'

children = (	^ {})



contentsEquals: other = (	^ string = other string)



correspondsHash = (	^ 42)



correspondsTo: other = (	^ true)



))



class Loading = ("The interface to be used by the outside world to interact with mirrors"|
private compilationUnitCache = MirrorCache onSelector: #compilationUnit.
private methodDeclCache = MirrorCache onSelector: #methodDecl.
|)

(



class MirrorLoader = (|
	private classDictionary
|)

(



class NameOnlySourceMirror named: n actualMirror: m = (
"Describe the class in this comment."
|
	name = n.
	actualMirror <Delay[SourceMirror]> = m.
|
)

()'as yet unclassified'

imageMirrorsNotCorrespondingTo: mirrors = (	| classes packages |	classes:: classDictionary values select: [:each |		each isBehavior 		and: [(each language isNewspeakLanguage3 or: [each language isNewspeakLanguage2]) 		and: [(each name includes: $`) not 		and: [mirrors noneSatisfy: [:mirror | "We shouldn't have this name-equality stuff here"			mirror name = each name or: [each name startsWith: 'AnObsolete']]]]]].	classes:: classes collect: [:each |		NameOnlySourceMirror 			named: each name , ' [module]'			actualMirror: (Delay computation: [imageMirrorCache at: each name , '.ns3' ifAbsentPut: [mirrorForClass: each]])].	packages:: PackageInfo allPackages select: [:each |		mirrors noneSatisfy: [:mirror | mirror name = each name]].	packages:: packages collect: [:each |		NameOnlySourceMirror			named: each name , ' [package]'			actualMirror: (Delay computation: [imageMirrorCache at: each name , '.st' ifAbsentPut: [mirrorForPackage: each]])].	^ classes ", packages")



installMirrorsAsToplevelClasses: newMirrors = (	| changedMirrors sources |	#BOGUS yourself. "This is not atomic!"	changedMirrors:: newMirrors select: [:each |		self			mirrorForClassInImageCorrespondingTo: each			ifPresent: [:it | (Differencer allEqual: {each. it}) not]			ifAbsent: [true]].	changedMirrors do: [:each |		each isPackageMirror			ifTrue: [each installPackage]			ifFalse: [LanguageFileReader new compileStream: each source readStream]].)



methodMirrorForStream: stream ifError: errorBlock = (	^ methodDeclCache mirrorForStream: stream ifError: errorBlock)



mirrorForClass: aClass = (	| stream |	stream:: (String streamContents: [:s | aClass printClassOn: s]) readStream.	^ mirrorForStream: stream.)



mirrorForClassInImageCorrespondingTo: mirror ifPresent: presentBlock ifAbsent: absentBlock = (        | correspondingMirror |	mirror isPackageMirror ifTrue: [		correspondingMirror:: imageMirrorCache			at: mirror filename			ifAbsentPut: [ 				|pkgInfo|				pkgInfo:: PackageInfo allPackages 					detect: [:e | e name = mirror name]					ifNone: [^absentBlock value].				mirrorForPackage: pkgInfo].		^presentBlock value: correspondingMirror.	].        correspondingMirror:: imageMirrorCache                at: mirror filename                ifAbsentPut: [ | existingClass |                        existingClass:: classDictionary                                at: mirror name                                ifAbsent: [^ absentBlock value].                        mirrorForClass: existingClass].        ^ presentBlock value: correspondingMirror.)



mirrorForPackage: pkgInfo = (	^SmalltalkPackageSourceMirror fromPackageInfo: pkgInfo)



mirrorForStream: stream = (	(stream contents startsWith: 'Smalltalk') 		ifTrue: [^SmalltalkPackageSourceMirror fromStream: stream].	^ compilationUnitCache mirrorForStream: stream)



) : (

'as yet unclassified'

classDictionary: classDictionary = (	^ self new		classDictionary: classDictionary;		yourself)



)



class MirrorCache onSelector: selector = ("Keeps a map of string -> mirror"|
"Keep the actual dictionaries in VCS(ImageMirror)Caching, so it can be reused over multiple instances"
cachedMirrors = imageMirrorCache stringToMirrorCacheForProduction: selector.
parser = SourceMirrorParser new.
production = parser perform: selector.
|)

('as yet unclassified'

mirrorForStream: stream = (	^ mirrorForStream: stream ifError: [:pos :msg | error])



mirrorForStream: stream ifError: errorBlock = (	| string |	string:: stream contents.	^ cachedMirrors at: string ifAbsentPut: [ | newMirror | 		parser input: string.		newMirror:: production parse: string readStream ifError: errorBlock.		"source -> mirror -> source might rearrange elements in source.		By caching the same mirror under all keys we might save time when comparing mirrors but we might just as well waste time as long as calculating a mirrors contents is slow"		cachedMirrors			at: newMirror contents			ifAbsentPut: [newMirror]])



))



class Parsing = ()

(



class MemoizingParser onParser: p = CombinatorialParser (|
parser = p.
cache = Dictionary new.
keySize = 30.
|)

('as yet unclassified'

cachedResultsStartingWithFirstCharsOf: input = (	| key length |	length:: keySize min: input size - input position.	key:: input next: length.	^ cache		at: key		ifAbsentPut: [OrderedCollection new]		)



parse: input inContext: context ifError: errorBlock  = (	| results position result |	position:: input position.	results:: cachedResultsStartingWithFirstCharsOf: input.	input position: position.	result:: resultFor: input inResults: results.	result = nil		ifTrue: [ | parsedInput |			result:: parser parse: input inContext: context ifError: errorBlock.			parsedInput:: stringIn: input fromPosition: position.			results add: parsedInput -> result].	^ result)



resultFor: input inResults: results = (	| result position |	position:: input position.	result:: results		detect: [:each | | inputChunk |			input position: position.			inputChunk:: input next: each key size.			inputChunk = each key]		ifNone: [			input position: position.			^ nil].	^ result value)



stringIn: input fromPosition: position = (	| parsedSize |	parsedSize:: input position - position.	input position: position.	^ input next: parsedSize.)



)



class SourceMirrorParser = TypedNS3Grammar (|
protected input
|)

('as yet unclassified'

binaryMsgPattern = (	^ super binaryMsgPattern wrapper: [:sel :p | 		(ParentYield wrap: {sel. p} input: input) children: sel token])



category = (	"category:: string, [methodDecl star]"	^super category		wrapper:			[ :catname :methods | | cat |			cat:: catname token.			"The MemoizingParser returns the identical mirror for all methods with the same source. If a method with the same source exists in multiple categories (in different classes), we need multiple mirrors.						We could create different mirrors right from the start by including the current category as a key to the memoizing dictionary. But accessing the category before the methods are being parsed would require the Newspeak grammar to be extended so that we have a 'categoryName' rule that we can override. We would want to do that in _the_ Newspeak grammar. We don't want to respecify it here.						For now we create copies of method mirrors if they are set to wrong categories.	"			methods collect: [:each |				(nil = each category or: [each category = cat])					ifTrue: [						each category: cat.						each]					ifFalse: [						each copy							category: cat;							yourself]]])



classComment = (	^"super classComment" "classComment is broken in super classes."	whitespace opt, comment		wrapper:			[ :ws :com | 			String streamContents: [:stream |				nil = ws ifFalse: [					stream nextPutAll: ws].				stream					nextPut: com first;					nextPutAll: (com at: 2);					nextPut: com last]])



classDeclaration = (	"classDeclaration:: (tokenFromSymbol: #class), [classHeader], [sideDecl], [classSideDecl opt]"	^super classDeclaration		wrapper:			[ :classKwd :hdr :instanceSide :classSide | | yield classes slots slotsSource instanceMethods classMethods klassName costructor scc cc initExpressions |			klassName:: hdr first token asSymbol.			yield:: Yield wrap: {classKwd. hdr. instanceSide. classSide} input: input.			costructor:: (hdr at: 2) ifNotNil: [:it | (Yield wrap: it input: input) contents].			scc:: (hdr at: 4) ifNotNil: [:it | (Yield wrap: it input: input) contents].			cc:: hdr at: 6.			slots:: (hdr at: 7) ifNotNil: [:it | it children children size = 5 ifTrue: [it children children at: 3] ifFalse: [it children children at: 2]].			slotsSource:: (hdr at: 7) ifNil: [nil] ifNotNilDo: [:it | it contents].			initExpressions:: (Yield wrap: (hdr at: 8) input: input) ifNotNilDo: [:it | it contents].			classes:: instanceSide children first.			instanceMethods:: instanceSide children at: 2.			classMethods:: classSide				ifNotNil: [:it | it children].			ClassSourceMirror new				name: klassName;				constructor: costructor;				superclassClause: scc;				slots: slots;				initExpressions: initExpressions;				slotsSource: slotsSource;				classes: classes;				instanceMethods: instanceMethods;				classMethods: classMethods;				classComment: cc;				yourself])



classSideDecl = (		"classSideDecl:: colon, [lparen], [category star], [rparen]"	^super classSideDecl		wrapper:			[ :cln :lp :categories :rp | | methods |			methods:: flatten: categories.			(ParentYield wrap: {lp. "categories." rp} input: input) children: methods asArray ])



compilationUnit = (	"compilationUnit::  languageId, [namespaceDecl | [toplevelClass] | [namespaceExpr] ], [eoi]"	^super compilationUnit		wrapper:			[ :langId :toplevel :eoi |				toplevel])



keywordMsgPattern = (	^ super keywordMsgPattern wrap: [:kws | | selector |		selector:: kws inject: '' into: [:acc :each | acc, each first token].		(ParentYield wrap: kws input: input) children: selector])



methodDecl = (	"methodDecl:: accessModifier opt, [messagePattern], [equalSign], [lparen], [codeBody], [rparen]"	^MemoizingParser onParser: (super methodDecl		wrapper:		[ :accessMod :msgPat :eq :lp :cb :rp | | yield accessSym msgPatYield |			msgPatYield:: Yield wrap: msgPat input: input.			accessSym:: accessMod = nil				ifTrue: [ nil ]				ifFalse: [ accessMod first token ].			MethodSourceMirror new				methodSource: (Yield wrap: {accessMod. msgPat. eq. lp. cb. rp} input: input) contents;				messagePattern: msgPatYield contents;				selector: msgPat first children;				accessModifier: accessSym;				yourself]))



nestedClassDecl = (		"nestedClassDecl:: accessModifier opt, [classDeclaration]"	^super nestedClassDecl		wrapper:			[ :accessMod :klass | | accessSym |				accessSym:: accessMod = nil					ifTrue: [ nil ]					ifFalse: [ accessMod first token ].				klass accessModifier: accessSym.				klass])



seqSlotDecls = (	^super seqSlotDecls wrap:		[ :list |			(ParentYield wrap: list input: input) children: list])



sideDecl = (		"sideDecl:: lparen, [nestedClassDecl star], [category star], [rparen]"	^super sideDecl		wrapper:			[ :lp :classes :categories :rp | | methods |			methods:: flatten: categories.			(ParentYield wrap: {lp. classes. "categories." rp} input: input) children: {classes asArray. methods asArray} ])



simSlotDecls = (	^super simSlotDecls wrap:		[ :list |			(ParentYield wrap: list input: input) children: list])



slotDecls = (	"slotDecls:: vbar, [slotDef star], [vbar]"	^super slotDecls wrap:		[ :list |			(ParentYield wrap: list input: input) children: list])



slotDef = (		"	slotDecls:: vbar, [slotDef star], [vbar].	slotDef::   accessModifier opt, [slotDecl], [ (((tokenFromSymbol: #=) | [tokenFromSymbol: #'::=']), [expression], [dot]) opt].	slotDecl::  identifier , [type opt].	"	^super slotDef wrapper:		[ :accessMod :nameAndType :init | | accessSym immutable expr typeString initializer |		accessSym:: accessMod = nil			ifTrue: [ nil ]			ifFalse: [ accessMod first token ].		init = nil			ifTrue: [ immutable:: false. expr:: nil ]			ifFalse: [immutable:: (init at: 1) token = #=. expr:: (init at: 2) contents ].		initializer:: expr ifNotNil: [:it | (Yield wrap: expr input: input) contents].		typeString:: (nameAndType at: 2) = nil			ifTrue: [ nil ]			ifFalse: [ | yield |				yield:: Yield wrap: ((nameAndType at: 2) contents at: 2) contents input: input.				yield contents].		SlotSourceMirror new			name: nameAndType first token;			accessModifier: accessSym;			initializer: initializer;			type: typeString;			immutable: immutable;			yourself])



toplevelClass = (	"toplevelClass:: classCategory, [classDeclaration]"	^super toplevelClass		wrapper:			[ :cat :klass |				klass category: cat token.				klass])



unaryMsgPattern = (	^ super unaryMsgPattern wrap: [:sel |		(ParentYield wrap: sel input: input) children: sel token])



))'as yet unclassified'

flatten: collection = (	| result |	result:: OrderedCollection new.	collection do: [:each | result addAll: each].	^ result)



imageMirrorsNotCorrespondingTo: mirrors = (	^ mirrorLoader imageMirrorsNotCorrespondingTo: mirrors)



installMirrorsAsToplevelClasses: newMirrors = (	mirrorLoader installMirrorsAsToplevelClasses: newMirrors)



methodMirrorForStream: stream ifError: errorBlock = (	^ mirrorLoader methodMirrorForStream: stream ifError: errorBlock)



mirrorForClassInImageCorrespondingTo: mirror ifPresent: presentBlock ifAbsent: absentBlock = (	^ mirrorLoader mirrorForClassInImageCorrespondingTo: mirror ifPresent: presentBlock ifAbsent: absentBlock)



mirrorForStream: stream = (	^ mirrorLoader mirrorForStream: stream)



)