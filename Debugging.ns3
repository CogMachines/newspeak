Newspeak3
'HopscotchIDE'
class Debugging usingPlatform: platform ide: ide = (
(* Newspeak debugging module. Holds system-wide debugger parameters. An instance of the inner Debugger class gets instantiated to handle each specific debug session.

Copyright (c) 2008-2012 Cadence Design Systems, Inc.
Copyright (c) 2009 Peter von der Ahe
Copyright (c) 2008 Vassili Bykov

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
''Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. *)|
	(* Imports *) 
	Gradient = platform brazil plumbing Gradient.
	RectangleShape = platform brazil widgets RectangleShape.
	Row = platform brazil containers Row.
	
	LeafFragment = platform hopscotch fragments LeafFragment.
	Subject = platform hopscotch core Subject.
	TextEditorFragment = platform hopscotch fragments TextEditorFragment.

	CodeEditorFragment = ide tools CodeEditorFragment.
	ExpandableMethodPresenter = ide browsing ExpandableMethodPresenter.
	IDEWindow = ide tools IDEWindow.
	MethodSubject = ide browsing MethodSubject.
	NSMethodInheritanceSubject = ide browsingNS3 MethodInheritanceSubject.
	InitializerMethodSubject = ide browsingNS3 InitializerMethodSubject.
	OneLineDefinitionTemplate = ide tools OneLineDefinitionTemplate.
	ProgrammingPresenter = ide tools ProgrammingPresenter.
	private ObjectSubject = ide inspection ObjectSubject.
	private ExceptionalResultPresenter = ide inspection ExceptionalResultPresenter.
	ide = ide.

	Color = platform blackMarket Graphics Color.
	OrderedCollection = platform collections OrderedCollection.
	SqueakDebugger = platform blackMarket Tools Debugger.
	TextColor = platform blackMarket Collections TextColor.
	TextEmphasis = platform blackMarket Collections TextEmphasis.
	UnhandledError = platform blackMarket Exceptions UnhandledError.

	errorReportBlock ::= [:activation | defaultErrorReportFor: activation].
	methodSourceRatio = 1.6.
|)
(
class Debugger thread: thread <ThreadMirror> activation: activation <ActivationMirror> = (
(* An instance of Debugger is created to manage a specific debug session represented by (mirrors on) the interrupted thread and its top activation passed as primary factory parameters. *)|
	public thread <ThreadMirror> ::= thread.
	public activation <ThreadMirror> ::= activation.
	public description <String>
	
	protected registry
	protected debuggerHopscotchWindow
	protected InitializerActivationSubject = InitializerMethodSubject mixin  |> ActivationSubject.
|)
(
class ActivationPresenter onSubject: subj <ActivationSubject> = ExpandableMethodPresenter onSubject: subj (|
	localVariables
	okToRestartBlock ::= false.
	results
	showMethodHeader ::= true.
|)
('as yet unclassified'
addExceptionalResultPresenterFor: exception <Exception> in: thread <NewspeakDebugging ThreadSubject> = (
	results addFirst: 
		(collapsed: [ExceptionalResultPresenter on: exception in: thread]
		expanded: [buildExceptionDetails: exception in: thread])
)
addResultPresenterOn: result <Object> = (
	results addFirst:
		(resultFragmentOn: (ObjectSubject onModel: result)).
)
buildActions = (
	
^column: {
		row: {
			button: 'over' action: [respondToStepOver].
			smallBlank.
			button: 'into' action: [respondToStepInto].
			smallBlank.
			button: 'into block' action: [respondToStepIntoBlock].
			filler.
			button: '^self' action: [respondtoReturnSelf].
			smallBlank.
			button: '^nil' action: [respondToReturnNil].
			holder: [buildReturnInterestingValue].
			smallBlank.
			button: 'Evaluate' action: [respondToEvaluate].
			smallBlank.
		      button: 'Continue' action: [respondToResume].
		      smallBlank.
		      button: 'Terminate' action: [respondToTerminate].
		}
	}
)
buildExceptionDetails: exception <Exception> in: thread <NewspeakDebugging ThreadSubject> = (
	^column: {
		ExceptionalResultPresenter on: exception in: thread.
		(ObjectSubject onModel: (vmMirror reflectOn: exception)) presenter.
	}
)
buildLocalVariables = (
	localVariables:: (ActivationStateSubject onModel: subject model) presenter.
	^floatingPanel: localVariables
)
buildMethodEditor = (
	| methodEditor |
	methodEditor:: super methodDetails.
	methodEditor colorizerBlock:
		[:text |
		subject colorizeMethodSource: text in: methodEditor editor].
	^methodEditor
)
buildReturnInterestingValue = (
	subject lastInterestingValueOnStack ifNotNil:
		[:it |
		^row: {
			smallBlank.
			button: '^', (it reflecteePrintStringLimitedTo: 10) action: [respondToReturnValue: it].
		}].
	^nothing
)
clearErrors = (
	editor ifNotNil: [:it | it removeMessages]
)
debugActionsMenu = (
	^menuWithLabelsAndActions: {
		'over' -> [respondToStepOver].
		'into' -> [respondToStepInto].
		'intoBlock' -> [respondToStepIntoBlock].
	}
)
definition = (
	| toggler |
	inspectionHolder:: holder: [nothing].
	showMethodHeader ifFalse: [^methodDetails].
	toggler::
		collapsed: methodHeading
		expanded: expandedMethod.
	toggler onUserToggled: [toggler isExpanded ifTrue: [requestVisibility]].
	^toggler
)
expand = (
	(showMethodHeader isNil or: [showMethodHeader]) ifTrue: [super expand]
)
frameColor = (
	^Color h: 240 s: 0.15 v: 0.74
)
frameLine = (
	^((row: {}) color: frameColor) width: 1
)
methodActionsMenu = (
	^menuWithLabelsAndActions: {
		(* 'Versions' -> [respondToVersions]. *)
		subject isBlockActivation
			ifTrue: ['Restart block' -> [respondToRestart]]
			ifFalse: ['Restart method' -> [respondToRestart]].
		'Unwind Recursion' -> [respondToUnwindRecursion].
		'Inspect Context' -> [respondToInspectContext].
		'Inspect Mirror' -> [respondToInspectMirror].
		'Inspect Presenter' -> [respondToInspectPresenter].
	},(
		subject isMessageNotUnderstood ifTrue: [
			{'Create missing method ', subject notUnderstoodMessage printString -> [respondToCreateMissingMethod].
			'Create missing class ', subject notUnderstoodMessage printString -> [respondToCreateMissingClass].
			(*'Create missing slot ', subject notUnderstoodMessage printString -> [respondToCreateMissingSlot].	*)
			}.
			]
			ifFalse: [{}]
	)
)
methodDetails = (
	^column: {
		floatingHeader: (minorHeadingBlock: buildActions)
		body: (
			(row: {
				buildMethodEditor width: 0 elasticity: methodSourceRatio.
				smallBlank.
				buildLocalVariables width: 0 elasticity: 1.
			}) color: methodHeadingColor).
		
		row: {
			frameLine. 
			elastic: (column: {
				minorHeadingBlock: 
					(row: {
						label: 'Evaluation Results'.
						filler.
						link: '[clear]' action: [respondToDiscardResults].
					}).
				results:: column: {}.
			}).
		      frameLine. 
		}.
		frameLine.
		smallBlank.
	}
)
recategorizeMethodIn: p <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (
	| newName |
	newName:: newCategoryName withBlanksTrimmed.
	newName isEmpty ifTrue: [^failureResponse value].
	subject
		changeCategoryTo: newName asSymbol
		ifSuccess: successResponse
		ifFailure: failureResponse
)
refreshActivationState = (
	localVariables ifNotNil: [:it | it refresh].
)
refreshPcRangeIndication = (
	editor ifNotNil: [:it | it editor maybeColorize].
)
requestVisibilityOfPcRange = (
	| range |
	range:: subject model pcRangeIn: thread.
	editor
		requestVisibilityOfTextInterval: range
		withExtraLines: 1
)
respondToBrowseReceiverClass = (
	browseClass: subject receiverClass
)
respondToCreateMissingClass = (
	browseClass: subject receiverClass.
	sendUp deliveryOptional navigatorDo:
		[:navigator |
		navigator currentPresenter sendDown
			addClassIn: subject receiverClass
			proposedSource: subject proposedMissingClassSource asString]	
)
respondToCreateMissingMethod = (
	browseClass: subject receiverClass.
	sendUp deliveryOptional navigatorDo:
		[:navigator |
		navigator currentPresenter sendDown
			addMethodIn: subject receiverClass
			proposedSource: subject proposedMissingMessageSource asString]
)
respondToCreateMissingSlot = (
	
)
respondToDiscardResults = (
	results children size timesRepeat: [results removeAt: 1]
)
respondToEvaluate = (
	| result <ObjectMirror> |
	editor removeMessages.
	result::	(ActivationStateSubject onModel: subject model)
		evaluate:
			editor maybeSelectCurrentLine
		ifCompilerError:
			[:message |
			^editor addMessage: message]
		ifError:
			[:thread :exception |
			^addExceptionalResultPresenterFor: exception in: thread].
	localVariables refresh.
	addResultPresenterOn: result.
)
respondToInspectContext = (
	inspect: subject model context_slot
)
respondToInspectMirror = (
	inspect: subject model
)
respondToRestart = (
	clearErrors.
	subject restartIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToResume = (
 sendUp respondToResume
)
respondToReturn: textEditor <TextEditorFragment> = (
	clearErrors.
	subject
		returnWith: textEditor editedText asString
		ifFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToReturnNil = (
	subject returnNil.
	sendUp deliveryOptional refreshActivations
)
respondToReturnValue: objectMirror <ObjectMirror> = (
	subject return: objectMirror.
	sendUp deliveryOptional refreshActivations
)
respondToStepInto = (
	clearErrors.
	subject stepIntoIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToStepIntoBlock = (
	clearErrors.
	subject stepIntoBlockIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToStepOver = (
	clearErrors.
	subject stepOverIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToTerminate = (
	sendUp respondToTerminate
)
respondToUnwindRecursion = (
	clearErrors.
	subject unwindRecursionIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondtoReturnSelf = (
	subject return: subject receiverMirror.
	sendUp deliveryOptional refreshActivations
)
resultFragmentOn: result <ObjectSubject> ^ <Fragment> = (
	^collapsed: [link: result title action: [enterSubject: result]]
		expanded: [result presenter]
)
selectorAndContainment = (
	(* Override to display only the immediately defining class instead of the complete nesting and to also display both the receiver class and the method class if they differ. *)
	|
	receiverClassLink =
		(link: subject receiverClass simpleName
			action: [respondToBrowseReceiverClass])
				color: secondaryTextColor.
	methodClassLink = 
		subject implementingClass
			ifNil: [nothing]
			ifNotNil:
				[:ic|
				row: {
					(label: ' (') color: secondaryTextColor.
					(link: ic simpleName
						action: [browseClass: subject implementingClass])
							color: secondaryTextColor.
					(label: ')') color: secondaryTextColor.
					}].
	selectorLink = 
		(link: subject selectorWithBlockNesting
			action: [substance userToggle]
			dragSubject: subject
			withImage: ide browsing HopscotchImages default hsExpandImage) 
				color: actionLinkColor.
	|

	^row: {
		selectorLink.
		(label: ' in ') color: tertiaryTextColor.
		receiverClassLink.		
		subject implementingClass == subject receiverClass
			ifTrue: [nothing]
			ifFalse: [methodClassLink].
		}
)
showClassLink = (
	^true
)
showClassName = (
	^true
)) : ()
class ActivationStatePresenter onSubject: subj <ActivationStateSubject> = ProgrammingPresenter onSubject: subj (|
	interactionEditor
	selfFragment
	localVarPresenters
	expressionStackPresenters
|)
('definition'
additionalResultFragment: fragmentConsumer <[:Fragment]> for: result <[:ObjectMirror]> = (
	fragmentConsumer
		value: (link: 'return it' action: [respondToReturn: result]) tinyFont
)
definition = (
	^list: [{
		(* interactionDefinition. *)
		selfFragment:: selfDefinition.
	}, (localVarPresenters:: localVarDefinitions)
	, (expressionStackPresenters:: expressionStackDefinition)]
)
expressionStackDefinition = (
	^{
		smallBlank.
		heading: (label: 'Expression Stack' asText allBold)
			detailsExpanded:
				(list: (subject stackIndicesWithValuesCollect:
					[:index :mirror |
					localVariableNamed: index asString value: mirror]), 
					{label: '--- end of stack ---'})
	}
)
headingForLocalVariableNamed: variableName value: object = (
	^row: {
		label: variableName asText allBold.
		smallBlank.
		link: (object reflecteePrintStringLimitedTo: 39) action:
			[inspectObjectMirror: object].
	}
)
interactionDefinition = (
	^inspection EvaluatorPresenter onSubject: subject
)
localVarDefinitions = (
	^subject localNamesWithValuesCollect:
		[:localName :mirror |
		presenterForLocal: localName]
)
localVariableNamed: variableName value: object = (
	^collapsed:
		[headingForLocalVariableNamed: variableName value: object]
	expanded:
		[column: {
			OneLineDefinitionTemplate new
				initialText: 'new value for ', variableName;
				acceptResponse: [:t | acceptNewValue: t for: variableName];
				cancelResponse: [:t | t editor defaultCancelResponse];
				initiallyInEditState: false.
			(objectSubjectForMirror: object) presenter selfCaption: variableName.
		}]
)
presenterForLocal: localName = (
	^(LocalVariableSubject onActivationMirror: subject model name: localName) presenter
)
selfDefinition = (
	^collapsed: [headingForLocalVariableNamed: 'self' value: subject receiverMirror]
		expanded: [(objectSubjectForMirror: subject receiverMirror) presenter]
)'notifications'
acceptNewValue: template <DefinitionTemplate> for: variableName = (
	subject
		setLocalVariable: variableName
		to: template text asString
		ifFail: [:msg | template editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToEvaluate = (
	
)
respondToReturn: mirror <ObjectMirror> = (
	subject return: mirror.
	sendUp deliveryOptional; refreshActivations
)) : ()
class ActivationStateSubject onModel: mirror <ActivationMirror> = Subject onModel: mirror ()
('as yet unclassified'
activationMirror = (
	^model
)
createPresenter = (
	^ActivationStatePresenter onSubject: self
)
evaluate: expression ifCompilerError: onCompilerError <[:String]> ifError: onError <[:NewspeakDebugging ThreadSubject :Exception]> ^<ObjectMirror> = (
	| result compilerError |
	compilerError:: {nil}.
	result:: registry
		do: [activationMirror
			evaluate: expression
			withBlackMarket: ide inspection blackMarket
			ifFail: [:msg | compilerError at: 1 put: msg]]
		name: 'Evaluating ', expression
		ifError:
			[:exception :process |
			onError value: (registry subjectFor: exception in: process) value: exception].
	compilerError first ifNotNil:
		[:message |
		^onCompilerError valueWithPossibleArgument: message].
	^result
)
localNamesWithValuesCollect: action <[:Integer :ObjectMirror | T]> ^<SequenceableCollection[T]>= (
	^Array streamContents:
		[:s |
		activationMirror localNamesWithValuesDo:
			[:i :mirror | s nextPut: (action value: i value: mirror)]]
)
localNamesWithValuesDo: action <[:String :ObjectMirror]> = (
	activationMirror localNamesWithValuesDo: action
)
receiver = (
	^activationMirror receiver
)
receiverMirror = (
	^activationMirror receiverMirror
)
return: objectMirror = (
	activation:: thread return: objectMirror from: activationMirror
)
setLocalVariable: variableName <String> to: exprString <String> ifFail: onFail <[:String]> = (
	activationMirror setLocalVariable: variableName to: exprString ifFail: onFail
)
stackIndicesWithValuesCollect: action <[:Integer :ObjectMirror | T]> ^<SequenceableCollection[T]>= (
	^Array streamContents:
		[:s |
		activationMirror stackIndicesWithValuesDo:
			[:i :mirror | s nextPut: (action value: i value: mirror)]]
)
stackIndicesWithValuesDo: action <[:Integer :ObjectMirror]> = (
	activationMirror stackIndicesWithValuesDo: action
)
title = (
	^'Expression Stack'
)) : ()
class ActivationSubject onModel: mirrorOnActivation <ActivationMirror> = MethodSubject onModel: mirrorOnActivation (| methodMirror_slot |)
('as yet unclassified'
= other <Object> ^<Boolean> = (
	^self class = other class and: [model = other model]
)
activationMirror ^  <ActivationMirror> = (
	^model
)
allMethodCategories ^<Collection[Symbol]> = (
	(* Answer a collection of all category names used in the implementor class, plus some common names. *)
	
	| names |
	names:: super allMethodCategories.
	names addAll: methodMirror enclosingClassStencil methodCategories.
	^names
)
asMethodInheritanceSubject = (
	^NSMethodInheritanceSubject onModel: methodMirror
)
changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
	methodMirror changeCategory: newName asSymbol.
	successBlock value
)
classAndSelectorString = (
	^model printString
)
colorizeMethodSource: sourceText = (
	
	activationMirror sourceAvailable ifFalse: [^sourceText].

	methodMirror reflectee methodClass language isNewspeakLanguage3 
		ifFalse:[^super colorizeMethodSource: sourceText].

	^ide browsingNS3 NS3Colorizer new 
		parseText: sourceText asString
		fromClass: methodMirror definingMixin reflectee definingClass
		usingSelector: #methodDecl
)
colorizeMethodSource: sourceText in: editor = (
	| range |
	activationMirror sourceAvailable ifFalse: [^sourceText].

	range:: activationMirror pcRangeIn: thread.
	sourceText asString = source asString ifTrue:
		[^highlight: (colorizeMethodSource: sourceText) range: range].
	^colorizeMethodSource: sourceText
)
compileNewSource: newSource <String> ifSuccess: onSuccess ifNewMethod: onNewMethod ifFailure: onFail = (
	| method failed |
	activationMirror homeMethod isSynthetic
		ifTrue: [^onFail valueWithPossibleArgument: 'Cannot change synthetic method.'].
	method:: activationMirror compile: newSource ifFail:
		[:msg | ^onFail valueWithPossibleArgument: msg].
	method simpleName = selector
		ifFalse: [^onNewMethod valueWithPossibleArgument: method].
	failed:: nil.
	activation:: thread install: method restart: model homeInThread ifFail:
		[:message | failed:: message].
	failed ifNotNil: [:it | ^onFail valueWithPossibleArgument: it].
	onSuccess value
)
createPresenter = (
	^ActivationPresenter onSubject: self
)
hasLegacyMirror = (
	^methodMirror enclosingClassStencil isLegacyMirror
)
hash ^<SmallInteger> = (
	^self class hash bitXor: model hash
)
implementingClass = (
	^activationMirror definingClass
)
isAnOverride = (
	superclass ifNotNil: [:it | ^it canUnderstand: selector].
	^false
)
isBlockActivation = (
	^activationMirror isBlockMirror
)
isInitializer ^ <Boolean> = (
	^methodMirror isInitializer
)
isMessageNotUnderstood = (
	^activationMirror isMessageNotUnderstood
)
isOverridden = (
	^false
)
isPrivate = (
	^methodMirror isPrivate
)
isValid = (
	^true
)
lastInterestingValueOnStack ^<ObjectMirror | nil> = (
	| mirror |
	activationMirror stackIndicesWithValuesDo:
		(* Prefer topmost value which comes first *)
		[:ignored :current |
		current reflecteeIsNil ifFalse: [^current]].
	model localNamesWithValuesDo:
		(* Prefer last argument which comes last *)
		[:ignored :current |
		current reflecteeIsNil ifFalse: [mirror:: current]].
	^mirror
)
localNames = (
	^activationMirror localNames
)
messages = (
	^(activationMirror homeMethod ifNil: [^{}]) messages
)
methodCategory = (
	^methodMirror category
)
methodMirror = (
	^model methodMirror
)
notUnderstoodMessage = (
	^activationMirror notUnderstoodMessage
)
proposedMissingClassSource = (
	^activationMirror proposedMissingClassSource
)
proposedMissingMessageSource = (
	^activationMirror proposedMissingMessageSource
)
receiver = (
	^activationMirror receiver
)
receiverClass = (
	^activationMirror receiverClass
)
receiverMirror = (
	^activationMirror receiverMirror
)
restartIfFail: onFail <[:String]> = (
	activation:: thread restart: activationMirror
)
return: objectMirror = (
	activation:: thread return: objectMirror from: activationMirror
)
returnNil = (
	return: activationMirror nilMirror
)
returnWith: expression ifFail: onFail = (
	return:: activationMirror evaluate: expression ifFail: [:msg | ^onFail value: msg]
)
selector = (
	^model selector
)
selectorWithBlockNesting = (
	(* [] in [] in doesNotUnderstand: #msg. *)
	#BOGUS yourself. (* Implementation should at least not directly access contexts. *)
	^String streamContents: [:stm | 
		| ctxt ::= activationMirror context_slot. |
		[ctxt home isNil not and: [ctxt closure isNil not]]
			whileTrue: [stm nextPutAll: '[] in '. ctxt: ctxt home].
		ctxt home isNil ifTrue: [stm nextPutAll: '<<Orphaned block>>'].
	
		stm nextPutAll: selector.
			
		isMessageNotUnderstood
			ifTrue: [stm nextPutAll: ' #', notUnderstoodMessage].
	].
)
source = (
	^[model source] ifError: [:desc | desc]
)
stepIntoBlockIfFail: onFail = (
	activation:: thread stepIntoBlock: activationMirror.
)
stepIntoIfFail: onFail = (
	activation:: thread stepInto: activationMirror.
)
stepOverIfFail: onFail = (
	(thread stepOver: activationMirror)
		ifNil: [onFail value: 'computation terminated']
		ifNotNil: [:anActivation| activation:: anActivation]
)
superclass = (
	(* ^methodMirror enclosingClassStencil guessSuperclass *)
	#BOGUS yourself.
	^Object
)
unwindRecursionIfFail: onFail <[:String]> = (
	activation:: thread unwindRecursion: activationMirror.
)
variableBindingKeys = (
	^Array streamContents:
		[:s |
		(model homeMethod ifNil:[^{}]) literalsDo:
			[:lit |
			(lit isVariableBinding and: [lit key notNil])
				ifTrue: [s nextPut: lit key]]]
)) : ()
class GlobalDebuggerControlsPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* Displays the global debugger control bar with buttons to go back to the debugger, continue or terminate execution. The subject of this presenter holds onto the original ThreadSubject for the current debugger window. *)|
|)
('as yet unclassified'
controlsBar = (
	^row: {
		button: 'Back to Debugger' action: [enterSubject: subject debuggerSubject].
		filler.
		button: 'Continue' action: [subject debuggerSubject presenter respondToResume].
		smallBlank.
		button: 'Terminate' action: [respondToTerminate].
	}
)
definition = (
	^floatingHeader: ((padded: controlsBar with: {5. 5. 5. 5}) color: mainHeadingColor)
		body: (column: {
			smallBlank.
			subject wrappedPresenter.
		})
)
navigateTo: s = (
	enterSubject:
		(shell shiftWasPressed
			ifTrue:
				[s]
			ifFalse:
				[((GlobalDebuggerControlsSubject onModel: s)
					debuggerSubject: subject debuggerSubject)])
)
respondToTerminate = (
	fork: [releaseThread terminate]
		thenUpdateUI:
			[shell window close].
)
title = (
	^subject model title
)) : ()
class GlobalDebuggerControlsSubject onModel: wrappedSubject = Subject onModel: wrappedSubject (
(* The core of the functionality to implement a persistent control bar for debugger. On navigating out of a ThreadPresenter, the presenter wraps the target subject into an instance of this. The presenter for this subject provides the buttons to go back to the debugger and also intercepts further navigation attempts to wrap destination targets in a similar way, so that the global control bar stays there. *)|
	debuggerSubject <ThreadSubject>
|)
('as yet unclassified'
createPresenter = (
	^GlobalDebuggerControlsPresenter onSubject: self
)
wrappedPresenter = (
	^model presenter
)) : ()
class LocalVariablePresenter onSubject: subject <LocalVariableSubject> = ProgrammingPresenter onSubject: subject (|
	editorFragment
	valueLink
	inspectorHolder
|)
('as yet unclassified'
collapsedDefinition = (
	^row: {
		label: subject name asText allBold.
		smallBlank.
		valueLink:: link: (subject valueStringLimitedTo: 200) action: [inspectObjectMirror: subject mirrorOnValue]
	}
)
definition = (
	^collapsed: [collapsedDefinition]
	expanded: [expandedDefinition]
)
editor = (
	^editorFragment editor
)
expandedDefinition = (
	editorFragment:: OneLineDefinitionTemplate new
		initialText: 'new value for ', subject name;
		acceptResponse: [:t | setValue: t text asString];
		cancelResponse: [:t | t editor defaultCancelResponse];
		initiallyInEditState: false.
	^column: {
		editorFragment.
		inspectorHolder:: holder:
			((objectSubjectForMirror: subject mirrorOnValue) presenter selfCaption: subject name).
	}
)
refresh = (
	valueLink ifNotNil: [:it | it label: (subject valueStringLimitedTo: 200)].
	inspectorHolder ifNotNil:
		[:it | it content: ((objectSubjectForMirror: subject mirrorOnValue) presenter selfCaption: subject name)]
)
setValue: expression <String> = (
	subject setValue: expression ifFail: [:msg | ^editor showMessage: msg].
	refresh.
	sendUp deliveryOptional refreshActivations
)) : ()
class LocalVariableSubject onActivationMirror: activationMirror <ActivationMirror> name: localVariableName <String> = Subject onModel: activationMirror (|
	name = localVariableName.
|)
('as yet unclassified'
= another = (
	^self class = another class and: [self name = another name]
)
createPresenter = (
	^LocalVariablePresenter onSubject: self
)
hash = (
	^name hash
)
mirrorOnValue = (
	^model localVariableValueMirror: name
)
setValue: expression <String> ifFail: block = (
	model setLocalVariable: name to: expression ifFail: block
)
valueStringLimitedTo: numberOfCharacters <Integer> = (
	^mirrorOnValue reflecteePrintStringLimitedTo: numberOfCharacters 
)) : ()
class ThreadPresenter onSubject: subj <ThreadSubject> = ProgrammingPresenter onSubject: subj (|
	protected activations <PresenterList>
	protected definitionHolder <HolderFragment>
	protected moreLinkHolder <HolderFragment>
|)
('as yet unclassified'
chunkSize = (
	(* Show at most this many activations at first. If there are more activations, show a 'more' link. *)
	^100
)
compileMethod: newSource <String>
inPresenter: p <ActivationPresenter>
ifCompiledAsSame: onCompiledAsSame <[]>
ifCompiledAsNew: onCompiledAsNew <[]>
ifFailed: onFail <[:String]> = (
	| edited home |
	edited:: p subject activationMirror.
	home:: edited homeInThread.
	home ifNil: [^onFail value: 'Block''s method not on stack.'].
	(edited = home or: [p okToRestartBlock]) ifFalse:
		[p okToRestartBlock: true.
		^onFail value: 'Need to revert to block''s method. Click Save again to revert.'].
	p subject
		compileNewSource: newSource
		ifSuccess:
			[refreshActivations.
			onCompiledAsSame value]
		ifNewMethod: onCompiledAsNew
		ifFailure:
			[:message |
			refreshActivations.
			onFail valueWithPossibleArgument: message].
)
definition = (
	isAlive ifFalse:
		[^nothing].
	definitionHolder::
		holder: definitionForMainContent.
	activations presenters size = 1
	   ifTrue:[
		definitionHolder::
		   holder: definitionForSingleFrame.
		 expandTopActivation.
		].	
	^definitionHolder.
)
definitionForActivationsHeader = (
	^majorHeadingBlock: (
		row: {
			label: 'Call stack' asText allBold.
			filler.
			expandButtonWithAction: [respondToExpandAll].
			blank: 3.
			collapseButtonWithAction: [respondToCollapseAll].
		}
	)
)
definitionForActivationsList = (
	^withTopChunkOfActivationsAndMoreLinkDo:
		[:presenters :moreLinkOrNothing |
		moreLinkHolder:: holder: moreLinkOrNothing.
		list: presenters]
)
definitionForErrorReport = (
	| toggle |
	^toggle::
		heading: 
			((link: 'Error Report' action: [toggle userToggle]) color: Color black)
		details:
			[TextEditorFragment new text: subject errorReport]
)
definitionForMainActions = (
	^padded: (row: {
		filler.
		button: 'Continue' action: [respondToResume].
		largeBlank.
		button: 'Terminate' action: [respondToTerminate].
		filler.
	}) with: {20. 20. 20. 20}
)
definitionForMainContent = (
	^column: {
		(padded: definitionForMainHeader with: {3. 3. 3. 3})
			color: mainHeadingColor.
		smallBlank.
		definitionForErrorReport.
		smallBlank.
		definitionForActivationsHeader.
		smallBlank.
		activations:: definitionForActivationsList.
		moreLinkHolder ifNil:
			[moreLinkHolder:: holder: [nothing]].
	}
)
definitionForMainHeader = (
	^column: {
		definitionForSummaryRow.
		definitionForMainActions.
	}
)
definitionForSingleFrame = (

	^column: {
		activations:: definitionForActivationsList.
           (* activations presenters first.*)
		moreLinkHolder ifNil:
			[moreLinkHolder:: holder: [nothing]].
	}
)
definitionForSummaryRow = (
	^row: {
		(label: subject summary) color: mainHeadingTextColor.
		filler.
		dropDownMenu: [secondaryActionsMenu].
	}
)
expandTopActivation = (
	activations presenters size > 0 ifTrue:
		[| top = activations presenters first. |
		top
			expand;
			refreshPcRangeIndication]
)
navigateTo: destinationSubject = (
	enterSubject::
		(isWindowOwnedByDebugger and: [shell shiftWasPressed not])
			ifTrue:
				[(GlobalDebuggerControlsSubject onModel: destinationSubject)
					debuggerSubject: subject]
			ifFalse:
				[destinationSubject])
noticeEvaluationBy: evaluator <EvaluatorPresenter> = (
	(* Received via sendUp. *)
	refreshExistingActivationPresenters
)
noticeRemoval = (
	thread ifNotNil: [releaseThread terminate]
)
refreshActivations = (
	(* Refresh the activation list, often after an incremental state change such as a step. Try to recognize small updates and avoid rebuilding too much. Also be smart about keeping interesting activation presenters expanded. Normally sent by a contained activation presenter via the sendUp mechanism. *)
	| oldTop oldSender i <Integer> maybeHome expandFirstIfIntoBlock |
	oldTop:: activations presenters first subject model.
	expandFirstIfIntoBlock:: activations presenters first isExpanded.
	oldSender:: activations presenters size >= 2 ifTrue:
					[(activations presenters at: 2) subject model].
	maybeHome:: oldTop context_slot closure ifNotNil: [oldTop context_slot home].

	(* Same activation *)
	oldTop == activation ifTrue:
		[refreshExistingActivationPresenters.
		refreshPcRangeIndication.
		expandTopActivation.
		^self].

	(* Returned to sender *)
	oldSender == activation ifTrue:
		[activations removeAt: 1.
		refreshExistingActivationPresenters.
		expandTopActivation.
		^self].

	(* Called other method *)
	(oldTop isSenderOf: activation) ifTrue:
		[activations addFirst: (subject activationSubjectOnModel: activation) presenter.
		refreshExistingActivationPresenters.
		expandTopActivation.
		^self].

	(* More than one new activation on stack *)
	(activation hasActivation: oldTop) ifTrue:
		[ | newPresenters |
		newPresenters:: (activation activationsUpTo: oldTop) collect:
			[:act | (subject activationSubjectOnModel: act) presenter].
		activations presenters: newPresenters, activations presenters.
		refreshExistingActivationPresenters.
		expandTopActivation.
		^self].

      i:: 0.
	(* See if activation was further up on the stack *)
	activations presenters do:
		[:each  |
		i:: i + 1.
		each subject model == activation ifTrue:
			[activations presenters: (activations presenters copyFrom: i to: activations presenters size).
			expandTopActivation.
			refreshExistingActivationPresenters.
			^self]].

	(* Now check for a new block activation for stepIntoBlock: *)
	(activation context_slot closure notNil
	 and: [activation context_slot home == maybeHome
	 and: [(i:: activations findFirst: [:p| p subject model context_slot == maybeHome]) ~= 0]]) ifTrue:
		[ | newPresenters |
		 newPresenters:: ((activation activationsUpTo: oldTop home) collect:
									[:act| (subject activationSubjectOnModel: act) presenter]) allButLast.
		activations presenters:
			newPresenters,
			(activations presenters copyFrom: i to: activations presenters size).
		expandFirstIfIntoBlock ifTrue:
			[expandTopActivation].
		refreshExistingActivationPresenters.
		^self].

	(* Used to think that normally, this should not happen.  But looks like stepIntoBlock makes it happen. *)
	activation context_slot home == maybeHome ifTrue:
		[repopulateActivations.
		expandFirstIfIntoBlock ifTrue: [expandTopActivation].
		^self].

	reportNoActivationsFrom: thisContext.
	repopulateActivations
)
refreshExistingActivationPresenters = (
	activations presenters do: [:each | each refreshActivationState]
)
refreshPcRangeIndication = (
	activations presenters size > 0 ifTrue:
		[activations presenters first refreshPcRangeIndication]
)
releaseUi: body = (
	majorUpdate:
		[activations setPresenters: {}.
		definitionHolder content: body].
)
repopulateActivations = (
	(* Fill the activations list with newly built activation presenters for the top chunk of the stack and update the contents of the moreLinkHolder. *)
	withTopChunkOfActivationsAndMoreLinkDo:
		[:presenters :moreLinkOrNothing |
		activations presenters: presenters.
		moreLinkHolder content: moreLinkOrNothing]
)
reportNoActivationsFrom: aContext = (
	(* Report that e.g. refreshActivatioons found no activafions to refresh.
	 In the normal debugger this is an error but in subclasses it may be OK. *)
	(aContext printString, ' : should not happen') out
)
respondToCollapseAll = (
	majorUpdate:
		[activations presenters do: [:each | each collapse]]
)
respondToExpandAll = (
	majorUpdate:
		[activations presenters do: [:each | each expand]]
)
respondToOpenSqueakDebugger = (
	releaseUi:: label: 'Debugging in Squeak debugger.'.
	debugInSqueak
)
respondToResume = (
	| threadToResume |
	releaseUi:: label: 'Resuming thread.'.
	threadToResume: releaseThread.
	isWindowOwnedByDebugger
		ifTrue: [shell window close]
		ifFalse: [shell goBack].
	threadToResume resume
)
respondToScrollPositionChange: p <Point> = (
	sendDown respondToScrollingInViewport: visual.
)
respondToTerminate = (
	releaseUi:: label: 'Unwinding stack.'.
	fork: [releaseThread terminate]
		thenUpdateUI:
			[releaseUi:: label: 'Thread is terminated.'. 
			isWindowOwnedByDebugger
				ifTrue: [debuggerHopscotchWindow window close]
				ifFalse: [shell goBack]].
)
secondaryActionsMenu = (
	^menuWithLabelsAndActions: {
		'Open in Squeak Debugger' -> [respondToOpenSqueakDebugger].
		'Inspect Presenter' -> [respondToInspectPresenter]
	}
)
showNextChunkOfActivations = (
	withNextChunkOfActivationsAndMoreLinkDo:
		[:presenters :moreLinkOrNothing |
		activations presenters: (activations presenters concatenate: presenters).
		moreLinkHolder content: moreLinkOrNothing]
)
title = (
	^'Stack Trace: ', subject title
)
withNextChunkOfActivationsAndMoreLinkDo: binaryBlock = (
	| toSkip index presenters |
	toSkip:: activations presenters size.
	index:: 1.
	presenters:: OrderedCollection new.
	subject activationsDo:
		[:each |
		index > toSkip ifTrue:
			[presenters size < chunkSize ifFalse:
				[^binaryBlock
					value: presenters
					value: (link: 'show more...' action: [showNextChunkOfActivations]) smallFont].
			presenters add: ((subject activationSubjectOnModel: each) presenter showMethodHeader: subject isExemplar not)].
		index:: index + 1].
	^binaryBlock value: presenters value: nothing
)
withTopChunkOfActivationsAndMoreLinkDo: binaryBlock = (
	| presenters |
	presenters:: OrderedCollection new.
	subject activationsDo:
		[:each |
		presenters size < chunkSize ifFalse:
			[^binaryBlock
				value: presenters
				value: (link: 'show more...' action: [showNextChunkOfActivations]) smallFont].
		presenters add: ((subject activationSubjectOnModel: each) presenter showMethodHeader: subject isExemplar not)].
	^binaryBlock value: presenters value: nothing
)) : ()
class ThreadSubject onModel: t <ThreadMirror> = Subject onModel: t ()
('as yet unclassified'
activationSubjectOnModel: m = (
	| subjectClass = m isInitializer 
		ifTrue:[InitializerActivationSubject] 
		ifFalse:[ActivationSubject]. 
	|
	^subjectClass onModel: m
)
activationsDo: action = (
	(* The debugger does quite a bit of forking UI activity. From time to time (with debugger tests), activation is nil. So, the folliwing check was added. *)
	activation ifNotNil: [:it | it activationsDo: action]
)
createPresenter = (
	^ThreadPresenter onSubject: self
)
errorReport = (
	^errorReportBlock value: activation
)
isExemplar = (
	^model squeakProcess name = 'Exemplar'
)
summary = (
	^windowTitle, ' in ', model summary
)
title = (
	^windowTitle
)) : ()'accessing'
open = (
	^debuggerHopscotchWindow:: IDEWindow openSubjectFromBlock:
		[:hopscotch |
                hopscotch initialExtent: 970 @ hopscotch initialExtent y.
		ThreadSubject onModel: thread]
)
windowTitle = (
	(* Backward compatibility; eradicate. *)
	^description
)'actions'
debugInSqueak = (
	| context |
	context:: activation context_slot.
	(* The Squeak debugger will schedule itself to be opened on in the Morphic UI thread. *)
	SqueakDebugger
		openOn: releaseThread squeakProcess
		context: context
		label: windowTitle
		contents: nil
		fullView: true.
)
releaseThread ^ <ThreadMirror> = (
	| theThread <ThreadMirror> |
	theThread:: thread.
	thread:: nil.
	activation:: nil.
	registry release: self.
	^theThread
)'as yet unclassified'
openWithin: bounds = (
	^debuggerHopscotchWindow:: IDEWindow openSubjectFromBlock:
		[:hopscotch |
		hopscotch initialBounds: bounds.
		ThreadSubject onModel: thread]
)'testing'
isAlive = (
	^thread isNil not
)
isWindowOwnedByDebugger ^<Boolean> = (
	(* Returns true when the debugger operated by this module has been initially opened in its own top-level window, as opposed to navigated into in a previously existing window. In the own-window case we may want to close the window on the debugged thread termination. *)
	^debuggerHopscotchWindow notNil
)) : ('instance creation'
thread: thread <ThreadMirror> activation: activation <ActivationMirror> description: description <String> = (
	^(thread: thread activation: activation)
		description: description.
))'as yet unclassified'
defaultErrorReportFor: activation = (
	^String streamContents:
		[:s|
		s nextPutAll: 'Please take a moment to complete the questions below and post this report to the forum: https://groups.google.com/group/newspeaklanguage?hl=en'; cr;
 		cr; nextPutAll: 'What did you want to do?'; cr;
		cr; nextPutAll: 'What did you do?'; cr;
		cr; nextPutAll: 'What happened?'; cr;
		cr; nextPutAll: 'What did you expect?'; cr;
		cr; nextPutAll: 'Please make sure you included all relevant information so that the problem can be verified and/or reproduced.'; cr;  
		cr;
		cr; nextPutAll: 'DETAILS:'; cr; cr.
		activation errorReportOn: s]
)'parameters'
mainHeadingColor = (
	^Gradient from: (Color h: 0 s: 0.5 v: 0.8) to: (Color h: 0 s: 0.5 v: 0.6).
)
mainHeadingTextColor = (
	^Color white
)'private'
highlight: text range: range = (
	^text
		addAttribute: TextEmphasis underlined from: range first to: range last;
		addAttribute: TextColor red from: range first to: range last;
		yourself
)) : ()