Newspeak3
'HopscotchIDE'
class Debugging usingPlatform: platform ide: ide = (
"Newspeak debugger module. Must be instantiated through ProcessFinalizer.

Copyright (c) 2009 Peter von der Ahe

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
''Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."|
	"Imports" 
	Gradient = platform brazil plumbing Gradient.

	TextEditorFragment = platform hopscotch fragments TextEditorFragment.
	Subject = platform hopscotch core Subject.

	CodeEditorFragment = ide tools CodeEditorFragment.
	ExpandableMethodPresenter = ide browsing ExpandableMethodPresenter.
	MethodSubject = ide browsing MethodSubject.
	IDEWindow = ide tools IDEWindow.
	NSMethodInheritanceSubject = ide browsingNS3 MethodInheritanceSubject.
	OneLineDefinitionTemplate = ide tools OneLineDefinitionTemplate.
	ProgrammingPresenter = ide tools ProgrammingPresenter.
	ide = ide.

	Color = platform blackMarket Graphics Color.
	OrderedCollection = platform collections OrderedCollection.
	SqueakDebugger = platform blackMarket Tools Debugger.
	TextColor = platform blackMarket Collections TextColor.
	TextEmphasis = platform blackMarket Collections TextEmphasis.
	UnhandledError = platform blackMarket Exceptions UnhandledError.

	"Slots"
	goldenRatio = (1 + 5 sqrt) / 2.
	registry <ProcessFinalizer>
	thread
	activation
	windowTitle
|)
(
class ActivationPresenter onSubject: subj <ActivationSubject> = ExpandableMethodPresenter onSubject: subj (|
	localVariables
	okToRestartBlock ::= false.
|)
('as yet unclassified'
buildActions = (
	| object |
	^column: {
		row: {
			button: 'over' action: [respondToStepOver].
			smallBlank.
			button: 'into' action: [respondToStepInto].
			smallBlank.
			button: 'into block' action: [respondToStepIntoBlock].
			filler.
			button: '^self' action: [respondtoReturnSelf].
			smallBlank.
			button: '^nil' action: [respondToReturnNil].
			holder: [buildReturnInterestingValue].
		}
	}
)
buildLocalVariables = (
	localVariables:: (ActivationStateSubject onModel: subject model) presenter.
	^localVariables
)
buildMethodEditor = (
	| methodEditor |
	methodEditor:: super methodDetails.
	methodEditor colorizerBlock:
		[:text |
		subject colorizeMethodSource: text in: methodEditor editor].
	^methodEditor
)
buildReturnInterestingValue = (
	subject lastInterestingValueOnStack ifNotNil:
		[:it |
		^row: {
			smallBlank.
			button: '^', (it reflecteePrintStringLimitedTo: 10) action: [respondToReturnValue: it].
		}].
	^nothing
)
clearErrors = (
	editor ifNotNil: [:it | it removeMessages]
)
methodActionsMenu = (
	^menuWithLabelsAndActions: {
		"'Versions' -> [respondToVersions]."
		subject isBlockActivation
			ifTrue: ['Restart block' -> [respondToRestart]]
			ifFalse: ['Restart method' -> [respondToRestart]].
		'Unwind Recursion' -> [respondToUnwindRecursion].
		'Inspect Context' -> [respondToInspectContext].
		'Inspect Presenter' -> [respondToInspectPresenter].
	},(
		subject isMessageNotUnderstood
			ifTrue: [{'Create missing method ', subject notUnderstoodMessage printString -> [respondToCreateMissing]}]
			ifFalse: [{}]
	)
)
methodDetails = (
	^column: {
		(row: {
			(column: {
				minorHeadingBlock: buildActions.
				buildMethodEditor.
			}) width: 0 elasticity: goldenRatio.
			smallBlank.
			buildLocalVariables width: 0 elasticity: 1.
		}) color: self methodHeadingColor.
	}
)
methodHeading = (
	| heading |
	heading:: super methodHeading.
	subject implementingClass == subject receiverClass
		ifTrue: [^heading].
	headingAfterLeftHolder content: (
		row: {
			largeBlank.
			(link: 'receiver class' action: [respondToBrowseReceiverClass]) tinyFont.
		}
	).
	^heading
)
recategorizeMethodIn: p <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (
	| newName |
	newName:: newCategoryName withBlanksTrimmed.
	newName isEmpty ifTrue: [^failureResponse value].
	subject
		changeCategoryTo: newName asSymbol
		ifSuccess: successResponse
		ifFailure: failureResponse
)
refresh = (
	super refresh.
	editor ifNotNil: [:it | it editor maybeColorize].
	localVariables ifNotNil: [:it | it refresh].
)
respondToBrowseReceiverClass = (
	browseClass: subject receiverClass
)
respondToCreateMissing = (
	browseClass: subject receiverClass.
	sendUp deliveryOptional navigatorDo:
		[:navigator |
		navigator currentPresenter sendDown
			addMethodIn: subject receiverClass
			proposedSource: subject proposedMissingMessageSource asString]
)
respondToInspectContext = (
	inspect: subject model context_slot
)
respondToRestart = (
	clearErrors.
	subject restartIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToReturn: textEditor <TextEditorFragment> = (
	clearErrors.
	subject
		returnWith: textEditor editedText asString
		ifFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToReturnNil = (
	subject returnNil.
	sendUp deliveryOptional refreshActivations
)
respondToReturnValue: objectMirror <ObjectMirror> = (
	subject return: objectMirror.
	sendUp deliveryOptional refreshActivations
)
respondToStepInto = (
	clearErrors.
	subject stepIntoIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToStepIntoBlock = (
	clearErrors.
	subject stepIntoBlockIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToStepOver = (
	clearErrors.
	subject stepOverIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondToUnwindRecursion = (
	clearErrors.
	subject unwindRecursionIfFail: [:msg | editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
respondtoReturnSelf = (
	subject return: subject receiverMirror.
	sendUp deliveryOptional refreshActivations
)
showClassLink = (
	^true
)
showClassName = (
	^true
))
class ActivationStatePresenter onSubject: subj <ActivationStateSubject> = ProgrammingPresenter onSubject: subj (|
	interactionEditor
|)
('as yet unclassified'
acceptNewValue: template <DefinitionTemplate> for: variableName = (
	subject
		setLocalVariable: variableName
		to: template text asString
		ifFail: [:msg | template editor showMessage: msg].
	sendUp deliveryOptional refreshActivations
)
additionalResultFragment: fragmentConsumer <[Fragment]> for: result <[ObjectMirror]> = (
	fragmentConsumer
		value: (link: 'return it' action: [respondToReturn: result]) tinyFont
)
buildExpressionStack = (
	^nothing
)
buildExpressionStackOn: s <WriteStream[Presenter]> = (
	s nextPut: smallBlank.
	s nextPut:
		(heading: (label: 'Expression Stack' asText allBold)
		detailsExpanded:
			[list: (subject stackIndicesWithValuesCollect:
				[:i :mirror |
				buildLocalVariable: i asString value: mirror])])
)
buildHeadingForLocalVariable: variableName value: object = (
	^row: {
		label: variableName asText allBold.
		smallBlank.
		link: (object reflecteePrintStringLimitedTo: 39) action:
			[inspectObjectMirror: object].
	}
)
buildInteraction = (
	^inspection EvaluatorPresenter onSubject: subject
)
buildLocalVariable: variableName value: object = (
	
	^collapsed: [buildHeadingForLocalVariable: variableName value: object]
	expanded:
		[| template |
		template:: OneLineDefinitionTemplate new
			initialText: 'new value for ', variableName;
			acceptResponse: [:t | acceptNewValue: t for: variableName];
			cancelResponse: [:t | t editor defaultCancelResponse];
			ensureSubstance.
		template editor defaultCancelResponse.
		column: {
			template.
			(objectSubjectForMirror: object) presenter selfCaption: variableName.
		}]
)
buildSelf = (
	^collapsed: [buildHeadingForLocalVariable: 'self' value: subject receiverMirror]
		expanded: [(objectSubjectForMirror: subject receiverMirror) presenter]
)
definition = (
	^list:
		[Array streamContents:
			[:s |
			"s nextPut: ((padded: (buildInteraction color: self methodHeadingColor) with: {1. 1. 1. 1}) color: (Color gray: 0.75))."
			s nextPut: buildInteraction.
			s nextPut: buildSelf.
			subject localNamesWithValuesDo:
				[:localName :mirror |
				s nextPut: (buildLocalVariable: localName value: mirror)].
			buildExpressionStackOn: s]].
)
respondToEvaluate = (
	
)
respondToReturn: mirror <ObjectMirror> = (
	subject return: mirror.
	sendUp deliveryOptional; refreshActivations
))
class ActivationStateSubject onModel: mirror <ActivationMirror> = Subject onModel: mirror ()
('as yet unclassified'
activationMirror = (
	^model
)
createPresenter = (
	^ActivationStatePresenter onSubject: self
)
evaluate: expression ifCompilerError: onCompilerError <[String]> ifError: onError <[NewspeakDebugging ThreadSubject, Exception]> ^<ObjectMirror> = (
	| result compilerError |
	compilerError:: {nil}.
	result:: registry
		do: [activationMirror evaluate: expression ifFail: [:msg | compilerError at: 1 put: msg]]
		name: 'Evaluating ', expression
		ifError:
			[:exception :process |
			onError value: (registry subjectFor: exception in: process) value: exception].
	compilerError first ifNotNil:
		[:message |
		^onCompilerError valueWithPossibleArgument: message].
	^result
)
localNamesWithValuesCollect: action <[Integer, ObjectMirror, ^T]> ^<SequenceableCollection[T]>= (
	^Array streamContents:
		[:s |
		activationMirror localNamesWithValuesDo:
			[:i :mirror | s nextPut: (action value: i value: mirror)]]
)
localNamesWithValuesDo: action <[String, ObjectMirror]> = (
	activationMirror localNamesWithValuesDo: action
)
receiver = (
	^activationMirror receiver
)
receiverMirror = (
	^activationMirror receiverMirror
)
return: objectMirror = (
	activation:: thread return: objectMirror from: activationMirror
)
setLocalVariable: variableName <String> to: exprString <String> ifFail: onFail <[String]> = (
	activationMirror setLocalVariable: variableName to: exprString ifFail: onFail
)
stackIndicesWithValuesCollect: action <[Integer, ObjectMirror, ^T]> ^<SequenceableCollection[T]>= (
	^Array streamContents:
		[:s |
		activationMirror stackIndicesWithValuesDo:
			[:i :mirror | s nextPut: (action value: i value: mirror)]]
)
stackIndicesWithValuesDo: action <[Integer, ObjectMirror]> = (
	activationMirror stackIndicesWithValuesDo: action
)
title = (
	^'Expression Stack'
))
class ActivationSubject onModel: mirrorOnActivation <ActivationMirror> = MethodSubject onModel: mirrorOnActivation (| methodMirror_slot |)
('as yet unclassified'
= other <Object> ^<Boolean> = (
	^self class = other class and: [model = other model]
)
activationMirror ^  <ActivationMirror> = (
	^model
)
allMethodCategories ^<Collection[Symbol]> = (
	"Answer a collection of all category names used in the implementor class, plus some common names."
	
	| names |
	names:: super allMethodCategories.
	names addAll: methodMirror enclosingClassStencil methodCategories.
	^names
)
asMethodInheritanceSubject = (
	^NSMethodInheritanceSubject onModel: methodMirror
)
changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
	methodMirror changeCategory: newName asSymbol.
	successBlock value
)
classAndSelectorString = (
	^model printString
)
colorizeMethodSource: sourceText = (
	
	activationMirror sourceAvailable ifFalse: [^sourceText].

	methodMirror reflectee methodClass language isNewspeakLanguage3 
		ifFalse:[^super colorizeMethodSource: sourceText].

	^ide browsingNS3 NS3Colorizer new 
		parseText: sourceText asString
		fromClass: methodMirror definingMixin reflectee definingClass
		usingSelector: #methodDecl
)
colorizeMethodSource: sourceText in: editor = (
	| range |
	range:: model pcRange.
	sourceText asString = source asString ifTrue:
		[editor selectFrom: range first to: range last.
		^highlight: (colorizeMethodSource: sourceText) range: range].
	^colorizeMethodSource: sourceText
)
compileNewSource: newSource <String> ifSuccess: onSuccess ifNewMethod: onNewMethod ifFailure: onFail = (
	| method failed |
	model homeMethod isSynthetic
		ifTrue: [^onFail valueWithPossibleArgument: 'Cannot change synthetic method.'].
	method:: activationMirror compile: newSource ifFail:
		[:msg | ^onFail valueWithPossibleArgument: msg].
	method simpleName = selector
		ifFalse: [^onNewMethod valueWithPossibleArgument: method].
	failed:: nil.
	activation:: thread install: method restart: model homeInThread ifFail:
		[:message | failed:: message].
	failed ifNotNil: [:it | ^onFail valueWithPossibleArgument: it].
	onSuccess value
)
createPresenter = (
	^ActivationPresenter onSubject: self
)
hasLegacyMirror = (
	^methodMirror enclosingClassStencil isLegacyMirror
)
hash ^<SmallInteger> = (
	^self class hash bitXor: model hash
)
implementingClass = (
	^model definingClass
)
isAnOverride = (
	superclass ifNotNil: [:it | ^it canUnderstand: selector].
	^false
)
isBlockActivation = (
	^model isBlockMirror
)
isMessageNotUnderstood = (
	^model isMessageNotUnderstood
)
isOverridden = (
	^false
)
isPrivate = (
	^methodMirror isPrivate
)
isValid = (
	^true
)
lastInterestingValueOnStack ^<ObjectMirror | nil> = (
	| mirror |
	model stackIndicesWithValuesDo:
		"Prefer topmost value which comes first"
		[:ignored :current |
		current reflecteeIsNil ifFalse: [^current]].
	model localNamesWithValuesDo:
		"Prefer last argument which comes last"
		[:ignored :current |
		current reflecteeIsNil ifFalse: [mirror:: current]].
	^mirror
)
localNames = (
	^model localNames
)
messages = (
	^(model homeMethod ifNil: [^{}]) messages
)
methodCategory = (
	^methodMirror category
)
methodMirror = (
	^model methodMirror
)
notUnderstoodMessage = (
	^model notUnderstoodMessage
)
proposedMissingMessageSource = (
	^model proposedMissingMessageSource
)
receiver = (
	^model receiver
)
receiverClass = (
	^model receiverClass
)
receiverMirror = (
	^model receiverMirror
)
restartIfFail: onFail <[String]> = (
	activation:: thread restart: model
)
return: objectMirror = (
	activation:: thread return: objectMirror from: model
)
returnNil = (
	return: activationMirror nilMirror
)
returnWith: expression ifFail: onFail = (
	return:: activationMirror evaluate: expression ifFail: [:msg | ^onFail value: msg]
)
selector = (
	^model selector
)
source = (
	^[model source] ifError: [:desc | desc]
)
stepIntoBlockIfFail: onFail = (
	activation:: thread stepIntoBlock: model.
)
stepIntoIfFail: onFail = (
	activation:: thread stepInto: model.
)
stepOverIfFail: onFail = (
	activation:: thread stepOver: model.
)
superclass = (
	"^methodMirror enclosingClassStencil guessSuperclass"
	#BOGUS yourself.
	^Object
)
unwindRecursionIfFail: onFail <[String]> = (
	activation:: thread unwindRecursion: model.
)
variableBindingKeys = (
	^Array streamContents:
		[:s |
		(model homeMethod ifNil:[^{}]) literalsDo:
			[:lit |
			(lit isVariableBinding and: [lit key notNil])
				ifTrue: [s nextPut: lit key]]]
))
class ThreadPresenter onSubject: subj <ThreadSubject> = ProgrammingPresenter onSubject: subj (|
	protected activations
	protected definitionHolder
|)
('as yet unclassified'
buildActivationsHeader = (
	^majorHeadingBlock: (
		row: {
			label: 'Call stack' asText allBold.
			filler.
			expandButtonWithAction: [respondToExpandAll].
			blank: 3.
			collapseButtonWithAction: [respondToCollapseAll].
		}
	)
)
buildErrorReport = (
	| toggle |
	toggle:: heading: ((link: 'Error Report' action: [toggle userToggle]) color: Color black) details:
		[TextEditorFragment new text: subject errorReport].
	^toggle
)
buildMainActions = (
	^padded: (row: {
		filler.
		button: 'Continue' action: [respondToResume].
		largeBlank.
		button: 'Terminate' action: [respondToTerminate].
		filler.
	}) with: {20. 20. 20. 20}
)
buildMainContent = (
	^column: {
		(padded: buildMainHeader with: {3. 3. 3. 3}) color: mainHeadingColor.
		smallBlank.
		buildErrorReport.
		smallBlank.
		buildActivationsHeader.
		smallBlank.
		activations.
	}
)
buildMainHeader = (
	^column: {
		buildSummaryRow.
		buildMainActions.
	}
)
buildSummaryRow = (
	^row: {
		(label: subject summary) color: mainHeadingTextColor.
		filler.
		dropDownMenu: [secondaryActionsMenu].
	}
)
chunkSize = (
	^60
)
compileMethod: newSource <String>
inPresenter: p <ActivationPresenter>
ifCompiledAsSame: onCompiledAsSame <[]>
ifCompiledAsNew: onCompiledAsNew <[]>
ifFailed: onFail <[String]> = (
	| edited home |
	edited:: p subject activationMirror.
	home:: edited homeInThread.
	home ifNil: [^onFail value: 'Block''s method not on stack.'].
	(edited = home or: [p okToRestartBlock]) ifFalse:
		[p okToRestartBlock: true.
		^onFail value: 'Need to revert to block''s method. Click Save again to revert.'].
	p subject
		compileNewSource: newSource
		ifSuccess:
			[refreshActivations.
			onCompiledAsSame value]
		ifNewMethod: onCompiledAsNew
		ifFailure:
			[:message |
			refreshActivations.
			onFail valueWithPossibleArgument: message].
)
definition = (
	isAlive ifFalse: [^nothing].
	activations:: list.
	definitionHolder:: holder: [buildMainContent].
	populateActivations.
	^definitionHolder
)
expandFirst = (
	activations presenters first expand
)
populateActivations = (
	refreshWhenDone:
		[ | presenters |
		presenters:: OrderedCollection new.
		subject activationsDo:
			[:each |
			presenters size > chunkSize ifTrue:
				[schedulePresentation: presenters.
				presenters:: OrderedCollection new].
			presenters add: (ActivationSubject onModel: each) presenter].
		schedulePresentation: presenters.
		nil].
)
refreshActivations = (
	| oldTop oldSender i <Integer> |
	oldTop:: activations presenters first subject model.
	oldSender:: (activations presenters at: 2) subject model.

	"Same activation"
	oldTop == activation ifTrue:
		[^majorUpdate: [refreshAll]].

	"Returned to sender"
	oldSender == activation ifTrue:
		[^majorUpdate:
			[activations presenters: (activations presenters copyWithout: activations presenters first).
			refreshAll.
			expandFirst]].

	"Called other method"
	(oldTop isSenderOf: activation) ifTrue:
		[^majorUpdate:
			[activations addFirst: (ActivationSubject onModel: activation) presenter.
			refreshAll.
			expandFirst]].

	"More than one new activation on stack"
	(activation hasActivation: oldTop) ifTrue:
		[ | newPresenters |
		newPresenters:: Array streamContents:
			[:s | | current |
			current:: activation.
				[s nextPut: (ActivationSubject onModel: current) presenter.
				oldTop isSenderOf: current] whileFalse:
					[current:: current sender]].
		^majorUpdate:
			[refreshAll.
			activations presenters: newPresenters, activations presenters.
			expandFirst]].

      i:: 0.
	"See if activation was further up on the stack"
	activations presenters do:
		[:each  |
		i:: i + 1.
		each subject model == activation ifTrue:
			[^majorUpdate:
				[activations presenters: (activations presenters copyFrom: i to: activations presenters size).
				expandFirst.
				refreshAll]]].

	"Normally, this should not happen"
	'ThreadPresenter>>refreshActivations : should not happen' out.
	activations presenters: {}.
	populateActivations.
)
refreshAll = (
	activations presenters do: [:each | each refresh]
)
releaseUi: body = (
	majorUpdate:
		[activations setPresenters: {}.
		definitionHolder content: body].
)
respondToCollapseAll = (
	majorUpdate:
		[activations presenters do: [:each | each collapse]]
)
respondToExpandAll = (
	majorUpdate:
		[activations presenters do: [:each | each expand]]
)
respondToOpenSqueakDebugger = (
	releaseUi:: label: 'Debugging in Squeak debugger.'.
	debugInSqueak
)
respondToResume = (
	releaseUi:: label: 'Resuming thread.'.
	releaseThread resume
)
respondToTerminate = (
	releaseUi:: label: 'Unwinding stack.'.
	fork: [releaseThread terminate] thenUpdateUI:
		[releaseUi:: label: 'Thread is terminated.'].
)
schedulePresentation: presenters = (
	schedule: [activations presenters: (activations presenters concatenate: presenters)]
)
secondaryActionsMenu = (
	^menuWithLabelsAndActions: {
		'Open in Squeak Debugger' -> [respondToOpenSqueakDebugger].
	}
)
title = (
	^'Stack Trace: ', subject title
))
class ThreadSubject onModel: t <ThreadMirror> = Subject onModel: t ()
('as yet unclassified'
activationsDo: action = (
	activation activationsDo: action
)
createPresenter = (
	^ThreadPresenter onSubject: self
)
errorReport = (
	^String streamContents: [:s |
		s nextPutAll: 'Please take a moment to complete the questions below and post this report to the forum: http://forums.newspeaklanguage.org/index.php?board=2.0'; cr;
			cr; nextPutAll: 'What did you want to do?'; cr;
			cr; nextPutAll: 'What did you do?'; cr;
			cr; nextPutAll: 'What happened?'; cr;
			cr; nextPutAll: 'What did you expect?'; cr;
			cr; nextPutAll: 'Please make sure you included all relevant information so that the problem can be verified and/or reproduced.'; cr; cr;
			cr; nextPutAll: 'DETAILS:'; cr; cr.
		activation errorReportOn: s]
)
summary = (
	^windowTitle, ' in ', model summary
)
title = (
	^windowTitle
))'as yet unclassified'
mainHeadingColor = (
	^Gradient from: (Color h: 0 s: 0.5 v: 0.8) to: (Color h: 0 s: 0.5 v: 0.6).
)
mainHeadingTextColor = (
	^Color white
)
open = (
	IDEWindow openSubjectFromBlock:
		[:hopscotch |
		hopscotch initialExtent: 970 @ hopscotch initialExtent y.
		ThreadSubject onModel: thread]
)'private'
debugInSqueak = (
	| context |
	context:: activation context_slot.
	"The Squeak debugger will schedule itself to be opened on in the Morphic UI thread."
	SqueakDebugger
		openOn: releaseThread squeakProcess
		context: context
		label: windowTitle
		contents: nil
		fullView: true.
)
highlight: text range: range = (
	^text
		addAttribute: TextEmphasis underlined from: range first to: range last;
		addAttribute: TextColor red from: range first to: range last;
		yourself
)
releaseThread = (
	| theThread <ThreadMirror> |
	theThread:: thread.
	thread:: nil.
	activation:: nil.
	registry release: self.
	^theThread
)'testing'
isAlive = (
	^thread isNil not
))