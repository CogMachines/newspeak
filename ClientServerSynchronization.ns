Newspeak3
'OrthogonalSynchronization'
class ClientServerSynchronization usingPlatform: platform  = (
|		
	Map = platform collections Map.
	ObjectMirror = platform mirrors ObjectMirror.
|
) (
public class ClientToServerChangeLog  withChanges: aChangeRecordsCollection withNewObjects: aNewObjectsCollection = (
|
	public versionId
	public changeRecords = aChangeRecordsCollection.
	public newObjectsDefinitions = aNewObjectsCollection.
	
|
) (
public hasNoChanges = (
	^ changeRecords isEmpty and: [ newObjectsDefinitions isEmpty].
)
public hasNoNewObjectsDefinitions = (
	^ newObjectsDefinitions isEmpty. 
)
) : (
)
public class NewObjectReference toObjectIdentifiedWith: anIdentifier  = (
|
	public identifier = anIdentifier.
|
) (
public asGlobalReferenceUsing: aStore = (
	 ^ ObjectReference toObjectIdentifiedWith: (aStore  guidForLocal: identifier). 
	(* ^ NewObjectReference toObjectIdentifiedWith: (aStore  guidForLocal: identifier).  *)
	
)
public existsReferencedObjectIn: aStore = (
	^ aStore containsNewObjectWithId: identifier
)
public isKindOfNewObjectReference = (
	^ true
)
public referencedObjectFrom: anObjectStore = (

	^ anObjectStore newObjectWithId: identifier.
)
public refersToNil = (
	^ false
)
) : (
)
public class ObjectChangeRecord for: anObjectReference withChanges: valuesBySlot  = (
|
	public objectReference =anObjectReference.
	public changes = valuesBySlot.
|) (
public applyChangesIn: aContext usingMirror: objectMirrorClass = (
	| objectToModify objectToModifyMirror |
	objectToModify:: objectReference referencedObjectFrom: aContext.
	objectToModifyMirror:: objectMirrorClass reflecting: objectToModify.
	changes keysAndValuesDo: [ :slot :reference |
		| referencedObject  |
		referencedObject:: reference referencedObjectFrom: aContext.
		objectToModifyMirror setSlot: slot to: referencedObject.
	].
)
public asGlobalReferenceUsing: objectStore = (

	|  changesWithGlobalReference |
	
	changesWithGlobalReference:: Map new.
	changes  keysAndValuesDo: [ :key :value |   changesWithGlobalReference at: key put: (value asGlobalReferenceUsing: objectStore)   ].	
	

	^ class for: objectReference withChanges: changesWithGlobalReference.
)
public isKindOfObjectChangeRecord = (
^ true
)
public refersTo: anObject in: aContext = (
	^ objectReference refersTo: anObject inContext: aContext.
)
) : (
)
public class ObjectDefinition classNamed: aClassName enclosingObjectReference: anObjectReference withContents: contents  = (
|
	public className = aClassName.
	public enclosingObjectReference ::= anObjectReference.
	slotsContents = contents.

|
) (
public asGlobalReferenceUsing: objectStore = (

	| globalEnclosingObjectReference globalSlotContents |
	
	globalEnclosingObjectReference:: ( enclosingObjectReference asGlobalReferenceUsing: objectStore).
	globalSlotContents:: Map new.
	slotsContents keysAndValuesDo: [ :key :value |   globalSlotContents at: key put: (value asGlobalReferenceUsing: objectStore)   ].	
	

	^ class classNamed: className enclosingObjectReference: globalEnclosingObjectReference withContents: globalSlotContents.
)
public createEmptyInstanceUsingEnclosingObjectMirror: anEnclosingObjectMirror  = (
	| klassMirror | 
	klassMirror:: anEnclosingObjectMirror evaluate: ('^self ', className) ifCompilerError: [] ifError: [ :error | error signal ].
	^ klassMirror reflectee basicNew .
)
public fill: anObjectMirror resolvingReferencesWith: anObjectStore = (
	slotsContents keysAndValuesDo: [ :slotName :reference |
		 anObjectMirror setSlot: slotName to: (reference referencedObjectFrom: anObjectStore).
	].

)
public isKindOfObjectDefinition = (
^ true
)
public slotNamed: aSlotName hasValue: anObject = (
	^ (slotsContents at: aSlotName) refersTo: anObject.
)
) : (
)
public class ObjectDefinitionWithIdentification id: anId definition: aDefinition = (
|
	public id = anId.
	public definition = aDefinition. 
|
) (
) : (
)
public class ObjectReference toObjectIdentifiedWith: anIdentifier = (
|
	public identifier = anIdentifier.
|
) (
public asGlobalReferenceUsing: aStore = (
	 ^  self .  
	(* ^ NewObjectReference toObjectIdentifiedWith: identifier. *)
)
public existsReferencedObjectIn: aStore = (
	^ aStore containsObjectWithGuid: identifier
)
public isKindOfObjectReference = (
	^ true
)
public referencedObjectFrom: anObjectStore = (
	^ anObjectStore objectWithGuid: identifier.
)
public refersTo: anObject  inContext: aContext  = (
	^( aContext isIdentifiable: anObject) and: 
		  [ (aContext isTracked: anObject) and:		
			[identifier = (aContext idForObject: anObject)] ]. 
)
public refersToNil = (
	^ false
)
) : (
)
public class ObjectStore = (
|

|
) (
public objectWithGuid: anIdentifier = (
	subclassResponsibility
)
public objectWithLocalId: anIdentifier = (
	subclassResponsibility
)
) : (
)
public class ServerToClientChangeLog  mappingIdsWith: idsMap changeRecords: changes newObjects: newObjectsCollection versionId: aVersionId   = (
|
	public localToGlobalIds = idsMap.
	public changeRecords = changes.
	public newObjects = newObjectsCollection.
	public versionId =aVersionId.
	public rootObjectReference
|
) (
) : (
)
public class UnidentifiableObject for: aValue = (
|
	value = aValue.
|
) (
public asGlobalReferenceUsing: aStore = (
	^  self
)
public existsReferencedObjectIn:  aStore  = (
	^ true
)
public referencedObjectFrom: anObjectStore = (
	^ value.
)
public refersTo: anObject = (
	^  value = anObject.
)
public refersTo: anObject inContext: aContext = (
	^refersTo: anObject.
)
public refersToNil = (
	^ refersTo: nil.
)
) : (
)
public classNameFor: anObject = (
	| mirror  |
	mirror:: ObjectMirror reflecting: anObject.
	^ mirror getClass  mixin name

)
public enclosingObjectForClassOf: anObject = (
	| mirror  |
	mirror:: ObjectMirror reflecting: anObject.
	^ mirror getClass enclosingObject reflectee

)
) : (
)
