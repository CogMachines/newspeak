Newspeak3'NSKernel'class Kernel usingPlatform: p vmMirror: vmm = NewspeakObject ("N.B.: This code is not live in the system.  true, false and nil are not instances of the True, False and UndefinedObject defined here.  NSObject is not the root of the class hierarchy.This code was derived in part by converting the Strongtalk Magnitude, Boolean and  UndefinedObject classes to Newspeak. For those classes, the Sun Microsystems copyright and BSD license below applies.Copyright 2008 Cadence Design Systems, Inc.   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0Copyright (c) 1995-2006 Sun Microsystems, Inc. ALL RIGHTS RESERVED.Copyright 2008-2009 David Pennell, Stephen Pair, Gilad Bracha and other contributors.Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:* Redistributions of source code must retain the above copyright notice,  this  list of conditions and the following disclaimer.* Redistribution in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/o other materials provided with the distribution.Neither the name of Sun Microsystems or the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.>>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.>>"|	"Imports"	protected CompiledMethod = p blackMarket Kernel CompiledMethod.	protected MethodProperties = p blackMarket Kernel MethodProperties.	protected HostAssociation = p blackMarket Collections Association.		"Store these classes, which work while NewspeakObject is a Squeak class and accesses them	from the system dictionary, so they can be returned by NSObject after Object become: NSObject"	private HostArray = super Array.	private HostByteArray = super ByteArray.	private HostCharacter = super Character.	private HostError = super Error.	private HostInteger = super Integer.	private HostFloat = super Float.	private HostString = super String.	private HostSymbol = super Symbol.	private vmMirror = vmm.		"We re-use the Squeak class for reifying messages."	public Message = p blackMarket Kernel  Message.|)(class Value = NSObject ("Some objects cannot change after they are created. They are deeply immutable and known as value objects. A value object is globally unique, in the sense that no other object is equal to it.An object o is a value object iff, under the assumption that o is a value object, it can be shown that:-All its slots are immutable and contain value objects.-Its enclosing objects are all value objects.-Its class inherits from class Value and does not override its identity method (==).Examples of such objects are numbers, booleans, characters, literal strings, symbols and module definitions."||)('as yet unclassified'public copy ^<Instance> = (	^self)'testing'public == otherObject = (	^self = otherObject))class Magnitude =  ("A Magnitude[M] is an object that has a linear relationship with objects of type M, suchthat they can be compared using the relational operations <,>,<=,>=.%note: The derived operations are carefully defined to use <    and not = for the following reasons:        - speed        - use of = may be bad for subclasses with a problematic definition of =,          such as floating point numbers."||)('comparing'< other <M> ^<Boolean> = (	self subclassResponsibility)<= other <M> ^<Boolean> = (	"%todo: when using inherited types, use the original definition:		^(other < self) not	"	^self < other or: [ self = other ])> other <M> ^<Boolean> = (	"%todo: for inherited types use:		^other < self	"	^(self <= other) not)>= other <M> ^<Boolean> = (	^(self < other) not)between: min <M> and: max <M> ^<Boolean> = (	"test whether the receiver is in the range min -> max, inclusive"	"test the max case first since end of range overflow is generally more common"	^self <= max and: [ self >= min ])compare: other <M>  ^<Int> = (	"Returns -1 if self < other, 0 if self = other, or 1 if self > other"	^self < other		ifTrue: [ -1 ]		ifFalse: [ self > other							ifTrue: [ 1 ] ifFalse: [ 0 ]  ])max: other <ARG> ^<Self | ARG> = (		"{where X is arg 1 of #< message of receiverType;			where ARG <X> is arg 1}"	"The guaranteed is safe because of the inference clause"	^self > ("guaranteed <M>:\" other)		ifTrue: [ self ]		ifFalse: [ other ])min: other <ARG> ^<Self | ARG> = (		"{where X is arg 1 of #< message of receiverType;			where ARG <X> is arg 1}"	"The guaranteed is safe because of the inference clause"	^self < ("guaranteed <M>" other)		ifTrue: [ self ]		ifFalse: [ other ])) : ('utility'defaultSort ^<[X,M, ^Boolean]> = (	"{where X is returnType of #new message of receiverType}"	"return a sort predicate suitable for a sorted collection of M"	"The guarantee is safe because of the inference clause"	^"guaranteed <[X,M,^Boolean]>"		[ :m1 <Magnitude[M]> :m2 <M> | m1 <= m2 ]))class Block = ("Tags: %BlueBook(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.3 $"|	protected hostBlock|)('evaluating'doWhileFalse: aBlock = ()doWhileTrue: aBlock = ()repeat = ()value = (	^hostBlock value)value: a1 = (	^hostBlock value: a1)value: a1 value: a2= (	^hostBlock		value: a1		value: a2)value: a1 value: a2 value: a3 = (	^hostBlock		value: a1		value: a2		value: a3)value: a1 value: a2 value: a3 value: a4 = (	^hostBlock		value: a1		value: a2		value: a3		value: a4 )value: a1 value: a2 value: a3 value: a4 value: a5 = (	^hostBlock		value: a1		value: a2		value: a3		value: a4 		value: a5)value: a1 value: a2 value: a3 value: a4 value: a5 value: a6 = (	^hostBlock		value: a1		value: a2		value: a3		value: a4 		value: a5		value: a6)value: a1 value: a2 value: a3 value: a4 value: a5 value: a6 value: a7 = (	^hostBlock		value: a1		value: a2		value: a3		value: a4 		value: a5		value: a6		value: a7)value: a1 value: a2 value: a3 value: a4 value: a5 value: a6 value: a7 value: a8 = (	^hostBlock		value: a1		value: a2		value: a3		value: a4 		value: a5		value: a6		value: a7		value: a8)value: a1 value: a2 value: a3 value: a4 value: a5 value: a6 value: a7 value: a8 value: a9 = (	^hostBlock		value: a1		value: a2		value: a3		value: a4 		value: a5		value: a6		value: a7		value: a8		value: a9)valueWithArguments: array = (	)whileFalse = ()whileFalse: aBlock = ()whileTrue = ()whileTrue: aBlock = ()'accessing'numArgs = ()'testing'isBlock = (	^true)'exceptions'ensure: aBlock = ()ifError: aBlock = ()on: exception do: handler = ()) : ('as yet unclassified'onHostBlock: aBlockContext = (	^self new		hostBlock: aBlockContext;		yourself))class Boolean = Value (""||)('as yet unclassified'asAlien ^ <Integer> = (	"Convert to C boolean representation"	self subclassResponsibility)'operations'& other <Boolean>^ <Boolean> = (	"and"	self subclassResponsibility)not ^ <Boolean> = (	self subclassResponsibility)xor: other <Boolean> ^ <Boolean> = (	"exclusive-or"	^self ~~ other)| other <Boolean> ^ <Boolean> = (	"or"	self subclassResponsibility)'control'&& f <[^Boolean]>	^ <Boolean> = (	"Synonym for and:"	self subclassResponsibility)and: f <[^Boolean]>	 ^ <Boolean> = (	self subclassResponsibility)ifFalse: then <[]> ^ <Object> = (	self subclassResponsibility)ifFalse: then <[^X def]> ifTrue: else <[^Y def]> ^ <X|Y> = (	self subclassResponsibility)ifTrue: then <[]> ^ <Object> = (	self subclassResponsibility)ifTrue: then <[^X def]> ifFalse: else <[^Y def]> ^ <X|Y> = (	self subclassResponsibility)or: f <[^Boolean]>	^ <Boolean> = (	self subclassResponsibility)|| f <[^Boolean]> ^ <Boolean> = (	"Synonym for or:"	self subclassResponsibility)'utility'onFalse: blk <[^Object]> ^ <Boolean> = (	"Like onTrue:, but evaluates block when false."	self subclassResponsibility)onTrue: blk <[^Object]>  ^<Boolean> = (	"Like ifTrue: except that the receiver is returned.  This is sometimes useful when an expensive	  side effect is needed based on the result of (a conditional expression whose	  result must be returned or preserved), and where factoring out parts of the conditional expression	  would obfusticate the control flow.   Example:  				^<john can run a marathon>						onTrue: [ <john, run marathon> ] 	  is prettier (some think) than any of the alternatives:		1) 	^<john can run a marathon>						ifTrue: [ <john, run marathon>.									  true ]						ifFalse: [ false ]		2)		| result <Boolean> |				result :=  <john can run a marathon>.				result					ifTrue: [ <john, run marathon> ].				^result		3)		^<john can run a marathon> and: [ <john, run marathon>.  true ]	  "	self subclassResponsibility))class Association = ("Associates an object of type K with an object of type V."|	protected key <K> ::= nil.	protected value <V> ::= nil.|)('as yet unclassified'copy = (	^class key: key value: value)'accessing'at1 ^<K> = (	^key)at1: k <K> = (	key:: k)at2 ^<V> = (	^value)at2: v <V> = (	value:: v)key: k <K> value: v <V> = (	key:: k.	value:: v.)'comparing'= other <Object> ^<Boolean> = (	"| othera <Assoc[Object,Object]> |"	"%todo: replace Association with Assoc when typecase is fully impl"	"othera:: Association[Object,Object] coerce: other else: [ ^false ]."	^key = other key and: [ value = other value ].)hash ^<Int> = (	^key hash bitXor: value hash)'printing'printOn: strm <CharOutputStream> = (	key printOn: strm.	strm nextPutAll: ' -> '.	value printOn: strm.)) : ('as yet unclassified'key: k <K> value: v <V> ^<Instance> = (	^new key: k value: v))class True = Boolean (""||)('as yet unclassified'asAlien ^ <Integer> = (	^1)'utility'onFalse: blk <[^Object]> ^ <Boolean> = (	^self)onTrue: blk <[^Object]> ^ <Boolean> = (	blk value.	^self)'control'&& f <[^Boolean]> ^ <Boolean> = (	^f value)and: f <[^Boolean]>	 ^ <Boolean> = (	^f value)ifFalse: then <[]> ^ <Object> = (	^nil)ifFalse: then <[^X def]> ifTrue: else <[^Y def]> ^ <X|Y> = (	^else value)ifTrue: then <[]> ^<Object> = (	^then value)ifTrue: then <[^X def]> ifFalse: else <[^Y def]> ^ <X|Y> = (	^then value)or: f <[^Boolean]> ^ <Boolean> = (	^true)|| f <[^Boolean]>^ <Boolean> = (	^true)'operations'& other <Boolean> ^ <Boolean> = (	^other)not ^ <Boolean> = (	^false)| other <Boolean> ^ <Boolean> = (	^true)'printing'printOn: strm <CharOutputStream> = (	strm nextPutAll: 'true'))class False = Boolean (""||)('as yet unclassified'asAlien ^ <Integer> = (	^0)'utility'onFalse: blk <[^Object]> ^ <Boolean> = (	blk value.	^self)onTrue: blk <[^Object]> ^ <Boolean> = (	^self)'control'&& f <[^Boolean]> ^ <Boolean> = (	^false)and: f <[^Boolean]> ^ <Boolean> = (	^false)ifFalse: then <[]> ^ <Object> = (	^then value)ifFalse: then <[^X def]> ifTrue: else <[^Y def]> ^ <X|Y> = (	^then value)ifTrue: then <[]> ^ <Object> = (	^nil)ifTrue: then <[^X def]> ifFalse: else <[^Y def]> ^ <X | Y> = (	^else value)or: f <[^Boolean]> ^ <Boolean> = (	^f value)|| f <[^Boolean]> ^ <Boolean> = (	^f value)'printing'printOn: strm <CharOutputStream> = (	strm nextPutAll: 'false')'operations'& other <Boolean> ^ <Boolean> = (	^false)not ^ <Boolean> = (	^true)| other <Boolean> ^ <Boolean> = (	^other))class NSObject = ("Note: due to an apparent limitation in the implementation of Newspeak, this cannot be named Object.Note2: the superclass should be Top.Class NewspeakObject is the root of the object hierarchy in the Newspeak programming language, and provides behavior common to all objects.For each protocol P in the system, this class provides a method 'isP' which answers true if and only if the receiver is an instance of a class which implements the protocol P.Discussion:Unlike other systems inspired by Smalltalk, the number of methods in this class is deliberately kept to a minimum. Behavior should only be provided by this class if it should be considered part of the core set of features available to *all* Newspeak programmers.The security model of the Newspeak programming language is based on capabilities and it is essential that capabilities cannot leak through behavior provided by this class. For example, this class provides no mechanism for accessing instance variables of its instances. Instead such capabilities are provided to the debugger and other tools through mirror based reflection modules."||)('as yet unclassified'subclassResponsibility = (	self Error signal: 'My subclass should have overridden ', thisContext sender selector printString)'newspeak requirement'Array ^<Array class> = (	"Answers the class Array or a compatible object.	May be overridden in subclasses."	^HostArray)ByteArray ^<ByteArray class> = (	"Answers the class ByteArray or a compatible object.	May be overridden in subclasses."	^HostByteArray)Character ^<Character class> = (	"Answers the class Character or a compatible object.	May be overridden in subclasses."	^HostCharacter)Error ^<Error class> = (	"Answers the class Character or a compatible object.	May be overridden in subclasses."	^HostError)Float ^<Error class> = (	"Answers the class Float or a compatible object.	May be overridden in subclasses."	^HostFloat)Integer ^<Integer class> = (	"Answers the class Integer or a compatible object.	May be overridden in subclasses."	^HostInteger)Object ^<Object class> = (	"Answers the class Object or a compatible object.	May be overridden in subclasses."	^NSObject)String ^<String class> = (	"Answers the class String or a compatible object.	May be overridden in subclasses."	^HostString)Symbol ^<Symbol class> = (	"Answers the class Symbol or a compatible object.	May be overridden in subclasses."	^HostSymbol)'comparing'= other ^<Boolean> = (	"Answers true if the receiver is considered equal to 'other'.	May be overridden by subclasses, and should be overridden if the method 'hash' is overridden.	This method must implement an equivalence relation, that is, the following must hold:	* x = x evaluates to true	* if x = y evaluates to true then y = x must evaluate to true	* if x = y evaluates to true and y = z evaluates to true then x = z must evaluate to true.	Furthermore, this method must be consistent with the implementation of hash, that is:	* if x = y evaluates to true then x hash = y hash must evaluate to true."	^self == other)== other ^<Boolean> = (	"Answers true if the receiver is the same object as 'other'.	Should not be overridden by subclasses."	^vmMirror is: self identicalTo: other)hash ^<Integer> = (	"Answers the hash code for the receiver.	May be overridden by subclasses, and should be overridden if the method '=' is overridden.	The hash code must obey the requirements set forth in the method '=', that is, the following must hold:	* if x = y evaluates to true then x hash = y hash must evaluate to true."	^identityHash)identityHash = (	^vmMirror identityHashOf: self)'accessing'class = (	^vmMirror classOf: self)yourself = ()'printing'printOn: s <WriteStream> ^<self> = (	"Prints a representation of the receiver on the given stream.	The printed representation is for debugging purposes only and should not be relied on for any other purpose whatsoever.	May be overridden in subclasses."	s		nextPutAll: self class name;		nextPut: $#;		nextPutAll: identityHash printString)printString ^<String> = (	"Returns a printed representation of the receiver.	The printed representation is for debugging purposes only and should not be relied on for any other purpose whatsoever.	May be overridden in subclasses."	^String streamContents: [ :s | printOn: s])'protected'assert: condition <[^Boolean]> message: message = (	"Raises an error with the given message if and only if condition evaluates to false."	condition isBlock ifFalse: [self Error signal: 'Block required'].	condition value ifFalse: [self Error signalAssertionFailure: message])clone = (	^vmMirror clone: self.)'message not understood'doesNotUnderstand: msg <Message> = (	"Sent by the underlying system if an attempt was made to send a message to the receiver that it does not understand, that is, implement.	May be overriden in subclasses."	| sel |	sel:: msg selector.	(sel isUnary		and: [sel size > 2		and: [(sel at: 1) = $i		and: [(sel at: 2) = $s		and: [(sel at: 3) isUppercase]]]]) ifTrue: [ | m |		"sel looks like 'isP' where P is a protocol.		Add default implementation of sel returning false."		"The following construct the method: 'isP ^false'"		(m:: CompiledMethod newMethod: 4 header: 1282)			"objectAt: 1 is the header"			objectAt: 2 put: (MethodProperties new selector: sel);			objectAt: 3 put: (HostAssociation key: class name value class).		"The four bytes of the method are zero which means no source."		class addSelectorSilently: msg selector withMethod: m.		^msg sentTo: self].	Error signalMessageNotUnderstoood: msg receiver: self.	^msg sentTo: self)'testing'isImmutable = (	^vmMirror isImmutable: self))class UndefinedObject = ("This class generally has one instance: nil.Tags: %BlueBook(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.1 $"||)('testing'isNil ^<Boolean> = (	^true)notNil ^<Boolean> = (	^false)'printing'printOn: strm <CharOutputStream> = (	strm putAll: 'nil')'comparing'= other <Object> ^<Boolean> = (	^other isNil)'copying'copy ^<Instance> = (	self messageNotUnderstood: 		(self "Message" receiver: self selector: #copy arguments: nil "empty array")))'as yet unclassified'MutableString = (	"Strings and MutableStrings are different when running on Javascript, but on Squeak they are the same."	^String))