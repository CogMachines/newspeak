Newspeak3
'NSKernel'
class Kernel usingPlatform: p vmMirror: vmm = NewspeakObject (
"N.B.: This code is not live in the system.  true, false and nil are not instances of the True, False and UndefinedObject defined here.  NSObject is not the root of the class hierarchy.

This code was derived in part by converting the Strongtalk Magnitude, Boolean and  UndefinedObject classes to Newspeak. For those classes, the Sun Microsystems copyright and BSD license below applies.

Copyright 2008 Cadence Design Systems, Inc.
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0

Copyright (c) 1995-2006 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
Copyright 2008-2009 David Pennell, Stephen Pair, Gilad Bracha and other contributors.
Copyright 2011 Ryan Macnak

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, 
 this  list of conditions and the following disclaimer.

* Redistribution in binary form must reproduce the above copyright notice, 
this list of conditions and the following disclaimer in the documentation and/o other materials provided with the distribution.

Neither the name of Sun Microsystems or the names of contributors may 
be used to endorse or promote products derived from this software without 
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS 
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGE.


Some experiments in class/mixin representation by Newspeak classes.

A more direct representation for mixins that does not require a VM or compiler change.  Relies on slots being represented in an object in the order they are defined. Adoption would involve changes to AtomicInstaller and mirrors. Simplifies enforcing immutable slots (which would need a compiler change).

A clone of the Behavior heirarchy that lacks slots unused by Newspeak.  Relies on instance initializers not conflicting with instance methods, in particular #new, which is why this is in NS3.

The alternative represenation would also save space:

[Mixin applications] Class + Metaclass: 14 + 8 -> 8 + 7
[Mixins] 
	DefiningClass + DefiningClassMetadata: 14 + 12 -> Mixin: 11
	DefiningMetaclass: 8 -> ClassMixin: 4"|
	Map = p Dictionary.
	WeakSet = p WeakSet.
	IdentitySet = p IdentitySet.
	MethodDictionary = p MethodDictionary.
	Language = p Language. 
	MessageNotUnderstood = p MessageNotUnderstood.
	platform = p.
	
	vmmirror = vmm.
	GetterPool = p Mixin getterPool.
	SetterPool = p Mixin setterPool.
	"N.B.: These pools contain anonymous methods: methods whose selector doesn't match the selectors which are their keys in method dictionaries. It is important that Cog can identify these methods as anonymous because it effects the mechanics of unlinking send sites. Anonymous methods are identified by having a nil method class association. So do not change the method class association of these methods!"
	
	ImplementationBase = p ImplementationBase.
	ArraySlot = Array.
	ByteArraySlot = ByteArray.
	CharacterSlot = Character.
	ErrorSlot = Error.
	FloatSlot = Float.
	IntegerSlot = Integer.
	ObjectSlot = Object.
	StringSlot = String.
	SymbolSlot = Symbol.
|)
(
class Association = (
"Associates an object of type K with an object of type V.
"|
	protected key <K> ::= nil.
	protected value <V> ::= nil.
|)
('accessing'
at1: k <K> = (
	key:: k
)
at2 ^<V> = (
	^value
)
at2: v <V> = (
	value:: v
)
key: k <K> value: v <V> = (
	key:: k.
	value:: v.
)'as yet unclassified'
copy = (
	^class key: key value: value
)'comparing'
= other <Object> ^<Boolean> = (
	"| othera <Assoc[Object,Object]> |"
	"%todo: replace Association with Assoc when typecase is fully impl"
	"othera:: Association[Object,Object] coerce: other else: [ ^false ]."
	^key = other key and: [ value = other value ].
)
hash ^<Int> = (
	^key hash bitXor: value hash
)'printing'
printOn: strm <CharOutputStream> = (
	key printOn: strm.
	strm nextPutAll: ' -> '.
	value printOn: strm.
)) : ('as yet unclassified'
key: k <K> value: v <V> ^<Instance> = (
	^new key: k value: v
))
class Behavior = (
"My instances describe the behavior of other objects. I provide the minimum state necessary for creating and running instances. Most objects are created as instances of the more fully supported subclass, Class, but I am a good starting point for providing instance-specific behavior (as in Metaclass)."|
	superclass <Behavior | nil> "Must be slot 1; known to VM"
	methodDict <MethodDictionary> "Must be slot 2; known to VM"
	format <SmallInteger> "Must be slot 3; known to VM"
	mixinSlot <Mixin | nil> "Must be slot 4; known to VM"
	enclosingObjectSlot <Behavior | nil> "Must be slot 5; known to VM"
|)
('accessing'
inheritsFrom: aClass  = (
	"Answer whether the argument, aClass, is on the receiver's superclass 
	chain."

	| aSuperclass |
	aSuperclass:: superclass.
	[aSuperclass == nil]
		whileFalse: 
			[aSuperclass == aClass ifTrue: [^true].
			aSuperclass:: aSuperclass superclass].
	^false
)
language = (
	^mixinSlot language
)
name = (
	^'someBehavior'	
)
simpleName = (
	^mixin simpleName
)'as yet unclassified'
allInstancesDo: aBlock = (
	"Evaluate the argument, aBlock, for each of the current instances of the 
	receiver.
	
	Because aBlock might change the class of inst (for example, using become:),
	it is essential to compute next before aBlock value: inst."
	| inst next |
	inst: self someInstance.
	[inst == nil]
		whileFalse:
		[
		next: inst nextInstance.
		aBlock value: inst.
		inst: next]
)
allSubclassesDo: aBlock = (
	"Evaluate the argument, aBlock, for each of the receiver's subclasses."

	self subclassesDo: 
		[:cl | 
		aBlock value: cl.
		cl allSubclassesDo: aBlock]
)
allSubclassesDoGently: block = (
	self allSubclassesDo: block
)
canUnderstand: selector = (
	"Answer whether the receiver can respond to the message whose selector 
	is the argument. The selector can be in the method dictionary of the 
	receiver's class or any of its superclasses."

	(self includesSelector: selector) ifTrue: [^true].
	superclass == nil ifTrue: [^false].
	^superclass canUnderstand: selector
)
includesBehavior: aClass = (
	^self == aClass or:[self inheritsFrom: aClass]
)
includesSelector: sel <Symbol> ^<Boolean> = (
	"Answer whether the message whose selector is the argument is in the 
	method dictionary of the receiver's class."

	^ self methodDict includesKey: sel 
)
methodDictionary = (
	^methodDict
)
selectorsAndMethodsDo: selectorAndMethodBlock = (
	"Evaluate the two argument selectorAndMethodBlock for all the selector/method pairs in my method dictionary."

	^ self methodDict keysAndValuesDo: selectorAndMethodBlock
)
someInstance = (
	^vmmirror firstInstanceOf: self ifNone: [nil]
)
thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte = (
	"Answer a set of selectors whose methods access the argument as a 
	literal. Dives into the compact literal notation, making it slow but 
	thorough "

	| who |
	who: IdentitySet new.
	self selectorsAndMethodsDo:
		[:sel :method |
		((method hasLiteralThorough: literal) or: [specialFlag and: [method scanFor: specialByte]])
			ifTrue:
				[((literal isVariableBinding) not
					or: [method literals allButLast includes: literal])
						ifTrue: [who add: sel]]].
	^ who
)
whichSelectorsReferTo: literal special: specialFlag byte: specialByte = (
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |
	who: IdentitySet new.
	self selectorsAndMethodsDo: 
		[:sel :method |
		((method hasLiteral: literal) or: [specialFlag and: [method scanFor: specialByte]])
			ifTrue:
				[((literal isVariableBinding) not
					or: [method literals allButLast includes: literal])
						ifTrue: [who add: sel]]].
	^ who
)'initialize-release'
superclass: sc methodDictionary: md format: fmt = (
	superclass: sc.
	methodDict: md.
	format: fmt.
)'instance creation'
basicNew = (
	"<primitive: 70>"
	^vmmirror instaniateFixedClass: self ifFail: [self halt]
)
basicNew: sizeRequested = (
	"<primitive: 71>"
	^vmmirror instaniateVariableClass: self withSize: sizeRequested ifFail: [self halt]
)
new = (
	^self basicNew
)
new: sizeRequested = (
	^self basicNew: sizeRequested
)'testing'
instSize = (
	"Answer the number of named instance variables
	(as opposed to indexed variables) of the receiver."

	self flag: #instSizeChange.  "Smalltalk browseAllCallsOn: #instSizeChange"
"
	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.
	When we revise the image format, it should become...
	^ ((format bitShift: -1) bitAnd: 16rFF) - 1
	Note also that every other method in this category will require
	2 bits more of right shift after the change.
"
	^ ((format bitShift: -10) bitAnd: 16rC0) + ((format bitShift: -1) bitAnd: 16r3F) - 1
)
instSpec = (
	^ (format bitShift: -7) bitAnd: 16rF
)
isBehavior = (
	"Return true if the receiver is a behavior"
	^true
)
isBits = (
	"Answer whether the receiver contains just bits (not pointers)."

	^ self instSpec >= 6
)
isBytes = (
	"Answer whether the receiver has 8-bit instance variables."

	^ self instSpec >= 8
)
isFixed = (
	"Answer whether the receiver does not have a variable (indexable) part."

	^self isVariable not
)
isMeta = (
	^ false
)
isMixinApplication = (
	^true "All instances of this Behavior class are.  Squeak Behaviors are not."
)
isPointers = (
	"Answer whether the receiver contains just pointers (not bits)."

	^self isBits not
)
isVariable = (
	"Answer whether the receiver has indexable variables."

	^ self instSpec >= 2
)
isWeak = (
	"Answer whether the receiver has contains weak references."
	^ self instSpec = 4
)
isWords = (
	"Answer whether the receiver has 16-bit instance variables."
	^self isBytes not
))
class Boolean = Value (self error: 'You may not create any more Booleans - this is two-valued logic')
('as yet unclassified'
asAlien ^ <Integer> = (

	"Convert to C boolean representation"

	self subclassResponsibility
)'control'
&& f <[^Boolean]>	^ <Boolean> = (

	"Synonym for and:"

	self subclassResponsibility
)
and: f <[^Boolean]>	 ^ <Boolean> = (

	self subclassResponsibility
)
ifFalse: then <[]> ^ <Object> = (

	self subclassResponsibility
)
ifFalse: then <[^X def]> ifTrue: else <[^Y def]> ^ <X|Y> = (

	self subclassResponsibility
)
ifTrue: then <[]> ^ <Object> = (

	self subclassResponsibility
)
ifTrue: then <[^X def]> ifFalse: else <[^Y def]> ^ <X|Y> = (

	self subclassResponsibility
)
or: f <[^Boolean]>	^ <Boolean> = (

	self subclassResponsibility
)
|| f <[^Boolean]> ^ <Boolean> = (

	"Synonym for or:"

	self subclassResponsibility
)'operations'
& other <Boolean>^ <Boolean> = (

	"and"

	self subclassResponsibility
)
not ^ <Boolean> = (


	self subclassResponsibility
)
xor: other <Boolean> ^ <Boolean> = (

	"exclusive-or"

	^self ~~ other
)
| other <Boolean> ^ <Boolean> = (

	"or"

	self subclassResponsibility
)'testing'
isBoolean ^<Boolean> = (
	^true
)'utility'
onFalse: blk <[^Object]> ^ <Boolean> = (

	"Like onTrue:, but evaluates block when false."

	self subclassResponsibility
)
onTrue: blk <[^Object]>  ^<Boolean> = (

	"Like ifTrue: except that the receiver is returned.  This is sometimes useful when an expensive
	  side effect is needed based on the result of (a conditional expression whose
	  result must be returned or preserved), and where factoring out parts of the conditional expression
	  would obfusticate the control flow.   Example:  

				^<john can run a marathon>
						onTrue: [ <john, run marathon> ] 

	  is prettier (some think) than any of the alternatives:

		1) 	^<john can run a marathon>
						ifTrue: [ <john, run marathon>.
									  true ]
						ifFalse: [ false ]

		2)		| result <Boolean> |
				result :=  <john can run a marathon>.
				result
					ifTrue: [ <john, run marathon> ].
				^result

		3)		^<john can run a marathon> and: [ <john, run marathon>.  true ]
	  "

	self subclassResponsibility
))
class Class = ClassDescription (
"My instances describe the representation and behavior of objects.  Except for Top, my instances are the result of mixin applications.

The slot 'subclasses' is a redundant structure.  It is never used during execution, but is used by the development system to simplify or speed certain operations."|
	subclassesSlot <WeakSet>
	nameSlot <Symbol> "N.B.: This must not be called name.  Otherwise its setter will conflict classes such as CLibrary that have #name: as their primary factory."
	"classPool
	sharedPools
	environment -- global namespace crap"
	"category This shouldn't be a property of a Class.  This only makes sense for a top level Class, and even then the relationship between a Class and its namespace shouldn't be bidirectional."
	"metadata Metadata is a property of the mixin, no?"
|)
('as yet unclassified'
addSubclass: subclass = (

	self assert: [subclass superclass == self] message: 'Not my subclass!'.

	subclassesSlot == nil ifTrue: [subclassesSlot: WeakSet new].
	
	subclassesSlot add: subclass.
)
basicCategory = (
	^mixin category
)
category = (
	^mixin category
)
category: newCategory = (
	#BOGUS.
	#WARN.
)
isMeta = (
	^false
)
mixin = (
	^self mixinSlot
)
mixinApply: superklass = (
	| application |
	application:: self mixin apply: superklass.
	"application instVarAt:  5 put: (self instVarAt: 5).
	application class instVarAt:  5 put: (self class instVarAt: 5)."
	application setEnclosingObjectSlot: self enclosingObjectSlot.
	^application
)
name = (
	^self nameSlot
)
setEnclosingObjectSlot: e = (
	enclosingObjectSlot: e.
	self class setEnclosingObjectSlot: e.
)
setName: n = (
	self nameSlot: n
)
subclasses= (
	^subclassesSlot ifNil: [{}]
)
subclassesDo: aBlock = (
	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."

	subclasses == nil  ifFalse: [ subclasses do: aBlock ].
)
theMetaClass = (
	^self class
)
theNonMetaClass = (
	^self
))
class ClassDescription = Behavior (
"Describe the class in this comment."|
	"instanceVariables"
	"organization"
|)
('as yet unclassified'
allInstVarNames = (
	"Answer an Array of the names of the receiver's instance variables. The 
	Array ordering is the order in which the variables are stored and 
	accessed by the interpreter."

	| vars |
	superclass == nil
		ifTrue: [vars:: self instVarNames copy]	"Guarantee a copy is answered."
		ifFalse: [vars:: superclass allInstVarNames , self instVarNames].
	^vars
)
instVarIndexFor: instVarName = (
	"Answer the index of the named instance variable."

	| index |
	index:: mixin instVarNames == nil
		ifTrue: [0]
		ifFalse: [mixin instVarNames indexOf: instVarName].
	index == 0 ifTrue: 
		[^superclass == nil 
			ifTrue: [0]
			ifFalse: [superclass instVarIndexFor: instVarName]].
	^superclass == nil 	
		ifTrue: [index]
		ifFalse: [index + superclass instSize]
)
instVarNames = (
	^mixin == nil
		ifTrue: [{} "Top"] 
		ifFalse: [mixin instVarNames]
)
organization = (
	^mixin organization 
)
printOn: stm = (
	stm nextPutAll: self name
)
setInstVarNames: instVarArray = (
"	| required |
	required:: self instSize.
	superclass notNil ifTrue:[required:: required - superclass instSize].
	instVarArray size = required
		ifFalse:[^self error: required printString, ' instvar names are required'].
	instVarArray isEmpty
		ifTrue:[instanceVariables:: nil]
		ifFalse:[instanceVariables:: instVarArray asArray]."
))
class ClassMixin = (
"The mixin for a metaclass.  Is ClassMixin or Metamixin a less confusing name?"|
	organization <ClassOrganizer>
	methodDictionary <MethodDictionary> "must be slot 2; known to VM"
	instanceMixin <Mixin>
	enclosingMixin <Mixin> "must be slot 4; known to VM"
|)
('as yet unclassified'
compiledMethodAt: selector <Symbol> ^<CompiledMethod> = (
	^ self methodDictionary at: selector
)
definingClass = (
	^self
)
enclosingClass = (
	#BOGUS. "Used by syntax highlighter, at least"
	^self enclosingMixin
)
instVarNames = (
	^Array new
)
isMeta ^<Boolean> = (
	^true
)
isMixin ^<Boolean> = (
	^true
)
language = (
	^instanceMixin language
)
methodDict = (
	^methodDictionary
)
mixin = (
	^self
)
name = (
	^instanceMixin name , ' class'
)
printCategoryChunk: cat on: aFileStream priorMethod: priorMethod = (
	
)
printOn: stm = (
	stm nextPutAll: name , ' mixin'
)
simpleName = (
	^name
)
theMetaClass = (
	^self
)
theNonMetaClass = (
	^instanceMixin
))
class False = Boolean ()
('as yet unclassified'
asAlien ^ <Integer> = (
	^0
)'control'
&& f <[^Boolean]> ^ <Boolean> = (
	^false
)
and: f <[^Boolean]> ^ <Boolean> = (
	^false
)
ifFalse: then <[]> ^ <Object> = (
	^then value
)
ifFalse: then <[^X def]> ifTrue: else <[^Y def]> ^ <X|Y> = (
	^then value
)
ifTrue: then <[]> ^ <Object> = (
	^nil
)
ifTrue: then <[^X def]> ifFalse: else <[^Y def]> ^ <X | Y> = (
	^else value
)
or: f <[^Boolean]> ^ <Boolean> = (
	^f value
)
|| f <[^Boolean]> ^ <Boolean> = (
	^f value
)'operations'
& other <Boolean> ^ <Boolean> = (
	^false
)
not ^ <Boolean> = (
	^true
)
| other <Boolean> ^ <Boolean> = (
	^other
)'printing'
printOn: strm <CharOutputStream>
 = (
	strm nextPutAll: 'false'
)'utility'
onFalse: blk <[^Object]> ^ <Boolean> = (
	blk value.
	^self
)
onTrue: blk <[^Object]> ^ <Boolean> = (
	^self
))
class Magnitude = (
"A Magnitude[M] is an object that has a linear relationship with objects of type M, such
that they can be compared using the relational operations <,>,<=,>=.

%note: The derived operations are carefully defined to use <
    and not = for the following reasons:
        - speed
        - use of = may be bad for subclasses with a problematic definition of =,
          such as floating point numbers.
"|
|)
('comparing'
< other <M> ^<Boolean> = (


	self subclassResponsibility
)
<= other <M> ^<Boolean> = (


	"%todo: when using inherited types, use the original definition:
		^(other < self) not
	"
	^self < other or: [ self = other ]
)
> other <M> ^<Boolean> = (


	"%todo: for inherited types use:
		^other < self
	"
	^(self <= other) not
)
>= other <M> ^<Boolean> = (


	^(self < other) not
)
between: min <M> and: max <M> ^<Boolean> = (

	"test whether the receiver is in the range min -> max, inclusive"

	"test the max case first since end of range overflow is generally more common"
	^self <= max and: [ self >= min ]
)
compare: other <M>  ^<Int> = (

	"Returns -1 if self < other, 0 if self = other, or 1 if self > other"

	^self < other
		ifTrue: [ -1 ]
		ifFalse: [ self > other
							ifTrue: [ 1 ] ifFalse: [ 0 ]  ]
)
max: other <ARG> ^<Self | ARG> = (
		"{where X is arg 1 of #< message of receiverType;
			where ARG <X> is arg 1}"

	"The guaranteed is safe because of the inference clause"
	^self > ("guaranteed <M>:\" other)
		ifTrue: [ self ]
		ifFalse: [ other ]
)
min: other <ARG> ^<Self | ARG> = (
		"{where X is arg 1 of #< message of receiverType;
			where ARG <X> is arg 1}"

	"The guaranteed is safe because of the inference clause"
	^self < ("guaranteed <M>" other)
		ifTrue: [ self ]
		ifFalse: [ other ]
)) : ('utility'
defaultSort ^<[X,M, ^Boolean]> = (
	"{where X is returnType of #new message of receiverType}"
	"return a sort predicate suitable for a sorted collection of M"

	"The guarantee is safe because of the inference clause"
	^"guaranteed <[X,M,^Boolean]>"
		[ :m1 <Magnitude[M]> :m2 <M> | m1 <= m2 ]
))
class Metaclass = ClassDescription (
"Each class is an instance of a unique metaclass. All metaclasses are instances
of Metaclass, and are direct subclasses of Class. This differs from Smalltalk, where the metaclass would be a subclass of the metaclass of the class's superclass."|
	private thisClass <Instance>
|)
('as yet unclassified'
isMeta = (
	^true
)
mixin ^<ClassMixin> = (
	^self mixinSlot
)
name = (
	thisClass == nil
		ifTrue: [^'a Metaclass']
		ifFalse: [^thisClass name , ' class']
)
new = (
	"The receiver can only have one instance. Create it or complain that
	one already exists."

	thisClass class == self
		ifTrue: [self error: 'A Metaclass should only have one instance!']
		ifFalse: [thisClass: self basicNew. ^thisClass]
)
setEnclosingObjectSlot: e = (
	enclosingObjectSlot: e
)
subclassesDo: aBlock = (
	"Evaluate aBlock for each of the receiver's immediate subclasses."
	thisClass subclassesDo:[:aSubclass|
		"The following test is for Class class which has to exclude
		the Metaclasses being subclasses of Class."
		aSubclass isMeta ifFalse:[aBlock value: aSubclass class]].
)
theMetaClass = (
	^self
)
theNonMetaClass = (
	^thisClass
))
class Mixin = (
"A mixin is the difference between a class and its superclass: a set of additional methods, slots and nested class declarations.  Newspeak class declarations implicitly define an instance-side mixin and a class-side mixin, and Newspeak classes (other than Top) are all mixin applications.

All of my members except methods to invoke mixin application should be hidden, and be only accessible by mirrors."|
name <Symbol>
methodDictionary <MethodDictionary> "must be slot 2; known to VM"
slots <List[{Symbol.Boolean}]> "name->mutable?"
enclosingMixin <Mixin | nil> "must be slot 4; known to VM"
nestedMixins <Map[Symbol,Mixin]> = Map new. "must be called nestedMixins; known to compiler"
applications <WeakSet> = WeakSet new.
classMixin <MetaMixin>
cachedHeaderSource <String>
cachedConstructorName <Symbol>
category <Symbol> = #Uncategorized.
organization <ClassOrganizer> "Yuck"
|)
('accessing'
apply: superclass <Class> ^<Class> = (
	^self perform: #|> with: superclass
)
apply: superclassArg <Class> withName: n <String> ^ <Class> = (

	| superclass <Class> invocation <Class> offset <Integer>  |

	superclass:: superclassArg yourself. "Extract real object from potential Delay"
 
	#BOGUS yourself. "Use named supplied as arg"
	invocation:: self invokeWithSuperclass: superclass withName: n.
	"invocation basicCategory: #'Irrelevant-Mixin-applications'."

	offset:: superclass instSize.
	offset ~= 0 ifTrue:[self generateAccessorsFor: invocation offset: offset].

	applications add: invocation.
	^invocation
)'as yet unclassified'
canUnderstand: sel = (
	^methodDictionary includesKey: sel
)
classComment = (
	
	^(Language newspeak3 parserInstance classHeader 
		parse: cachedHeaderSource readStream) classComment
)
classVarNames = (
	^{}
)
compiledMethodAt: selector <Symbol> ^<CompiledMethod> = (
	^ self methodDictionary at: selector
)
constructorName = (
	^cachedConstructorName
)
definingClass = (
	^self
)
definingModule = (
	^enclosingMixin isNil ifTrue: [self] ifFalse: [enclosingMixin definingModule]
)
enclosingClass = (
	#BOGUS. "Used by syntax highlighter, at least"
	^self enclosingMixin
)
format: nInstVars <Integer> variable: isVar <Boolean> words: isWords <Boolean> pointers: isPointers <Boolean> weak: isWeak <Boolean> ^ <Integer> = (
	"This method was derived from the same method in ClassBuilder, and
	somwewhat cleaned up
	
	Compute the format for the given instance specification.
	nInstVars - the number of named inst vars (e.g. Point's x,y => nInstVars = 2).
	isVar  true if indexable inst vars.
	isWords  true for bit objects not organized as bytes (Float wpould you believe)
	isPointers  true for pointer objects (except CompiledMethod) false otherwise
	isWeak, true if indexable, named weak collection
	"
	| cClass instSpec sizeHiBits fmt |
"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize. The format word is...
		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>"
	sizeHiBits:: (nInstVars+1) // 64.
	cClass:: 0.  "for now"
	instSpec:: isWeak
		ifTrue:[4]
		ifFalse:[isPointers
				ifTrue: [isVar
						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]
						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]
				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].
	fmt:: sizeHiBits.
	fmt:: (fmt bitShift: 5) + cClass.
	fmt:: (fmt bitShift: 4) + instSpec.
	fmt:: (fmt bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"
	fmt:: (fmt bitShift: 1). "This shift plus integer bit lets wordSize work like byteSize"
	^fmt
)
generateAccessorsFor: invocation <Class> offset: offset <Integer> = (
	| ivs <Collection[String]> mtds <MethodDictionary> |
	ivs:: invocation instVarNames.
	mtds:: invocation methodDict.
	(offset +1  to: offset + ivs size) with: ivs do:[:n <Integer> :iv <String> |
		mtds at:iv asSymbol put: (GetterPool at: n).
		mtds at: (iv, ':') asSymbol put: (SetterPool at: n).
		
		#BOGUS yourself.
		"If immutable slot, add name mangled setter.  Remove existing setter (copied from the mixin) or replace with one that raises an exception."
	]
)
instVarAt: n = (
	n = 14 ifTrue: [^self]. "compiler compatability"
	^super instVarAt: n
)
instVarNames = (
	^(slots collect: [:pair | pair first]) asArray
)
invokeWithSuperclass: superclass <Class> withName: n  <String> ^<Class> = (

	| fmt <Integer> newMeta <Metaclass> newClass <Class> env |

	newMeta:: Metaclass new.
	newMeta 
		superclass: Class
		methodDictionary: classMixin methodDictionary copy
		format: Class format.

	"newMeta setInstVarNames: {}."
	newClass:: newMeta new.
	fmt:: self pointerFormatNumberOfInstVars: superclass instSize + slots size .
	newClass
		superclass: superclass
		methodDictionary: methodDictionary copy
		format: fmt.
	newClass setInstVarNames: instVarNames.
	newClass setName: n.
	
	newClass mixinSlot: self.
	newMeta mixinSlot: self classMixin.
	
	applications add: newClass.
	superclass addSubclass: newClass.
	
	^newClass
)
isMeta ^<Boolean> = (
	^false
)
isMixin ^<Boolean> = (
	^true
)
language = (
	^Language newspeak3
)
languageData = (
	^cachedHeaderSource
)
methodDict = (
	^methodDictionary
)
mixin = (
	^self
)
nestedClasses = (
	^nestedMixins values
)
pointerFormatNumberOfInstVars: n <Integer> ^ <Integer> = (
	^self format: n variable: false words: false pointers: true weak: false
)
printCategoryChunk: cat on: aFileStream priorMethod: priorMethod = (
	
)
printClassOn: stm = (

	stm nextPutAll: 'class '.
	stm nextPutAll: cachedHeaderSource.

	stm cr; nextPut: $(.
	nestedMixins values do: [:ea | stm cr. ea printClassOn: stm].
	writeOrganizationOf: self on: stm.
	stm nextPut: $).

	stm nextPutAll: ' : ('; cr.
	writeOrganizationOf: classMixin on: stm.
	stm nextPut: $).
)
printOn: stm = (
	stm nextPutAll: name , ' mixin'
)
sharedPools = (
	^{}
)
simpleName = (
	^(name subStrings: {$`}) last asSymbol
)
superclass = (
	^Object
)
theMetaClass = (
	^classMixin
)
theNonMetaClass = (
	^self
)
traitComposition = (
	^{}
)
writeOrganizationOf: mxn on: aStream = (
	| org <ClassOrganizer> |
	org:: mxn organization.

	(org elementArray isEmpty and:
		[ (org categories copyWithout: org class nullCategory) isEmpty]) ifTrue: [^self].

	org categories do:
		[ :cat | | sels |
		aStream  nextPut:$'; nextPutAll: cat;  nextPut:$'; cr.
		sels:: org listAtCategoryNamed: cat.
		sels do: [ :sel | aStream nextPutAll: (mxn compiledMethodAt: sel) getSource; cr; cr ]]
)
|> superclass <Class> ^<Class> = (
	^self apply: superclass withName: (self simpleName, 'mixin |>', superclass name)
))
class Object = ImplementationBase (
"Object is the root of the object hierarchy in the Newspeak programming language, and provides behavior common to all objects.  The superclass of Object is the empty class Top.  The purpose of Top is to allow all code to live in mixins.

For each protocol P in the system, this class provides a method 'isP' which answers true if and only if the receiver is an instance of a class which implements the protocol P.

Unlike other systems inspired by Smalltalk, the number of methods in this class is deliberately kept to a minimum. Behavior should only be provided by this class if it should be considered part of the core set of features available to *all* Newspeak programmers.

The security model of the Newspeak programming language is based on capabilities and it is essential that capabilities cannot leak through behavior provided by this class. For example, this class provides no mechanism for accessing instance variables of its instances. Instead such capabilities are provided to the debugger and other tools through mirror based reflection modules.

Object has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes."|
|)
('accessing'
class = (
	"Answers the class of the receiver.
	Should not be overriden by subclasses."
	^vmmirror classOf: self
)
yourself = (
	^self
)'as yet unclassified'
subclassResponsibility = (
	self Error signal: 'My subclass should have overridden ', thisContext sender selector printString
)'comparing'
= other <Object> ^<Boolean> = (
	"Answers true if the receiver is considered equal to 'other'.
	May be overridden by subclasses, and should be overridden if the method 'hash' is overridden.
	This method must implement an equivalence relation, that is, the following must hold:
	* x = x evaluates to true
	* if x = y evaluates to true then y = x must evaluate to true
	* if x = y evaluates to true and y = z evaluates to true then x = z must evaluate to true.
	Furthermore, this method must be consistent with the implementation of hash, that is:
	* if x = y evaluates to true then x hash = y hash must evaluate to true."
	^self == other
)
== other <Object> ^<Boolean> = (
	"Answers true if the receiver is the same object as 'other'.
	Should not be overridden by subclasses."
	^vmmirror is: self identicalTo: other
)
hash ^<Integer> = (
	"Answers the hash code for the receiver.
	May be overridden by subclasses, and should be overridden if the method '=' is overridden.
	The hash code must obey the requirements set forth in the method '=', that is, the following must hold:
	* if x = y evaluates to true then x hash = y hash must evaluate to true."
	^self identityHash
)
identityHash ^<Integer> = (
	"Answers the identity hash code of the reciever.
	Should not be overriden by subclasses."
	^vmmirror identityHashOf: self
)'message not understood'
doesNotUnderstand: aMessage = (

	| sel |
	sel: aMessage selector.
	sel isUnary ifTrue: [(sel startsWith: 'is') ifTrue: [^false]].

	(sel startsWith: 'initializer`') ifTrue: [ 
		msg setSelector: (sel allButFirst: 12) asSymbol.
		^msg sentTo: self.
	].

	^ MessageNotUnderstood new 
		message: aMessage;
		receiver: self;
		signal
)'newspeak requirement'
Array = (
	^ArraySlot
)
ByteArray = (
	^ByteArraySlot
)
Character = (
	^CharacterSlot
)
Delay = (
	^DelaySlot
)
Error = (
	^ErrorSlot
)
Float = (
	^FloatSlot
)
Integer = (
	^IntegerSlot
)
Object = (
	^ObjectSlot
)
String = (
	^StringSlot
)
Symbol = (
	^SymbolSlot
)'printing'
printOn: s <WriteStream> ^<self> = (
	"Prints a representation of the receiver on the given stream.
	The printed representation is for debugging purposes only and should not be relied on for any other purpose whatsoever.
	May be overridden in subclasses."
	s
		nextPutAll: self class name;
		nextPut: $#;
		nextPutAll: self identityHash printString
)
printString ^<String> = (
	"Returns a printed representation of the receiver.
	The printed representation is for debugging purposes only and should not be relied on for any other purpose whatsoever.
	May be overridden in subclasses."
	^self String streamContents: [ :s | self printOn: s]
)'protected'
assert: condition <[^Boolean]> message: message = (
	"Raises an error with the given message if and only if condition evaluates to false."
	condition isBlock ifFalse: [Error signal: 'Block required'].
	condition value ifFalse: [Error signalAssertionFailure: message]
)
clone = (
	^vmmirror clone: self
)'testing'
isImmutable "^<Boolean>" = (
	"Answer true if and only if the receiver is immutable.
	Should not be overridden in subclasses."
	^vmmirror isImmutable: self
))
class True = Boolean ()
('as yet unclassified'
asAlien ^ <Integer> = (
	^1
)'control'
&& f <[^Boolean]> ^ <Boolean> = (
	^f value
)
and: f <[^Boolean]>	 ^ <Boolean> = (
	^f value
)
ifFalse: then <[]> ^ <Object> = (
	^nil
)
ifFalse: then <[^X def]> ifTrue: else <[^Y def]> ^ <X|Y> = (
	^else value
)
ifTrue: then <[]> ^<Object> = (
	^then value
)
ifTrue: then <[^X def]> ifFalse: else <[^Y def]> ^ <X|Y> = (
	^then value
)
or: f <[^Boolean]> ^ <Boolean> = (
	^true
)
|| f <[^Boolean]>^ <Boolean> = (
	^true
)'operations'
& other <Boolean> ^ <Boolean> = (
	^other
)
not ^ <Boolean> = (
	^false
)
| other <Boolean> ^ <Boolean> = (
	^true
)'printing'
printOn: strm <CharOutputStream>
 = (
	strm nextPutAll: 'true'
)'utility'
onFalse: blk <[^Object]> ^ <Boolean> = (
	^self
)
onTrue: blk <[^Object]> ^ <Boolean> = (
	blk value.
	^self
))
class UndefinedObject = Value ()
('comparing'
= other <Object> ^<Boolean> = (
	^other isNil
)'copying'
copy ^<Instance> = (
	self messageNotUnderstood: 
		(self "Message" receiver: self selector: #copy arguments: nil "empty array")
)'printing'
printOn: strm <CharOutputStream> = (
	strm putAll: 'nil'
)'testing'
isNil ^<Boolean> = (
	^true
)
notNil ^<Boolean> = (
	^false
))
class Value = (
"Some objects cannot change after they are created. They are deeply immutable and known as value objects. A value object is globally unique, in the sense that no other object is equal to it.

An object o is a value object iff, under the assumption that o is a value object, it can be shown that:
-All its slots are immutable and contain value objects.
-Its enclosing objects are all value objects.
-Its class inherits from class Value and does not override its identity method (==).

Examples of such objects are numbers, booleans, characters, literal strings, symbols and module definitions.")
('as yet unclassified'
public copy ^<Instance> = (
	^self
))'as yet unclassified'
MutableString = (
	^String
)
TODO = (
	"
	Behavior heirarchy to use proper factory method initialization.
	
	Mixin/ClassMixin to use proper initialization.
	
	Mark private methods/slots.
	"
))