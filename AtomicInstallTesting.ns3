Newspeak3
'Mirrors-tests'
class AtomicInstallTesting usingPlatform: platform 
      testing: installer
      compiler: c 
      mirrors: ms 
      testFramework: utf = (|
      (*imports*)
      private TestContext = utf TestContext.
      private LowLevelMethodMirror = ms LowLevelMethodMirror.
      private LowLevelMixinMirror = ms LowLevelMixinMirror.
	private CompiledMixinMirror = ms CompiledMixinMirror.
      private InstanceVariableMirror = ms InstanceVariableMirror.
	private ClassDeclarationMirror = ms ClassDeclarationMirror.
	private ClassMirror = ms ClassMirror.

	private Smalltalk = platform blackMarket Smalltalk.
	private Map = platform collections Dictionary.
	private MessageNotUnderstood = platform blackMarket MessageNotUnderstood.

      (*module variables*)
	private ns3Lang = platform blackMarket Language newspeak3.
	private atomicInstaller = installer.
      private newCompiler = c.
      private lowLevelMirrors = ms.
      |)
(
class AtomicInstallTests = TestContext (
(*Tests of atomic installer.*))
('as yet unclassified'
xtestNestedMixinsSuperClassSubclassIsSetAfterDuplicateCompilation = (
	(*Disabled for new mixins and atomic installer. Mixins no longer have a defining class.*)

	(*Addresses a bug in the AtomicInstaller that results in classes representing nested mixins not being registered as subclasses of ProtoObject after repeated compilation.*)
	| classSource testClass mixinClass registered |
	classSource:: 'class TestClassDuplicateCompilation = ()(class Inner = ()(''category''foo = ()))'.

	testClass:: makeClass:  classSource.
	mixinClass:: testClass new Inner mixin definingClass.
	registered:: mixinClass superclass subclasses includes: mixinClass.
	assert: registered description: 'Nested class not registered as subclass of its superclass'.

	testClass:: makeClass:  classSource.
	mixinClass:: testClass new Inner mixin definingClass.
	registered:: mixinClass superclass subclasses includes: mixinClass.
	(*Ensure the class is removed from the system, in case of regression. Not needed once we come up with a proper way to clean up classes created by tests*)
	testClass removeFromSystem.
	(SystemMetadata mixinOf: testClass) removeFromSystem.
	assert: registered description: 'Regression: After being compiled twice, nested class is not registered as subclass of its superclass'.	
)'private'
compileToMixinRep: source <String> ^<MixinRep> = (
	^newCompiler compileClassSource: ('Newspeak3 ''NS2-tests'' ', source) readStream within: nil
)
makeClass: source <String> ^<Class> = (
	^(makeMixin: source) |> Object.
)
makeLowLevelMirrorForClassMixin: classMixin <ClassMixin> ^<LowLevelMixinMirror> = (
	| llm <LowLevelMixinMirror> |
	assert: [classMixin isMeta].
	llm:: LowLevelMixinMirror named: classMixin name isMeta: true.
	classMixin methodDictionary do:
		[:method <CompiledMethod> |
		| methodMirror |
		methodMirror:: makeMethodMirrorFrom: method.
		methodMirror selector = classMixin theNonMetaClass constructorName ifTrue:
			[methodMirror metadata at: #isConstructor put: true].
		llm methods addMirror: methodMirror].
	^llm
)
makeLowLevelMirrorForMixin: mixin <Mixin> ^<LowLevelMixinMirror> = (
	| llm <LowLevelMixinMirror> |
	assert: [mixin isMeta not].
	llm:: LowLevelMixinMirror named: mixin name isMeta: false.
	mixin instVarNames do:
		[:each | llm instVars addMirror: (InstanceVariableMirror named: each mutable: true)].
	mixin methodDictionary do:
		[:method <CompiledMethod> | 
		llm methods addMirror: (makeMethodMirrorFrom: method)].
	llm cachedClassMixin: (makeLowLevelMirrorForClassMixin: mixin classMixin).
	^llm
)
makeMethodMirror: source <String> in: klass <Class> ^ <LowLevelMethodMirror> = (
	(*Compile src in the context of klass and return a low level mirror on the method created  *)
	^newCompiler compileMethodSource: source readStream within: (ClassDeclarationMirror reflecting: klass mixin)
)
makeMethodMirrorFrom: compiledMethod <CompiledMethod> ^ <LowLevelMethodMirror> = (
	^LowLevelMethodMirror new
		method: compiledMethod;
		selector: compiledMethod selector;
		yourself
)
makeMirrorFor: klass <Class> ^ <CompiledMixinMirror> = (
	^newCompiler CompiledMixinMirror language: NewspeakLanguage2 new header: '' mirror: (makeLowLevelMirrorFor: klass)
)
makeMixin: source <String> ^<Mixin> = (
	| mixin <Mixin> rep <MxinRep> |
	rep:: compileToMixinRep: source.
	^(atomicInstaller install: {rep} withExistingMixins: Map new) first.
)
mixin: mixin <Mixin> hasSlotNamed: name <String> ^<Boolean> = (
	^(makeLowLevelMirrorForMixin: mixin) instVars includesMirrorNamed: name
)
updateMixin: mixin <Mixin> withNewDefinition: source <String> = (
(*Compile the source string (a complete source of the class) as a replacement of an existing mixin. Install the replacement.*)
	| newRep existingMixinMap |
	newRep:: compileToMixinRep: source.
	existingMixinMap:: Map new.
	existingMixinMap at: newRep put: mixin.
(*	existingMixinMap at: newRep last first put: mixin nestedMixins anyOne.*)
	atomicInstaller install: {newRep} withExistingMixins: existingMixinMap.
)
updateMixins: mixins <{Mixin}> withNewDefinitions: sources <{String}> = (
(*Compile the source string (a complete source of the class) as a replacement of existing mixins. Atomically install the replacements.*)
	| newReps existingMixinMap |
	assert: [mixins size = sources size].
	newReps:: sources collect: [:each | compileToMixinRep: each].
	existingMixinMap:: Map new.
	newReps with: mixins do:
		[:eachRep :eachMixin |
		existingMixinMap at: eachRep put: eachMixin].
	atomicInstaller install: newReps withExistingMixins: existingMixinMap.
)
withMirrorFor: mixin <Mixin> doThenInstall: aBlock <[:LowLevelMixinMirror]> = (
(*Create a mirror for the mixin, then evaluate the block with the mirror as the parameter. The block is expected to make modifications to the mirror. Once the block is done, atomically install the mirror.*)
	| lowLevelMirror cmm rep existingMixinMap |
	lowLevelMirror:: makeLowLevelMirrorForMixin: mixin.
	cmm:: CompiledMixinMirror language: ns3Lang header: mixin cachedHeaderSource mirror: lowLevelMirror.
	rep:: {cmm. {}}.
	existingMixinMap:: Map new.
	existingMixinMap at: rep put: mixin.
	aBlock value: lowLevelMirror.
	atomicInstaller install: {rep} withExistingMixins: existingMixinMap.
)'testing'
testAddMethod = (
	| testClass <Class>  instance <TestAddMethod_oneClass> outerMixin <Mixin> |
	testClass:: makeClass:  'class TestAddMethod = ()(''unclassified'' bar = (^35))'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin reflectee.
	instance:: testClass new.
	withMirrorFor: outerMixin doThenInstall:
		[:mirror |
		mirror methods addMirror: (makeMethodMirror: 'foo = ( ^self bar + 7)' in: testClass)].
	assert: instance foo equals: instance bar + 7.
)
testAddNestedClass = (
	| testClass <Class>  mirror <LowLevelMixinMirror> method <LowLevelMethodMirror> instance <TestAddMethod_oneClass> rep <MixinRep> nestedMixin <Class> outerMixin <Class> |
	testClass:: makeClass:  'class TestAddNestedClass = ()(''unclassified'' bar = (^35))'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin reflectee.
	instance:: testClass new.
	updateMixin: outerMixin withNewDefinition:
'class TestAddNestedClass = ()(
	class Nested = () (
	''unclassified'' 
	bar = (^35)
	)
)'.
	assert: instance Nested new bar equals: 35.
)
testAddSlot = (
	| testClass <Class>  instance <TestAddSlot_oneClass> outerMixin <Class> |
	testClass:: makeClass:  'class TestAddSlot = ()()'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin reflectee.
	instance:: testClass new.
	withMirrorFor: outerMixin doThenInstall:
		[:mirror |
		| slot |
		slot:: InstanceVariableMirror named: #x mutable: true.
		mirror instVars addMirror: slot].
	assert: [mixin: outerMixin hasSlotNamed: #x].
)
testAddSlotAndAccessors = (
	| testClass <Class>  instance <TestAddSlot_oneClass> outerMixin <Mixin> |
	testClass:: makeClass:  'class TestAddSlotAndAccessors = ()()'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin reflectee.
	instance:: testClass new.
	updateMixin: outerMixin withNewDefinition: 'class TestAddSlotAndAccessors = ( | x | ) ()'.
	assert: instance x equals: nil.
	instance x: 3.
	assert: instance x equals: 3.
)
testChangeMethod = (
	|
	testClass <Class>
	outerMixin <Mixin>
	instance <TestAddMethod_oneClass>
	|
	testClass:: makeClass:  'class TestChangeMethod = ()(''unclassified'' bar = (^35))'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin reflectee.
	instance:: testClass new.
	withMirrorFor: outerMixin doThenInstall:
		[:mirror <LowLevelMixinMirror> |
		mirror methods addMirror: (makeMethodMirror: 'bar = ( ^7)' in: testClass)].
	assert: instance bar equals: 7.
)
testChangeNestedClass = (
	| testClass <Class>  instance <TestChangeNestedClass> instance1 <NestedClass> outerMixin <Class> |
	testClass:: makeClass:
'class TestChangeNestedClass = ()(
	class Nested = () (
		''unclassified'' 
		bar = (^35)
	)
)'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin reflectee.
	instance:: testClass new.
	instance1:: instance Nested new.

	updateMixin: outerMixin withNewDefinition:
'class TestChangeNestedClass = ()(
	class Nested = (| x y = 5. |) (
		''unclassified'' 
		bar = (x::7. ^x)
		bam = (^bar*2)
	)
)'.

	assert: instance1 y equals: nil.
	assert: instance1 x equals: nil.	
	assert: instance Nested new y equals: 5.
	assert: instance1 bar equals: 7.
	assert: instance1 x equals: 7.
	assert: instance1 bam equals: 14.
)
testCreateMultipleClasses = (
	| testMixin <Class> testClass1 <Class>  testClass2 <Class>  testClass3 <Class>   instance1 <TestCreateMultipleClasses1>  instance2 <TestCreateMultipleClasses2>  instance3 <TestCreateMultipleClasses3> reps <List[MixinRep]> lreps <List[LowLevelMixinRep]> testMixins <List[MixinList]>  |
	
	reps:: {
		compileToMixinRep: 'class TestCreateMultipleClasses1 = ()(''unclassified'' bar = (^37))'.
		compileToMixinRep: 'class TestCreateMultipleClasses2 = ()(''unclassified'' baz = (^42))'.
		compileToMixinRep: 'class TestCreateMultipleClasses3 = ()(''unclassified'' foo = (^91))'
	}.
	testMixins:: atomicInstaller install: reps withExistingMixins: Map new.

	testClass1:: (testMixins at: 1) |> Object.
	instance1:: testClass1 new.
	assert: [instance1 bar = 37].
	
	testClass2:: (testMixins at: 2) |> Object.
	instance2:: testClass2 new.
	assert: [instance2 baz = 42].
	
	testClass3:: (testMixins at: 3) |> Object.
	instance3:: testClass3 new.
	assert: [instance3 foo = 91].
)
testCreateOneClass = (
	|  testClass1 <Class>  instance1 <TestCreateMultipleClasses1>  reps <List[MixinRep]> lreps <List[LowLevelMixinRep]> testMixins <List[MixinList]>  |
	
	reps:: {compileToMixinRep:  'class TestCreateOneClass = ()(''unclassified'' bar = (^37))'}.
	testMixins:: atomicInstaller install: reps withExistingMixins: Map new.
	
	testClass1:: (testMixins at: 1) |> Object.
	instance1:: testClass1 new.
	assert: [instance1 bar = 37].
)
testHierarchyChanges = (
	|
	superMixin1 <Mixin>
	superMixin2 <Mixin>
	superMixin3 <Mixin>
	subMixin <Mixin>
	superclass1 <Class>
	superclass2 <Class>
	superclass3 <Class>
	subclass1 <Class>
	subclass2 <Class>
	subclass3 <Class>
	subclass12 <Class>
	instance1 <TestHierarchyChanges2>
	instance2 <TestHierarchyChanges1>
	instance3 <TestHierarchyChanges3>
	instance12 <TestHierarchyChanges1>
	|
	superMixin1:: makeMixin: 'class TestHierarchyChanges1 =  ()(''unclassified'' bar = (^37))'.
	superMixin2:: makeMixin: 'class TestHierachyChanges2 = ()(''unclassified'' baz = (^42))'.
	superMixin3:: makeMixin: 'class TestHierarchyChanges3 = ( | z | )(''unclassified'' foo = (^91))'.
	subMixin:: makeMixin: 'class TestHierarchyChanges = ( | z | )(''unclassified'' foo = (^91))'.

	superclass1:: superMixin1 |> Object.
	superclass2:: superMixin2 |> Object.
	superclass3:: superMixin3 |> Object.
	subclass1:: subMixin |> superclass1.
	subclass2:: subMixin |> superclass2.
	subclass3:: subMixin |> superclass3.
	subclass12:: superMixin1 |> subclass2.
	
	instance1:: subclass1 new.
	instance2:: subclass2 new.
	instance3:: subclass3 new.
	instance12:: subclass12 new.

	updateMixin: subMixin withNewDefinition:
		'class TestHierarchyChanges = ( | x =  2* bar. y = x + 2. | )(''unclassified'' bar = (^7) bam = (^x) )'.
	
	assert: [instance1 bar = 7].
	assert: [instance2 bar = 7].
	assert: [instance3 bar = 7].
	assert: [instance12 bar = 37].

	assert: [instance1 bam = nil].
	assert: [instance2 bam = nil].
	assert: [instance3 bam = nil].
	assert: [subclass12 new y = 76].
)
testMultipleChanges = (
	|
	testClass1 <Class>
	testClass2 <Class>
	testClass3 <Class>
	instance1 <TestCreateMultipleClasses1>
	instance2 <TestCreateMultipleClasses2>
	instance3 <TestCreateMultipleClasses3>
	testMixins <List[MixinList]>  
	|
	testClass1:: makeClass:  'class TestMultipleChanges1 = ()(''unclassified'' bar = (^37))'.
	testClass2:: makeClass:  'class TestMultipleChanges2 = ()(''unclassified'' baz = (^42))'.
	testClass3:: makeClass:  'class TestMultipleChanges3 = ( | z | )(''unclassified'' foo = (^91))'.	
	testMixins:: {testClass1. testClass2 . testClass3} collect:[:c <Class> | (ClassMirror reflecting: c) mixin reflectee].	
	instance1:: testClass1 new.
	instance2:: testClass2 new.
	instance3:: testClass3 new.

	assert:[ instance1 bar = 37].
	assert:[ instance2 baz = 42].
	assert:[ instance3 foo = 91].
	assert:[ instance3 z isNil].

	updateMixins: testMixins withNewDefinitions: {
		'class TestMultipleChanges1 = ()(''unclassified'' bar = (^7))'.
		'class TestMultipleChanges2 = ()(''unclassified'' baz = (^91) bar = (^baz + 17))'.
		'class TestMultipleChanges3 = ( | x =  2* bar. y = x + 2. | )(''unclassified'' bar = (^7) bam = (^x) )'.
	}.
	
	assert: [instance1 bar = 7].
	assert: [instance2 bar = 108].
	assert: [instance2 baz = 91].	
	assert: [instance3 bam = nil].	
	assert: [testClass3 new bam = 14]. 
	assert: [testClass3 new y = 16].
	assert: [(mixin: (testMixins at: 3) hasSlotNamed: #z) not].
)
testNesting = (
	| outerClass0 <Class> outerMixin0 <Class> instance0 <TestNesting> 
	nestedClass1 <Class> nestedMixin1 <Class> nestedClass11 <Class> 
	nestedMixin11 <Class>
	instance1 <Nested1> instance11 <Nested11>
	nestedClass111 <Class> nestedMixin111 <Class> instance111 <Nested111>
	rep <MixinRep>
	|
	outerClass0:: makeClass:
'class TestNesting = () (
	class Nested1 = ( | a b c | ) (
		class Nested11 = () (
			class Nested111 = ( | x = a. |) ()
		)
		class Nested12 = Nested11 () ()
	)
	class Nested2 = () (
      )
)'.
	outerMixin0:: (ClassMirror reflecting: outerClass0) mixin reflectee.
	instance0:: outerClass0 new.
	nestedClass1::  instance0 Nested1.
	instance1:: nestedClass1 new.
	nestedClass11:: instance1 Nested11.
	instance11:: nestedClass11 new.
	nestedClass111:: instance11 Nested111.
	instance111:: nestedClass111 new.

	updateMixin: outerMixin0 withNewDefinition:
'class TestNesting = () (
	class Nested1 = ( | d e = 5.  | ) (
		class Nested11 = () (
			class Nested111 = ( | z = e. |) ()
			''unclassified'' 
			bar = (^7)
		)
		class Nested12 = Nested11 () ()
		class Nested13 = Nested12() ()
	)
	class Nested3 = Nested1 ()()
)'.	
	
	assert:[instance111 z isNil].
	assert:[instance11 bar = 7].
	assert:[instance1 d isNil].
	assert:[instance1 e isNil].
	assert:[instance1 Nested12 new bar = 7].
	assert:[instance0 Nested3 new Nested12 new Nested111 new z  = 5].
)
testRemoveMethod = (
	| testClass <Class> nestedMixin <Class> outerMixin <Class> mirror |
	testClass:: makeClass:  'class TestRemoveMethod = ()(''unclassified'' bar = (^35))'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin reflectee.
	withMirrorFor: outerMixin doThenInstall:
		[:mirror |
		mirror methods removeMirrorNamed: #bar].
	mirror:: makeLowLevelMirrorForMixin: outerMixin.
	assert: [(mirror methods includesMirrorNamed: #bar) not].
)
testRemoveNestedClass = (
	| testClass <Class>  mirror <LowLevelMixinMirror> method <LowLevelMethodMirror> instance <TestAddMethod_oneClass> rep <MixinRep> outerMixin <Class> |
	testClass:: makeClass:  'class TestRemoveNestedClass = ()(
	class Nested = () (
	''unclassified'' 
	bar = (^35)
	)
)'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin reflectee.
	updateMixin: outerMixin withNewDefinition:
'class TestRemoveNestedClass = ()(
	''unclassified'' 
	bar = (^35)
)'.

	mirror:: makeLowLevelMirrorForMixin: outerMixin.
	assert: [(mirror methods includesMirrorNamed: #Nested) not].
)
testRemoveNestedNestedClass = (
	| testClass <Class>  mirror <LowLevelMixinMirror> method <LowLevelMethodMirror> instance <TestAddMethod_oneClass> rep <MixinRep> outerMixin <Class> nestedClassDecl <ClassDeclarationMirror> |
	testClass:: makeClass:  'class TestRemoveNestedNestedClass = ()(
	class Nested = () (
		class NestedNested = ()()
		''unclassified'' 
		bar = (^35)
	)
)'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin  reflectee.
	updateMixin: outerMixin withNewDefinition:
'class TestRemoveNestedNestedClass = ()(
	class Nested = () (
		''unclassified'' 
		bar = (^35)
	)
)'.
	nestedClassDecl:: (ClassMirror reflecting: testClass) nestedClasses findMirrorNamed: #Nested.
	assert: [(nestedClassDecl instanceSide methods includesMirrorNamed: #NestedNested) not].
)
testRemoveNestedNestedClass2 = (
	| testClass <Class>  mirror <LowLevelMixinMirror> method <LowLevelMethodMirror> instance <TestAddMethod_oneClass> rep <MixinRep> outerMixin <Class> nestedClass <Class> ns <Map[Symbol, Class]> |
	testClass:: makeClass:
'class TestRemoveNestedNestedClass = ()(
	class Nested = () (
		class NestedNested = ()()
	''unclassified'' 
	bar = (^35)
	)
)'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin reflectee.

	updateMixin: outerMixin withNewDefinition:
'class TestRemoveNestedNestedClass = ()(
	class Nested = () (
	''unclassified'' 
	bar = (^35)
	)
)'.

	mirror:: makeLowLevelMirrorForMixin: testClass new Nested mixin.
	assert: [(mirror methods includesMirrorNamed: #NestedNested) not].
)
testRemoveSlot = (
	| testClass <Class> outerMixin <Class> |
	testClass:: makeClass:  'class TestRemoveSlot = ( | aSlot | )()'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin reflectee.
	updateMixin: outerMixin withNewDefinition: 'class TestRemoveSlot = ()()'.
	assert: [(mixin: outerMixin hasSlotNamed: #aSlot) not].
)
testStressfulShapeChange = (

	| testClass <Class>  mirror <LowLevelMixinMirror> method <LowLevelMethodMirror> rep <MixinRep> nestedMixin <Class> outerMixin <Class> testInstance |
	testClass:: makeClass:  'class Shapeshifter = ()()'.
	outerMixin:: (ClassMirror reflecting: testClass) mixin reflectee.
	updateMixin: outerMixin withNewDefinition: 'class Shapeshifter = ( | one = 1. two = 2. three = 3. | ) ()'.
	testInstance:: testClass new.
	updateMixin: outerMixin withNewDefinition: 'class Shapeshifter = ( | three = 3. four = 4. five = 5. two = 2. | ) ()'.
	
	assert: [testInstance class == testClass].
	assert: [testInstance three = 3].
	assert: [testInstance two = 2].
	assert: [testInstance four = nil].
	assert: [testInstance five = nil].
	should: [testInstance one] signal: MessageNotUnderstood.
	
	updateMixin: outerMixin withNewDefinition: 'class Shapeshifter = ( | six = 6. three = 3. |) ()'.
	
	assert: [testInstance class == testClass].
	assert: [testInstance three = 3].
	assert: [testInstance six = nil].
	should: [testInstance one] signal: MessageNotUnderstood.
	should: [testInstance two] signal: MessageNotUnderstood.
	should: [testInstance four] signal: MessageNotUnderstood.
	should: [testInstance five] signal: MessageNotUnderstood.
)
testSubclass = (
	(*Test the effect of modifying a subclass of an unmodified but non-trivial superclass.*)
	|
	superMixin <Class>
	subMixin <Class>
	superClass <Class>
	subClass <Class>
	objectSubClass <Class>
	instanceSuper <TestSubclassSuper>
	instanceSub <TestSubclassSub>
	instanceObjectSub <TestSubclassSub>
	|
	superMixin:: makeMixin:  'class TestSubclassSuper = ( | z | )(''unclassified'' foo = (^91))'.
	superClass:: superMixin |> Object.
	subMixin:: makeMixin:  'class TestSubclassSub = ()(''unclassified'' bar = (^37))'.
	subClass:: subMixin |> superClass.
	objectSubClass:: subMixin |> Object.
	instanceSuper:: superClass new.
	instanceSub::  subClass new.
	instanceObjectSub:: objectSubClass new.

	assert: [instanceSuper foo = 91].
	assert: [instanceSub foo = 91].
	assert: [instanceSuper z isNil].
	assert: [instanceSub z isNil].	
	assert: [instanceObjectSub bar = 37].
	assert: [instanceSub bar = 37].

	updateMixin: subMixin withNewDefinition:
		'class TestSubclassSub = ( | x ::=  2* bar. y = x + 2. | )(''unclassified'' bar = (^7) bam = (^x) )'.

	assert: [instanceSuper foo = 91].
	assert: [instanceSub foo = 91].
	assert: [instanceSuper z isNil].
	assert: [instanceSub z isNil].
	assert: [instanceObjectSub bar = 7].
	assert: [instanceSub bar = 7].
	assert: [instanceObjectSub bam isNil].

	instanceObjectSub x: 3.
	assert: [instanceObjectSub bam = 3].
	assert: [instanceSub bam isNil].

	instanceSub x: 5.
	assert: [instanceSub bam = 5].
	assert: [subClass new x = 14].
	assert: [objectSubClass new x = 14].
	assert: [subClass new y = 16].
	assert: [objectSubClass new y = 16].
)
testSuperAndSubclass = (
	(*Test the effect of simultaneously modifying a superclass and a subclass.*)
	|
	superMixin <Mixin>
	subMixin <Mixin>
	superClass <Class>
	subClass <Class>
	objectSubClass <Class>
	instanceSuper <TestSuperclassSuper>
	instanceSub <TestSuperclassSub>
	instanceObjectSub <TestSuperclassSub>
	|
	superMixin:: makeMixin:  'class TestSuperAndSubclassSuper = ( | z | )(''unclassified'' foo = (^91))'.
	subMixin:: makeMixin:  'class TestSuperAndSubclassSub = ()(''unclassified'' bar = (^37))'.
	superClass:: superMixin |> Object.
	subClass:: subMixin |> superClass.
	objectSubClass:: subMixin |> Object.
	instanceSuper:: superClass new.
	instanceSub::  subClass new.
	instanceObjectSub:: objectSubClass new.

	assert: [instanceSuper foo = 91].
	assert: [instanceSub foo = 91].
	assert: [instanceSuper z isNil].
	assert: [instanceSub z isNil].	
	assert: [instanceObjectSub bar = 37].
	assert: [instanceSub bar = 37].

	updateMixins: {superMixin. subMixin} withNewDefinitions: {
		'class TestSuperAndSubclassSuper = ( | w ::= bar*3. | )(''unclassified'' bar = (^7) bam = (^w) )'.
		'class TestSuperAndSubclassSub = ( | x =  2* bar. y = x + 2. | )(''unclassified'' bar = (^39) baz = (^x + y) )'.
	}.
	assert: [instanceSuper bar = 7].
	assert: [instanceObjectSub bar = 39].
	assert: [instanceSub bar = 39].
	assert: [instanceSuper bam isNil].

	instanceSuper w:3.
	assert: [instanceSuper bam = 3].	
	assert: [instanceSub bam isNil].

	instanceSub w: 5.
	assert: [instanceSub bam = 5].
	assert: [superClass new w = 21].
	assert: [subClass new x = 78].
	assert: [subClass new w = 117].
	assert: [superClass new bam = 21].
	assert: [subClass new bam = 117].
	assert: [objectSubClass new baz = 158].
	assert: [subClass new baz = 158].
	assert: [objectSubClass new y = 80].
	assert: [subClass new y = 80].
)
testSuperclass = (
	(*Test the effect of modifying the superclass of an umodified subclass.*)
	| 
	superMixin <Mixin>
	subMixin <Mixin>
	superClass <Class>
	subClass <Class>
	objectSubClass <Class>
	instanceSuper <TestSuperclassSub>
	instanceSub <TestSuperclassSub>
	instanceObjectSub
	|
	superMixin:: makeMixin:  'class TestSuperclassSuper = ( | z | )(''unclassified'' foo = (^91))'.
	superClass:: superMixin |> Object.
	subMixin:: makeMixin:  'class TestSuperclassSub = ()(''unclassified'' bar = (^37))'.
	subClass:: subMixin |> superClass.
	objectSubClass:: subMixin |> Object.

	instanceSuper:: superClass new.
	instanceSub::  subClass new.
	instanceObjectSub:: objectSubClass new.

	assert: [instanceSuper foo = 91].
	assert: [instanceSub foo = 91].
	assert: [instanceSuper z isNil].
	assert: [instanceSub z isNil].	
	assert: [instanceSub bar = 37].
	assert: [instanceObjectSub bar = 37].

	updateMixin: superMixin withNewDefinition:
		'class TestSuperclassSuper = ( | x ::=  2* bar. y = x + 2. | )(''unclassified'' bar = (^7) bam = (^x) )'.

	assert: [instanceSuper bar = 7].
	assert: [instanceObjectSub bar = 37].
	assert: [instanceSub bar = 37].
	assert: [instanceSuper bam isNil].
	assert: [instanceSub bam isNil].

	instanceSub x: 5.

	assert:[instanceSub bam = 5].
	assert:[superClass new x = 14].
	assert:[subClass new x = 74].
	assert:[superClass new y = 16].
	assert:[subClass new y = 76].
)) : ('test framework'
TEST_CONTEXT = ())) : ()