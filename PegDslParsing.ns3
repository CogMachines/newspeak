Newspeak3
'NS2 Combinatorial Parsing'
class PegDslParsing usingLib: platform ast: astModule grammar: grammar = (
"Parser for the EBNF/PEG DSL."|
      List = platform collections MutableArrayList.

      ASTModule = astModule.
 	ParserError = grammar ParserError.

	AlternationAST = astModule AlternationAST.	
	GrammarAST = astModule GrammarAST.		
	NegationAST = astModule NegationAST.	
	OneOrMoreAST = astModule OneOrMoreAST.
	OptionAST = astModule OptionAST.
	ProductionAST = astModule ProductionAST.
	ProductionReferenceAST = astModule ProductionReferenceAST.
	SequenceAST = astModule SequenceAST.		
	StringAST = astModule StringAST.
      ZeroOrMoreAST = astModule ZeroOrMoreAST.
|)
(
class Parser = ()
('as yet unclassified'
alternation ^ <AlternationAST> = (
  ^super alternation
     wrap:[:a1 <AST> :vb <Token> :a2 <AST>  | 
	   AlternationAST right: a1 left: a2; start: a1 start; end: a2 end
	]. 		
)
atom ^ <AST> = (
  ^super atom
     wrap:[:a <AST> :m <Token>  | 
	   m isNil 
	      ifTrue:[a]
	      ifFalse:[ | result  <OptionAST | OneOrMoreAST | ZeroOrMoreAST> | 
		     m token = #? 
		        ifTrue:[result:: OptionAST operand: a].
		      m token = #+ 
		          ifTrue:[OneOrMoreAST repeating: a].
		      m token = #* 
		          ifTrue:[ZeroOrMoreAST repeating: a].		
		      result start: a start; end: m end.
		      result
	      ]
	].		
)
grammar = (
  ^super grammar
     wrap:[: ps <List[ProductionAST]> |   | start <Integer> end <Integer> rs <List> |
	   ps isEmpty 
	       ifTrue:[start:: end:: 0. rs:: List new] 
	       ifFalse:[start:: ps first start. end:: ps last end. rs:: ps.].
	   GrammarAST rules: rs; start: start; end: end
	]. 	
)
negation ^ <NegationAST> = (
  ^super negation
     wrap:[:t <Token>  :p <AST> | 
	  NegationAST negating: p; start: t start; end: p end
	]. 	
)
parenthesizedProduction ^ <AST> = (
  ^super parenthesizedProduction wrap:[:lp <Token> : t <AST> :rp <Token> | t].	
	"Filter out parentheses tokens"
)
production ^ <ProductionAST> = (
  ^super production
     wrap:[:n <Token> :c <Token> :r <AST> :s <Token> | 
	   ProductionAST named: n token rhs: r; start: n start; end: s end
	].	
)
productionName ^ <ProductionReferenceAST> = (
  ^super productionName
     wrap:[: t | ProductionReferenceAST id: t token; start: t start; end: t end]. 	
)
sequence = (
  ^super sequence
     wrap:[: es <List[AST]> | 
	   SequenceAST sequence: es ; start: es first start; end: es last end
	]. 	
)
string ^ <StringAST> = (
  ^super string
     wrap:[: t | StringAST val: t token; start: t start; end: t end]. 
)) : ()) : ()