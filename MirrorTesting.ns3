Newspeak3
'Mirrors-tests'
class MirrorTesting usingPlatform: platform mirrors: m testFramework: utf = (|
	private ClassDeclarationMirror = m ClassDeclarationMirror.
	private ClassDeclarationBuilder = m ClassDeclarationBuilder.
	private ClassMirror = m ClassMirror.
	private MixinMirror = m MixinMirror.
	private ObjectMirror = m ObjectMirror.
	private MessageNotUnderstood = platform squeak MessageNotUnderstood.

	private TestContext = utf TestContext.

      private Smalltalk = platform squeak Smalltalk.
	private ContextPart = platform squeak ContextPart.

	private vmmirror = platform squeak VMMirror new.
|) (
class ClassDeclarationBuilderTests = TestContext () (
'as yet unclassified'
public testClassDeclAddMethod = (
	(* add a new method *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	|
	testBuilder:: ClassDeclarationBuilder reflecting: newClass mixin.
	testBuilder instanceSide methods addFromSource: 'public foo: x = (^x * x)'.
	testMirror:: testBuilder install.
	klass:: testMirror reflectee apply: Object.
      assert: (klass new foo: 3) equals: 9. 
)
public testClassDeclAddNestedClass = (
	(* add a new nested class decl *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	|
	testBuilder:: ClassDeclarationBuilder reflecting: newClass mixin.
	testBuilder instanceSide nestedClasses addFromSource: 'public class Nested = ()(''cat'' public foo = (^91))'.
	testMirror:: testBuilder install.
	klass:: testMirror reflectee apply: Object.
	assert: klass new Nested new foo equals: 91.
)
public testClassDeclChangeHeader = (
	(* add a new slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	testBuilder:: ClassDeclarationBuilder reflecting: newClass mixin.
	testBuilder headerFromSource: 'class EmptyClass = ( | public newSlot ::= 91. | )'.
	testMirror:: testBuilder install.
	klass:: testMirror reflectee apply: Object.
	instance:: klass new.
	assert: instance newSlot equals: 91.
	instance newSlot: 101.
	assert: instance newSlot equals: 101.	
)
public testClassDeclCopyNested = (
	(* The bug here seems to be the copy doesn't get its qualified name patched. *)
	| 
	enclosingBuilder <ClassDeclarationBuilder>
	origBuilder
	origMirror
	origMixin
	copyBuilder
	copySource
	copyMixin
	|
	enclosingBuilder:: ClassDeclarationBuilder fromSource: 'class Enclosing = ()()'.
	
	origBuilder:: enclosingBuilder instanceSide nestedClasses addFromSource: 'class TheOriginal = ()()'.
	origMirror:: origBuilder install.
	origMixin:: origMirror reflectee.
	assert: origMixin simpleName equals: 'TheOriginal'.
	assert: origMixin accessModifier equals: #protected.

	copyBuilder:: ClassDeclarationBuilder fromSource: origMirror source.
	copyBuilder header name: 'TheCopy'.
	copySource:: copyBuilder source.
	copyBuilder:: enclosingBuilder instanceSide nestedClasses addFromSource: copySource.
	enclosingBuilder install.
	copyMixin:: copyBuilder reflectee.
	
	assert: copyMixin simpleName equals: 'TheCopy'.
	assert: copyMixin accessModifier equals: #protected.
)
public testClassDeclCopyTopLevel = (
	| 
	origBuilder
	origMirror
	origMixin
	copyBuilder
	copyMixin
	|
	origBuilder:: ClassDeclarationBuilder fromSource: 'class TheOriginal = ()()'.
	origMirror:: origBuilder install.
	origMixin:: origMirror reflectee.
	assert: origMixin simpleName equals: 'TheOriginal'.
	assert: origMixin accessModifier equals: #public.
	
	copyBuilder:: ClassDeclarationBuilder fromSource: origMirror source.
	copyBuilder header name: 'TheCopy'.
	copyMixin:: copyBuilder install reflectee.
	assert: copyMixin simpleName equals: 'TheCopy'.
	assert: copyMixin accessModifier equals: #public.
)
public testClassDeclModifySlot = (
	(* modify the declaration of an existing slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	klass:: classFromSource: 'class TestClassDeclModifySlot = ( | x ::= 117.  y = 0. z  | )()'.
	testBuilder:: ClassDeclarationBuilder reflecting: klass mixin.
	testBuilder headerFromSource: 'class TestClassDeclModifySlot = ( | public x ::= 120. y = 0.  z | )'.
	testMirror:: testBuilder install.
	assert: [testMirror instanceSide slots includesMirrorNamed: #x].
	assert: [testMirror instanceSide slots includesMirrorNamed: #y].
	assert: [testMirror instanceSide slots includesMirrorNamed: #z].
	instance:: klass new.
	assert: instance x equals: 120.
	instance x: 101.
	assert: instance x equals: 101.	
)
public testClassDeclRemoveMethod = (
	(* remove an existing method *)
	| 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	myKlass <Class>
	|	
	myKlass:: classFromSource: 'class TestClassDeclRemoveMethod = ()(
		''unclassified''
		foo = (^91)
	      bar = (^42)
	)'.
	testBuilder::  ClassDeclarationBuilder reflecting: myKlass mixin. 
	testBuilder instanceSide methods removeMirrorNamed: 'foo'.
	testMirror:: testBuilder install.
	deny: [testMirror instanceSide methods includesMirrorNamed: #foo].
)
public testClassDeclRemoveNestedClass = (
	(* remove an existing nested class *)
	| builder <ClassMirrorBuilder> outerClass <Class> |
	
	outerClass:: classFromSource: 'class TestClassDeclRemoveNestedClass = ()(
		class Nested = ()()
	)'.
	builder:: ClassDeclarationBuilder reflecting: outerClass mixin. 
	builder instanceSide nestedClasses removeMirrorNamed: #Nested.
	builder install. (* remove *)
	should: [outerClass new Nested] signal: MessageNotUnderstood.
	assert:[
		((ClassDeclarationMirror reflecting: outerClass mixin) instanceSide nestedClasses 
			findMirrorNamed: #Nested) = nil
		].(* verify *)
)
public testClassDeclRemoveNonExistantMethod = (
	(* remove a non-existing method. The effect should be to do nothing, so our only goal here is to run without error *)
	| 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	myKlass <Class>
	|	
	myKlass:: classFromSource: 'class TestClassDeclRemoveMethod = ()(
		''unclassified''
		foo = (^91)
	      bar = (^42)
	)'.
	testBuilder:: ClassDeclarationBuilder reflecting: myKlass mixin. 
	testBuilder instanceSide methods removeMirrorNamed: 'baz'.
)
public testClassDeclRemoveNonExistantNestedClass = (
	(* remove a non-existing nested class. The effect should be to do nothing, so our only goal here is to run without error *)
	| builder <ClassMirrorBuilder>  outerClass <Class> |
	
	outerClass:: classFromSource: 'class TestClassDeclRemoveNonExistantNestedClass = ()()'.
	builder:: ClassDeclarationBuilder reflecting: outerClass mixin. 
	builder instanceSide nestedClasses removeMirrorNamed: #Nested.
)
public testClassDeclRemoveSlot = (
	(* remove an existing slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	klass:: classFromSource: 'class TestClassDeclRemoveSlot = ( | x ::= 117.  y = 0. z  | )()'.
	testBuilder:: ClassDeclarationBuilder reflecting: klass mixin.
	testBuilder headerFromSource: 'class TestClassDeclRemoveSlot = ( | x ::= 117. y = 0.  | )'.
	testMirror:: testBuilder install.
	deny: [testMirror instanceSide slots includesMirrorNamed: #z].
	assert: [testMirror instanceSide slots includesMirrorNamed: #y].
	assert: [testMirror instanceSide slots includesMirrorNamed: #x].
)
public testClassDeclRenameNested = (
	| 
	mixin <InstanceMixin> 
	enclosingBuilder <ClassDeclarationBuilder>
	builder
	builder2
	|
	enclosingBuilder:: ClassDeclarationBuilder fromSource: 'class Enclosing = ()()'.
	builder:: enclosingBuilder instanceSide nestedClasses addFromSource: 'class OldName = ()()'.
	mixin:: builder install reflectee.
	assert: mixin simpleName equals: 'OldName'.
	builder2:: ClassDeclarationBuilder reflecting: mixin.
	builder2 header name: 'NewName'.
	builder2 install.
	assert: mixin simpleName equals: 'NewName'.
)
public testClassDeclRenameNestedPrivate = (
	| 
	mixin <InstanceMixin> 
	enclosingBuilder <ClassDeclarationBuilder>
	builder
	builder2
	|
	enclosingBuilder:: ClassDeclarationBuilder fromSource: 'class Enclosing = ()()'.
	builder:: enclosingBuilder instanceSide nestedClasses addFromSource: 'private class OldName = ()()'.
	mixin:: builder install reflectee.
	assert: mixin simpleName equals: 'OldName'.
	builder2:: ClassDeclarationBuilder reflecting: mixin.
	builder2 header name: 'NewName'.
	builder2 install.
	assert: mixin simpleName equals: 'NewName'.
	assert: mixin accessModifier equals: #private.
)
public testClassDeclRenameTopLevel = (
	| 
	mixin <InstanceMixin> 
	builder <ClassDeclarationBuilder>
	builder2
	|
	builder:: ClassDeclarationBuilder fromSource: 'class OldName = ()()'.
	mixin:: builder install reflectee.
	assert: mixin name equals: 'OldName'.
	builder2:: ClassDeclarationBuilder reflecting: mixin.
	builder2 header name: 'NewName'.
	builder2 install.
	assert: mixin name equals: 'NewName'.
)
public testClassDeclReplaceMethod = (
	(* replace an existing method *)
	| 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	myKlass <Class>
	|	
	myKlass:: classFromSource: 'class TestClassDeclReplaceMethod = ()(
		''unclassified''
		public foo = (^91)
	      bar = (^42)
	)'.
	testBuilder::  ClassDeclarationBuilder reflecting: myKlass mixin. 
	testBuilder instanceSide methods addFromSource: 'public foo = (^254 + 1)'.
	testMirror:: testBuilder install.
	assert: myKlass new foo equals: 255.
)
public testClassDeclReplaceNestedClass = (
	(* replace an existing nested class *)
| builder <ClassMirrorBuilder>  outerClass <Class> nestedKlass <Class> instance <OuterClass> nestedInstance <OuterClass Nested> |
	
	outerClass:: classFromSource: 'class TestClassDeclReplaceNestedClass = ()(
		public class Nested = ()()
	
	)'.
	instance:: outerClass new.
	nestedKlass:: instance Nested.
	nestedInstance:: nestedKlass new.
	builder::  ClassDeclarationBuilder reflecting: outerClass mixin. 
	builder instanceSide nestedClasses addFromSource:
'public class Nested = (| public a = 0.  public b ::= 1. public c |)(''cat'' public foo = (^27))'.
	builder install. (* replace *)
	
	assert: instance Nested new a equals: 0.
	assert: instance Nested new b equals: 1.
	assert: instance Nested new c equals: nil.
	assert: instance Nested new foo equals: 27.
		
	assert: nestedKlass new a equals: 0.
	assert: nestedKlass new b equals: 1.
	assert: nestedKlass new c equals: nil.
	assert: nestedKlass new foo equals: 27.
	
	assert: nestedInstance a equals: nil.
	assert: nestedInstance b equals: nil.
	assert: nestedInstance c equals: nil.
	assert: nestedInstance foo = 27.
	
	assert: nestedKlass equals: instance Nested.
	assert: nestedInstance class equals: nestedKlass.

	assert: outerClass new Nested new a equals: 0.
	assert: outerClass new Nested new b equals: 1.
	assert: outerClass new Nested new c equals: nil.
	assert: outerClass new Nested new foo equals: 27.
)
public testClassDeclReplaceSlot = (
	(* replace an existing slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	klass:: classFromSource: 'class TestClassDeclReplaceSlot = ( | x ::= 117.  y = 0. z  | )()'.
	testBuilder:: ClassDeclarationBuilder reflecting: klass mixin.
	testBuilder headerFromSource: 'class TestClassDeclReplaceSlot = ( | public a ::= 120. y = 0.  z | )'.
	testMirror:: testBuilder install.
	deny:[testMirror instanceSide slots includesMirrorNamed: #x].
	assert:[testMirror instanceSide slots includesMirrorNamed: #y].
	assert:[testMirror instanceSide slots includesMirrorNamed: #z].
	assert:[testMirror instanceSide slots includesMirrorNamed: #a].
	instance:: klass new.
	assert: instance a equals: 120.
	instance a: 101.
	assert: instance a equals: 101.
)
public testConflictingMethodOverFactory = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted foo = ()()'.
	should: [builder classSide methods addFromSource: 'foo = ()'] signal: Error.
)
public testConflictingMethodOverNestedClass = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()(
		class foo = ()()
	)'.
	should: [builder instanceSide methods addFromSource: 'foo = ()'] signal: Error.
)
public testConflictingMethodOverSlot = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = (| foo bar = 1. |)()'.
	should: [builder instanceSide methods addFromSource: 'foo = ()'] signal: Error.
	should: [builder instanceSide methods addFromSource: 'foo: x = ()'] signal: Error.
	should: [builder instanceSide methods addFromSource: 'bar = ()'] signal: Error.
	builder instanceSide methods addFromSource: 'bar: x = ()'.
)
public testConflictingNestedClassOverMethod = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = (| foo |)()'.
	should: [builder instanceSide nestedClasses addFromSource: 'class foo = ()()'] signal: Error.
)
public testConflictingSlotOverMethod = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()(
		''cat'' foo = ()
	)'.
	should: [builder headerFromSource: 'Conflicted = (| foo |)'] signal: Error.
)
public testConflictingSlotOverNestedClass = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()(
		class foo = ()()
	)'.
	should: [builder headerFromSource: 'Conflicted = (| foo |)'] signal: Error.
)
public testIncrementalScopeBuilding = (
	(* add a new method *)
	| 
	builder <ClassDeclarationBuilder> 
	klass <Class>
	ooter
	inner
	r
	|
	builder:: ClassDeclarationBuilder fromSource:
'class Outer = ( | outerSlot = 1. | )(
	public class Inner = ( | public innerSlot = 3. | )(
		public class InnerInner = ()()
		''cat'' public  innerMethod = (^4)
	)
	class Sibling = ()()
	''cat'' outerMethod = (^2)
)'.
	klass:: builder install reflectee apply: Object.
	ooter:: klass new.
	inner:: ooter Inner new.

	(* Incremental eval *)
	r:: (ObjectMirror reflecting: inner) 
		evaluate: '{outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner}'
		ifCompilerError: [ compileTimeFail ] ifError: [ runtimeFail ].
	assert: r reflectee equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.
	
	(* Incremental method *)
	(builder instanceSide nestedClasses findMirrorNamed: #Inner) instanceSide methods addFromSource: 'public testMethod = (^{outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner})'.
	builder install.
	assert: inner testMethod equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.
	
	(* Incremental header *)
	(builder instanceSide nestedClasses findMirrorNamed: #Inner) headerFromSource: 'public class Inner = ( | innerSlot = 33. public testSlot = {outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner}. |)'.
	builder install.
	inner:: ooter Inner new.
	assert: inner testSlot equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.
	
	(* Incremental nested class *)
	builder instanceSide nestedClasses addFromSource: 'class Inner2 = ( | innerSlot = 333. | )(
		class InnerInner = ()()
		''cat'' innerMethod = (^444)
		public testMethod = (^{outer Outer. outerSlot. outerMethod. outer Inner2. innerSlot. innerMethod. Inner2. Sibling. InnerInner})
	)'.
	builder install.
	inner:: ooter Inner2 new.
	assert: inner testMethod equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner2. ooter Sibling. inner InnerInner.}.
)
'private'
emptyClassSource ^ <String> = (
	^'class EmptyClass = ()()'
)
newClass ^ <Class> = (
	^(ClassDeclarationBuilder fromSource: emptyClassSource) install reflectee apply: Object
)
) : (
'test markers'
TEST_CONTEXT = ()
)
class IntrospectionTests = TestContext (|
source = 'class Module moduleFactory: x = ()(
	private class Super superFactory: x = ()()
	public class Class classFactory: x = Super superFactory: x ()()
)'.
M = (ClassDeclarationBuilder fromSource: source) install.
S = M instanceSide nestedClasses findMirrorNamed: #Super.
C = M instanceSide nestedClasses findMirrorNamed: #Class.
|) (
'as yet unclassified'
assertGroup: group <MirrorGroup> definedBy: mixin <MixinMirror> = (
	assert: group definingMixin equals: mixin.
	group do: [:member | assert: member definingMixin equals: mixin].
)
public testClassClasses = (
	
)
public testClassMethods = (
	
)
public testClassSlots = (
	
)
public testHeaderFactory = (
	assert: M header primaryFactory name equals: 'moduleFactory:'.
	assert: S header primaryFactory name equals: 'superFactory:'.
	assert: C header primaryFactory name equals: 'classFactory:'.
)
public testHeaderInitializer = (
	
)
public testHeaderSource = (
	assert: M header source equals: 'class Module moduleFactory: x = ()'.
	assert: S header source equals: 'private class Super superFactory: x = ()'.
	assert: C header source equals: 'public class Class classFactory: x = Super superFactory: x ()'.
)
public testMixinClasses = (
	assertGroup: M instanceSide nestedClasses definedBy: M instanceSide.
	assertGroup: M classSide nestedClasses definedBy: M classSide.
	
	assertGroup: S instanceSide nestedClasses definedBy: S instanceSide.
	assertGroup: S classSide nestedClasses definedBy: S classSide.
	
	assertGroup: C instanceSide nestedClasses definedBy: C instanceSide.
	assertGroup: C classSide nestedClasses definedBy: C classSide.
)
public testMixinMethods = (
	assertGroup: M instanceSide methods definedBy: M instanceSide.
	assertGroup: M classSide methods definedBy: M classSide.
	
	assertGroup: S instanceSide methods definedBy: S instanceSide.
	assertGroup: S classSide methods definedBy: S classSide.
	
	assertGroup: C instanceSide methods definedBy: C instanceSide.
	assertGroup: C classSide methods definedBy: C classSide.
)
public testMixinSlots = (
	assertGroup: M instanceSide slots definedBy: M instanceSide.
	assertGroup: M classSide slots definedBy: M classSide.
	
	assertGroup: S instanceSide slots definedBy: S instanceSide.
	assertGroup: S classSide slots definedBy: S classSide.
	
	assertGroup: C instanceSide slots definedBy: C instanceSide.
	assertGroup: C classSide slots definedBy: C classSide.	
)
public testQualifiedNames = (
	assert: M qualifiedName equals: 'Module'.
	assert: M header qualifiedName equals: 'Module'.
	assert: M instanceSide qualifiedName equals: 'Module'.
	assert: M classSide qualifiedName equals: 'Module class'.

	assert: S qualifiedName equals: 'Module`Super'.
	assert: S header qualifiedName equals: 'Module`Super'.
	assert: S instanceSide qualifiedName equals: 'Module`Super'.
	assert: S classSide qualifiedName equals: 'Module`Super class'.
		
	assert: C qualifiedName equals: 'Module`Class'.
	assert: C header qualifiedName equals: 'Module`Class'.
	assert: C instanceSide qualifiedName equals: 'Module`Class'.
	assert: C classSide qualifiedName equals: 'Module`Class class'.
)
public testSimpleNames = (
	assert: M simpleName equals: 'Module'.
	assert: M header simpleName equals: 'Module'.
	assert: M instanceSide simpleName equals: 'Module'.
	assert: M classSide simpleName equals: 'Module class'.

	assert: S simpleName equals: 'Super'.
	assert: S header simpleName equals: 'Super'.
	assert: S instanceSide simpleName equals: 'Super'.
	assert: S classSide simpleName equals: 'Super class'.
		
	assert: C simpleName equals: 'Class'.
	assert: C header simpleName equals: 'Class'.
	assert: C instanceSide simpleName equals: 'Class'.
	assert: C classSide simpleName equals: 'Class class'.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
class RuntimeClassTests = (
(* Encapsulate test cases that run vis-a-vis a fixed class, klass *)|
klass <Class> = makeSampleClass.
|) (
class ClassMirrorTests = TestContext (| 
	|) (
'as yet unclassified'
classOf: classMirror = (
	^(ObjectMirror reflecting: classMirror reflectee) getClass
)
public testMetaRelationships = (
	|
	mClassMirrorTests = ClassMirror reflecting: class.
	mObject = ClassMirror reflecting: Object.
	mClass = (classOf: mClassMirrorTests) superclass.
	mMetaclass = classOf: (classOf: mClassMirrorTests).
	|
	assert: mObject simpleName equals: 'Object'.
	assert: mClass simpleName equals: 'Class'.
	assert: mMetaclass simpleName equals: 'Metaclass'.
	
	assert: [mClass superclass = mObject
			or: [mClass superclass superclass = mObject]]
	description: 'Class superclass [superclass] = Object'.
	
	assert: (classOf: mObject) superclass equals: mClass.
	assert: (classOf: mClass) superclass equals: mClass.
	assert: (classOf: mClassMirrorTests) superclass equals: mClass.
	assert: (classOf: mMetaclass) superclass equals: mClass.
	
	assert: (classOf: (classOf: mObject)) equals: mMetaclass.
	assert: (classOf: (classOf: mClass)) equals: mMetaclass.
	assert: (classOf: (classOf: mMetaclass)) equals: mMetaclass.
	assert: (classOf: (classOf: mClassMirrorTests)) equals: mMetaclass.
)
public testMirror = (
	#BOGUS.  (* This was a slot but wasn't being initialized.  Problem in Minitest? *)
	^ClassMirror reflecting: klass.
)
'tests'
public testClassMirrorHasInheritedMethods = (
	(* See that mirror shows expected inherited methods *)
	assert:[testMirror methods includesMirrorNamed: #superMethod].
)
public testClassMirrorHasInheritedNestedClasses = (
	(* define a class and see that mirror shows expected inherited nested classes *)
	assert:[testMirror nestedClasses includesMirrorNamed: #SuperNested1].
	assert:[testMirror nestedClasses includesMirrorNamed: #SuperNestedClass2].
)
public testClassMirrorHasInheritedSlots = (
	(* define a class and see that mirror shows expected inherited slots *)
	assert:[testMirror slots includesMirrorNamed: #anInheritedSlot].
	assert:[testMirror slots includesMirrorNamed: #anotherInheritedSlot].
	assert:[testMirror slots includesMirrorNamed: #andYetAnother].
)
public testClassMirrorHasLocalMethods = (
	(* define a class and see that mirror shows expected local methods *)
	assert:[testMirror methods includesMirrorNamed: #unaryMethod].
	assert:[testMirror methods includesMirrorNamed: #aTernaryMethod:with:and:].
)
public testClassMirrorHasLocalNestedClasses = (
	(* define a class and see that mirror shows expected local nested classes *)
	assert:[testMirror nestedClasses includesMirrorNamed: #Nested1].
	assert:[testMirror nestedClasses includesMirrorNamed: #NestedClass2].
)
public testClassMirrorHasLocalSlots = (
	(* define a class and see that mirror shows expected local slots *)
	assert:[testMirror slots includesMirrorNamed: #aNullSlot].
	assert:[testMirror slots includesMirrorNamed: #anotherNullSlot].
	assert:[testMirror slots includesMirrorNamed: #anImmutableSlot].
	assert:[testMirror slots includesMirrorNamed: #anotherImmutableSlot].
	assert:[testMirror slots includesMirrorNamed: #aMutableSlot].
	assert:[testMirror slots includesMirrorNamed: #andAnother].
)
) : (
'test markers'
TEST_CONTEXT = ()
)
class MixinMirrorTests = TestContext (|
	|) (
'as yet unclassified'
public testMirror = (
	#BOGUS.  (* This was a slot but wasn't being initialized.  Problem in Minitest? *)
	^MixinMirror reflecting: klass mixin
)
'tests'
public testMixinMirrorMethods = (
	(* See that the mirror shows expected  methods *)
	assert:[testMirror methods includesMirrorNamed: #unaryMethod].
	assert:[testMirror methods includesMirrorNamed: #aTernaryMethod:with:and:].
)
public testMixinMirrorNestedClasses = (
	(* See that mirror shows expected  nested classes *)
	assert:[testMirror nestedClasses includesMirrorNamed: #Nested1].
	assert:[testMirror nestedClasses includesMirrorNamed: #NestedClass2].
)
public testMixinMirrorSlots = (
	(* See that mirror shows expected  slots *)
	assert:[testMirror slots includesMirrorNamed: #aNullSlot].
	assert:[testMirror slots includesMirrorNamed: #anotherNullSlot].
	assert:[testMirror slots includesMirrorNamed: #anImmutableSlot].
	assert:[testMirror slots includesMirrorNamed: #anotherImmutableSlot].
	assert:[testMirror slots includesMirrorNamed: #aMutableSlot].
	assert:[testMirror slots includesMirrorNamed: #andAnother].
	
	
	assert:[(testMirror slots findMirrorNamed: #aNullSlot) isMutable].
	assert:[(testMirror slots findMirrorNamed: #anotherNullSlot) isMutable].
	deny:[(testMirror slots findMirrorNamed: #anImmutableSlot) isMutable].
	deny:[(testMirror slots findMirrorNamed: #anotherImmutableSlot) isMutable].
)
) : (
'test markers'
TEST_CONTEXT = ()
)
'as yet unclassified'
makeSampleClass ^ <Class> = (
	(* create a test class *)
	| definingKlass <Class> |
	
	definingKlass:: classFromSource: sourceForTestClass.
	^definingKlass mixin apply: superKlass.
)
sourceForSuperClass ^ <String> = (
	^'class SampleSuperClass superFactory: x  = (
	   |
	   anInheritedSlot
	   anotherInheritedSlot andYetAnother
	    |
	   )(
	    class SuperNested1 = ()()
	
	    class SuperNestedClass2 = ()()
	    ''unclassified''
	    superMethod = (^77)
	    )
	'
)
superKlass ^ <Class> = (
	^classFromSource: sourceForSuperClass.
)
'private'
sourceForTestClass ^ <String> = (
	^'class SampleClass factory: x = (
	   |
	   aNullSlot
	   aMutableSlot ::= 0.
	   anImmutableSlot = 91.
	   anotherImmutableSlot = 42.
	    anotherNullSlot andAnother
	    |
	   )(
	    class Nested1 = ()()
	
	    class NestedClass2 = ()()
	    ''unclassified''
	    unaryMethod = (^3)
	
	    aTernaryMethod: a with: b and: c = (
	        ^a + b + c
	     )
	    )
	'
)
) : (
)
class SimulationTests = SuperSimulationTests (
(* Test that the Newspeak bytecodes run under image-side simulation and return the same results as the VM. *)) (
'as yet unclassified'
assertSimulation: block answers: result = (
	assert: [result = (ContextPart runSimulated: block)].
)
foo = (
	^'sub'
)
fooWithArg: n = (
	^'sub'
)
public testImplicitReceiverSendSimulation = (
	assertSimulation: [foo] answers: 'sub'.
	assertSimulation: [fooWithArg: 1] answers: 'sub'.
	assertSimulation: [bar] answers: 'enclosing'.
)
public testOuterExpressionSimulation = (
	assertSimulation: [outer SimulationTests] answers: outer SimulationTests.
	assertSimulation: [outer MirrorTesting] answers: outer MirrorTesting.
)
public testOuterSendSimulation = (
	assertSimulation: [outer SimulationTests foo] answers: 'sub'.
	assertSimulation: [outer SimulationTests fooWithArg: 1] answers: 'sub'.
	assertSimulation: [outer MirrorTesting foo] answers: 'enclosing'.
	assertSimulation: [outer MirrorTesting fooWithArg: 1] answers: 'enclosing'.
)
public testSelfSendSimulation = (
	assertSimulation: [self foo] answers: 'sub'.
	assertSimulation: [self fooWithArg: 1] answers: 'sub'.
)
public testSuperSendSimulation = (
	assertSimulation: [super foo] answers: 'super'.
	assertSimulation: [super fooWithArg: 1] answers: 'super'.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
class SuperSimulationTests = TestContext () (
'as yet unclassified'
foo = (
	^'super'
)
fooWithArg: n = (
	^'super'
)
) : (
)
class VMMirrorTests = TestContext (|
|) (
class A = (|
	public foo
	public bar
|) (
'as yet unclassified'
public isA = (
	^true
)
public isB = (
	^false
)
) : (
)
class B = (|
	public baz
	public quo
|) (
'as yet unclassified'
public isA = (
	^false
)
public isB = (
	^true
)
) : (
)
'as yet unclassified'
public testChangeClass = (
	| obj |
	obj:: A new.
	obj foo: 3.
	obj bar: 4.
	assert: obj isA.
	vmmirror changeClassOf: obj to: B ifFail: [:why | failWithMessage: why ].
	assert: obj isB.
	assert: obj baz equals: 3.
	assert: obj quo equals: 4.
)
) : (
'as yet unclassified'
TEST_CONTEXT = ()
)
'as yet unclassified'
bar = (
	^'enclosing'
)
classFromSource: src <String> ^<Class> = (
	^(ClassDeclarationBuilder fromSource: src) install reflectee apply: Object
)
foo = (
	^'enclosing'
)
fooWithArg: n = (
	^'enclosing'
)
) : (
)
