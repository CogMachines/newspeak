Newspeak3
'Mirrors-tests'
class MirrorTesting usingPlatform: platform  <Platform> mirrorLib:  m <NewspeakMirrors> testFramework: utf <Minitest> = (|
	private ClassDeclarationMirror = m ClassDeclarationMirror.
	private ClassDeclarationBuilder = m ClassDeclarationBuilder.
	private ClassMirror = m ClassMirror.
	private MixinMirror = m MixinMirror.
	private ObjectMirror = m ObjectMirror.
	private MessageNotUnderstood = platform blackMarket Exceptions MessageNotUnderstood.

	private TestContext = utf TestContext.

      private Smalltalk = platform blackMarket Smalltalk.
	private ContextPart = platform blackMarket ContextPart.

	private vmmirror = platform blackMarket NewspeakCore VMMirror new.
	|)
(
class ClassDeclarationBuilderTests = TestContext ()
('as yet unclassified'
testClassDeclAddMethod = (
	(* add a new method *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	|
	testBuilder:: ClassDeclarationBuilder reflecting: newClass mixin.
	testBuilder instanceSide methods addFromSource: 'foo: x = (^x * x)'.
	testMirror:: testBuilder install.
	klass:: testMirror reflectee apply: Object.
      assert: [(klass new foo: 3) = 9]. 
)
testClassDeclAddNestedClass = (
	(* add a new nested class decl *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	|
	testBuilder:: ClassDeclarationBuilder reflecting: newClass mixin.
	testBuilder instanceSide nestedClasses addFromSource: 'class Nested = ()(''cat'' foo = (^91))'.
	testMirror:: testBuilder install.
	klass:: testMirror reflectee apply: Object.
	assert: [klass new Nested new foo = 91].
)
testClassDeclChangeHeader = (
	(* add a new slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	testBuilder:: ClassDeclarationBuilder reflecting: newClass mixin.
	testBuilder headerFromSource: 'EmptyClass = ( | newSlot ::= 91. | )'.
	testMirror:: testBuilder install.
	klass:: testMirror reflectee apply: Object.
	instance:: klass new.
	assert: [instance newSlot = 91].
	instance newSlot: 101.
	assert: [instance newSlot = 101].	
)
testClassDeclCopyNested = (
	| 
	enclosingBuilder <ClassDeclarationBuilder>
	origBuilder
	origMirror
	origMixin
	copyBuilder
	copyMixin
	|
	enclosingBuilder:: ClassDeclarationBuilder fromSource: 'class Enclosing = ()()'.
	
	origBuilder:: enclosingBuilder instanceSide nestedClasses addFromSource: 'class TheOriginal = ()()'.
	origMirror:: origBuilder install.
	origMixin:: origMirror reflectee.
	assert: origMixin simpleName equals: 'TheOriginal'.
	assert: origMixin accessModifier equals: #protected.

	copyBuilder:: ClassDeclarationBuilder fromSource: origMirror source.
	copyBuilder header name: 'TheCopy'.
	enclosingBuilder instanceSide nestedClasses addMirror: copyBuilder.
	enclosingBuilder install.
	copyMixin:: copyBuilder reflectee.
	
	assert: copyMixin simpleName equals: 'TheCopy'.
	assert: copyMixin accessModifier equals: #protected.
)
testClassDeclCopyTopLevel = (
	| 
	origBuilder
	origMirror
	origMixin
	copyBuilder
	copyMixin
	|
	origBuilder:: ClassDeclarationBuilder fromSource: 'class TheOriginal = ()()'.
	origMirror:: origBuilder install.
	origMixin:: origMirror reflectee.
	assert: origMixin simpleName equals: 'TheOriginal'.
	assert: origMixin accessModifier equals: #public.
	
	copyBuilder:: ClassDeclarationBuilder fromSource: origMirror source.
	copyBuilder header name: 'TheCopy'.
	copyMixin:: copyBuilder install reflectee.
	assert: copyMixin simpleName equals: 'TheCopy'.
	assert: copyMixin accessModifier equals: #public.
)
testClassDeclModifySlot = (
	(* modify the declaration of an existing slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	klass:: classFromSource: 'class TestClassDeclModifySlot = ( | x ::= 117.  y = 0. z  | )()'.
	testBuilder:: ClassDeclarationBuilder reflecting: klass mixin.
	testBuilder headerFromSource: 'TestClassDeclModifySlot = ( | x ::= 120. y = 0.  z | )'.
	testMirror:: testBuilder install.
	assert:[testMirror instanceSide slots includesMirrorNamed: #x].
	assert:[testMirror instanceSide slots includesMirrorNamed: #y].
	assert:[testMirror instanceSide slots includesMirrorNamed: #z].
	instance:: klass new.
	assert: [instance x = 120].
	instance x: 101.
	assert: [instance x = 101].	
)
testClassDeclRemoveMethod = (
	(* remove an existing method *)
	| 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	myKlass <Class>
	|	
	myKlass:: classFromSource: 'class TestClassDeclRemoveMethod = ()(
		''unclassified''
		foo = (^91)
	      bar = (^42)
	)'.
	testBuilder::  ClassDeclarationBuilder reflecting: myKlass mixin. 
	testBuilder instanceSide methods removeMirrorNamed: 'foo'.
	testMirror:: testBuilder install.
	deny:[testMirror instanceSide methods includesMirrorNamed: #foo].
)
testClassDeclRemoveNestedClass = (
	(* remove an existing nested class *)
| builder <ClassMirrorBuilder>  outerClass <Class> |
	
	outerClass:: classFromSource: 'class TestClassDeclRemoveNestedClass = ()(
		class Nested = ()()
	)'.
	builder:: ClassDeclarationBuilder reflecting: outerClass mixin. 
	builder instanceSide nestedClasses removeMirrorNamed: #Nested.
	builder install. (* remove *)
	assert:[[outerClass new Nested. false] on: MessageNotUnderstood do:[true]].
	assert:[
		((ClassDeclarationMirror reflecting: outerClass mixin) instanceSide nestedClasses 
			findMirrorNamed: #Nested) = nil
		].(* verify *)
)
testClassDeclRemoveNonExistantMethod = (
	(* remove a non-existing method. The effect should be to do nothing, so our only goal here is to run without error *)
	| 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	myKlass <Class>
	|	
	myKlass:: classFromSource: 'class TestClassDeclRemoveMethod = ()(
		''unclassified''
		foo = (^91)
	      bar = (^42)
	)'.
	testBuilder::  ClassDeclarationBuilder reflecting: myKlass mixin. 
	testBuilder instanceSide methods removeMirrorNamed: 'baz'.
)
testClassDeclRemoveNonExistantNestedClass = (
	(* remove a non-existing nested class. The effect should be to do nothing, so our only goal here is to run without error *)
| builder <ClassMirrorBuilder>  outerClass <Class> |
	
	outerClass:: classFromSource: 'class TestClassDeclRemoveNonExistantNestedClass = ()()'.
	builder::  ClassDeclarationBuilder reflecting: outerClass mixin. 
	builder instanceSide nestedClasses removeMirrorNamed: #Nested.
)
testClassDeclRemoveSlot = (
	(* remove an existing slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	klass:: classFromSource: 'class TestClassDeclRemoveSlot = ( | x ::= 117.  y = 0. z  | )()'.
	testBuilder:: ClassDeclarationBuilder reflecting: klass mixin.
	testBuilder headerFromSource: 'TestClassDeclRemoveSlot = ( | x ::= 117. y = 0.  | )'.
	testMirror:: testBuilder install.
	deny:[testMirror instanceSide slots includesMirrorNamed: #z].
	assert:[testMirror instanceSide slots includesMirrorNamed: #y].
	assert:[testMirror instanceSide slots includesMirrorNamed: #x].
)
testClassDeclRenameNested = (
	| 
	mixin <InstanceMixin> 
	enclosingBuilder <ClassDeclarationBuilder>
	builder
	builder2
	|
	enclosingBuilder:: ClassDeclarationBuilder fromSource: 'class Enclosing = ()()'.
	builder:: enclosingBuilder instanceSide nestedClasses addFromSource: 'class OldName = ()()'.
	mixin:: builder install reflectee.
	assert: mixin simpleName equals: 'OldName'.
	builder2:: ClassDeclarationBuilder reflecting: mixin.
	builder2 header name: 'NewName'.
	builder2 install.
	assert: mixin simpleName equals: 'NewName'.
)
testClassDeclRenameNestedPrivate = (
	| 
	mixin <InstanceMixin> 
	enclosingBuilder <ClassDeclarationBuilder>
	builder
	builder2
	|
	enclosingBuilder:: ClassDeclarationBuilder fromSource: 'class Enclosing = ()()'.
	builder:: enclosingBuilder instanceSide nestedClasses addFromSource: 'private class OldName = ()()'.
	mixin:: builder install reflectee.
	assert: mixin simpleName equals: 'OldName'.
	builder2:: ClassDeclarationBuilder reflecting: mixin.
	builder2 header name: 'NewName'.
	builder2 install.
	assert: mixin simpleName equals: 'NewName'.
	assert: mixin accessModifier equals: #private.
)
testClassDeclRenameTopLevel = (
	| 
	mixin <InstanceMixin> 
	builder <ClassDeclarationBuilder>
	builder2
	|
	builder:: ClassDeclarationBuilder fromSource: 'class OldName = ()()'.
	mixin:: builder install reflectee.
	assert: mixin name equals: 'OldName'.
	builder2:: ClassDeclarationBuilder reflecting: mixin.
	builder2 header name: 'NewName'.
	builder2 install.
	assert: mixin name equals: 'NewName'.
)
testClassDeclReplaceMethod = (
	(* replace an existing method *)
	| 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	myKlass <Class>
	|	
	myKlass:: classFromSource: 'class TestClassDeclReplaceMethod = ()(
		''unclassified''
		foo = (^91)
	      bar = (^42)
	)'.
	testBuilder::  ClassDeclarationBuilder reflecting: myKlass mixin. 
	testBuilder instanceSide methods addFromSource: 'foo = (^254 + 1)'.
	testMirror:: testBuilder install.
	assert:[myKlass new foo = 255].
)
testClassDeclReplaceNestedClass = (
	(* replace an existing nested class *)
| builder <ClassMirrorBuilder>  outerClass <Class> nestedKlass <Class> instance <OuterClass> nestedInstance <OuterClass Nested> |
	
	outerClass:: classFromSource: 'class TestClassDeclReplaceNestedClass = ()(
		class Nested = ()()
	
	)'.
	instance:: outerClass new.
	nestedKlass:: instance Nested.
	nestedInstance:: nestedKlass new.
	builder::  ClassDeclarationBuilder reflecting: outerClass mixin. 
	builder instanceSide nestedClasses addFromSource: 'class Nested = (|a = 0.  b ::= 1. c|)(''cat'' foo = (^27))'.
	builder install. (* replace *)
	
	assert:[instance Nested new a = 0].
	assert:[instance Nested new b = 1].
	assert:[instance Nested new c isNil].
	assert:[instance Nested new foo = 27].
		
	assert:[nestedKlass new a = 0].
	assert:[nestedKlass new b = 1].
	assert:[nestedKlass new c isNil].
	assert:[nestedKlass new foo = 27].
	
	assert:[nestedInstance a isNil].
	assert:[nestedInstance b isNil].
	assert:[nestedInstance c isNil].
	assert:[nestedInstance foo = 27].
	
	assert:[nestedKlass = instance Nested].
	assert:[nestedInstance class = nestedKlass].

	assert:[outerClass new Nested new a = 0].
	assert:[outerClass new Nested new b = 1].
	assert:[outerClass new Nested new c isNil].
	assert:[outerClass new Nested new foo = 27].
)
testClassDeclReplaceSlot = (
	(* replace an existing slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	klass:: classFromSource: 'class TestClassDeclReplaceSlot = ( | x ::= 117.  y = 0. z  | )()'.
	testBuilder:: ClassDeclarationBuilder reflecting: klass mixin.
	testBuilder headerFromSource: 'TestClassDeclReplaceSlot = ( | a ::= 120. y = 0.  z | )'.
	testMirror:: testBuilder install.
	deny:[testMirror instanceSide slots includesMirrorNamed: #x].
	assert:[testMirror instanceSide slots includesMirrorNamed: #y].
	assert:[testMirror instanceSide slots includesMirrorNamed: #z].
	assert:[testMirror instanceSide slots includesMirrorNamed: #a].
	instance:: klass new.
	assert: [instance a = 120].
	instance a: 101.
	assert: [instance a = 101].	
)
testIncrementalScopeBuilding = (
	(* add a new method *)
	| 
	builder <ClassDeclarationBuilder> 
	klass <Class>
	ooter
	inner
	r
	|
	builder:: ClassDeclarationBuilder fromSource:
'class Outer = ( | outerSlot = 1.| )(
	class Inner = ( | innerSlot = 3.| )(
		class InnerInner = ()()
		''cat'' innerMethod = (^4)
	)
	class Sibling = ()()
	''cat'' outerMethod = (^2)
)'.
	klass:: builder install reflectee apply: Object.
	ooter:: klass new.
	inner:: ooter Inner new.

	(* Incremental eval *)
	r:: (ObjectMirror reflecting: inner) 
		evaluate: '{outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner}'
		ifCompilerError: [ compileTimeFail ] ifError: [ runtimeFail ].
	assert: r reflectee equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.
	
	(* Incremental method *)
	(builder instanceSide nestedClasses findMirrorNamed: #Inner) instanceSide methods addFromSource: 'testMethod = (^{outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner})'.
	builder install.
	assert: inner testMethod equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.
	
	(* Incremental header *)
	(builder instanceSide nestedClasses findMirrorNamed: #Inner) headerFromSource: 'Inner = ( | innerSlot = 33. testSlot = {outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner}. |)'.
	builder install.
	inner:: ooter Inner new.
	assert: inner testSlot equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.
	
	(* Incremental nested class *)
	builder instanceSide nestedClasses addFromSource: 'class Inner2 = ( | innerSlot = 333.| )(
		class InnerInner = ()()
		''cat'' innerMethod = (^444)
		testMethod = (^{outer Outer. outerSlot. outerMethod. outer Inner2. innerSlot. innerMethod. Inner2. Sibling. InnerInner})
	)'.
	builder install.
	inner:: ooter Inner2 new.
	assert: inner testMethod equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner2. ooter Sibling. inner InnerInner.}.
)'private'
emptyClassSource ^ <String> = (
	^'class EmptyClass = ()()'
)
newClass ^ <Class> = (
	^(ClassDeclarationBuilder fromSource: emptyClassSource) install reflectee apply: Object
)) : ('test markers'
TEST_CONTEXT = ())
class RuntimeClassTests = (
(* Encapsulate test cases that run vis-a-vis a fixed class, klass *)|
klass <Class> = makeSampleClass.
|)
(
class ClassMirrorTests = TestContext (| 
	|)
('as yet unclassified'
classOf: classMirror = (
	^(ObjectMirror reflecting: classMirror reflectee) getClassIfFail: [halt]
)
testMetaRelationships = (
	|
	mClassMirrorTests = ClassMirror reflecting: class.
	mObject = ClassMirror reflecting: Object.
	mClass = (classOf: mClassMirrorTests) superclass.
	mMetaclass = classOf: (classOf: mClassMirrorTests).
	|
	assert: mObject simpleName equals: 'Object'.
	assert: mClass simpleName equals: 'Class'.
	assert: mMetaclass simpleName equals: 'Metaclass'.
	
	assert: [mClass superclass = mObject
			or: [mClass superclass superclass = mObject]]
	description: 'Class superclass [superclass] = Object'.
	
	assert: (classOf: mObject) superclass equals: mClass.
	assert: (classOf: mClass) superclass equals: mClass.
	assert: (classOf: mClassMirrorTests) superclass equals: mClass.
	assert: (classOf: mMetaclass) superclass equals: mClass.
	
	assert: (classOf: (classOf: mObject)) equals: mMetaclass.
	assert: (classOf: (classOf: mClass)) equals: mMetaclass.
	assert: (classOf: (classOf: mMetaclass)) equals: mMetaclass.
	assert: (classOf: (classOf: mClassMirrorTests)) equals: mMetaclass.
)
testMirror = (
	#BOGUS.  (* This was a slot but wasn't being initialized.  Problem in Minitest? *)
	^ClassMirror reflecting: klass.
)'tests'
testClassMirrorHasInheritedMethods = (
	(* See that mirror shows expected inherited methods *)
	assert:[testMirror methods includesMirrorNamed: #superMethod].
)
testClassMirrorHasInheritedNestedClasses = (
	(* define a class and see that mirror shows expected inherited nested classes *)
	assert:[testMirror nestedClasses includesMirrorNamed: #SuperNested1].
	assert:[testMirror nestedClasses includesMirrorNamed: #SuperNestedClass2].
)
testClassMirrorHasInheritedSlots = (
	(* define a class and see that mirror shows expected inherited slots *)
	assert:[testMirror slots includesMirrorNamed: #anInheritedSlot].
	assert:[testMirror slots includesMirrorNamed: #anotherInheritedSlot].
	assert:[testMirror slots includesMirrorNamed: #andYetAnother].
)
testClassMirrorHasLocalMethods = (
	(* define a class and see that mirror shows expected local methods *)
	assert:[testMirror methods includesMirrorNamed: #unaryMethod].
	assert:[testMirror methods includesMirrorNamed: #aTernaryMethod:with:and:].
)
testClassMirrorHasLocalNestedClasses = (
	(* define a class and see that mirror shows expected local nested classes *)
	assert:[testMirror nestedClasses includesMirrorNamed: #Nested1].
	assert:[testMirror nestedClasses includesMirrorNamed: #NestedClass2].
)
testClassMirrorHasLocalSlots = (
	(* define a class and see that mirror shows expected local slots *)
	assert:[testMirror slots includesMirrorNamed: #aNullSlot].
	assert:[testMirror slots includesMirrorNamed: #anotherNullSlot].
	assert:[testMirror slots includesMirrorNamed: #anImmutableSlot].
	assert:[testMirror slots includesMirrorNamed: #anotherImmutableSlot].
	assert:[testMirror slots includesMirrorNamed: #aMutableSlot].
	assert:[testMirror slots includesMirrorNamed: #andAnother].
)) : ('test markers'
TEST_CONTEXT = ())
class MixinMirrorTests = TestContext (|
	|)
('as yet unclassified'
testMirror = (
	#BOGUS.  (* This was a slot but wasn't being initialized.  Problem in Minitest? *)
	^MixinMirror reflecting: klass mixin
)'tests'
testMixinMirrorMethods = (
	(* See that the mirror shows expected  methods *)
	assert:[testMirror methods includesMirrorNamed: #unaryMethod].
	assert:[testMirror methods includesMirrorNamed: #aTernaryMethod:with:and:].
)
testMixinMirrorNestedClasses = (
	(* See that mirror shows expected  nested classes *)
	assert:[testMirror nestedClasses includesMirrorNamed: #Nested1].
	assert:[testMirror nestedClasses includesMirrorNamed: #NestedClass2].
)
testMixinMirrorSlots = (
	(* See that mirror shows expected  slots *)
	assert:[testMirror slots includesMirrorNamed: #aNullSlot].
	assert:[testMirror slots includesMirrorNamed: #anotherNullSlot].
	assert:[testMirror slots includesMirrorNamed: #anImmutableSlot].
	assert:[testMirror slots includesMirrorNamed: #anotherImmutableSlot].
	assert:[testMirror slots includesMirrorNamed: #aMutableSlot].
	assert:[testMirror slots includesMirrorNamed: #andAnother].
	
	
	assert:[(testMirror slots findMirrorNamed: #aNullSlot) isMutable].
	assert:[(testMirror slots findMirrorNamed: #anotherNullSlot) isMutable].
	deny:[(testMirror slots findMirrorNamed: #anImmutableSlot) isMutable].
	deny:[(testMirror slots findMirrorNamed: #anotherImmutableSlot) isMutable].
)) : ('test markers'
TEST_CONTEXT = ())'as yet unclassified'
makeSampleClass ^ <Class> = (
	(* create a test class *)
	| definingKlass <Class> |
	
	definingKlass:: classFromSource: sourceForTestClass.
	^definingKlass mixin apply: superKlass.
)
sourceForSuperClass ^ <String> = (
	^'class SampleSuperClass superFactory: x  = (
	   |
	   anInheritedSlot
	   anotherInheritedSlot andYetAnother
	    |
	   )(
	    class SuperNested1 = ()()
	
	    class SuperNestedClass2 = ()()
	    ''unclassified''
	    superMethod = (^77)
	    )
	'
)
superKlass ^ <Class> = (
	^classFromSource: sourceForSuperClass.
)'private'
sourceForTestClass ^ <String> = (
	^'class SampleClass factory: x = (
	   |
	   aNullSlot
	   aMutableSlot ::= 0.
	   anImmutableSlot = 91.
	   anotherImmutableSlot = 42.
	    anotherNullSlot andAnother
	    |
	   )(
	    class Nested1 = ()()
	
	    class NestedClass2 = ()()
	    ''unclassified''
	    unaryMethod = (^3)
	
	    aTernaryMethod: a with: b and: c = (
	        ^a + b + c
	     )
	    )
	'
)) : ()
class SimulationTests = SuperSimulationTests (
(* Test that the Newspeak bytecodes run under image-side simulation and return the same results as the VM. *))
('as yet unclassified'
assertSimulation: block answers: result = (
	assert: [result = (ContextPart runSimulated: block)].
)
foo = (
	^'sub'
)
fooWithArg: n = (
	^'sub'
)
testImplicitReceiverSendSimulation = (
	assertSimulation: [foo] answers: 'sub'.
	assertSimulation: [fooWithArg: 1] answers: 'sub'.
	assertSimulation: [bar] answers: 'enclosing'.
)
testOuterExpressionSimulation = (
	assertSimulation: [outer SimulationTests] answers: outer SimulationTests.
	assertSimulation: [outer MirrorTesting] answers: outer MirrorTesting.
)
testOuterSendSimulation = (
	assertSimulation: [outer SimulationTests foo] answers: 'sub'.
	assertSimulation: [outer SimulationTests fooWithArg: 1] answers: 'sub'.
	assertSimulation: [outer MirrorTesting foo] answers: 'enclosing'.
	assertSimulation: [outer MirrorTesting fooWithArg: 1] answers: 'enclosing'.
)
testSelfSendSimulation = (
	assertSimulation: [self foo] answers: 'sub'.
	assertSimulation: [self fooWithArg: 1] answers: 'sub'.
)
testSuperSendSimulation = (
	assertSimulation: [super foo] answers: 'super'.
	assertSimulation: [super fooWithArg: 1] answers: 'super'.
)) : ('as yet unclassified'
TEST_CONTEXT = ())
class SuperSimulationTests = TestContext ()
('as yet unclassified'
foo = (
	^'super'
)
fooWithArg: n = (
	^'super'
)) : ()
class VMMirrorTests = TestContext (|
|)
(
class A = (|
	foo bar
|)
() : ()
class B = (|
	baz quo
|)
() : ()'as yet unclassified'
testChangeClass = (
	| obj |
	obj:: A new.
	obj foo: 3.
	obj bar: 4.
	vmmirror changeClassOf: obj to: B ifFail: [:why | failWithMessage: why ].
	assert: [obj class = B].
	assert: [obj baz = 3].
	assert: [obj quo = 4].
)) : ('as yet unclassified'
TEST_CONTEXT = ())'as yet unclassified'
bar = (
	^'enclosing'
)
classFromSource: src <String> ^<Class> = (
	^(ClassDeclarationBuilder fromSource: src) install reflectee apply: Object
)
foo = (
	^'enclosing'
)
fooWithArg: n = (
	^'enclosing'
)) : ()