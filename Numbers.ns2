Newspeak3
'NSKernel'
class Numbers usingPlatform: p = NewspeakObject (
"This module is not live in the system.  Numbers are still represented as instances of the Squeak classes."|
	private Interval = p collections Interval.
|)
(
class Complex real: r imaginary: i = (
"A number, but not a magnitude"|
	real <Number> = r.
	imaginary <Number> = i.
|)
('as yet unclassified'
isComplexNumber = (
	^true
))
class FixedPointNumber = (
""|
	num denom scale
|)
()
class Float = Number (|
	
|)
('as yet unclassified'
isFloat ^<Boolean> = (
	^true
))
class Fraction reducedNumerator: n <Integer> denominator: d <Integer> = Number (|
	public numerator <Integer> = n.
	public denominator <Integer> = d.
|)
('as yet unclassified'
isFraction ^<Boolean> = (
	^true
)
truncated ^<Integer> = (
	^numerator quo: denominator
)) : ('as yet unclassified'
numerator: numerator <Integer> denominator: denominator <Integer> ^<Number> = (
	"Instances of Fraction must always be in reduced form"
	| gcd numer denom |
	numerator = 0 ifTrue: [^0].
	gcd:: numerator gcd: denominator.
	numer:: numerator // gcd.
	denom:: denominator // gcd.
	denom = 1 ifTrue: [^numer].
	^Fraction reducedNumerator: numer denominator: denom
))
class Integer = Number (|
"If ^ becomes available as a selector, consider changing the bitwise operations to the convention symbols

& | ^ >> <<

Although, one might like 2^8 to mean '2 to the power of 8' rather than '2 xor 8'

"

|)
('arithmetic'
gcd: int <Integer> ^<Integer> = (
	| n m |
	n:: self.
	m:: int.
	[n = 0]
		whileFalse: 
			[n _ m \\ (m _ n)].
	^ m abs
)
lcm: int <Integer> ^<Integer> = (
	
	^self * int / (self gcd: int)
)'as yet unclassified'
timesRepeat: block <[]> ^<Self> = (
	"Normally compiled inline and therefore not subject to override"
	
	| count |
	count: 1.
	[count <= self] 	whileTrue: [
		block value.
		count: count + 1.
	]
)'bitwise'
bitAnd: int <Integer> ^<Integer> = (

)
bitInvert ^<Integer> = (

)
bitOr: int <Integer> ^<Integer> = (

)
bitShift: int <Integer> ^<Integer> = (

)
bitXor: int <Integer> ^<Integer> = (

)'testing'
isInteger ^<Boolean> = (
	^true
))
class Number = Magnitude (
"Value"|

|)
('converting'
@ y ^<Point> = (
	#BOGUS yourself.
	"Change the selector to comma so points can be represented in conventional notation: (1,2) ?"

	^Point x: self y: y
)
i ^<Complex> = (
	^Complex real: 0 imaginary: self
)'functions'
abs ^<Number> = (
	"Answer the absolute value of the receiver"
	self < 0 ifTrue: [^0 - self].
)
acos ^<Number> = (
	"Answer the arc cosine of the receiver in radians."
	^self asFloat acos
)
asin ^<Number> = (
	^self asFloat asin
)
atan ^<Number> = (
	^self asFloat atan
)
atan: denominator ^<Number> = (
	^self asFloat atan: denominator
)
cos ^<Number> = (
	^self asFloat cos
)
exp ^<Number> = (
	"Answer e raised to the power of the receiver"
	^self asFloat exp
)
ln ^<Number> = (
	"Return the natural logarithmn of the receiver"
	^self asFloat ln
)
log ^<Number> = (
	"Return the common logarithmn of the receiver"
	^self asFloat log
)
sin ^<Number> = (
	^self asFloat sin
)
tan ^<Number> = (
	^self asFloat tan
)'intervals'
to: stop <Number> ^<Interval> = (
	^Interval from: self to: stop by: 1
)
to: stop <Number> by: step <Number> ^<Interval> = (
	^Interval from: self to: stop by: step
)
to: stop <Number> by: step <Number> do: block <[Number]> = (
	"Normally compiled inline and therefore not subject to override"
	notYetImplemented
)
to: stop <Number> do: block <[Number]> = (
	"Normally compiled inline and therefore not subject to override"
	notYetImplemented
)'operations'
* number <Number> ^<Number> = (
	"Answer the receiver multiplied by the argument"
	subclassResponsibility
)
** number <Number> ^<Number> = (
	"Answer the receiver raised to the argument power"
	subclassResponsibility
)
+ number <Number> ^<Number> = (
	"Answer the sum of the receiver and the argument"
	subclassResponsibility
)
- number <Number> ^<Number> = (
	"Answer the difference of the argument from the receiver"
	subclassResponsibility
)
/ number <Number> ^<Number> = (
	"Answer the receiver divided by the argument.
	 'Exact' division. For integer division see // and quo: "
	subclassResponsibility
)
// number <Number> ^<Number> = (
	"Answer the receiver divided by the argument, rounded to nearest integer toward negative infinity.  The remainder of this division is given by \\"
	subclassResponsibility
)
\\ number <Number> ^<Number> = (
	"Answer the remainder of division rounded to the nearest integer toward negative inifinity.  The quoitent of this division is given by //"
	subclassResponsibility
)
quo: number <Number> ^<Number> = (
	"Answer the receiver divided by the argument, rounded to nearest integer toward zero.  The remainder of this division is given by rem:"
	subclassResponsibility
)
rem: number <Number> ^<Number> = (
	"Answer the remainder of division rounded to the nearest integer toward zero.  The quoitent of this division is given by quo:"
	subclassResponsibility
)'printing'
printOn: stm <WriteStream> = (
	self printOn: stm base: 10
)
printOn: stm <WriteStream> base: radix <Integer> = (
	subclassResponsibility
)
printStringBase: radix <Integer> ^<String> = (

)'rounding'
ceiling ^<Integer> = (
	"The nearest integer to the reciever toward positive infinity"
	subclassResponsibility
)
floor ^<Integer> = (
	"The nearest integer to the receiver toward negative infinity"
	subclassResponsibility
)
truncated ^<Integer> = (
	"The receiver without its fraction part"
	subclassResponsibility
)'testing'
isInfinite ^<Boolean> = (
	^false
)
isNaN ^<Boolean> = (
	^(self == self) not
)
isNumber ^<Boolean> = (
	^true
)))