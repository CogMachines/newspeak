Newspeak3
'NSAuthentication'
class UnixPAM usingPlatform: p <NsPlatform> = (
(* Top-level class to interface to Unix's Pluggable Authentication Module "PAM".
    For example the following answers if the user is authenticated w.r.t. login:
	((UnixPAM usingPlatform: BlackMarket platform) resetForNewImageSession;
		authenticate: (FillInTheBlankMorph request: 'username')
		with: (FillInTheBlankMorph requestPassword: 'password')
		for: 'login')
   The last argument should match one of the entries in /etc/pam.d.
   Eliot Miranda, 2013/4/2 *)
|
private Smalltalk = p blackMarket System SmalltalkImage current.
private Alien = p aliens Alien.
private Error = p blackMarket Exceptions Error.

(* The API functions from libpam *)
private pam_acct_mgmt
private pam_authenticate
private pam_end
private pam_get_item
private pam_set_item
private pam_start
private pam_strerror

(* The relevant constants *)
PAM_SUCCESS						= 0.
PAM_OPEN_ERR					= 1.
PAM_SYMBOL_ERR					= 2.
PAM_SERVICE_ERR					= 3.
PAM_SYSTEM_ERR					= 4.
PAM_BUF_ERR						= 5.
PAM_CONV_ERR					= 6.
PAM_PERM_DENIED					= 7.
PAM_MAXTRIES						= 8.
PAM_AUTH_ERR					= 9.
PAM_NEW_AUTHTOK_REQD		= 10.
PAM_CRED_INSUFFICIENT			= 11.
PAM_AUTHINFO_UNAVAIL			= 12.
PAM_USER_UNKNOWN				= 13.
PAM_CRED_UNAVAIL				= 14.
PAM_CRED_EXPIRED				= 15.
PAM_CRED_ERR					= 16.
PAM_ACCT_EXPIRED				= 17.
PAM_AUTHTOK_EXPIRED			= 18.
PAM_SESSION_ERR					= 19.
PAM_AUTHTOK_ERR				= 20.
PAM_AUTHTOK_RECOVERY_ERR	= 21.
PAM_AUTHTOK_LOCK_BUSY		= 22.
PAM_AUTHTOK_DISABLE_AGING	= 23.
PAM_NO_MODULE_DATA			= 24.
PAM_IGNORE						= 25.
PAM_ABORT						= 26.
PAM_TRY_AGAIN					= 27.
PAM_MODULE_UNKNOWN			= 28.
PAM_DOMAIN_UNKNOWN			= 29.

PAM_AUTHTOK = 6.
|
)
('authentication'
authenticate: username <String> with: password <String> for: servicename <String> = (
	(*  Answer if the user with the giuven password is authenticated w.r.t. servicename. *)
	| handlep conversation snstr unstr pwstr startrv endrv arv rv handle_storage |
	(* the session handle pam_handle_t * *)
	handlep:: Alien newC: Smalltalk wordSize.
	(* an empty struct pam_conv, so 16 bytes of nulls is big enough for 64-bits. *)
	conversation:: Alien newC: 16.
	snstr:: Alien newCString: servicename.
	unstr:: Alien newCString: username.
	pwstr:: Alien newCString: password.
	^[rv:: startrv:: self	start: snstr address
						user: unstr address
						conv: conversation address
						handle: handlep address.
	  rv ~= PAM_SUCCESS ifTrue:
		[(*worry not; handle is ignored by pam_strerror*)
		 self error: endrv for: handlep text: 'pam_start'].
	  rv:: self set_item: handlep type: PAM_AUTHTOK item: pwstr address.
	  rv ~= PAM_SUCCESS ifTrue:
			[self error: rv for: handlep text: 'pam_set_item'].
	  arv:: rv:: self authenticate: handlep flags: 0.
	  (rv ~= PAM_SUCCESS
	   and: [rv ~= PAM_AUTH_ERR]) ifTrue:
		[self error: rv for: handlep text: 'pam_authenticate'].
	  arv = PAM_SUCCESS]
		ensure:
			[[startrv = PAM_SUCCESS ifTrue:
				[(endrv:: self end: (handlep unsignedLongAt: 1) status: rv) ~= 0 ifTrue:
					[self error: endrv for: handlep text: 'pam_end']]]
				ensure:
					[handlep free.
					 conversation free.
					 snstr free.
					 unstr free.
					 pwstr free]]
)

'initialize-release'
resetForNewImageSession = (
	| libpam |
	libpam:: libpamName.
	pam_acct_mgmt::		Alien lookup: 'pam_acct_mgmt' inLibrary: libpam.
	pam_authenticate::		Alien lookup: 'pam_authenticate' inLibrary: libpam.
	pam_end::				Alien lookup: 'pam_end' inLibrary: libpam.
	pam_get_item::		Alien lookup: 'pam_get_item' inLibrary: libpam.
	pam_set_item::		Alien lookup: 'pam_set_item' inLibrary: libpam.
	pam_start::			Alien lookup: 'pam_start' inLibrary: libpam.
	pam_strerror::			Alien lookup: 'pam_strerror' inLibrary: libpam
)

'private'
error: pam_status <Integer> for: handlep <Alien> text: aString = (
	| result <Alien> msg <String> |
	result:: (self pam_strerror primFFICallResult: (Alien new: 4) with: handlep with: pam_status).
	msg:: (Alien forPointer: (result unsignedLongAt: 1)) strcpy.
	Error signal: aString, ' ', msg
)

private libpamName = (
	| platform |
	platform: Smalltalk os platformName.
	platform = 'Mac OS' ifTrue:
		[^'libpam.dylib' (* N.B. a symbolic link to libpam.2.dylib et al *)].
	platform = 'unix' ifTrue:
		[^'libpam.so.0'].
	^nil
)

'private-api'
private authenticate: handle flags: flags = (
	(*  int  pam_authenticate(pam_handle_t *pamh, int flags)
	 *)
	^(pam_authenticate
		primFFICallResult: (Alien new: 4)
		with: handle
		with: flags) asSignedLong
)

private end: handle status: status = (
	(*  int  pam_end(pam_handle_t *pamh, int pam_status)
	 *)
	^(pam_end
		primFFICallResult: (Alien new: 4)
		with: handle
		with: status) asSignedLong
)

private get_item: handle type: item_type itemptr: itemptr = (
	(*  int  pam_get_item(const pam_handle_t *pamh, int item_type, const void **item_p)
	 *)
	^(pam_get_item
		primFFICallResult: (Alien new: 4)
		with: handle
		with: item_type
		with: itemptr) asSignedLong
)

private manage_account: handle flags: flags = (
	(*  int  pam_acct_mgmt(pam_handle_t *pamh, int flags)
	 *)
	^(pam_acct_mgmt
		primFFICallResult: (Alien new: 4)
		with: handle
		with: flags) asSignedLong
)

private set_item: handle type: item_type item: item = (
	(*  int  pam_set_item(pam_handle_t *pamh, int item_type, void *item)
	 *)
	^(pam_set_item
		primFFICallResult: (Alien new: 4)
		with: handle
		with: item_type
		with: item) asSignedLong
)

private start: service user: user conv: conv handle: handleptr = (
	(*  int  pam_start(	const  char  *service, 
						const  char *user, const struct
						pam_conv *conv,
						pam_handle_t **pamh_p)
	 *)
	^(pam_start
		primFFICallResult: (Alien new: 4)
		with: service
		with: user
		with: conv
		with: handleptr) asSignedLong
)

) : (
)