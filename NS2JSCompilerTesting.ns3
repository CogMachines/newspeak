Newspeak3
'NS2JS Tests'
class NS2JSCompilerTesting usingPlatform: platform testFramework: testing compilationModule: compilation = (
"Tests for various things in the Newspeak2Javascript module.

   Copyright 2012 SAP AG.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"|
	private Compiler = compilation Compiler2.
	private Infrastructure = compilation InfrastructureFunctions.
	private JSComparator = compilation javascriptGeneration ASTComparator.
	private js = compilation js.
	private TestContext = testing TestContext.	

	private CrLfFileStream = platform blackMarket Files  CrLfFileStream.
	private NewShell = platform blackMarket ExternalProcess NewShell usingPlatform: platform.

	compiler
|compiler:: Compiler new)
(
class BasicStructureCompilationTests = TestContext (|
|)
('as yet unclassified'
assert: source <String> translatesToMethodWithArgs: argNames body: body <Block> withNlr: handleNlr <Boolean> = (
	| translation expected comparator |
	translation:: translateToJsTree: source.
	expected:: 
		js functionOf: argNames 
			body: (handleNlr ifTrue: [wrappedForNlr: body] ifFalse: [wrappedNoNlr: body]).
	comparator:: JSComparator new.
	assert: (comparator compare: translation and: expected)
		descriptionBlock: ['Comparator failure: ', comparator failureMessage]
)
testArgGetter = (
	assert: 'foobar: bar = ( ^bar )'
	translatesToMethodWithArgs: {'l_bar'}
	body:
		(js block: {
			js return: (js ident: 'l_bar')
			})
	withNlr: false
)
testBooleanLiteralFalse = (
	assert: 'foobar = ( ^false )'
	translatesToMethodWithArgs: {}
	body:
		(js block: {
			js return: (js literal: false)
			})
	withNlr: false
)
testBooleanLiteralTrue = (
	assert: 'foobar = ( ^true )'
	translatesToMethodWithArgs: {}
	body:
		(js block: {
			js return: (js literal: true)
			})
	withNlr: false
)
testCascadeTranslation = (
	assert: 'foobar = (self foo; bar)'
	translatesToMethodWithArgs: {}
	body:
		(js block: {
			js call: (
				js functionOf: {'cascadeReceiver@'} body: (js block: {
				"should we use cascadeReciver@ everywhere"
					js call: (js propertyOf: (js ident: 'cascadeReceiver') at: (js literal: '#foo')) with: {}.
					js return: (js call: (js propertyOf: (js ident: 'cascadeReceiver') at: (js literal: '#bar')) with: {})
					}))
				with: {js ident: 'self'}.
			js return: (js ident: 'self')
		})
	withNlr: false
	"function foobar () {
		(function (cascadeReceiver@) {
			cascadeReceiver[''foo'']();
			return cascadeReceiver[''bar'']();
		}) (self);
		return self;
	}"
)
testEmptyMethod = (
	assert: 'foobar = ()'
	translatesToMethodWithArgs: {}
	body: (js block: {js return: (js ident: 'self')})
	withNlr: false
)
testImplicitSetter = (
	"foobar:: 42
		should be rewritten as
	[:l_setter_arg@ | foobar: l_setter_arg@. l_setter_arg@] value: 42
		and further translated as
	(function (l_setter_arg@) {
		l__here[''#foobar:''](l_setter_arg@);
		return l_setter_arg@;
	})[''#value:''](42)
	"
	| setterSend function valueColon |
	setterSend::
		js call: (js propertyOf: (js ident: 'l__here') at: (js literal: '#foobar:'))
			with: {js ident: 'l_setter_arg@'}.
	function::
		js functionOf: {'l_setter_arg@'} body: (js block: {
			setterSend.
			js return: (js ident: 'l_setter_arg@')
		}).
	valueColon::
		js propertyOf: function at: (js literal: '#value:').
	assert: 'foobar = ( ^foobar:: 42 )'
	translatesToMethodWithArgs: {}
	body: 
		(js block: {
			js return: (js call: valueColon with: {js literal: 42}).
		})
	withNlr: false
)
testImplicitSetterUnusedValue = (
	assert: 'foobar = ( foobar:: 42 )'
	translatesToMethodWithArgs: {}
	body:
		(js block: {
			js call: (js propertyOf: (js ident: 'l__here') at: (js literal: '#foobar:')) with: {js literal: 42}.
			js return: (js ident: 'self')
		})
	withNlr: false
)
testNonLocalReturn = (
	| argBlock |
	argBlock::
		js functionOf: {}
			body: (js block: {
				js block: {
					js assign: (js propertyOf: (js ident: 'NLR') at: (js literal: 'value')) toBe: (js ident: 'l_x').
					js throw: (js ident: 'NLR').
				}
			}).
	assert: 'foobar: x = ( self foo: [^x] )'
	translatesToMethodWithArgs: {'l_x'}
	body:
		(js block: {
			js call: (js propertyOf: (js ident: 'self') at: (js literal: '#foo:')) with: {argBlock}.
			js return: (js ident: 'self')
		})
	withNlr: true
)
testNumberLiteral = (
	assert: 'foobar = ( ^42 )'
	translatesToMethodWithArgs: {}
	body:
		(js block: {
			js return: (js literal: 42)
		})
	withNlr: false
)
testOneParamMethod = (
	assert: 'foobar: x = ()'
	translatesToMethodWithArgs: {'l_x'}
	body: (js block: {js return: (js ident: 'self')})
	withNlr: false
)
testOneTempMethod = (
	assert: 'foobar = ( | foo | )'
	translatesToMethodWithArgs: {}
	body:
		(js block: {
			js var: 'l_foo'.
			js return: (js ident: 'self')
		})
	withNlr: false
)
testReturnParameter = (
	assert: 'foobar: x = ( ^x )'
	translatesToMethodWithArgs: {'l_x'}
	body:
		(js block: {
			js return: (js ident: 'l_x')
		})
	withNlr: false
)
testSelfSendKeyword = (
	assert: 'foobar: x = ( self foo: x )'
	translatesToMethodWithArgs: {'l_x'}
	body:
		(js block: {
			js call: (js propertyOf: (js ident: 'self') at: (js literal: '#foo:')) with: {js ident: 'l_x'}.
			js return: (js ident: 'self')
		})
	withNlr: false
)
testSelfSendKeyword2 = (
	assert: 'foobar: x and: y = ( self foo: x and: y  )'
	translatesToMethodWithArgs: {'l_x'. 'l_y'}
	body:
		(js block: {
			js call: (js propertyOf: (js ident: 'self') at: (js literal: '#foo:and:')) with: {js ident: 'l_x'. js ident: 'l_y'}.
			js return: (js ident: 'self')
		})
	withNlr: false
)
testSelfSendUnary = (
	assert: 'foobar = ( self foo  )'
	translatesToMethodWithArgs: {}
	body:
		(js block: {
			js call: (js propertyOf: (js ident: 'self') at: (js literal: '#foo')) with: {}.
			js return: (js ident: 'self')
		})
	withNlr: false
)
testStringLiteral = (
	assert: 'foobar = ( ^''foobar'' )'
	translatesToMethodWithArgs: {}
	body:
		(js block: {
			js return: (js literal: 'foobar')
		})
	withNlr: false
)
testTempGetter = (
	assert: 'foobar: bar = ( | foo | ^foo )'
	translatesToMethodWithArgs: {'l_bar'}
	body:
		(js block: {
			js var: 'l_foo'.
			js return: (js ident: 'l_foo')
		})
	withNlr: false
)
testTempSetter = (
	assert: 'foobar: bar = ( | foo | foo:: bar )'
	translatesToMethodWithArgs: {'l_bar'}
	body:
		(js block: {
			js var: 'l_foo'.
			js assign: (js ident: 'l_foo') toBe: (js ident: 'l_bar').
			js return: (js ident: 'self')
			})
	withNlr: false
)
translateToJsTree: string = (
	| source |
	source:: string readStream.
	compiler 
		beginNewCompileCycle;
		compileMethodSource: source within: nil.
	^compiler jsTree
)
wrappedAsMethodBody: block <Node>  = (
	| nlrName nlrVarNode nlrParamName nlrParamNode |
	nlrName: 'NLR'.
	nlrVarNode:: js ident: nlrName.
	nlrParamName:: nlrName, '_exception'.
	nlrParamNode:: js ident: nlrParamName.
	^js block: {
		js var: 'self' value: (js ident: 'this').
		js var: nlrName value: (js new: (js ident: 'Object') with: {}).
		js try: block catch: nlrParamName with:
			(js block: {
				js if: (js operator: '==' with: nlrVarNode and: nlrParamNode)
					then: (js return: (js propertyOf: nlrParamNode at: (js literal: 'value')))
					else: (js throw: nlrParamNode)
			})
	}
)
wrappedForNlr: block <Node>  = (
	| nlrName nlrVarNode nlrParamName nlrParamNode |
	nlrName: 'NLR'.
	nlrVarNode:: js ident: nlrName.
	nlrParamName:: nlrName, '_exception'.
	nlrParamNode:: js ident: nlrParamName.
	^js block: {
		js var: 'self' value: (js ident: 'this').
		js var: nlrName value: (js new: (js ident: 'Object') with: {}).
		js try: block catch: nlrParamName with:
			(js block: {
				js if: (js operator: '==' with: nlrVarNode and: nlrParamNode)
					then: (js return: (js propertyOf: nlrParamNode at: (js literal: 'value')))
					else: (js throw: nlrParamNode)
			})
	}
)
wrappedNoNlr: block <Node>  = (
	^js block: {js var: 'self' value: (js ident: 'this')}, block statements
)) : ('as yet unclassified'
TEST_CONTEXT = (
	
))
class ExecutionTests = TestContext (|
|)
('as yet unclassified'
basicTestSource = (
	^'
	Newsqueak2
	''NS22JS testing''
	class Simple = ( 
		|  |
	)(
	'' dummy''
	test = (^''foobar'')
	)'
)
compileClassSource: src <String> = (
	| rep <MixinRep>  file <CrLfFileStream> |
	rep:: compiler compileClassSource: src readStream within: nil "mirror mixin".
	file:: CrLfFileStream forceNewFileNamed: scriptFileName.
	[Infrastructure new outputTo: file.
	file
		cr; cr; 
		nextPutAll: 'var ';
		nextPutAll: rep first lowLevelMirror name;
		nextPutAll: ' = '.
	compiler outputTopLevelClass: rep to: file.
	file nextPutAll: ';'.
	file cr; cr;
		nextPutAll: 'print(Simple["#new"]()["#test"]())'
	] ensure:
		[file close]
)
executeScript ^<String> = (
	"Run the script expected to previously be written out to a file with the name defined by #scriptFileName."
	
	^v8 value: scriptFileName
)
scriptFileName = (
	^'/tmp/NS2JSExecutionTest.js'
)
testBasicClass = (
	compileClassSource: basicTestSource.
	assert: executeScript equals: 'foobar
'
)
v8 = (
	^NewShell perform: v8pathSelector
)
v8pathSelector ^<Symbol> = (
	^#'/usr/local/bin/v8'
)) : ('as yet unclassified'
TEST_CONTEXT = (
	
))
class JSFileWritingTests = (
"Not proper tests in the sense that they cannot fail other than on outright errors. They produce a few .js files to be manually checked for correctness."|
|)
('as yet unclassified'
cleanUp = (
)
compileClassSource: src <String> = (
	| rep <MixinRep>  file <CrLfFileStream> |
	rep:: compiler compileClassSource: src readStream within: nil "mirror mixin".
	file:: CrLfFileStream forceNewFileNamed: rep first name , '.js'.
	[compiler outputTopLevelClass: rep to: file] ensure:
		[file close]
)
testClassSide = (
	compileClassSource: '
	Newsqueak2
	''NS22JS testing''
	class Point2D_2  x: i y: j = ( 
		| x ::= i.  y ::= j. |
	)(
	'' dummy''
	rho = (^ x cos: theta)
	) : ( ''stuff''
		rho: r theta: t = (^x: rho cos: theta y: rho sin: theta)
	)'
)
testNestedClasses1 = (
	compileClassSource: '
	Newsqueak2
	''NS22JS testing''
	class Shapes = ( 
	)(
		class Shape = ()()
		
		class  Rectangle x: i y: j = Shape (
			| width = i. height = j. |
		)(
			'' nonsense ''
			area ^ <Integer> = (^ width * height)
		)
		
		class Square side: n <Integer> = Rectangle x: n y: n  ()(
			''foo''
			size ^ <Integer> = (^width)
		)
	)'
)
testNestedClasses2 = (
	compileClassSource: '
	Newsqueak2
	''NS22JS testing''
	class ColorShapes usingPlatform: platform = ( 
		| SuperShape = super Shape. Color = platform Graphics Color. |
	)(
		class Shape = SuperShape ( | color ::= defaultColor. |)(
			''whatever''
			isWhite = (^color = Color white)
		)
		'' dummy ''
		defaultColor = (^Color white)
	)'
)
testSimpleClass = (
	compileClassSource: '
	Newsqueak2
	''NS22JS testing''
	class Point2D = ( 
		| x y |
	)(
	'' dummy''
	rho = (^ x cos: (x/y cotan))
	)'
)) : ('as yet unclassified'
TEST_CONTEXT = (
))) : ()