Newspeak3
'NS2Dart'
class KernelForDart = (
(* Definitions for the built-in types of Newspeak on Dart. All sends to the receiver 'vmmirror' are evaluated at compile time by an instance of VMMirrorIntrinsics and transformed to the appropriate Dart code. Unlike the corresponding KernelForSqueak, the instance initializer of this class is never run because without pre-existing Object/Class/Metaclass/String the initialization is divergent.

**Changes to the names or superclass of the built-in types will require corresponding changes to the kernel initialization code in NS2DartCompilation`Infrastructure.**

Derived from the NS2JS Phase1Platform classes.

Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|

|) (
class Array uninstantiable = (|
|) (
'as yet unclassified'
= other = (
	self == other ifTrue: [^true].
	other isArray ifFalse: [^false].
	self size = other size ifFalse: [^false].
	1 to: size do: [:index |
		(self at: index) = (other at: index) ifFalse: [^false]].
	^true
)
at: index = (
	^dart subscript: self at: index - 1
)
at: index put: value = (
	^dart
		assign: (dart subscript: self at: (index - 1))
		toBe: value
)
binarySearchFor: el between: start and: end toCompare: compare = (
	(* This does a binary search for the index such that if el was inserted before it
	  the receiver would remain sorted.  The receiver must be sorted relative to the
	  comparison block.  The comparison block should return true if the first block argument
	  cannot appear after the second block argument *)

	| low high |
	low:: start.
	high:: end.
	[ low <= high ]
		whileTrue:
				[	| mid |
					mid:: (low + high) // 2.
	  				(compare value: (self at: mid) value: el)
						ifTrue: [ low:: mid + 1 ]	
						ifFalse: [ high:: mid - 1 ].
				].
	^low
)
collect: block = (
	| result = Array new: size. |
	1 to: size do: [:n |
		result at: n put: (block value: (self at: n))].
	^result
)
copyWith: extraElement = (
	| newSize ::= self size + 1. a |
	a:: (Array new: newSize) replaceFrom: 1 to: self size with: self.
	a at: newSize put: extraElement.
	^a
)
copyWithSize: s = (
	| safeself |
	safeself:: self.
	^(Array new: s) replaceFrom: 1 to: (s min: self size) with: safeself
)
do: block = (
	1 to: size do: [:n | block value: (self at: n)].
)
do: block separatedBy: betweenBlock = (
	| firstTime ::= true. |

	self do: [:element |
		firstTime ifTrue: [ firstTime:: false ] ifFalse: [betweenBlock value].
		block value: element].
)
first = (
	^self at: 1
)
includes: element = (

	self do: [:each | each = element ifTrue: [^true]].
	^false
)
inject: val into: f = (

	(* Taken from NSCollections *)
	| v <X> |
	v:: val.
	self do: [ :e <X> | v:: f value: v value: e ].
	^v
)
isArray = (
	^true
)
last = (
	^self at: self size
)
printString = (
	| x ::= '{'. |
	#FLAG. (* This is not safe for arrays that contain themselves. *)
	self do: [:ea | x:: x , ea printString] separatedBy: [x:: x, '. '].
	^x , '}'
)
replaceFrom: start to: stop with: replacement = (
	(* This destructively replaces elements from start to stop in the receiver. 
	Answer the receiver itself. Use copyReplaceFrom:to:with: for 
	insertion/deletion which may alter the size of the result. *)

	replacement size = (stop - start + 1)
		ifFalse: [self error: 'Size of replacement doesnt match'].
	^self replaceFrom: start to: stop with: replacement startingAt: 1
)
replaceFrom: start to: stop with: replacement startingAt: repStart = (
	(* This destructively replaces elements from start to stop in the receiver 
	starting at index, repStart, in the sequenceable collection, 
	replacementCollection. Answer the receiver. No range checks are 
	performed. *)

	| index repOff |
	repOff:: repStart - start.
	index:: start - 1.
	[(index:: index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]
)
size = (
	^dart memberOf: self at: 'length' 
)
) : (
'as yet unclassified'
INTERCEPTOR = (
	
)
new: size = (
	| a = dart new: (dart ident: 'List') with: {size}. |
	1 to: size do: [:i | a at: i put: nil].
	^a
)
new: size withAll: initialElement = (
	| a = dart new: (dart ident: 'List') with: {size}. |
	1 to: size do: [:i | a at: i put: initialElement].
	^a
)
with: element = (
	| a = self new: 1. |
	a at: 1 put: element.
	^a
)
wrapping: x = (
	5 halt.
	^x
)
)
class Behavior = (|
	superclass ::= nil.
	mixin
	enclosingObject
	hasStaticChain ::= true.
|) (
'as yet unclassified'
isMeta = (
	^false
)
) : (
)
class Block uninstantiable = (|
|) (
'as yet unclassified'
ensure: block = (
	dart 
		try: (dart block: {dart return: self value})
		finally: (dart block: {block value})
)
ifError: handlerBlock = (
	^self on: Error do: [:ex | handlerBlock value: ex]
)
public isClosure ^<Boolean> = (
	^true
)
public isFuture ^<Boolean> = (
	^false
)
numArgsError: calledWith = (
	(self Error description: 'This block accepts ', numArgs printString,
		' arguments but was called with ',calledWith printString) signal
)
on: error do: handlerBlock = (
	dart 
		try: (dart block: {
			dart return: (dart invoke: self with: {})}) 
		(* on: (dart ident: 	(names mixinClassNameFor: 'KernelForDart`Error')) *)
		catch: (dart ident: 'e_')
		with: (dart block: {
			dart
				for: (dart verbatim: 'var c_ = e_.klass_')
				while: (dart verbatim: 'c_ != nil_')
				step: (dart verbatim: 'c_ = c_.superclass_slot')
				do: (dart block: {
					dart
					if: (dart
						operator: '=='
						with: (dart ident: 'c_')
						and: error)
					then: (dart block: {
						dart return: (dart 
							invoke: handlerBlock 
							with: {dart ident: 'e_'})})
				}).
			dart rethrow
		})
)
printString = (
	^'[closure] in SomeNewspeakContext'
)
repeat = (
	[true] whileTrue: self
)
value = (
	^dart invoke: self with: {}
)
value: arg1 = (
	^dart invoke: self with: {arg1}
)
value: arg1 value: arg2 = (
	^dart invoke: self with: {arg1. arg2}
)
value: arg1 value: arg2 value: arg3 = (
	^dart invoke: self with: {arg1. arg2. arg3}
)
value: arg1 value: arg2 value: arg3 value: arg4 = (
	^dart invoke: self with: {arg1. arg2. arg3. arg4}
)
valueWithArguments: argArray = (
	^dart on: (dart ident: 'Function') invoke: (dart ident: 'apply') with: {self. argArray}
)
whileFalse = (
	^self whileFalse: [].
)
whileFalse: aBlock = (
	dart
		while: (dart prefixOperator: '!' on: (dart invoke: self with: {}))
		do: (self invoke: aBlock).
	^nil
)
whileTrue = (
	^self whileTrue: []
)
whileTrue: aBlock = (
	dart
		while: (dart invoke: self with: {})
		do: (self invoke: aBlock).
	^nil
)
) : (
'as yet unclassified'
INTERCEPTOR = (
	
)
)
class Boolean uninstantiable = () (
'as yet unclassified'
& other = (
	^dart operator: '&&' with: self and: other
)
ifFalse: else = (
	^dart ternaryIf: self then: nil else: else value
)
ifFalse: else ifTrue: then = (
	^dart ternaryIf: self then: then value else: else value
)
ifTrue: then = (
	^dart ternaryIf: self then: then value else: nil
)
ifTrue: then ifFalse: else = (
	^dart ternaryIf: self then: then value else: else value
)
not = (
	^dart prefixOperator: '!' on: self
)
value = (
	^self
)
| other = (
	^dart operator: '||' with: self and: other
)
) : (
'as yet unclassified'
INTERCEPTOR = (
	
)
)
class Class = Behavior (|
	name
|) (
'as yet unclassified'
mixinApply: superclass = (
	^vmmirror mixinApply: self to: superclass
)
printString = (
	^self name
)
) : (
)
class Error description: d <String> = (| description = d. |) (
'as yet unclassified'
printString = (
	^'NewspeakError: ',description
)
signal = (
	dart throw: self.
)
) : (
'as yet unclassified'
signal: description = (
	^(self description: description) signal
)
)
class Future computing: block <[E]> = (
(* The simplest possible future. It evalutes its closure in response to nearly every message. *)|
	private blockOrValue000 <[E] | E> ::= block.
	private state000 <Symbol> ::= #unresolved.
|) (
'as yet unclassified'
protected doesNotUnderstand: message = (
	^message sendTo: self resolve
)
public isFuture ^<Boolean> = (
	^true
)
resolve = (
	state000 = #resolving ifTrue: [
		Error signal: 'Divergent evaluation of ', blockOrValue000 printString].
	state000 = #unresolved ifTrue: [
		state000: #resolving.
		blockOrValue000: blockOrValue000 value.
		[blockOrValue000 isFuture] whileTrue:
			[blockOrValue000: blockOrValue000 resolve].
		state000: #resolved.
	].
	^blockOrValue000
)
public yourself = (
	(* See InstanceMixin>>apply:withName: *)
	^self resolve
)
) : (
'as yet unclassified'
computation: block = (
	^self computing: block
)
)
class Message selector: s arguments: a = (|
	public selectorSymbol = s.
	public arguments = a.
|) (
'as yet unclassified'
printString = (
	^'Message: ', (dart on: selectorSymbol invoke: (dart ident: 'toString') with: {})
)
selector = (
	^dart 
		on: (dart memberOf: (dart ident: 'Mirrors') at: (dart ident: 'MirrorSystem'))
		invoke: (dart ident: 'getName')
		with: {selectorSymbol}
)
sendTo: newReceiver = (
	^dart
		memberOf: (dart
			on: (dart on: (dart ident: 'Mirrors') invoke: (dart ident: 'reflect') with: {newReceiver})
			invoke: (dart ident: 'invoke')
			with: {selectorSymbol. arguments})
		at: 'reflectee'
)
) : (
)
class MessageNotUnderstood receiver: r message: m = Error description: 'MessageNotUnderstood: ', r class name, ' ', m selector (|
receiver = r.
message = m.
|) (
'as yet unclassified'
printString = (
	^description
)
) : (
)
class Metaclass = Behavior (|
	thisClass
|) (
'as yet unclassified'
isMeta = (
	^true
)
name = (
	^thisClass name, ' class'
)
printString = (
	^thisClass name, ' class'
)
) : (
)
class MutableString initialSize: n = (
(* A string whose contents (but not size) can change after it's been created. The contents are stored as an array of individual characters (which in the Dart platform means an array of 1-character strings). *)|
	private contentsArray <Array[String]> = Array new: n.
|) (
'as yet unclassified'
, anotherString = (
	| newInstance |
	newInstance:: self class new: self size + anotherString size.
	newInstance
		replaceFrom: 1 to: self size with: self startingAt: 1;
		replaceFrom: self size + 1 to: self size + 1 + anotherString size with: anotherString startingAt: 1.
	^newInstance
)
asString ^<String> = (
	^String withAll: (self collect: [:each | each])
	(* this identity collect: converts undefineds in contentsArray to null characters *)
)
asSymbol ^<String> = (
	^self asString
)
at: index <Integer> = (
	^(contentsArray at: index) ifNil: [String null] 
)
at: index <Integer> put: character <String> = (
	contentsArray at: index put: character.
	^character
)
collect: aBlock = (
	^contentsArray collect: [:each | aBlock value: (each ifNil: [String null])]
)
copyFrom: start to: stop = (
(* Answer a new mutable string with a copy of the receiver contents between the two indices, inclusive. The range is not validated; the sender must ensure its correctness. *)
	| newInstance |
	newInstance:: self class new: stop - start + 1.
	newInstance
		replaceFrom: 1 to: newInstance size with: self startingAt: start.
	^newInstance
)
copyWithSize: newSize = (
	| newString |
	newString:: self class new: newSize.
	newString
		replaceFrom: 1
		to: (newString size min: self size)
		with: self
		startingAt: 1.
	^newString
)
do: aBlock = (
	contentsArray do:
		[:each | aBlock value: (each ifNil: [String null])]
)
first = (
	^self at: 1
)
includes: element <String> = (
	self do: [:each | each = element ifTrue: [^true]].
	^false
)
isString = (
	^true
)
last = (
	^self at: self size
)
printString = (
	^'''', self asString, ''''
)
replaceFrom: start to: stop with: replacement startingAt: indexInReplacement = (
(* Destructively modify the receiver by replacing the elements between the two indices (inclusive) with those of the replacement, starting at the specified index in the replacement. Ranges are not validated; the sender must ensure their correctness. *)
	| index delta |
	index:: start.
	delta:: indexInReplacement - start.
	[index <= stop] whileTrue:
		[self at: index put: (replacement at: index + delta).
		index:: index + 1]
)
size = (
	^contentsArray size
)
) : (
'as yet unclassified'
new = (
	^self initialSize: 0
)
new: n = (
	^self initialSize: n
)
new: size <Integer> withAll: character <String> = (
	| instance |
	instance:: self initialSize: size.
	1 to: size do: [:index | instance at: index put: character].
	^instance
)
withAll: string <String> = (
	| instance |
	instance:: self initialSize: string size.
	1 to: string size do: [:index | instance at: index put: (string at: index)].
	^instance
)
)
class Number uninstantiable = (|	
|) (
'as yet unclassified'
** other = (
	^(dart on: (dart ident: 'Math') invoke: (dart ident: 'pow') with: {self. other})
)
// arg = (
 	(* from VMMaker by way of Primordial Soup *)
	 | posArg posRcvr result |
	self > 0 ifTrue: [
		arg > 0 ifTrue: [^dart operator: '~/' with: self and: arg]
		ifFalse: [
			posArg:: 0 - arg.
			^0 - (dart operator: '~/' with: (self + (posArg - 1)) and: posArg).
		 ]
	] ifFalse: [
		posRcvr:: 0 - self.
		arg > 0 ifTrue: [^0 - (dart operator: '~/' with: (posRcvr + (arg - 1)) and: arg).
		] ifFalse: [
			posArg:: 0 - arg.
			^dart operator: '~/' with: posRcvr and: posArg.
		]
	]
)
\\ arg = (
 	^self - (self // arg * arg)
)
asFloat = (
	^dart on: self invoke: (dart ident: 'toDouble') with: {}
)
asString = (
	^dart on: self invoke: (dart ident: 'toString') with: {}
)
between: min and: max = (
	^self <= max and: [ self >= min ]
)
exp = (
	^(dart on: (dart ident: 'Math') invoke: (dart ident: 'exp') with: {self})
)
isNumber = (
	^true
)
ln = (
	^(dart on: (dart ident: 'Math') invoke: (dart ident: 'log') with: {self})
)
max: other = (
	^self > other ifTrue: [ self ] ifFalse: [ other ]
)
min: other = (
	^self < other ifTrue: [ self ] ifFalse: [ other ]
)
printString = (
	^dart on: self invoke: (dart ident: 'toString') with: {}
)
rem: arg = (
	^self - ((dart operator: '~/' with: self and: arg) * arg)
)
sign = (
	self > 0 ifTrue: [^1].
	self < 0 ifTrue: [^-1].
	^0
)
sqrt = (
	^(dart on: (dart ident: 'Math') invoke: (dart ident: 'sqrt') with: {self})
)
timesRepeat: aBlock = (
	1 to: self do: [:i | aBlock value]
)
to: stop by: step do: aBlock = (
	| nextValue |
	nextValue: self.
	step = 0 ifTrue: [self error: 'step must be non-zero'].
	step < 0
		ifTrue: [[stop <= nextValue]
				whileTrue: 
					[aBlock value: nextValue.
					nextValue: nextValue + step]]
		ifFalse: [[stop >= nextValue]
				whileTrue: 
					[aBlock value: nextValue.
					nextValue: nextValue + step]]
)
to: stop do: aBlock = (
	| nextValue |
	nextValue: self.
	[nextValue <= stop]
		whileTrue: 
			[aBlock value: nextValue.
			nextValue: nextValue + 1]
)
value = (
	^self
)
) : (
'as yet unclassified'
INTERCEPTOR = (
	
)
)
class Object = Top () (
'as yet unclassified'
public = other = (
	^self == other
)
public == other = (
	^dart invoke: (dart ident: 'identical') with: { self. other }
)
protected Array = (
	^outer KernelForDart Array
)
protected Block = (
	^outer KernelForDart Block
)
protected ByteArray = (
	asYetUnimplemented
)
protected Error = (
	^outer KernelForDart Error
)
protected Future = (
	^outer KernelForDart Future
)
protected Number = (
	^outer KernelForDart Number
)
protected Object = (
	^outer KernelForDart Object
)
protected String = (
	^outer KernelForDart String
)
assert: condition <[Boolean]> message: message = (
	(* Raises an error with the given message if and only if condition evaluates to false. *)
	condition isClosure ifFalse: [Error signal: 'Block required'].
	condition value ifFalse: [Error signal: message]
)
class = (
	^dart memberOf: self at: 'klass_'
)
protected doesNotUnderstand: message = (
	^(MessageNotUnderstood receiver: self message: message) signal
)
error: description = (
	^Error signal: description
)
hash = (
	^self identityHash
)
identityHash = (
	^dart memberOf: self at: 'hashCode'
)
ifNil: nilBlock = (
	^self
)
ifNil: nilBlock ifNotNil: notNilBlock = (
	^notNilBlock value
)
ifNotNil: notNilBlock = (
	^notNilBlock value
)
isAlien = (
	#FLAG. (* Subsumed by as-yet-unimplemented auto isFoo *)
	^false
)
isCollection = (
	#FLAG. (* Subsumed by as-yet-unimplemented auto isFoo *)
	^false
)
isDictionary = (
	#FLAG. (* Subsumed by as-yet-unimplemented auto isFoo *)
	^false
)
isExpat = (
	#FLAG. (* Subsumed by as-yet-unimplemented auto isFoo *)
	^false
)
isFuture = (
	#FLAG. (* Subsumed by as-yet-unimplemented auto isFoo *)
	^false
)
isKindOfCollection = (
	#FLAG. (* Subsumed by as-yet-unimplemented auto isFoo *)
	^false
)
isMessageNode = (
	#FLAG. (* Subsumed by as-yet-unimplemented auto isFoo *)
	^false
)
isNil = (
	^false
)
isString = (
	#FLAG. (* Subsumed by as-yet-unimplemented auto isFoo *)
	^false
)
notNil = (
	^true
)
out = (
	print: self
)
print: obj = (
	(* Dart debugging: not part of the real Object API *)
	^dart invoke: (dart ident: 'print') with: {obj}
)
printString = (
	^'a ', self class name
)
yourself = (
	^self
)
) : (
)
class String uninstantiable = () (
'as yet unclassified'
, other = (
	^dart operator: '+' with: self and: other
)
asNumber = (
	^dart on: (dart ident: 'int') invoke: (dart ident: 'parse') with: {self}
)
asString = (
	^self
)
asSymbol = (
	^self
)
asciiValue = (
	^dart on: self invoke: (dart ident: 'codeUnitAt') with: {dart literal: 0}
)
at: index = (
	^dart subscript: self at: (index - 1)
)
between: min and: max = (
	#BOGUS.
	^self asciiValue <= max asciiValue and: [ self >= min asciiValue ]
)
copyFrom: start to: end = (
	^dart on: self invoke: (dart ident: 'substring') with: {start -1. end}
)
copyWithSize: newSize = (

	(* This differes from the implementation in Array in order to not rely on mutating functions *)
	| copyCount result |
	copyCount:: newSize min: self size.
	result:: self copyFrom: 1 to: copyCount.	
	[copyCount < newSize] whileTrue: [
		copyCount:: copyCount + 1.
		result:: result, ' '].
	^ result
)
do: block = (
	1 to: size do: [:n | block value: (self at: n)].
)
hash = (
	^dart memberOf: self at: 'hashCode'
)
identityHash = (
	^dart memberOf: self at: 'hashCode'
)
isKindOfCharacter = (
	^size = 1
)
isLetter = (
	| value = asciiValue. |
	^(value >= 97 and: [value <= 122]) or: [value >= 65 and: [value <= 90]]
)
isNil = (
	^false
)
isSeparator ^<Boolean> = (
	| value = asciiValue. |
	value = 32 ifTrue: [^true].	(* space *)
	value = 13 ifTrue: [^true].	(* cr *)
	value = 9 ifTrue: [^true].	(* tab *)
	value = 10 ifTrue: [^true].	(* line feed *)
	value = 12 ifTrue: [^true].	(* form feed *)
	^false
)
isString = (
	^true
)
notNil = (
	^true
)
out = (
	dart invoke: (dart ident: 'print') with: {self}
)
printString = (
	#FLAG. (* Need to escape single quotes in self *)
	^'''', self, ''''
)
size = (
	^dart memberOf: self at: 'length' 
)
) : (
'as yet unclassified'
INTERCEPTOR = (
	
)
backspace = (
	^codePoint: 16r08
)
codePoint: cp <Integer> ^<String> = (
	5 halt.
	^wrapping: (vmmirror stringWithCodePoint: cp)
)
cr = (
	^codePoint: 16r0D
)
lf = (
	^codePoint: 16r0A
)
tab = (
	^codePoint: 16r09
)
withAll: characters = (
	| x ::= ''. |
	characters do: [:char | x: x, char].
	^x
)
)
class UndefinedObject doNotInstaniate = () (
'as yet unclassified'
ifNil: nilBlock = (
	^nilBlock value
)
ifNil: nilBlock ifNotNil: notNilBlock = (
	^nilBlock value
)
ifNotNil: notNilBlock = (
	^nil
)
isNil = (
	^true
)
notNil = (
	^false
)
printString = (
	^'nil'
)
) : (
)
) : (
)
