Newspeak3
'Aliens'
class AliensForV8 usingPlatform: p = (
(* Aliens are a capability-based API for a foreign function interface (FFI). On NS2V8, they allow Newspeak code to invoke JavaScript code and vice versa.

An Alien is a Newspeak proxy for a JavaScript object. Upon receiving a message, an Alien expatriates the arguments, sends the message to the target JavaScript object, and alienates the result.

An Expat is a JavaScript proxy for a Newspeak object. Unpon receiving a message, an Expat alienates the arguments, sends the message to the target Newspeak object, and expatriates the result.

A bilingual object is one whose representation is the same in both languages: unwrapped basic types such as numbers, booleans. Note that even though Newspeak and JavaScript closures have the same representation, they are not bilingual and wrapping should occur because Newspeak closures expect Newspeak/Alien arguments and JavaScript closures expect JavaScript/Expat arguments. What about strings and arrays? It would seem we have to wrap arrays because their elements should be alieniated/expatriated. It may be safe to treat strings as bilingual if they always respond to messages with other bilingual objects.

Alien mappings:
alien sort: a ignored: b ignored: c -> alien.sort(a, b, c)
alien new: a ignored: b ignored: c  -> new alien(a, b, c)
alien at: 'a' -> alien.a
alien at: 'a' put: b -> alien.a = b

Expat mappings:
?

*)|
public global = Alien wrapping: (js verbatim: 'Function("return this;")()').
|)
(
class Alien wrapping: o = (|
private _jsTarget = o.
|)
('as yet unclassified'
at: memberName = (
	^alienate: (js propertyOf: _jsTarget at: memberName)
)
at: memberName put: value = (
	js assign: (js propertyOf: _jsTarget at: memberName) toBe: (expatriate: value).
	^value
)
doesNotUnderstand: msg = (
	| jsSelector jsArguments jsResult |
	jsArguments:: msg arguments collect: [:arg | expatriate: arg].
	jsResult::  msg selector = '$new' (* Sigh. DNU doesn't unmangle yet... *)
		ifTrue:
			[ (* var args = [null].concat(jsArguments);
				var boundFunction = _jsTarget.bind.apply(_jsTarget, args);
				return new boundFunction(); *)
			| args boundFunction |
			args:: js call: (js propertyOf: (js array: {js ident: 'null'}) at: (js literal: 'concat')) with: {jsArguments}.
			boundFunction:: (js call: (js propertyOf: (js propertyOf: _jsTarget at: (js literal: 'bind')) at: (js literal: 'apply')) with: {_jsTarget. args}).
			js new: boundFunction with: {} ]
		ifFalse:
			[ jsSelector:: copyUntilFirstColon: msg selector.
			(* return _jsTarget[jsSelector].apply(_jsTarget, jsArguments; *)
			js call: (js propertyOf: (js propertyOf:_jsTarget at: jsSelector) at: (js literal: 'apply')) 
			with: {_jsTarget. jsArguments} ].
	^alienate: jsResult
)
isAlien ^<Boolean> = (
	^true
)
isExpat ^<Boolean> = (
	^false
)
isUndefined = (
	^js operator: '===' with: _jsTarget and: (js ident: 'undefined')
)) : ()
class Expat wrapping: o = (|
private _nsTarget = o.
|)
('as yet unclassified'
doesNotUnderstand: msg = (
	|
	nsSelector = something: msg selector.
	nsArguments = msg arguments collect: [:arg | alienate: arg].
	nsResult = js
		call: (js propertyOf: (js propertyOf:_nsTarget at: nsSelector) at: (js literal: 'apply')) 
		with: {_nsTarget. nsArguments}.
	|
	^expatriate: nsResult
)
isAlien ^<Boolean> = (
	^false
)
isExpat ^<Boolean> = (
	^true
)) : ()'as yet unclassified'
alienate: jsObj = (
	#TODO.
	(js prefixOperator: 'typeof ' on: jsObj) == 'string' ifTrue: [^jsObj].
	(js prefixOperator: 'typeof ' on: jsObj) == 'number' ifTrue: [^jsObj].
	(js prefixOperator: 'typeof ' on: jsObj) == 'boolean' ifTrue: [^jsObj].
	(js operator: 'instanceof' with: jsObj and: (js propertyOf: Object runtimeClass at: (js literal: 'basicNew')))
		ifTrue:
			[jsObj isAlien ifTrue: [Error signal: 'Shouldnt be asked to double alienate...'].
			jsObj isExpat ifTrue: [^jsObj _nsTarget].
			Error signal: 'Asked to alienate a raw Newspeak object...'].
	(js operator: 'instanceof' with: jsObj and: (js ident: 'Array'))
		ifTrue: [Error signal: 'TODO: Support arrays'].
	^Alien wrapping: jsObj
)
copyUntilFirstColon: sel = (
	#BOGUS. (* DNU does not yet pass unmangled selectors. *)
	1 to: sel size do: [:i |
		((sel at: i) = $$) ifTrue: [^sel copyFrom: 1 to: i-1]].
	^sel
)
expatriate: nsObj = (
	#TODO.
	(js prefixOperator: 'typeof ' on: nsObj) == 'string' ifTrue: [^nsObj].
	(js prefixOperator: 'typeof ' on: nsObj) == 'number' ifTrue: [^nsObj].
	(js prefixOperator: 'typeof ' on: nsObj) == 'boolean' ifTrue: [^nsObj].
	(js operator: 'instanceof' with: nsObj and: (js propertyOf: Object runtimeClass at: (js literal: 'basicNew')))
		ifTrue:
			[nsObj isAlien ifTrue: [^nsObj _jsTarget].
			nsObj isExpat ifTrue: [Error signal: 'Shouldnt be asked to double expatriate...'].
			^Expat wrapping: nsObj.].
	(js operator: 'instanceof' with: nsObj and: (js ident: 'Array'))
		ifTrue: [Error signal: 'TODO: Support arrays'].
	Error signal: 'Asked to expatriate a raw JS object...'
)) : ()