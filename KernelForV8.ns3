Newspeak3
'NS2V8'
class KernelForV8 usingVmMirror: vmm = (
(*

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
Copyright 2012 Google Inc.
Copyright 2013 Ryan Macnak

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
vmmirror = vmm.
platform
|)
(
class Array uninstantiable = ()
('as yet unclassified'
, otherSequence = (
	^js call: (js propertyOf: self at: (js literal: 'concat')) with: {otherSequence asArray}
)
= other = (
	self == other ifTrue: [^true].
	other isArray ifFalse: [^false].
	self size = other size ifFalse: [^false].
	1 to: size do: [:index |
		(self at: index) = (other at: index) ifFalse: [^false]].
	^true
)
asArray = (
	^self
)
at: index = (
	^js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1))
)
at: index put: value = (
	^js assign: (js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1)))
	 toBe: value
)
binarySearchFor: el between: start and: end toCompare: compare = (
	(* This does a binary search for the index such that if el was inserted before it
	  the receiver would remain sorted.  The receiver must be sorted relative to the
	  comparison block.  The comparison block should return true if the first block argument
	  cannot appear after the second block argument *)

	| low high |
	low:: start.
	high:: end.
	[ low <= high ]
		whileTrue:
				[	| mid |
					mid:: (low + high) // 2.
	  				(compare value: (self at: mid) value: el)
						ifTrue: [ low:: mid + 1 ]	
						ifFalse: [ high:: mid - 1 ].
				].
	^low
)
class = (
	^Array
)
collect: block = (
	^js call: (js propertyOf: self at: (js literal: 'map')) with: {block}.
)
copyFrom: start to: end = (
	^js call: (js propertyOf: self at: (js literal: 'slice')) with: {start - 1. end}
)
copyWith: extraElement = (
	| newSize ::= self size + 1. a |
	a:: (Array new: newSize) replaceFrom: 1 to: self size with: self.
	a at: newSize put: extraElement.
	^a
)
copyWithSize: s = (
	^(Array new: s) replaceFrom: 1 to: (s min: self size) with: self
)
do: block = (
	js call: (js propertyOf: self at: (js literal: 'forEach')) with: {block}.
)
do: block separatedBy: betweenBlock = (
	| firstTime ::= true. |

	self do: [:element |
		firstTime ifTrue: [ firstTime:: false ] ifFalse: [betweenBlock value].
		block value: element].
)
doWithIndex: block = (
	1 to: size do: [:n | block value: (self at: n) value: n].
)
first = (
	^self at: 1
)
includes: element = (

	self do: [:each | each = element ifTrue: [^true]].
	^false
)
inject: initialValue into: accumulator = (
	^js call: (js propertyOf: self at: (js literal: 'reduce')) with: {accumulator. initialValue}.
)
isArray = (
	^true
)
isCollection ^<Boolean> = (
	^true
)
last = (
	^self at: self size
)
printString = (
	| x ::= '{'. |
	#FLAG. (* This is not safe for arrays that contain themselves. *)
	self do: [:ea | x:: x , ea printString] separatedBy: [x:: x, '. '].
	^x , '}'
)
replaceFrom: start to: stop with: replacement = (
	(* This destructively replaces elements from start to stop in the receiver. 
	Answer the receiver itself. Use copyReplaceFrom:to:with: for 
	insertion/deletion which may alter the size of the result. *)

	replacement size = (stop - start + 1)
		ifFalse: [self error: 'Size of replacement doesnt match'].
	^self replaceFrom: start to: stop with: replacement startingAt: 1
)
replaceFrom: start to: stop with: replacement startingAt: repStart = (
	(* This destructively replaces elements from start to stop in the receiver 
	starting at index, repStart, in the sequenceable collection, 
	replacementCollection. Answer the receiver. No range checks are 
	performed. *)

	| index repOff |
	repOff:: repStart - start.
	index:: start - 1.
	[(index:: index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]
)
size = (
	^js verbatim: 'this.length'
)) : ('as yet unclassified'
new = (
	^js array: {}
)
new: size = (
	^self new: size withAll: nil
)
new: size withAll: initialElement = (
	|
	array = js new: (js ident: 'Array') with: {size}.
	i ::= 0.
	|	
	js 
		for: (js verbatim: '')
		while: (js operator: '<' with: i and: size) 
		step: (js postfixOperator: '++' on: i)
		do: (js block: {
			js assign: (js propertyOf: array at: i) toBe: initialElement}).
	^array
)
with: element = (
	^{element}
))
class Block uninstantiable = ()
('as yet unclassified'
ensure: onUnwind = (
	| result |
	js try: (js block: {
		result:: self value.
	})
	catch: (js ident: 'e')
	with: (js block: {
		onUnwind value.
		js throw: (js ident: 'e').
	}).
	onUnwind value.
	^result
)
isBlock = (
	^true
)
numArgs ^<Integer> = (
	^js propertyOf: self at: (js literal: 'length')
)
on: errorClass do: handler = (
	(* Perhaps we should match on mixin instead of class... *)
	| c |
	js try: (js block: {js return: self value})
	catch: (js ident: 'e')
	with: (js block: {
		js for: (c:: (js ident: 'e') class) while: c isNil not step: (js verbatim: '') do: (js block: {
			js if: (js operator: '===' with: c and: errorClass)
			then: (js block: {js return: (handler value: (js ident: 'e'))}).
			c:: c superclass.
		}) .
		js throw: (js ident: 'e').
	})
)
value = (
	^js call: (js ident: 'this') with: {}
)
value: a1 = (
	^js call: (js ident: 'this') with: {a1}
)
value: a1 value: a2 = (
	^js call: (js ident: 'this') with: {a1. a2}
)
value: a1 value: a2 value: a3 = (
	^js call: (js ident: 'this') with: {a1. a2. a3}
)
valueWithArguments: args = (
	^js call: (js propertyOf: (js ident: 'this') at: (js literal: 'apply')) with: {js ident: 'this'. args}
)) : ()
class Boolean uninstantiable = ()
('as yet unclassified'
& other = (
	(* Evaluating conjunction. *)
	^js operator: '&&' with: self and: other
)
ifFalse: else = (
	^js ternaryIf: self then: nil else: (js call: else with: {})
)
ifFalse: else ifTrue: then = (
	^js ternaryIf: self then: (js call: then with: {}) else: (js call: else with: {})
)
ifTrue: onTrue = (
	^js ternaryIf: self then: (js call: onTrue with: {}) else: nil
)
ifTrue: then ifFalse: else = (
	^js ternaryIf: self then: (js call: then with: {}) else: (js call: else with: {})
)
isBoolean = (
	^true
)
not = (
	^js prefixOperator: '!' on: self.
)
printString = (
	^self ifTrue: ['true'] ifFalse: ['false']
)
| other = (
	(* Evaluating disjunction. *)
	^js operator: '||' with: self and: other
)) : ()
class Class = (|
superclass
mixin
enclosingObject (* Remove me *)
enclosingObjects 
name
|)
('as yet unclassified'
isBehavior = (
	^true
)
isMeta = (
	^true
)
mixinApply: newSuperclass = (
	^vmmirror 
		applyMixin: (js propertyOf: self mixin at: (js literal: 'runtimeMixin'))
		toSuperclass: newSuperclass
		withEnclosingObjects: self enclosingObjects
)) : ()
class Error description: d <String> = (| description = d. |)
('as yet unclassified'
isError = (
	^true
)
printString = (
	^description
)
signal = (
	js verbatim: 'this.trace = new Error().stack'.
	js throw: self.
)) : ('as yet unclassified'
signal: description = (
	^(self description: description) signal
))
class Future computing: block <[E]> = (
(* The simplest possible future. It evalutes its closure in response to nearly every message. *)|
	private blockOrValue000 <[E] | E> ::= block.
	private state000 <Symbol> ::= #unresolved.
|)
('as yet unclassified'
protected doesNotUnderstand: message = (
	^message sendTo: self resolve
)
public isFuture ^<Boolean> = (
	^true
)
resolve = (
	state000 = #resolving ifTrue: [
		Error signal: 'Divergent evalutation of ', blockOrValue000 printString].
	state000 = #unresolved ifTrue: [
		state000: #resolving.
		blockOrValue000: blockOrValue000 value.
		[blockOrValue000 isFuture] whileTrue:
			[blockOrValue000: blockOrValue000 resolve].
		state000: #resolved.
	].
	^blockOrValue000
)
public yourself = (
	(* See InstanceMixin>>apply:withName: *)
	^self resolve
)) : ()
class Message selector: s arguments: a = (|
	public mangledSelector = s.
	public arguments = a.
|)
('as yet unclassified'
printString = (
	^'#',selector
)
selector = (
	^vmmirror unmangleSelector: mangledSelector
)
sendTo: receiver = (
	^js call: (js propertyOf: (js propertyOf: receiver at: mangledSelector) at: (js literal: 'apply')) with: {receiver. arguments}
)) : ()
class MessageNotUnderstood receiver: r message: m = Error description: 'MessageNotUnderstood: ', r class name, '>>', m selector (|
	receiver = r.
	message = m.
|)
() : ()
class Metaclass = (
(* Describe the class in this comment. *)|
superclass
mixin
enclosingObject
name
thisClass
|)
('as yet unclassified'
isBehavior = (
	^true
)
isMeta = (
	^true
)) : ()
class Mixin fromRuntimeMixin: rm = (js assign: (js propertyOf: self at: (js literal: 'runtimeMixin')) toBe: rm.
	js assign: (js propertyOf: self at: (js literal: 'applications')) toBe: (js array: {}))
('as yet unclassified'
public applyTo: superclass <Class> ^<Class> = (
	(* assert: [isTopLevel] message: 'Only top-level mixins may be applied directly' *)
	assert: [isMeta not] message: 'Only instance-side mixins may be applied directly'.
	^self applyTo: superclass withName: (superclass name, ' <: ', name)
)
public applyTo: superclass <Class> withName: name <String> ^<Class> = (
	^vmmirror 
		applyMixin: (js propertyOf: self at: (js literal: 'runtimeMixin'))
		toSuperclass: superclass
		withEnclosingObjects: {nil}
)
public isMeta ^<Boolean> = (
	^js operator: '===' with: (js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'meta')) and: (js ident: 'undefined')
)
public name ^<Symbol> = (
	^isMeta 
		ifTrue: [(js propertyOf: (js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'nonMeta')) at: (js literal: 'name')), ' class']
		ifFalse: [js propertyOf: (js propertyOf: self at: (js literal: 'runtimeMixin')) at: (js literal: 'name')].
)
public printString ^<String> = (
	^name, ' mixin'
)) : ()
class Number uninstantiable = ()
('as yet unclassified'
* other = (
	^js operator: '*' with: self and: other
)
** exponent = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'pow')) with: {self. exponent}
)
+ other = (
	^js operator: '+' with: self and: other
)
- other = (
	^js operator: '-' with: self and: other
)
/ other = (
	^js operator: '/' with: self and: other
)
// other = (
	^(self / other) floor
)
< other = (
	^js operator: '<' with: self and: other
)
<< other = (
	^js operator: '<<' with: self and: other
)
<= other = (
	^js operator: '<=' with: self and: other
)
= other = (
	^js operator: '===' with: self and: other
)
> other = (
	^js operator: '>' with: self and: other
)
>= other = (
	^js operator: '>=' with: self and: other
)
>> other = (
	^js operator: '>>' with: self and: other
)
@ y = (
	^platform graphics Point x: self y: y
)
\\ other = (
	^self - (self // other * other)
)
abs = (
	self >= 0 ifTrue: [^self] ifFalse: [^-1.0 * self]
)
asFloat = (
	^self * 1.0
)
asInteger = (
	^self truncated
)
asString = (
	^js call: (js propertyOf: self at: (js literal: 'toString')) with: {}
)
between: min and: max = (
	^self <= max and: [ self >= min ]
)
bitAnd: other = (
	^js operator: '&' with: self and: other
)
bitXor: other = (
	^js operator: '^' with: self and: other
)
ceiling = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'ceil')) with: {self}
)
cos = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'cos')) with: {self}
)
exp = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'exp')) with: {self}
)
floor = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'floor')) with: {self}
)
hash = (
	^self rem: 16rFFFFFF
)
isNumber = (
	^true
)
ln = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'log')) with: {self}
)
max: other = (
	^self > other ifTrue: [ self ] ifFalse: [ other ]
)
min: other = (
	^self < other ifTrue: [ self ] ifFalse: [ other ]
)
printString = (
	^js call: (js propertyOf: self at: (js literal: 'toString')) with: {}
)
quo: other = (
	^(self / other) truncated
)
rem: other = (
	^self - ((self quo: other) * other)
)
sign = (
	self > 0 ifTrue: [^1].
	self < 0 ifTrue: [^-1].
	^0
)
sin = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'sin')) with: {self}
)
sqrt = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'sqrt')) with: {self}
)
tan = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'tan')) with: {self}
)
timesRepeat: block = (
	| i ::= 0. |	
	js 
		for: (js verbatim: '')
		while: (js operator: '<' with: i and: (js ident: 'this')) 
		step: (js postfixOperator: '++' on: i)
		do: (js block: {js call: block with: {}})
)
to: stop = (
	^platform collections Interval from: self to: stop
)
to: limit do: block = (
	| i ::= self. |	
	js 
		for: (js verbatim: '')
		while: (js operator: '<=' with: i and: limit) 
		step: (js postfixOperator: '++' on: i)
		do: (js block: {js call: block with: {i}})
)
truncated = (
	(* ^self > 0 ifTrue: [self floor] ifFalse: [self ceiling] *)
	^js operator: '|' with: self and: (js literal: 0)
)) : ()
class Object = ImplementationBase ()
('as yet unclassified'
= other = (
	^js operator: '===' with: self and: other
)
== other = (
	^js operator: '===' with: self and: other
)
Array = (
	^outer KernelForV8 Array
)
Character = (
	^outer KernelForV8 String
)
Error = (
	^outer KernelForV8 Error
)
Future = (
	^outer KernelForV8 Future
)
Object = (
	^outer KernelForV8 Object
)
String = (
	^outer KernelForV8 String
)
assert: condition <[Boolean]> message: message = (
	(* Raises an error with the given message if and only if condition evaluates to false. *)
	condition isBlock ifFalse: [Error signal: 'Block required'].
	condition value ifFalse: [Error signal: 'Assertion failed: ', message]
)
class = (
	^js propertyOf: (js ident: 'this') at: (js literal: 'newspeakClass')
)
doesNotUnderstand: message = (
	((message selector startsWith: 'is') and: [message arguments size = 0])
		ifTrue: [^false].
	^(MessageNotUnderstood receiver: self message: message) signal
)
hash = (
	^self identityHash
)
identityHash = (
	(* It might be worth giving every object the hashCode field at instantiation to avoid map transitions. *)
	js verbatim: 'while(this.hashCode === 0) this.hashCode = Math.random() * 0x3FFFFFF | 0'.
	^js verbatim: 'this.hashCode'
)
ifNil: nilBlock = (
	^self
)
ifNil: nilBlock ifNotNil: notNilBlock = (
	^notNilBlock value: self
)
ifNotNil: nonNilBlock = (
	^nonNilBlock value: self
)
isAlien = (
	^false
)
isBlock = (
	^false
)
isExpat = (
	^false
)
isFuture = (
	^false
)
isNil = (
	^false
)
notNil = (
	^true
)
out = (
	print: self
)
print: obj = (
	js call: (js propertyOf: (js ident: 'console') at: (js literal: 'log')) with: {obj printString}
)
printString = (
	^'instance of ', self class name
)
yourself = (
	^self
)) : ()
class String uninstantiable = ()
('as yet unclassified'
, other = (
	^js call: (js propertyOf: self at: (js literal: 'concat')) with: {other}
)
<= other = (
	^js operator: '<=' with: self and: other
)
= other = (
	^js operator: '===' with: self and: other
)
>= other = (
	^js operator: '>=' with: self and: other
)
asNumber = (
	^js call: (js ident: 'parseInt') with: {self}
)
asString = (
	^self
)
asSymbol = (
	^self
)
at: index = (
	^js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1))
)
at: index put: value = (
	^js assign: (js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1)))
	 toBe: value
)
between: min and: max = (
	^self <= max and: [ self >= min ]
)
charCode = (
	#BOGUS.
	^js verbatim: 'this.charCodeAt(0)'
)
class = (
	^String
)
copyFrom: start to: end = (
	^js call: (js propertyOf: self at: (js literal: 'substring')) with: {start - 1. end}
)
do: action = (
	|
	i ::= 0.
	len ::= js verbatim: 'this.length'.
	|
	js
		for: (js verbatim: '')
		while: (js operator: '<' with: i and: len)
		step: (js postfixOperator: '++' on: i)
		do: (js block: {
			js call: action with: {js propertyOf: self at: i}}).
)
first = (
	^self at: 1
)
hash = (
	js var: 'l' value: (js propertyOf: (js ident: 'this') at: (js literal: 'length')).
	^js ternaryIf: (js operator: '==' with: (js ident: 'l') and: (js literal: 0))
		then: (js literal: 0)
		else: (js verbatim: '(l * 32 ^ this.charCodeAt(0)) * 32 ^ this.charCodeAt(l - 1)')
)
identityHash = (
	^self hash
)
includes: object = (
	self do: [:element | object = element ifTrue: [^true]].
	^false.	
)
public inject: initialValue <X> into: foldBlock <[:X def :E | X]> ^<X> = (
	| runningValue <X> |
	runningValue:: initialValue.
	self do: [:element <X> | runningValue:: foldBlock value: runningValue value: element].
	^runningValue
)
isString = (
	^true
)
last = (
	^self at: self size
)
printString = (
	^js verbatim: '"''"+this.toString()+"''"'
)
replaceAll: substring with: newSubstring = (
	#BOGUS. (* Ought to be able to say this.replace(target, replacement, 'g'). *)
	js var: 'target' value: substring.
	js var: 'replacement' value: newSubstring.
	^js verbatim: 'this.replace(new RegExp(target.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), replacement)'
)
size = (
	^js verbatim: 'this.length'
)
splitBy: str = (
	^js call: (js propertyOf: self at: (js literal: 'split')) with: {str}
)
startsWith: substring = (
	^js operator: '==' with: (js literal: 0) and: (js call: (js propertyOf: self at: (js literal: 'indexOf')) with: {substring})
)) : ('as yet unclassified'
cr = (
	^js verbatim: '"\r"'
)
fromCharCode: unicodeValue = (
	^js call: (js propertyOf: (js ident: 'String') at: (js literal: 'fromCharCode')) with: {unicodeValue}
)
lf = (
	^js verbatim: '"\n"'
)
tab = (
	^js verbatim: '"\t"'
)
withAll: characters = (
	^js call: (js propertyOf: characters asArray at: (js literal: 'join')) with: {js literal: ''}
))
class UndefinedObject uninstantiable = ()
('as yet unclassified'
ifNil: nilBlock = (
	^nilBlock value
)
ifNil: nilBlock ifNotNil: notNilBlock = (
	^nilBlock value
)
ifNotNil: notNilBlock = (
	^self
)
isNil = (
	^true
)
notNil = (
	^false
)
printString = (
	^'nil'
)) : ()'as yet unclassified'
MutableString = (
	#BOGUS.
	^String
)
augment: prototype withPropertiesOf: runtimeClass = (
	| keys = js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'keys')) with: {runtimeClass}. |
	js call: (js propertyOf: keys at: (js literal: 'forEach')) with: {js functionOf: {'key'} body: (js block: {
		js assign: (js propertyOf: prototype at: (js ident: 'key'))
			toBe: (js propertyOf: runtimeClass at: (js ident: 'key'))
	})}.
)
augmentPrototypes = (
	js call: (js ident: 'installDnuHandlersOn') with: {js verbatim: 'Object.prototype'}.
	augment: (js verbatim: 'Array.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Array.prototype') withPropertiesOf: (js propertyOf: Array at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Boolean.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Boolean.prototype') withPropertiesOf: (js propertyOf: Boolean at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Function.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Function.prototype') withPropertiesOf: (js propertyOf: Block at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Number.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'Number.prototype') withPropertiesOf: (js propertyOf: Number at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'String.prototype') withPropertiesOf: (js propertyOf: Object at: (js literal: 'runtimeClass')).
	augment: (js verbatim: 'String.prototype') withPropertiesOf: (js propertyOf: String at: (js literal: 'runtimeClass')).
)) : ()