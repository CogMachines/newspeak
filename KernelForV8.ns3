Newspeak3
'NS2V8'
class KernelForV8 usingVmMirror: vmm = (
(*

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
Copyright 2012 Google Inc.
Copyright 2013 Ryan Macnak

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
vmmirror = vmm.
platform
|)
(
class Array uninstantiable = ()
('as yet unclassified'
= other = (
	self == other ifTrue: [^true].
	other isArray ifFalse: [^false].
	self size = other size ifFalse: [^false].
	1 to: size do: [:index |
		(self at: index) = (other at: index) ifFalse: [^false]].
	^true
)
asArray = (
	^self
)
at: index = (
	^js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1))
)
at: index put: value = (
	^js assign: (js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1)))
	 toBe: value
)
binarySearchFor: el between: start and: end toCompare: compare = (
	(* This does a binary search for the index such that if el was inserted before it
	  the receiver would remain sorted.  The receiver must be sorted relative to the
	  comparison block.  The comparison block should return true if the first block argument
	  cannot appear after the second block argument *)

	| low high |
	low:: start.
	high:: end.
	[ low <= high ]
		whileTrue:
				[	| mid |
					mid:: (low + high) // 2.
	  				(compare value: (self at: mid) value: el)
						ifTrue: [ low:: mid + 1 ]	
						ifFalse: [ high:: mid - 1 ].
				].
	^low
)
class = (
	^Array
)
collect: block = (
	^js call: (js propertyOf: self at: (js literal: 'map')) with: {block}.
)
copyWith: extraElement = (
	| newSize ::= self size + 1. a |
	a:: (Array new: newSize) replaceFrom: 1 to: self size with: self.
	a at: newSize put: extraElement.
	^a
)
copyWithSize: s = (
	^(Array new: s) replaceFrom: 1 to: (s min: self size) with: self
)
do: block = (
	js call: (js propertyOf: self at: (js literal: 'forEach')) with: {block}.
)
do: block separatedBy: betweenBlock = (
	| firstTime ::= true. |

	self do: [:element |
		firstTime ifTrue: [ firstTime:: false ] ifFalse: [betweenBlock value].
		block value: element].
)
doWithIndex: block = (
	1 to: size do: [:n | block value: (self at: n) value: n].
)
first = (
	^self at: 1
)
includes: element = (

	self do: [:each | each = element ifTrue: [^true]].
	^false
)
isArray = (
	^true
)
last = (
	^self at: self size
)
printString = (
	| x ::= '{'. |
	#FLAG. (* This is not safe for arrays that contain themselves. *)
	self do: [:ea | x:: x , ea printString] separatedBy: [x:: x, '. '].
	^x , '}'
)
replaceFrom: start to: stop with: replacement = (
	(* This destructively replaces elements from start to stop in the receiver. 
	Answer the receiver itself. Use copyReplaceFrom:to:with: for 
	insertion/deletion which may alter the size of the result. *)

	replacement size = (stop - start + 1)
		ifFalse: [self error: 'Size of replacement doesnt match'].
	^self replaceFrom: start to: stop with: replacement startingAt: 1
)
replaceFrom: start to: stop with: replacement startingAt: repStart = (
	(* This destructively replaces elements from start to stop in the receiver 
	starting at index, repStart, in the sequenceable collection, 
	replacementCollection. Answer the receiver. No range checks are 
	performed. *)

	| index repOff |
	repOff:: repStart - start.
	index:: start - 1.
	[(index:: index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]
)
size = (
	^js verbatim: 'this.length'
)) : ('as yet unclassified'
new = (
	^js array: {}
)
new: size = (
	^self new: size withAll: nil
)
new: size withAll: initialElement = (
	|
	array = js new: (js ident: 'Array') with: {size}.
	i ::= 0.
	|	
	js 
		for: (js verbatim: '')
		while: (js operator: '<' with: i and: size) 
		step: (js postfixOperator: '++' on: i)
		do: (js block: {
			js assign: (js propertyOf: array at: i) toBe: initialElement}).
	^array
)
with: element = (
	^{element}
))
class Block uninstantiable = ()
('as yet unclassified'
isBlock = (
	^true
)
numArgs ^<Integer> = (
	^js propertyOf: self at: (js literal: 'length')
)
value = (
	^js call: (js ident: 'this') with: {}
)
value: a1 = (
	^js call: (js ident: 'this') with: {a1}
)
value: a1 value: a2 = (
	^js call: (js ident: 'this') with: {a1. a2}
)
value: a1 value: a2 value: a3 = (
	^js call: (js ident: 'this') with: {a1. a2. a3}
)
valueWithArguments: args = (
	^js call: (js propertyOf: (js ident: 'this') at: (js literal: 'apply')) with: {js ident: 'this'. args}
)) : ()
class Boolean uninstantiable = ()
('as yet unclassified'
& other = (
	(* Evaluating conjunction. *)
	^js operator: '&&' with: self and: other
)
ifFalse: else = (
	^js ternaryIf: self then: nil else: (js call: else with: {})
)
ifFalse: else ifTrue: then = (
	^js ternaryIf: self then: (js call: then with: {}) else: (js call: else with: {})
)
ifTrue: onTrue = (
	^js ternaryIf: self then: (js call: onTrue with: {}) else: nil
)
ifTrue: then ifFalse: else = (
	^js ternaryIf: self then: (js call: then with: {}) else: (js call: else with: {})
)
not = (
	^js prefixOperator: '!' on: self.
)
printString = (
	^self ifTrue: ['true'] ifFalse: ['false']
)
| other = (
	(* Evaluating disjunction. *)
	^js operator: '||' with: self and: other
)) : ()
class Class = (|
superclass
mixin
enclosingObject
enclosingObjects (*Pick one*)
name
runtimeClass (* Remove me *)
|)
('as yet unclassified'
isMeta = (
	^true
)
mixinApply: newSuperclass = (
	^vmmirror applyMixin: self mixin runtimeMixin toSuperclass: newSuperclass withEnclosingObjects: self enclosingObjects
)) : ()
class Error description: d <String> = (| description = d. |)
('as yet unclassified'
signal = (
	js throw: self.
)) : ('as yet unclassified'
signal: description = (
	^(self description: description) signal
))
class Future computing: block <[E]> = (
(* The simplest possible future. It evalutes its closure in response to nearly every message. *)|
	private blockOrValue000 <[E] | E> ::= block.
	private state000 <Symbol> ::= #unresolved.
|)
('as yet unclassified'
protected doesNotUnderstand: message = (
	^message sendTo: self resolve
)
public isFuture ^<Boolean> = (
	^true
)
public printString = (
	^self resolve printString
)
resolve = (
	state000 = #resolving ifTrue: [
		Error signal: 'Divergent evalutation of ', blockOrValue000 printString].
	state000 = #unresolved ifTrue: [
		state000: #resolving.
		blockOrValue000: blockOrValue000 value.
		[blockOrValue000 isFuture] whileTrue:
			[blockOrValue000: blockOrValue000 resolve].
		state000: #resolved.
	].
	^blockOrValue000
)
public yourself = (
	(* See InstanceMixin>>apply:withName: *)
	^self resolve
)) : ()
class Message selector: s arguments: a = (|
	public mangledSelector = s.
	public arguments = a.
|)
('as yet unclassified'
printString = (
	^'#',selector
)
selector = (
	^vmmirror unmangleSelector: mangledSelector
)
sendTo: receiver = (
	^js call: (js propertyOf: (js propertyOf: receiver at: mangledSelector) at: (js literal: 'apply')) with: {receiver. arguments}
)) : ()
class Metaclass = (
(* Describe the class in this comment. *)|
superclass
mixin
enclosingObject
name
thisClass
runtimeClass
|)
('as yet unclassified'
isMeta = (
	^true
)) : ()
class Mixin fromRuntimeMixin: rm = (|
runtimeMixin = rm.
|)
('as yet unclassified'
classMixin = (
	^Mixin fromRuntimeMixin: (js propertyOf: runtimeMixin at: (js literal: 'meta'))
)
isMeta = (
	^js operator: '===' with: (js propertyOf: runtimeMixin at: (js literal: 'meta')) and: (js ident: 'undefined')
)
name = (
	^isMeta 
		ifTrue: [(js propertyOf: (js propertyOf: runtimeMixin at: (js literal: 'nonMeta')) at: (js literal: 'name')), ' class']
		ifFalse: [js propertyOf: runtimeMixin at: (js literal: 'name')].
)
printString = (
	^name, ' mixin'
)) : ()
class Number uninstantiable = ()
('as yet unclassified'
* other = (
	^js operator: '*' with: self and: other
)
+ other = (
	^js operator: '+' with: self and: other
)
- other = (
	^js operator: '-' with: self and: other
)
/ other = (
	^js operator: '/' with: self and: other
)
// other = (
	^(self / other) floor
)
< other = (
	^js operator: '<' with: self and: other
)
<< other = (
	^js operator: '<<' with: self and: other
)
<= other = (
	^js operator: '<=' with: self and: other
)
= other = (
	^js operator: '==' with: self and: other
)
> other = (
	^js operator: '>' with: self and: other
)
>= other = (
	^js operator: '>=' with: self and: other
)
>> other = (
	^js operator: '>>' with: self and: other
)
@ y = (
	^platform graphics Point x: self y: y
)
\\ other = (
	^self - (self // other * other)
)
abs = (
	self >= 0 ifTrue: [^self] ifFalse: [^-1.0 * self]
)
asFloat = (
	^self * 1.0
)
asInteger = (
	^self truncated
)
asString = (
	^js call: (js propertyOf: self at: (js literal: 'toString')) with: {}
)
between: min and: max = (
	^self <= max and: [ self >= min ]
)
bitAnd: other = (
	^js operator: '&' with: self and: other
)
bitXor: other = (
	^js operator: '^' with: self and: other
)
ceiling = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'ceil')) with: {self}
)
cos = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'cos')) with: {self}
)
floor = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'floor')) with: {self}
)
hash = (
	^self rem: 16rFFFFFF
)
max: other = (
	^self > other ifTrue: [ self ] ifFalse: [ other ]
)
min: other = (
	^self < other ifTrue: [ self ] ifFalse: [ other ]
)
printString = (
	^js call: (js propertyOf: self at: (js literal: 'toString')) with: {}
)
quo: other = (
	^(self / other) truncated
)
rem: other = (
	^self - ((self quo: other) * other)
)
sign = (
	self > 0 ifTrue: [^1].
	self < 0 ifTrue: [^-1].
	^0
)
sin = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'sin')) with: {self}
)
sqrt = (
	^js call: (js propertyOf: (js ident: 'Math') at: (js literal: 'sqrt')) with: {self}
)
timesRepeat: block = (
	| i ::= 0. |	
	js 
		for: (js verbatim: '')
		while: (js operator: '<' with: i and: (js ident: 'this')) 
		step: (js postfixOperator: '++' on: i)
		do: (js block: {js call: block with: {}})
)
to: limit do: block = (
	| i ::= self. |	
	js 
		for: (js verbatim: '')
		while: (js operator: '<=' with: i and: limit) 
		step: (js postfixOperator: '++' on: i)
		do: (js block: {js call: block with: {i}})
)
truncated = (
	(* ^self > 0 ifTrue: [self floor] ifFalse: [self ceiling] *)
	^js operator: '|' with: self and: (js literal: 0)
)) : ()
class Object = ImplementationBase ()
('as yet unclassified'
= other = (
	^self == other
)
== other = (
	^js operator: '===' with: self and: other
)
Array = (
	^outer KernelForV8 Array
)
Error = (
	^outer KernelForV8 Error
)
Future = (
	^outer KernelForV8 Future
)
Object = (
	^outer KernelForV8 Object
)
String = (
	^outer KernelForV8 String
)
assert: condition <[Boolean]> message: message = (
	(* Raises an error with the given message if and only if condition evaluates to false. *)
	condition isBlock ifFalse: [Error signal: 'Block required'].
	condition value ifFalse: [Error signal: message]
)
class = (
	^js propertyOf: (js ident: 'this') at: (js literal: 'newspeakClass')
)
doesNotUnderstand: message = (
	js throw: 'MessageNotUnderstood: ', class name, '>>', message selector.
)
hash = (
	^self identityHash
)
identityHash = (
	(* It might be worth giving every object the hashCode field at instantiation to avoid map transitions. *)
	js verbatim: 'if(this.hashCode === undefined) this.hashCode = Math.random() * 0x3FFFFFF | 0'.
	^js verbatim: 'this.hashCode'
)
isAlien = (
	^false
)
isBlock = (
	^false
)
isExpat = (
	^false
)
isFuture = (
	^false
)
isNil = (
	^false
)
notNil = (
	^true
)
out = (
	print: self
)
print: obj = (
	js call: (js propertyOf: (js ident: 'console') at: (js literal: 'log')) with: {obj printString}
)
printString = (
	^'instance of ', self class name
)
yourself = (
	^self
)) : ()
class String uninstantiable = ()
('as yet unclassified'
, other = (
	^js call: (js propertyOf: self at: (js literal: 'concat')) with: {other}
)
<= other = (
	^js operator: '<=' with: self and: other
)
= other = (
	^js operator: '==' with: self and: other
)
>= other = (
	^js operator: '>=' with: self and: other
)
asNumber = (
	^js call: (js ident: 'parseInt') with: {self}
)
asString = (
	^self
)
asSymbol = (
	^self
)
at: index = (
	^js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1))
)
at: index put: value = (
	^js assign: (js propertyOf: (js ident: 'this') at: (js operator: '-' with: index and: (js literal: 1)))
	 toBe: value
)
between: min and: max = (
	^self <= max and: [ self >= min ]
)
class = (
	^String
)
copyFrom: start to: end = (
	^js call: (js propertyOf: self at: (js literal: 'substring')) with: {start - 1. end}
)
do: action = (
	|
	i ::= 0.
	len ::= js verbatim: 'this.length'.
	|
	js
		for: (js verbatim: '')
		while: (js operator: '<' with: i and: len)
		step: (js postfixOperator: '++' on: i)
		do: (js block: {
			js call: action with: {js propertyOf: self at: i}}).
)
hash = (
	js var: 'l' value: (js propertyOf: (js ident: 'this') at: (js literal: 'length')).
	^js ternaryIf: (js operator: '==' with: (js ident: 'l') and: (js literal: 0))
		then: (js literal: 0)
		else: (js verbatim: '(l * 32 ^ this.charCodeAt(0)) * 32 ^ this.charCodeAt(l - 1)')
)
identityHash = (
	^self hash
)
printString = (
	^js verbatim: '"''"+this.toString()+"''"'
)
size = (
	^js verbatim: 'this.length'
)
splitBy: str = (
	^js call: (js propertyOf: self at: (js literal: 'split')) with: {str}
)) : ('as yet unclassified'
fromCharCode: unicodeValue = (
	^js call: (js propertyOf: (js ident: 'String') at: (js literal: 'fromCharCode')) with: {unicodeValue}
)
withAll: characters = (
	^js call: (js propertyOf: characters asArray at: (js literal: 'join')) with: {js literal: ''}
))
class UndefinedObject uninstantiable = ()
('as yet unclassified'
isNil = (
	^true
)
notNil = (
	^false
)
printString = (
	^'nil'
)) : ()'as yet unclassified'
MutableString = (
	#BOGUS.
	^String
)
augment: prototype withPropertiesOf: runtimeClass = (
	(* Note this also copies inherited properties from (Newspeak)Object and ImplementationBase. *)
	js for: (js var: 'propertyName') in: runtimeClass do: (js block: {
		js assign: (js propertyOf: prototype at: (js ident: 'propertyName'))
			toBe: (js propertyOf: runtimeClass at: (js ident: 'propertyName'))
	})
)
augmentPrototypes = (
	augment: (js verbatim: 'Array.prototype') withPropertiesOf: Array runtimeClass.
	augment: (js verbatim: 'Boolean.prototype') withPropertiesOf: Boolean runtimeClass.
	augment: (js verbatim: 'Function.prototype') withPropertiesOf: Block runtimeClass.
	augment: (js verbatim: 'Number.prototype') withPropertiesOf: Number runtimeClass.
	augment: (js verbatim: 'String.prototype') withPropertiesOf: String runtimeClass.
	(* We install the DNU handlers after augmenting the built-in prototypes so they will NOT be added to the built-in prototypes. *)
	js call: (js ident: 'installDnuHandlersOn') with: {js verbatim: 'vmmirror.$ImplementationBase().$runtimeClass$slot'}
)) : ()