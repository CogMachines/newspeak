Newspeak3
'Samples'
class HopscotchWebIDE using: p <Platform>
  browsing: B <SimpleBrowsing class>
  namespacing: N <NamespacingForV8 class>
  workspaceManager: W <WorkspaceManagerForV8 class>
  minitest: M <Minitest class>
  minitestUI: MUI <MinitestUI class>
  colorization: C <NewspeakColorization class>
  images: Images <HopscotchImages class> = ( 
(* I am to the IDE as Platform is to the runtime.  I wire together and store the IDE modules. *)|| 
	(* imports  *)
	private Browsing = B.
	private Namespacing = N. 
	private WorkspaceManager = W.
	private Minitest = M.
	private MinitestUI = MUI.
	private NewspeakColorization = C.

	(* Simultaneous slots for IDE components *)
	public browsing <SimpleBrowsing> = Browsing usingPlatform: p ide: self.
	public namespacing <NamespacingForV8> = Namespacing usingPlatform: p.
	public theWorkspaceManager <WorkspaceManagerForV8> = WorkspaceManager usingPlatform: p ide: self.
	public minitest <Minitest> = Minitest usingPlatform: p.
	public minitestUI <MinitestUI> (*= MintestsUO usingPlatform: p minitest: minitest ide: self.*)
	public colorizer <NewspeakColorization> = (NewspeakColorization usingPlatform: p) NS3BrowserColorizer new.
	
	public images <HopscotchImages> = Images new.
	||populateNamespaceUsingPlatform: p) (
populateIconNamespace: ns  <HopscotchImages> ^ <Namespace> = (
	^ns
		at: 'publicAccessImage' put: images publicAccessImage;
		at: 'protectedAccessImage' put: images protectedAccessImage;
		at: 'privateAccessImage' put: images privateAccessImage;
		at: 'addImage' put: images addImage;
		at: 'addOutImage' put: images addOutImage;
		at: 'addOverImage' put: images addOverImage;
		at: 'dropDownImage' put: images dropDownImage;
		at: 'dropDownOutImage' put: images dropDownOutImage;
		at: 'dropDownOverImage' put: images dropDownOverImage;
		at: 'expandImage' put: images expandImage;
		at: 'expandOverImage' put: images expandOverImage;
		at: 'expandDownImage' put: images expandDownImage;
		at: 'collapseImage' put: images collapseImage;
		at: 'collapseOverImage' put: images collapseOverImage;
		at: 'collapseDownImage' put: images collapseDownImage;
		at: 'classPresenterIcon' put: images classPresenterIcon;
		at: 'classUnknownIcon' put: images classUnknownIcon;
		at: 'classIcon' put: images classIcon;
		yourself
)
populateNamespaceUsingPlatform: p <Platform> ^ <Namespace> = (
  | 
  platformMirror <ObjectMirror> = p mirrors ObjectMirror reflecting: p.
  platformClass <ClassMirror> = topLevelClassOf: platformMirror. 
  namespace <Namespace> = namespacing Root.
  |

	namespace
	      at: 'Icons' put: (populateIconNamespace: namespacing freshNamespace);
		at: platformClass name put: platformClass reflectee;
		at: 'SimpleBrowsing' put: Browsing;
		at: 'Minitest' put: Minitest;
		at: 'MinitestUI' put: MinitestUI;
		at: 'NamespacingForV8' put: Namespacing;
		at: 'NewspeakColorization2' put: NewspeakColorization;
		at: 'WorkspaceManagerForV8' put: WorkspaceManager.
 
     platformMirror getClass slots do: [:s <SlotMirror> |  | klass <ClassMIrror> o <ObjectMirror>  |
		o:: platformMirror getSlot: s name.
		klass:: topLevelClassOf: (p mirrors ObjectMirror reflecting: o reflectee yourself). (* Work around futures!
		The seemingly pointless exercise above extracts the reflectee from an ObjectMirror, invokes yourself on it and 
		wraps the result in an ObjectMirror again. Usually, yourself is an identity and all this would be a waste, but yourself
		is used to force the resolution of futures, so we get the actual instances.
		 *)
		namespace at: klass name put: klass reflectee.
		].
	^namespace
)
topLevelClassOf: om <ObjectMirror> ^ <ClassMirror> = (
	| klass <ClassMirror> ::= om getClass.  |
	[klass enclosingObject reflectee isNil] whileFalse: [klass:: klass enclosingObject getClass].
      ^klass
)
) : (
)
