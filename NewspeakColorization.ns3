Newspeak3
'HopscotchIDE'
class NewspeakColorization usingPlatform: p = (|
private Color = p graphics Color.
private Dictionary = p collections Dictionary.
private OrderedCollection = p collections OrderedCollection.
private TokenizingParser = p mirrors parserLib TokenizingParser.	
private TypedNS3Grammar = p mirrors grammar TypedNS3Grammar.

private ImplementationBase = p squeak ImplementationBase.
private TextColor = p squeak TextColor.
private TextEmphasis = p squeak TextEmphasis.
private SHRange = p squeak SHRange.
|) (
public class NS3BrowserColorizer = NS3Colorizer (|
	coloredText
|) (
'as yet unclassified'
applyColor: kind from: start to: end  = (
(* Hacked up to roughly match the table in SHTextStylerST80 newsqueakStyleTable.
The advantage is that this code is not dependent on Shout *)

	({#error. #undefinedUnary. #undefinedKeyword. #undefinedBinary.} includes: kind)
		ifTrue:
			[ coloredText addAttribute: TextColor red from: start to: end.
			coloredText addAttribute: TextEmphasis underlined from: start to: end.
			^self ].

	({#shadowingTempVar. #obsoleteMessage} includes: kind)
		ifTrue:
			[coloredText addAttribute: TextEmphasis bold from: start to: end.
			coloredText addAttribute: (TextColor color: Color orange) from: start to: end.
			coloredText addAttribute: TextEmphasis underlined from: start to: end.
			^self ].

	({#incompleteKeyword. #incompleteBinary. #incompleteUnary.} includes: kind)
		ifTrue:
			[ coloredText addAttribute: TextEmphasis underlined from: start to: end. ^self ].

	({ #self. #super. #outer. #true. #false. #nil. #string. #symbol. #stringSymbol. #number. #character.  #protected. #private. #public } includes: kind)
		ifTrue:
			[ 
			 coloredText addAttribute: TextColor gray from: start to: end. 
			^self 
			].
		
	({#tempVar. #blockTempVar. #blockPatternArg. #patternArg. #patternTempVar} includes: kind)
		ifTrue:
			[ coloredText addAttribute: TextEmphasis bold from: start to: end. 
			  coloredText addAttribute: TextColor gray from: start to: end. 
			^self 
			].
		
			({#methodTempBar. #leftParenthesis. #rightParenthesis.  #leftParenthesis3. #rightParenthesis3.  #leftParenthesis6. #rightParenthesis6. #blockStart. #blockEnd.  #blockStart3. #blockEnd3.  #blockStart6. #blockEnd6.  #leftBrace. #rightBrace.  #leftBrace3. #rightBrace3.  #leftBrace6. #rightBrace6. 
} includes: kind)
		ifTrue:
			[ coloredText addAttribute: TextEmphasis bold from: start to: end. 
			  coloredText addAttribute: TextColor black from: start to: end. 
			^self 
			].
	#slotDecl = kind
		ifTrue:
			[ coloredText addAttribute: TextEmphasis bold from: start to: end. 
			  coloredText addAttribute: TextColor gray from: start to: end. 
			^self 
			].

	({#messagePatternDecl. #className} includes: kind)
		ifTrue:
			[ coloredText addAttribute: TextEmphasis bold from: start to: end. ^self ].
		
	kind = #comment
		ifTrue:[ coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end. 
			^self ].
		
		({#type. #return. #leftParenthesis1. #rightParenthesis1.  #leftParenthesis4. #rightParenthesis4. #leftParenthesis7. #rightParenthesis7. #blockStart1. #blockEnd1.  #blockStart4. #blockEnd4.  #blockStart7. #blockEnd7.  #leftBrace1. #rightBrace1.  #leftBrace4. #rightBrace4.  #leftBrace7. #rightBrace7.} includes: kind)
		ifTrue:
			[ coloredText addAttribute: TextEmphasis bold from: start to: end. 
			  coloredText addAttribute: (TextColor color: Color blue twiceDarker) from: start to: end. 
			^self ].
		({#leftParenthesis2. #rightParenthesis2. #leftParenthesis5. #rightParenthesis5.   #blockStart2. #blockEnd2.  #blockStart5. #blockEnd5.  #leftBrace2. #rightBrace2.  #leftBrace5. #rightBrace5 } includes: kind)
		  ifTrue:[coloredText addAttribute: TextEmphasis bold from: start to: end. 
			  coloredText addAttribute: (TextColor color: Color magenta twiceDarker) from: start to: end. 
			].

	(* Transcript show: kind; cr. *)
)
applyRanges =(	
	rangeMap do: [ :blk | blk value ].
	^coloredText
)
classDefinitionTemplate = (
	^(tokenFromSymbol: #class), [classHeader]
)
noteRange: kind from: start to: end = (
	assert: [start between: 1 and: inputSize] message: 'bad start'.
	assert: [end between: 1 and: inputSize] message: 'bad end'.
	rangeMap add: [ applyColor: kind from: start to: end ].
)
public parseText: s <String> fromClass: c <Class> usingSelector: selector <Symbol> ^<Text> = (
	| stream parser |

	assert: [s isString].

	inputSize:: s size.
	klass:: c.
	bracketDepth:: 0.
	braceDepth:: 0.
	parenDepth:: 0.
	rangeMap:: OrderedCollection new.
	cachedScopeStack: nil.

	coloredText:: s asText.
	stream:: s readStream.

	parser:: (perform: selector), eoi.
	parser parse: stream ifError: [:msg :pos |
		(* The range 0..size is degenerate and leads to errors in Squeak 5.0 Morphic layout of paragraphs. *)
		noteRange: #error from: (pos = 0 ifTrue: [1] ifFalse: [pos]) to: inputSize.
		^applyRanges ].
	^applyRanges
)
rangesIn: s classOrMetaClass: c workspace: w environment: e = (
^Error signal
)
) : (
)
class NS3Colorizer = TypedNS3Grammar (|
	cachedScopeStack
	klass
	rangeMap
	inputSize
	startComment
	braceDepth
	bracketDepth
	parenDepth
	isFirst ::= true.
|) (
'as yet unclassified'
accessModifier = (
	^super accessModifier wrapper: [ :mod :ws |
		noteRange: mod token asSymbol from: mod start to: mod end.
		mod]
)
beginComment = (
	^ (TokenizingParser withSubparser: super beginComment) 
			wrap:[:t | 
				self noteRange: #unfinishedComment from: t start to: self inputSize. t].
)
binaryMsgPattern = (
^super binaryMsgPattern
    wrapper:[:sel <Token>  :p <Tuple[Token, Token]> |
	          self pushScope.
	          self currentScope at: p first token put: #parameter.
                self noteRange: #messagePatternDecl from: sel start to: sel end.
                self noteRange: #patternArg from: p first start to: p first end.             
               ].
)
binarySelector = (
	^super binarySelector wrap:
		[:t | | kind |
		kind:: selector: t token 
			ifDefined: [#binary] 
			ifIncomplete: [#incompleteBinary]
			ifUndefined: [#undefinedBinary] 
			ifObsolete: [#obsoleteMessage].
		self noteRange: kind from: t start to: t end.
		t].
)
block = (
^super block 
   wrapper:[:lb :params :cb :rb |
                  params isNil ifFalse:[params isEmpty ifFalse:[self popScope]].
                  {lb. params. cb. rb}
  ]
)
blockParameter = (
	^super blockParameter wrapper: [ :cn :sd | (* blockParameter ::= colon, slotDecl *)
		| kind |
		kind:: (symbolInScope: sd first token) ifTrue: [#shadowingTempVar] ifFalse: [#blockPatternArg].
		noteRange: kind from: sd first start to: sd first end.
		sd]
)
blockParameters = (
^super blockParameters
   wrapper:[:ps :vb  | self pushScope. 
	                         ps do:[:p | self currentScope at: p first token put: #parameter].
	                         {ps. vb}
	          ]
)
braceLevelString = (
^self braceDepth = 1 ifTrue:[''] ifFalse:[self braceDepth printString]
)
bracketLevelString = (
	^ self bracketDepth = 1 ifTrue:[''] ifFalse:[self bracketDepth printString]
)
characterConstant = (
	^ super characterConstant 
		   wrap:[: t | self noteRange: #'$' from: t start to: t end. t].
)
public classHeader = (
	^super classHeader
		wrap:
			[ :tokens |
			(tokens at: 9) = nil ifFalse:
				[ | decs |
					decs:: (tokens at: 9) size = 3 ifTrue: [
						((tokens at: 9) at: 2) ] ifFalse: [(tokens at: 9) at: 3].			
					
					decs
					do: [ :each | noteRange: #slotDecl from: (each at: 2) first start to: (each at: 2) first end ] ].
			tokens ]
)
public codeBody = (
^super codeBody
  wrapper:[:litMsg :tmps :stmts | tmps isNil ifFalse:[tmps isEmpty ifFalse:[self popScope]].
	                                 {tmps. stmts}
	         ]
)
comment = (
	^super comment
		wrapper: [:token | self noteRange: #comment from: token start to: token end].
)
currentScope = (
self assert: [self scopeStack isEmpty not].
^self scopeStack last
)
decreaseBraceLevel = (
	self braceDepth: (self braceDepth - 1) \\ 7.
)
decreaseBracketLevel = (
self bracketDepth: (self bracketDepth - 1) \\ 7.
)
decreaseParenLevel = (
self parenDepth: (self parenDepth - 1) \\ 7.
)
endComment = (
^(TokenizingParser withSubparser: super endComment) wrap:[:t | self rangeMap removeLast. t].
)
extendedCanUnderstand: sel = (
	| k |
	k: klass.
	[k isNil] whileFalse: [
		(k canUnderstand: sel) ifTrue: [^true].
		k: k enclosingClass.
	].

	klass mixin applications do: [:any | ^any canUnderstand: sel].
	^Object canUnderstand: sel
)
increaseBraceLevel = (
self braceDepth: (self braceDepth + 1) \\ 7.
)
increaseBracketLevel = (
self bracketDepth: (self bracketDepth + 1) \\ 7.
)
increaseParenLevel = (
	self parenDepth: (self parenDepth + 1) \\ 7.
)
keywordHereSend = (
	^super keywordHereSend wrap:[ :kws | | sel  kind  |
		sel:: String streamContents: [ :s |
			kws do: [ :kwd |
				self rangeMap removeLast.
				s nextPutAll: kwd first token]].
		kind:: symbol: sel
			ifInScope: [#instVar] ifNotInScope: [#undefinedKeyword] ifObsolete: [#obsoleteMessage].
		kws do: [:kwp |
			self noteRange: kind from: kwp first start to: kwp first end]]
)
keywordMsg = (
	^super keywordMsg wrapper:
		[:esend :kws |
		| sel kind |
		sel:: (kws inject:'' into: [:s :kwd | s, (kwd at:1) token]) asString.
		kind:: selector: sel 
			ifDefined: [#keyword] 
			ifIncomplete: [#incompleteKeyword]
			ifUndefined: [#undefinedKeyword] 
			ifObsolete: [#obsoleteMessage].
		kws do: [:kwp | self noteRange: kind from: kwp first start to: kwp first end]].
)
keywordMsgPattern = (
	^super keywordMsgPattern wrap: [ :kws |
		assert: [kws isEmpty not].
		pushScope.
		kws do: [ :kwp | | kind |
			kind:: (symbolInScope: kwp last first token) ifTrue: [#shadowingTempVar] ifFalse: [#patternArg].
			currentScope at: kwp last first token put: #parameter.
			noteRange: #messagePatternDecl from: kwp first start to: kwp first end.
			noteRange: kind from: kwp last first start to: kwp last first end]]
)
lbracket = (
^super lbracket
   wrap:[:t | 
           | range |
           self increaseBracketLevel.
           range:: ('blockStart', self bracketLevelString) asSymbol.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
lcurly = (
^super lcurly
   wrap:[:t | 
           | range |
           self increaseBraceLevel.
           range:: ('leftBrace', self braceLevelString) asSymbol.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
lparen = (
^super lparen 
   wrap:[:t | 
           | range |
           self increaseParenLevel.
           range:: ('leftParenthesis', self parenLevelString) asSymbol.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
method = (
| res |
  self pushScope.
  res:: super method.
  self popScope.
  ^res
)
nestedClassDecl = (
	^super nestedClassDecl
		wrap:
			[ :tokens | (* accessModifier opt, classDeclaration*)
			noteRange: #className from: ((tokens last) at: 2) start to: ((tokens last) at: 2) end.
			tokens ]
)
noteRange: kind from: start to: end  = (
self rangeMap addLast: (SHRange new start: start; end: end; type: kind).
)
number = (
^super number
   wrap:[: t | self noteRange: #number from: t start to: t end. t].
)
parenLevelString = (
	^self parenDepth = 1 ifTrue:[''] ifFalse:[self parenDepth printString]
)
pattern = (
^super pattern
   wrap:[ :tpl | self noteRange: #string 
					from: (tpl at: 1) start 
					to: (tpl at: 3) end.
			tpl at: 2 ]
)
popScope = (
	self scopeStack removeLast
)
pushScope = (
self scopeStack addLast: Dictionary new
)
rangesIn: s classOrMetaClass: c workspace: w environment: e = (
| defaultRange input  |

self inputSize: s size.
self rangeMap: (OrderedCollection new: self inputSize).
self klass: c.
self bracketDepth: 0.
self braceDepth: 0.
self parenDepth: 0.
input:: s readStream.

defaultRange:: SHRange new start:1; end: self inputSize; type: #default.
self rangeMap add: defaultRange.
self methodDecl parse: input ifError:[:msg :pos | 
                                        self rangeMap add:( SHRange new start:(pos max:1); end: self inputSize; type:#excessCode).
                                        ^self rangeMap.
                                       ].
input position < self inputSize 
   ifTrue:[self rangeMap add:( SHRange new start: input position + 1 ; end: self inputSize; type:#excessCode)].
^self rangeMap
)
rbracket = (
^super rbracket
   wrap:[:t | 
           | range |
           range:: ('blockEnd', self bracketLevelString) asSymbol.
           self decreaseBracketLevel.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
rcurly = (
^super rcurly 
   wrap:[:t | 
           | range |
           range:: ('rightBrace', self braceLevelString) asSymbol.
           self decreaseBraceLevel.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
returnStatement = (
^super returnStatement
  wrapper:[:h <Token>  : expr :od <Token>  | 
               self noteRange: #return from: h start to: h end.
               expr
             ].
)
returnType = (
^super returnType
   wrapper:[:h <Token> :t | self noteRange: #type from: h start to: h end. t]
)
rparen = (
^super rparen 
   wrap:[:t | 
           | range |
           range:: ('rightParenthesis', self parenLevelString) asSymbol.
           self decreaseParenLevel.
           self noteRange: range from: t start to: t end. 
           t.
          ]
)
scopeStack = (
	(* deal with forwarding reference *)
	cachedScopeStack isCollection 
		ifFalse: [ cachedScopeStack:: OrderedCollection new ].
	^ cachedScopeStack
)
selector: sel ifDefined: definedAction ifIncomplete: incompleteAction ifUndefined: undefinedAction ifObsolete: obsoleteAction = (
	({#isKindOf:. #out. #halt. #inspect. #flag:. #instVarAt:. #isMemberOf:. #~} includes: sel) ifTrue: [^obsoleteAction value].
	Symbol hasInterned: sel ifTrue: [:s | ^definedAction value].
	(Symbol thatStartsCaseSensitive: sel skipping: nil) isNil
		ifTrue: [^incompleteAction value]
		ifFalse: [^undefinedAction value]
)
semicolon = (
^super semicolon
  wrap:[:t | self noteRange: #cascadeSeparator from: t start to: t end. t].
)
setterKeyword = (
	^super setterKeyword wrap:[ :skw <Token> | | kind  |
		kind:: (self symbolInScope: (skw token copyUpToLast: ":"))
			ifTrue:[#instVar]
			ifFalse:[#undefinedKeyword].
		self noteRange: kind from: skw  start to: skw end.
		skw]
	)
slotDef = (
	^ super slotDef wrap: [ :tokens | | sd kind |
		sd:: (tokens at: 2) first.
		noteRange: #slotDecl from: sd start to: sd end.
		
		(* isFirst ifTrue: [pushScope. isFirst: false]. *)
		
		tokens]
)
slotName = (
	^super slotName wrap: [:n <Token> |
		| kind |
		kind:: ({'self'. 'super'. 'outer'. 'true'. 'false'. 'nil'. 'thisContext'} includes: n token)
			ifTrue: [n token asSymbol]
                  ifFalse: [symbol: n token
			ifInScope: [#instVar] ifNotInScope: [#undefinedUnary] ifObsolete: [#obsoleteMessage]].
		noteRange: kind from: n start to: n end.
		n]
)
string = (
^super string
   wrap:[:t | self noteRange: #string from: t start to: t end. t]
)
symbol: aString <String> ifInScope: inScopeAction ifNotInScope: notInScopeAction ifObsolete: obsoleteAction = (
	scopeStack do: [:s | (s includesKey: aString) ifTrue:[^inScopeAction value]].
	Symbol hasInterned: aString ifTrue: [ :sel <Symbol> |
		scopeStack do: [:s | (s includesKey: sel) ifTrue:[^inScopeAction value]].
		(extendedCanUnderstand: sel) ifTrue:[
			(ImplementationBase canUnderstand: sel)
				ifTrue: [^obsoleteAction value]
				ifFalse: [^inScopeAction value]]].
	^notInScopeAction value
)
symbolConstant = (
^super symbolConstant
   wrapper:[:p <Token>  :s | 
               self noteRange: #symbol from: p start to: s end.
               s.
              ].
)
symbolInScope: aString <String> ^ <Boolean> = (
	scopeStack do: [:s | (s includesKey: aString) ifTrue:[^true]].
	^Symbol hasInterned: aString ifTrue: [ :sel <Symbol> |
		scopeStack do: [:s | (s includesKey: sel) ifTrue:[^true]].
		(extendedCanUnderstand: sel) ifTrue:[^true].
		^false]
)
tempSlotDef = (
	^ super slotDef wrap: [ :tokens | | sd kind |
		sd:: (tokens at: 2) first.
		noteRange: #slotDecl from: sd start to: sd end.
		
		isFirst ifTrue: [pushScope. isFirst: false].
		
		kind:: (symbolInScope: sd token) ifTrue: [#shadowingTempVar] ifFalse: [#tempVar].
		currentScope at: sd token put: #temporary.
		currentScope at: sd token, ':' put: #temporary.
		noteRange: kind from: sd start to: sd end.
		
		tokens]
)
temporaries = (

	|
	tempSlotDefs = tempSlotDef star.
 	tempSeqSlotDecls = vbar, tempSlotDefs, vbar.
 	tempSimSlotDecls = vbar, vbar, tempSlotDefs, vbar, vbar.
 	tempSlotDecls = tempSimSlotDecls | tempSeqSlotDecls.
	|

^ tempSlotDecls wrap: [ :parts | 
	| vb1 vb2 vds vb3 vb4 |
	
	parts size = 3 ifTrue: [ 
		vb1:: parts at: 1.
		vb2:: vb1. 
		vds:: parts at: 2. 
		vb3:: parts at: 3.
		vb4:: vb3] ifFalse: [ 
		vb1:: parts at: 1. 
		vb2:: parts at: 2.
		vds:: parts at: 3.
		vb3:: parts at: 4.
		vb4:: parts at: 5].
	
	isFirst: true.
	noteRange: #methodTempBar from: vb1 start to: vb2 end.
	noteRange: #methodTempBar from: vb3 start to: vb4 end.
	vds]
)
type = (
^super type
   wrapper:[:lb :te : rb | self noteRange: #type from: lb start to: rb end. te]
)
unaryMsgPattern = (
	^super unaryMsgPattern
		wrap:
			[:sel <Symbol> |
			self noteRange: #messagePatternDecl from: sel start to: sel end.
			sel ].
)
unarySelector = (
	^super unarySelector wrap:
		[:t | | kind |
		kind:: selector: t token 
			ifDefined: [#unary] 
			ifIncomplete: [#incompleteUnary]
			ifUndefined: [#undefinedUnary] 
			ifObsolete: [#obsoleteMessage].
		self noteRange: kind from: t start to: t end.
		t].
)
variableName = (
^super variableName
  wrap:[:n <Token> |   n token = 'self'
                  ifTrue:[self noteRange: #self from: n start to: n end]
                  ifFalse:[n token = 'super' ifTrue:[self noteRange: #super from: n start to: n end]
                  ifFalse:[n token = 'true' ifTrue:[self noteRange: #true from: n start to: n end]
                  ifFalse:[n token = 'false' ifTrue:[self noteRange: #false from: n start to: n end]
                  ifFalse:[n token = 'nil' ifTrue:[self noteRange: #nil from: n start to: n end]
                  ifFalse:[n token = 'thisContext' ifTrue:[self noteRange: #thisContext from: n start to: n end]
                  ifFalse:[]]]]]].
             n.
         ]
)
) : (
)
) : (
)
