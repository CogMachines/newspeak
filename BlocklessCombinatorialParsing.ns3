Newspeak3
'NS2 Combinatorial Parsing'
class BlocklessCombinatorialParsing usingLib: platform = Object usingLib: platform (
(*A submodule that does not strictly require blocks to be used as inputs to the sequencing and
 alternating  combinators

   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)| 
  SuperCombinatorialParser <CombinatorialParser class> = super CombinatorialParser.
  SuperSequentialParser = super SequentialParser.
  SuperAlternatingParser = super AlternatingParser.
  Dictionary = platform collections Dictionary.
  List = platform collections OrderedCollection.
  ObjectMirror = platform mirrors ObjectMirror.
  |)
(
class AlternatingParser = SuperAlternatingParser ()
('initialization'
either: pf1 or: pf2 = (
 
  pfun:: pf1.
  qfun:: pf2
)) : ()
class CombinatorialParser = SuperCombinatorialParser (|
	name|)
('as yet unclassified'
printOn: stm = (
	name isNil ifTrue: [super printOn: stm] ifFalse: [stm nextPutAll: name]
)
ultimateParser = (
(*Used to bypass 0 .. n ForwardReferenceParsers to get to the real parser.  Usually, this is self. Only ForwardReferenceParsers forward the request to their forwardee*)
	^self
)'combinators'
& p <CombinatorialParser> ^ <CombinatorialParser> = (
 
(*The sequencing combinator (implicit in BNF). *)
| o  |

o:: List new add: self; add: p; yourself.
^SequentialParser new on: o
)) : ()
class ExecutableGrammar = CombinatorialParser (
(*This class is intended to implement Parser
Combinators. A ExecutableGrammar[T]
returns a value of type T after successful
parsing.

The class is abstract. It does not implement
 the parsing routine parse:ifError: .
 
If parsing fails, parse:ifError: should call the error handling block
passed to it.

Concrete subclasses should implement specific grammars.

Parsing is initiated by calling parse:ifError:. This routine takes a ReadStream[Object] as input.
If parsing fails, it is the caller''s responsibility to set the input stream back to its original position
(Q: is this a good idea?).
If an error occurs, the error block passed in is called.*)| 
	forwardReferenceTable ::= Dictionary new.
	protected  selfMirror <ObjectMirror> = ObjectMirror reflecting: self. 
|self setupForwardReferences.
  self bindForwardReferences)
('forward references'
bindForwardReferences = (
   forwardReferenceTable values do:[:v | v bindingRoutine:[finalBindForwardReferences]].
)
finalBindForwardReferences = (
  self forwardReferenceTable keysAndValuesDo:[:k :v | | p |
	p:: (selfMirror getSlot: k asSymbol ifFail:[]) reflecteeIfFail:[].
	(p isKindOfCombinatorialParser) ifTrue:[
		v bind: p.
		p name: k (* a good place to name the productions*)
	]]
)
setupForwardReferences = ( 
  (*go thru all non-nil instance variables and set them to a fresh forward reference*)
(*If these do not correspond to productions, they will be overridden by the subclass*)
  (selfMirror getClassIfFail:[]) slots do:[: slot <SlotMirror> |  | fref iv |
	iv:: slot name.
	fref::  ForwardReferenceParser new.
	(selfMirror getSlot: iv asSymbol ifFail:[]) reflectee isNil ifTrue:[
		self forwardReferenceTable at: iv put: fref.
		(*set iv to fref*)
		selfMirror  setSlot: iv asSymbol  to: fref ifFail:[].
		]
	]
	 
)) : ()
class ForwardReferenceParser = CombinatorialParser (| forwardee bindingRoutine |)
('access'
bind: p <CombinatorialParser> = (
  (p isKindOfCombinatorialParser) ifTrue:[forwardee: p]
(*as a precaution, only bind if p is a parser*)
)'as yet unclassified'
parserToForwardTo ^ <CombinatorialParser> = (
	forwardee isNil ifTrue:[bindingRoutine value].
	^forwardee
)
ultimateParser^ <CombinatorialParser> = (
	^parserToForwardTo ultimateParser
)
wrapper: blk ^ <CombinatorialParser> = (
(*see comments in ForwardingWrappingParser*)

^ForwardingWrappingParser new wrapParser: self withWrapper: blk
)'combinators'
& p <CombinatorialParser> ^ <CombinatorialParser> = (
^forwardee isNil ifTrue:[super & p]
                 ifFalse:[forwardee  & p]

)
opt = (
^forwardee isNil ifTrue:[super opt]
                 ifFalse:[forwardee opt]
)
| p = (
^forwardee isNil ifTrue:[super | p]
                 ifFalse:[forwardee | p]
)'parsing'
parse: input inContext: context  ifError: blk = (

^parserToForwardTo parse: input inContext: context  ifError: blk.
)) : ()
class ForwardingWrappingParser = WrappingParser (
(*When a ForwardingReferenceParser is wrapped using the wrapper:  combinator, we don't know what the  arity the wrapping block should have - it will depend on the arity of the parser we forward to.  We cannot determine whether to use the implementation of wrapper: given in ordinary parsers, which forwards to the wrap: combinator (designed for block with arity 1) or the implementation used in SequentialParsers, (designed for n-ary blocks, where n is the length of the list of parsers the SequentialParser sequences). Instead, we must defer the decision on how to handle the situation until the parser tree is complete. This is accomplished by using this class as the result of the wrapper: combinator for ForwardReferenceParser.  

Instances of this class determiine how to act when asked to parse. At that time, the parse tree must be complete, and they can ask the ultimate parser for a wrappin parser that is suitable configured, and forward requests to it. *)|
	wrappingParser
|)
('as yet unclassified'
parse: input inContext: context ifError: blk = (
 

^trueWrappingParser parse: input inContext: context ifError: blk 
)
trueWrappingParser ^ <WrappingParser> = (
	wrappingParser isNil ifTrue:[
		wrappingParser:: parser ultimateParser wrapper: wrapperBlock
		].
	^wrappingParser
)) : ()
class SequentialParser = SuperSequentialParser ()
('accessing - private'
parsers = (

	(*accessor for parsers that caches value of all blocks*)
	subparsers isNil
		ifTrue: [subparsers:: parserFuns
						collect: [:pf | pf value]].
	^ subparsers
)'combinators'
, p <CombinatorialParser> ^ <SequentialParser> = (
 

| o  |

o:: List new addAll:  parserFuns; add: p; yourself.
^SequentialParser new on: o
)) : ()) : ()