Newspeak3
'Hopscotch-Core'
class HopscotchFramework usingPlatform: platform = (
(* Hopscotch is Newspeak's highly composable application framework.

Vassili Bykov. Hopscotch: Toward User Interface Composition
http://bracha.org/hopscotch-wasdett.pdf

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009 Ryan Macnak and other contributors.
Copyright 2012 Cadence Design Systems, Inc.
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
	public HopscotchImages = platform blackMarket HopscotchImages. (* I tried to pull this into the module except ns2 won't compile the methods because the literals are too large *)
      private Form = platform blackMarket Form.
	private Color = platform blackMarket Graphics Color.
	private Point = platform blackMarket Graphics Point.
	private Clipboard = platform blackMarket Clipboard.
	private Cursor = platform blackMarket Graphics Cursor.
	private Rectangle = platform blackMarket Graphics Rectangle.
	private SharedQueue = platform blackMarket Collections SharedQueue.
	private Processor = platform blackMarket Processor.
	private World = platform blackMarket World.
	private Request = platform blackMarket HostSystem Request.

	private OrderedCollection = platform collections OrderedCollection.
	private Dictionary = platform collections Dictionary.

	private brazil = platform brazil.
	private Anchor = brazil areas Anchor.
	private CellWidthEqualizer = brazil areas CellWidthEqualizer.
	private Frame = brazil areas Frame.
	private Menu = brazil menus Menu.
	private MenuItem = brazil menus MenuItem.
	private SeparatorItem = brazil menus SeparatorItem.
	private SubmenuItem = brazil menus SubmenuItem.
	private AdHocMessageReceiver = brazil manipulation AdHocMessageReceiver.
	private DragSource = brazil manipulation DragSource.
	private DropTarget = brazil manipulation DropTarget.
	private DragDropTracker = brazil manipulation DragDropTracker.
	private ArbitraryArityBlockWrapper = brazil manipulation ArbitraryArityBlockWrapper.
	private Font = brazil plumbing Font.
	private Gradient = brazil plumbing Gradient.
	private Viewport = brazil containers Viewport.
	private Column = brazil containers Column.
	private CompositeVisual = brazil containers CompositeVisual.
	private Flow = brazil containers Flow.
	private Row = brazil containers Row.
	private SpyingWrapper = brazil containers SpyingWrapper.
	private Wrapper = brazil containers Wrapper.
	private Desktop = brazil containers Desktop.
	private VerticalViewport = brazil containers VerticalViewport.
	private Window = brazil containers Window.
	private Icon  = brazil widgets Icon.
	private Label = brazil widgets Label.
	private Button = brazil widgets Button.
	private SensitiveIcon = brazil widgets SensitiveIcon.
	private TextDisplay = brazil widgets TextDisplay.
	private TextView = brazil widgets TextView.
	private LineShape = brazil widgets LineShape.
	private PolygonShape = brazil widgets PolygonShape.
	private ActiveIcon = brazil widgets ActiveIcon.
	private Blank = brazil widgets Blank.
	private Hyperlink = brazil widgets Hyperlink.
	private RectangleShape = brazil widgets RectangleShape.
	private RoundedRectangleShape = brazil widgets RoundedRectangleShape.
	private MessageBox = brazil tools MessageBox.
	
	private cachedPlatform = platform.

	public core = CoreClasses new.
	public fragments = FragmentClasses new. (* after core *)
	public composers = ComposerClasses new. (* after core, fragments *)
	public canvas = CanvasClasses new. (* after core, composers *)
	public outline = OutlineClasses new. (* after core *)
|composers postInit. core postInit)
(
class CanvasClasses = (|
	Composer = core Composer.
	ColorDecorator = composers ColorDecorator.
	DragSensitiveHolderComposer = composers DragSensitiveHolderComposer.
	HolderComposer = composers HolderComposer.
|)
(
class CanvasComposer = Composer (
(* Displays its elements within a free-form scrollable area. The elements are either CanvasItems or CanvasDependents.

Slots:

items <OrderedCollection[CanvasItem]>
dropTargetCreationBlock <[DropTarget] | nil>
dragTracker <DragDropTracker> *)| items dropTargetCreationBlock dragTracker |)
('accessing'
childrenDo: aBlock = (


	items do: aBlock
)
color: aColor = (

	addDecorator:: ColorDecorator new color: aColor
)'content accessing'
add: presenter <Presenter> at: location <Point> ^<CanvasItem> = (

	^addItem:: CanvasItem withContent: presenter at: location.
)
addItem: item <CanvasItem | CanvasDecoration> ^<CanvasItem> = (

	items add: item.
	item parent: self.
	hasVisual ifTrue: [item addVisualsTo: visual].
	^item
)
includes: containedChild <Fragment> = (

	^includesItem: containedChild parent
)
includesItem: item <CanvasItem> = (

	^items includes: item
)
move: containedChild <Fragment> to: newLocation <Point> = (

	self move: containedChild parent to: newLocation.
)
moveItem: child <CanvasItem> to: newLocation <Point> = (

	child position: newLocation.
)
remove: containedChild <Fragment> = (

	self removeItem: containedChild parent
)
removeItem: child <CanvasItem> = (

	items remove: child.
	child noticeRemoval.
	hasVisual ifTrue: [child removeVisualsFrom: visual].
	child noticeAbandonment
)'drag/drop'
abandonCanvasItemFrom: source <CanvasItemMoveDragSource> = (

	self moveItem: source item to: source originalPosition
)
createClientSuppliedDropTargetFor: session <DragDropSession> ^<DropTarget> = (

	^dropTargetCreationBlock valueWithPossibleArgument: session
)
createDropTargetFor: session <DragDropSession> ^<DropTarget> = (

	^if: session source
		isMovingMyItem: [createDropTargetForItemMove]
		otherwise: [createClientSuppliedDropTargetFor: session]
)
createDropTargetForItemMove = (

	^DropTarget new
		entryAction: [:source | pickUpCanvasItemFrom: source];
		stepAction: [:source | moveCanvasItemFrom: source];
		dropAction: [:source | dropCanvasItemFrom: source];
		exitAction: [:source | abandonCanvasItemFrom: source]
)
dropCanvasItemFrom: source <CanvasItemMoveDragSource> = (

	(* Nothing to be done for the move - after the last step event the item is already where it should be. *)
)
dropTargetFor: session <DragDropSession> ^<DropTarget | nil> = (

	^session 
		targetAt: self 
		ifAbsentPut: [createDropTargetFor: session]
)
ifInterestedInDragAt: windowRelativePoint <Point> 
forSession: session <DragDropSession>
doWithTarget: targetBlock = (

	(dropTargetCreationBlock notNil 
			and: [visualContainsPoint: windowRelativePoint]) 
		ifTrue: 
			[(dropTargetFor: session) ifNotNil: targetBlock]
)
moveCanvasItemFrom: source <CanvasItemMoveDragSource> = (

	self 
		moveItem: source item 
		to: (computeCurrentPositionForItemMove: source)
)
pickUpCanvasItemFrom: source <CanvasItemMoveDragSource> = (

	(* Nothing special to do; the item is physically moved by the step response. *)
)'initialize-release'
elements: itemCollection <Collection[CanvasItem]> = (

	items:: itemCollection asOrderedCollection
)'parameters'
defaultColor = (

	^Color gray: 0.7
)'private'
computeCurrentPositionForItemMove: source <CanvasItemMoveDragSource> ^<Point> = (

	(* Compute the origin the item being moved by the source should have now, based on the current position of the mouse. When we implement client drag trajectory control, this is the place to hook it up. *)
	^visual mousePoint - source grabPoint
)
if: source <DragSource> isMovingMyItem: action <[]> otherwise: alternative <[]> = (

	source identifyPayloadTo:
		(AdHocMessageReceiver new
			receive: #draggingCanvasItem:
			using: 
				[:item |
				source canvas == self ifTrue: [^action value]]).
	^alternative value
)
visualContainsPoint: windowRelativePoint <Point> ^<Boolean> = (

	^visual windowRelativeBounds containsPoint: windowRelativePoint
)'restricted'
canvasDo: action <[:CanvasComposer]> = (

	^action value: self
)
createViewport ^<Viewport> = (

	^createVisual
)
createVisual ^<Visual> = (

	| viewport |
	viewport:: Viewport new color: defaultColor.
	items do:
		[:each |
		each addVisualsTo: viewport].
	^viewport
)
receiveRequestFrom: dispatcher <UpwardRequestDispatcher | DownwardRequestDispatcher> ^<Boolean> = (

	(* Enable the receiver to receive messages sent using the sendUp/sendDown mechanism. *)

	(self respondsTo: dispatcher selector) ifTrue: 
		[dispatcher message sendTo: self.
		^true].
	^false
)) : ('as yet unclassified'
elements: itemCollection <Collection[CanvasItem]> = (

	^self new elements: itemCollection
))
class CanvasDependent = Composer (
(* This abstract class captures the concept of a dependent canvas item, i.e. an item whose position and existence depends on that of its 'masters'. The item will receive notifications when the position of one of the masters change, as well as one of the master items has been removed. In response to these, concrete subclasses should make arrangements to update their own layout and to remove themselves if they should not exist without the master. *))
('as yet unclassified'
addVisualsTo: container = (

	subclassResponsibility
)
childrenDo: aBlock = (

	(* This is a leaf. *)
)
mastersDo: action <[:CanvasItem]> = (

	(* A subclass must implement this method to invoke the argument with each of its masters as the argument. *)
	subclassResponsibility
)
noticeLayoutChangeOfMaster: item <CanvasItem> = (

	updateLayout
)
noticeRemovalOfMaster: item <CanvasItem> = (

	(* A subclass should implement this to remove itself from the canvas if it cannot exist without the master. *)
	subclassResponsibility
)
registerWithMasters = (

	mastersDo: [:each | each addDependent: self]
)
remove = (

	unregisterWithMasters.
	parent removeItem: self
)
removeVisualsFrom: container = (

	subclassResponsibility
)
replaceChild: aFragment with: anotherFragment = (

	self error: 'this is a leaf'
)
unregisterWithMasters = (

	mastersDo: [:each | each removeDependent: self]
)
updateLayout = (

	(* Sent by one of the master items when its bounds have changed, as a chance for all dependents to update their layout. *)
	subclassResponsibility
)) : ()
class CanvasItem withContent: definition = HolderComposer withContent: definition (
(* This is a special kind of holder used as a wrapper around presenters placed inside a canvas. A part of its content can be marked as grabArea:, which will automatically equip it for drag-and-drop to pick up and drag the item. Canvas items can also manage dependents, which are subclasses of CanvasDependent providing decorations whose position and existence depends on the available items. For example, lines connecting the items can be implemented as dependents. A canvas item notifies all dependents when it is moved or deleted. *)| internalPosition xAnchorFraction::=0. yAnchorFraction::=0. dependents::= OrderedCollection new. |)
('accessing'
position ^<Point> = (

	^internalPosition
)
position: newPosition <Point> = (

	internalPosition:: newPosition.
	hasVisual ifTrue: [visual area anchorPosition: internalPosition]
)'as yet unclassified'
addDependent: dependent = (

	dependents add: dependent
)
createVisual = (

	| theVisual |
	theVisual:: super createVisual.
	theVisual boundsChangedChannel => 
		[:ignored <Rectangle> | notifyDependentsOfLayoutChange].
	^theVisual
)
noticeRemoval = (

	(* Sent by the canvas just after the item has been removed from it. *)
	dependents copy do: [:each | each noticeRemovalOfMaster: self].
)
notifyDependentsOfLayoutChange = (

	dependents do: [:each | each noticeLayoutChangeOfMaster: self]
)
remove = (

	parent removeItem: self
)
removeDependent: dependent = (

	dependents remove: dependent
)'restricted'
addVisualsTo: viewport <Viewport> = (

	viewport add: visual in: Anchor.
	visual area
		origin: position;
		xAnchorFraction: xAnchorFraction;
		yAnchorFraction: yAnchorFraction
)
canvasItemDo: action <[:CanvasItem]> = (

	(* This message is sent by a containing grab area through the sendUp mechanism in order to find the item the area is supposed to move. *)
	^action value: self
)
receiveRequestFrom: dispatcher <UpwardRequestDispatcher | DownwardRequestDispatcher> 
^<Boolean> = (

	(* Enable the receiver to receive messages sent using the sendUp/sendDown mechanism. *)

	(self respondsTo: dispatcher selector) ifTrue: 
		[dispatcher message sendTo: self.
		^true].
	^false
)
removeVisualsFrom: viewport <Viewport> = (

	viewport remove: visual
)) : ('as yet unclassified'
withContent: presenter <Presenter> at: location <Point> = (

	^(self withContent: presenter)
		position: location
))
class CanvasItemGrabArea withContent: definition = DragSensitiveHolderComposer withContent: definition (
(* This class implements the move behavior of canvas items. The elements of the items wrapped with a grab area become a ''handle'' that cooperates with the canvas to pick up and move the item when dragged. *))
('accessing'
containingCanvas ^<CanvasComposer | nil> = (

	sendUp optional canvasDo: [:canvas | ^canvas].
	^nil
)
containingCanvasItem ^<CanvasItem | nil> = (

	sendUp optional canvasItemDo: [:item | ^item].
	^nil
)'as yet unclassified'
createDragSource = (

	| canvas item |
	canvas:: containingCanvas.
	item:: containingCanvasItem.
	^(canvas notNil and: [item notNil]) 
		ifTrue: 
			[CanvasItemMoveDragSource new
				canvas: canvas;
				item: item;
				grabPoint: (grabPointRelativeTo: item);
				originalPosition: item position]
		ifFalse:
			[DragSource new]
)
grabPointRelativeTo: item <CanvasItem> = (

	^tracker dragOrigin
		translateFrom: tracker visual
		to: item visual
)) : ()
class CanvasItemMoveDragSource = DragSource (
(* Represents the dragging of a canvas item initiated by grabbing the item's drag area. The item and the canvas that contains it are stored in the instance slots.

Slots:

canvas <Canvas> The canvas the dragged item belongs to.
item <CanvasItem> The item itself.
grabPoint <Point> The location of the mouse relative to the item at the time the drag started.
originalPosition <Point> The position of the item within the canvas at the time the drag started. *)| canvas item grabPoint originalPosition |)
('as yet unclassified'
identifyPayloadTo: identificationReceiver = (

	^identificationReceiver 
		try: [identificationReceiver draggingCanvasItem: item]
		or: [super identifyPayloadTo: identificationReceiver]
)) : ()
class CanvasLineBetweenItems from: item1 <CanvasItem> to: item2 <CanvasItem> = CanvasDependent (
(* Creates and manages a line between two canvas items, so that the line goes from the center of one item to the center of the other. *)| 
	lineColorS::= Color black.
	showArrowS::= false.
	arrowColorS::= Color black.
	arrowBorderColorS::= nil. (* that is, use lineColor *) 
	arrowSizeS::= 10.
	arrowSweepS::= 40 (* degrees *). 
	fromItem::= item1.
	toItem::= item2.
	line arrowhead 
|registerWithMasters)
('accessing'
arrowBorderColor = (

	^arrowBorderColorS ifNil: [lineColor]
)
arrowBorderColor: newColor <Color> = (

	arrowBorderColorS:: newColor.
	arrowhead ifNotNil: [:it | it borderColor: newColor]
)
arrowColor = (

	^arrowColorS
)
arrowColor: newColor <Color> = (

	arrowColorS:: newColor.
	arrowhead ifNotNil: [:it | it color: newColor]
)
arrowSize = (

	^arrowSizeS
)
arrowSize: newSize <Number> = (

	arrowSizeS:: newSize.
	arrowhead ifNotNil: [updateLayout]
)
arrowSweep = (

	^arrowSweepS
)
arrowSweep: degrees <Number> = (

	arrowSweepS:: degrees.
	arrowhead ifNotNil: [updateLayout]
)
childrenDo: action <[:Fragment]> = (

	(* This is a leaf. *)
)
lineColor = (

	^lineColorS
)
lineColor: newColor <Color> = (

	lineColorS:: newColor.
	line ifNotNil: [:it | it color: newColor]
)
mastersDo: action <[:CanvasItem]> = (

	action
		value: fromItem;
		value: toItem
)
replaceChild: one <Fragment> with: two <Fragment> = (

	self error: 'Canvas line decorations are leaves.'
)
showArrow = (

	^showArrowS
)
showArrow: show <Boolean> = (

	showArrowS:: show.
	arrowhead notNil
		ifTrue: [arrowhead visible: show]
		ifFalse:
			[line notNil ifTrue:
				[arrowhead:: createArrowheadShape.
				line parent add: arrowhead inFrontOf: line]]
)'notifications'
noticeRemovalOfMaster: item <CanvasItem> = (

	remove
)'private'
computeArrowVerticesPointingAt: toPoint <Point> from: fromPoint <Point> ^<Collection[Point]> = (

	| halfSweep size direction point1 point2 |
	halfSweep:: arrowSweepS // 2.
	size:: arrowSize.
	direction:: (toPoint - fromPoint) theta radiansToDegrees.
	^{
		toPoint.
		toPoint - (Point r: size degrees: direction + halfSweep) rounded.
		toPoint - (Point r: size degrees: direction - halfSweep) rounded.
	}
)
createArrowheadShape = (

	^PolygonShape new
		borderColor: arrowBorderColor;
		borderWidth: 1;
		color: arrowColor;
		visible: showArrow
)
edgePointOf: rect <Rectangle> goingTo: point <Point> ^<Point> = (

	(* Compute a point at the intersection of the rectangle border and the line going from the rectangle center to the given point. *)
	| center |
	(rect containsPoint: point) ifTrue: [^point].
	center:: rect center.
	center y = point y ifFalse:
		[ | k x |
		k:: (point x - center x) / (point y - center y).
		point y < center y 
			ifTrue:
				[x:: (rect top - center y) * k + center x.
				(x between: rect left and: rect right) ifTrue: 
					[^x rounded @ rect top]]
			ifFalse:
				[x:: (rect bottom - center y) * k + center x.
				(x between: rect left and: rect right) ifTrue: 
					[^x rounded @ rect bottom]]].
	center x = point x ifFalse:
		[ | k y |
		k:: (point y - center y) / (point x - center x).
		point x < center x 
			ifTrue:
				[y:: (rect left - center x) * k + center y.
				(y between: rect top  and: rect bottom) ifTrue: 
					[^rect left @ y rounded]]
			ifFalse:
				[y:: (rect right - center x) * k + center y.
				(y between: rect top and: rect bottom) ifTrue:
					[^rect right @ y rounded]]].
	(* If the point is outside the rectangle, one of the four exit conditions above should have held. *)
	error: 'eh?'
)'restricted'
addVisualsTo: viewport <Viewport> = (

	viewport addAtBack: visual.
	showArrow ifTrue:
		[arrowhead:: createArrowheadShape.
		viewport add: arrowhead inFrontOf: line].
	updateLayout.
)
createVisual = (

	line:: LineShape new.
	^line
)
removeVisualsFrom: viewport <Viewport> = (

	line ifNotNil: [:it | viewport remove: it].
	arrowhead ifNotNil: [:it | viewport remove: it].
)
updateLayout = (

	| fromBounds toBounds fromPoint toPoint |
	fromBounds:: fromItem visual bounds.
	toBounds:: toItem visual bounds.
	(fromBounds intersects: toBounds) ifTrue: 
		[line visible: false.
		arrowhead ifNotNil: [:it | it visible: false].
		^self].
	fromPoint:: edgePointOf: fromBounds goingTo: toBounds center.
	toPoint:: edgePointOf: toBounds goingTo: fromBounds center.
	line area startPoint: fromPoint endPoint: toPoint.
	arrowhead ifNotNil:
		[:it |
		it area vertices: (computeArrowVerticesPointingAt: toPoint from: fromPoint).
		it visible: showArrow].
	line visible: true.
)) : ()) : ()
class ComposerClasses = (|
	Presenter = core Presenter.
	Subject = core Subject.
	Decorator = core Decorator.
	Composer = core Composer.

	BlankFragment = fragments BlankFragment.
	HopscotchSubjectDragSource = fragments HopscotchSubjectDragSource.
	HopscotchWastelandDropTarget = fragments HopscotchWastelandDropTarget.

	OutlineItemPresenter (* = Outline OutlineItemPresenter *)
|)
(
class AdHocRoundedCornersHolderComposer withContent: definition = HolderComposer withContent: definition (
(* Until we clean up the whole decoration story so that there are a number of visual appearance gadgets that can be composed even more freely, here is a simple holder that shows itself as a rounded corners rectangle. *)| color |)
('as yet unclassified'
createVisual = (

	| composite contentVisual roundedCornersRectangle |
	composite:: CompositeVisual new.
	contentVisual:: content visual.
	roundedCornersRectangle:: RoundedRectangleShape new color: color.
	composite
		add: roundedCornersRectangle in: Frame;
		add: contentVisual in: Frame.
	roundedCornersRectangle area fullyCoverParent.
	contentVisual area fullyCoverParent.
	^composite.
)) : ()
class AggregatePresenter onSubject: s = Presenter onSubject: s ()
('as yet unclassified'
definition = (


	^list: [subject model collect: [:each | each presenter]]
)) : ()
class AggregateSubject onModel: m = Subject onModel: m (
(* The model is a collection of other subjects. The presenter will display default presenters of those subjects. *))
('as yet unclassified'
createPresenter = (

	^AggregatePresenter subject: self
)
title = (

	| titles |
	titles:: (String new: 30) writeStream.
	model
		do: [:each | titles nextPutAll: each title]
		separatedBy: [titles nextPutAll: ', '].
	^titles contents
)) : ()
class CellLayoutDecorator = Decorator (
(* A decorator that can be attached to a fragment contained by a row to control its layout parameters. Can be used for columns too, but in typical Hopscotch UIs there is no need to control column cell layout. *)|
	size
	minimumSize
	expansibility
	compressibility
|)
('accessing'
decorate: aVisual = (
	size ifNotNil: [:it | aVisual area principalSize: it].
	minimumSize ifNotNil: [:it | aVisual area minimumSize: it].
	(* general elasticity is obsolete and will go away. Until then, apply
	the general before the specific so the specific can override. *)
	expansibility ifNotNil: [:it | aVisual area expansibility: it].
	compressibility ifNotNil: [:it | aVisual area compressibility: it].
	^aVisual
)
elasticity: newValue = (
	(* Support the old API. *)
	expansibility: newValue.
	compressibility: newValue.
)) : ()
class CenteringFrameComposer content: aFragment = FrameComposer content: aFragment (
(*  *))
('as yet unclassified'
contentAreaClass = (

	^Anchor
)
setupContentArea: anArea = (

	anArea beCentered
)) : ()
class ColorDecorator = Decorator (
(*  *)| color coloredDefinition |)
('private'
decorate: aVisual = (


	aVisual color: color.
	^aVisual
)) : ()
class ColumnComposer definitions: fragments = SequenceComposer definitions: fragments (
(* Arranges the fragments it holds as a column. *))
('private'
visualClass = (


	^Column
)) : ()
class DeferredContentComposer = Composer (
(*  *)| contentSource initialContent::= BlankFragment new.
 contentFragment |)
('accessing'
childrenDo: aBlock = (


	contentFragment ifNotNil: aBlock
)
installDeferredContent = (

	(* Replace the placeholder blank with the real content fragment, typically computed before. *)

	visualX content: 
		(contentFragment ifNil: [createDeferredContent]) 
			visual
)'private'
createDeferredContent = (

	(* Evaluate the content source block to produce the actual content fragment and remember it to be installed later. This method is executed by a background process parallel to the main UI. *)

	contentFragment:: contentSource clone value.
	flag: #squeakBogosity. (* the send of #clone above should not be needed *) 
	contentFragment parent: self.
	^contentFragment
)'requests'
collectDeferredContentInto: aCollection = (


	aCollection add: self.
	super collectDeferredContentInto: aCollection
)'restricted'
createVisual = (


	^Wrapper with: initialContent visual
)) : ()
class DisclosureComposer = TwoStateComposerWithToggleIcon (
(* Displays a ''heading'' fragment with a triangular ''expand'' button which shows or hides an additional ''details'' fragment. *)| header bodyDefinition bodyPresenter contentHolder |)
('accessing'
bodyPartOrNil = (


	^bodyPresenter
)
childrenDo: aBlock = (


	aBlock value: header.
	bodyPresenter notNil ifTrue:
		[aBlock value: bodyPresenter]
)
headerPart = (


	^header
)'initialize-release'
header: headerPresenter <HopscotchPresenter> bodyDefinition: block <Block> = (


	header:: headerPresenter.
	header parent: self.
	bodyDefinition:: block
)'private'
createVisual = (

	(* IMPORTANT: a change in the structure of visuals created here also requires changing the #updateVisual:of: method. *)

	| column |
	column:: Column new.
	column 
		addNew: Row setup:
			[:row |
			row
				add: (Wrapper with: toggleIcon) beCentered;
				addBlankSize: 3;
				add: header visual.
			header visual area elasticity: 1];
		addNew: Row setup:
			[:row |
			row addBlankSize: 13.
			contentHolder:: Wrapper new.
			row add: contentHolder.
			contentHolder area elasticity: 1].
	isExpanded
		ifTrue: [privateExpand].
	^column
)
installContentVisual: aVisual = (


	contentHolder content: aVisual.
	aVisual areaClass: Frame.
	aVisual area fullyCoverParent
)
privateCollapse = (


	contentHolder content: Blank new.
	(* bodyPresenter:: nil *)
)
privateExpand = (


	bodyPresenter ifNil: 
		[bodyPresenter:: bodyDefinition value.
		bodyPresenter parent: self].
	installContentVisual: bodyPresenter visual.
)) : ()
class DragSensitiveHolderComposer withContent: definition = HolderComposer withContent: definition (
(* Turns the content into an area that can be dragged from. The content is passivized in the process--any mouse interaction with it is impossible, so presumably it is made of components that are passive in the first place, such as labels, images and their compositions. This class is abstract, to be specialized to interpret the dragging in a particular way. *)| grabOverlay tracker |)
('as yet unclassified'
createDragSource = (

	subclassResponsibility
)
createGrabOverlay = (

	grabOverlay:: RectangleShape new
		borderWidth: 0;
		color: Color transparent.
	^grabOverlay
)
createTracker = (

	tracker:: DragDropTracker new
		attachTo: grabOverlay;
		sourceCreationBlock: [createDragSource].
)
createVisual = (

	| composite contentVisual |
	createGrabOverlay.
	createTracker.
	composite:: CompositeVisual new.
	contentVisual:: content visual.
	composite
		add: contentVisual in: Frame;
		add: grabOverlay in: Frame.
	grabOverlay area fullyCoverParent.
	contentVisual area fullyCoverParent.
	^composite.
)) : ()
class DragSubjectHolderComposer withContent: definition = DragSensitiveHolderComposer withContent: definition (
(* A specialization of the abstract DragSensitiveHolderComposer allowing to drag out a Hopscotch Subject. *)| subject image |)
('as yet unclassified'
createDragSource = (

	^HopscotchSubjectDragSource new
		visual: visual;
		subject: subject;
		draggedImage: image;
		wastelandTarget: HopscotchWastelandDropTarget new
)) : ()
class DropTargetHolderComposer withContent: definition = HolderComposer withContent: definition (
(*  *)| expectedSelector dropAction cachedTarget |)
('as yet unclassified'
createTarget = (

	^DropTarget new
		dropAction: [:source | dropFrom: source]
)
dropFrom: dragSource <DropSource> = (

	dragSource identifyPayloadTo:
		(AdHocMessageReceiver new
			receive: expectedSelector
			using: dropAction)
)
ifInterestedInDragAt: windowRelativePoint <Point> 
forSession: session <DragDropSession>
doWithTarget: targetBlock = (

	(visualContainsPoint: windowRelativePoint) ifTrue:
		[targetBlock value: target]
)
receiveRequestFrom: dispatcher ^<Boolean> = (

	(* Receive and process a notice coming from one of the children (usually as the result of using #sendUp or #sendDown). *)

	(self respondsTo: dispatcher selector) ifTrue: 
		[dispatcher message sendTo: self.
		^true].
	^false
)
target = (

	^cachedTarget ifNil: 
		[cachedTarget:: createTarget.
		cachedTarget]
)
visualContainsPoint: windowRelativePoint <Point> ^<Boolean> = (

	^visual windowRelativeBounds containsPoint: windowRelativePoint
)) : ()
class EqualizerDecorator = Decorator (
(*  *)| sequenceDefinition elementIndex |)
('private'
decorate: aVisual = (


	CellWidthEqualizer
		equalize: aVisual children
		at: elementIndex.
	^aVisual
)) : ()
class FloatingHeaderComposer header: header <Fragment> body: body <Fragment> = Composer (
(* Holds onto two fragments: a header and a body. In a situation when the entire composer area is visible in the top-level presenter's viewport, acts as a column positioning the header fragment above the body fragment. However, if the area is partially scrolled out of view so the top is hidden, the header moves the header component down to keep it visible.

The composer will try to keep some of the body visible as the view is scrolled up, so at some point it will stop repositioning the header and will let it scroll up out of the view. When this will happen is determined by the minimumBodyToHeaderRatio parameter. If the ratio is 2, the default, the header will start scrolling out of view when the visible body height drops to twice the header height.

The top-level presenter that supplies the viewport for the entire page must register an interest in the #changed duct of its viewport's scrollPosition holder and send down the #respondToScrollingInViewport: message when the scroll position changes. That is taken care of in the standard Presenter>>createViewportWithVisual method.
*)|
	header = header.
	body = body.
	minimumBodyToHeaderRatio ::= 2.

	headerVisual
	bodyVisual
|header parent: self.
	body parent: self)
('accessing'
childrenDo: aBlock = (
	header childrenDo: aBlock.
	body childrenDo: aBlock.
)
refresh = (
	header refresh.
	body refresh.
)'notifications'
respondToScrollingInViewport: viewport <VerticalViewport> = (
	(* Received when the top-level viewport has been scrolled to a new position. If possible, move the header to keep it in sight. *)
	| visibleBounds newTop |
	visibleBounds:: visual localBounds translateFrom: visual to: viewport.
	visibleBounds bottom < 0 ifTrue:
		(* Scrolled up out of sight, don't bother adjusting. *)
		[^self].
	visibleBounds top > viewport localBounds bottom ifTrue:
		(* Scrolled down out of sight, don't bother adjusting. *)
		[^self].
	newTop:: (visibleBounds top negated
		min: visual localBounds bottom - ((minimumBodyToHeaderRatio + 1) * headerHeight))
			max: 0.
	repositionHeaderAt: newTop.
)'private'
headerHeight = (
	^headerVisual naturalExtent y
)
repositionHeaderAt: topPosition <Integer> = (
	| height |
	height:: headerHeight.
	headerVisual area
		leftFraction: 0 offset: 0
		topFraction: 0 offset: topPosition
		rightFraction: 1 offset: 0
		bottomFraction: 0 offset: topPosition + height.
	(* We update the body position too because headerHeight is not constant over time. *)
	bodyVisual area
		leftFraction: 0 offset: 0
		topFraction: 0 offset: height
		rightFraction: 1 offset: 0
		bottomFraction: 1 offset: 0.
)'restricted'
createVisual = (
	| panel |
	panel:: CompositeVisual new.
	panel
		add: (bodyVisual:: body visual) in: Frame;
		add: (headerVisual:: header visual) in: Frame.
	repositionHeaderAt: 0.
	^panel
)
receiveRequestFrom: dispatcher <RequestDispatcher> ^<Boolean> = (
	(* Receive a request sent from somewhere using sendDown or sendUp. We are interested specifically in the scrolling notifications sent by the top-level presenter that manages the main viewport. *)
	^dispatcher selector = #respondToScrollingInViewport:
		and: [dispatcher message sendTo: self. true]
)) : ()
class FloatingPanelComposer panel: panel <Fragment> = Composer (
(* Makes the content panel float within a potentially larger container space, keeping the panel positioned within the visible area of the main viewport as the viewport is scrolled. *)|
	panel = panel.
|panel parent: self)
('as yet unclassified'
childrenDo: aBlock = (
	panel childrenDo: aBlock
)
createVisual = (
	| column |
	column:: Column new.
	column
		addBlankSize: 0;
		add: panel visual.
	^column
)
receiveRequestFrom: dispatcher <RequestDispatcher> ^<Boolean> = (
	(* Receive a request sent from somewhere using sendDown or sendUp. We are interested specifically in the scrolling notifications sent by the top-level presenter that manages the main viewport. *)
	^dispatcher selector = #respondToScrollingInViewport:
		and: [dispatcher message sendTo: self. true]
)
repositionPanelAt: newTop <Integer> = (
	visual children first area height: newTop
)
respondToScrollingInViewport: viewport <VerticalViewport> = (
	(* Received when the top-level viewport has been scrolled to a new position. If possible, move the header to keep it in sight. *)
	| visibleBounds newTop |
	visibleBounds:: visual localBounds translateFrom: visual to: viewport.
	visibleBounds bottom < 0 ifTrue:
		(* Scrolled up out of sight, don't bother adjusting. *)
		[^self].
	visibleBounds top > viewport localBounds bottom ifTrue:
		(* Scrolled down out of sight, don't bother adjusting. *)
		[^self].
	newTop:: (visibleBounds top negated
		min: visual localBounds bottom - panel visual localBounds height)
			max: 0.
	repositionPanelAt: newTop.
)) : ()
class FlowComposer definitions: fragments = SequenceComposer definitions: fragments ()
('private'
createVisual = (


	| visual |

	flag: #BOGUS. (* the right implementation is at the end. The current is a temporary one to hold us over until Flow can wholesale-set childedn. *)

	visual:: visualClass new.
	visual horizontalGap: 8.
	children keysAndValuesDo: 
		[:index :each | | elasticity |
		visual add: each visual].
	^visual


(*	^super createVisual
		horizontalGap: 8 *)
)
visualClass = (


	^Flow
)) : ()
class FrameComposer content: aFragment = Composer (
(*  *)| contentX ::= aFragment. |)
('as yet unclassified'
childrenDo: aBlock = (


	content ifNotNil: aBlock
)
content = (

	^contentX
)
content: aFragment = (

	contentX:: aFragment.
	aFragment parent: self
)
contentAreaClass = (

	subclassResponsibility
)
createVisual ^<Visual> = (


	| holder |
	holder:: Wrapper with: content visual.
	holder content areaClass: contentAreaClass.
	setupContentArea: holder content area.
	^holder
)
replaceChild: aFragment with: anotherFragment = (


	aFragment == content ifFalse: [error: 'not the child'].
	hasVisual ifTrue: [content noticeConcealment].
	content parent: nil.
	content: anotherFragment.
	content parent: self.
	hasVisual ifTrue:
		[content noticeImminentExposure.
		visualX content: content visual.
		content noticeExposure]
)
setupContentArea: anArea = (

	subclassResponsibility
)) : ()
class HolderComposer withContent: definition = Composer (
(* Holds onto a fragment that can be replaced at any time by sending the #content: message. The fragment can be set either literally or as a block evaluated to produce the fragment. In the latter case the block is re-evaluated each time the holder is refreshed, replacing the old content with the new.

Slots:
	contentSource <Fragment | Block> The fragment to display or the block to be evaluated to produce the fragment.
	actualContent <Fragment> The actual fragment held onto--the same as contentX if the content is a fragment, or the result of last evaluation of contentX if it's a block. *)| contentSource::=definition. actualContent |)
('accessing'
childrenDo: aBlock = (


	actualContent ifNotNil: aBlock
)
content ^<Fragment> = (

	(* Answer the current content fragment, evaluating the source to fetch it if needed. *)

	actualContent ifNil: 
		[actualContent:: contentSource value.
		actualContent parent: self].
	^actualContent
)
content: newSource <Fragment | Block> = (

	(* Accept the new content source. If the actual content has already been retrieved from the old source, retrieve new content from the new source right away. No-op if newSource is identical to the current contentSource. *)

	newSource == contentSource ifTrue: [^self].
	actualContent notNil ifTrue:
		[hasVisual ifTrue: [actualContent noticeConcealment].
		actualContent parent: nil].
	contentSource:: newSource.
	actualContent notNil ifTrue:
		[actualContent:: nil. (* force content fetch in next step *)
		content (* recreates and sets actualContent *)
			noticeImminentExposure.
		hasVisual ifTrue:
			[visualX content: actualContent visual.
			actualContent noticeExposure]]
)
replaceChild: aFragment with: anotherFragment = (


	(actualContent == aFragment and: [aFragment ~~ anotherFragment])
		ifTrue:
			[hasVisual ifTrue: 
				[actualContent noticeConcealment].
			actualContent parent: nil.
			contentSource:: anotherFragment.
			actualContent:: anotherFragment.
			actualContent parent: self.
			hasVisual ifTrue:
				[actualContent noticeImminentExposure.
				visualX content: actualContent visual.
				actualContent noticeExposure]]
		ifFalse:
			[error: 'not a child']
)'as yet unclassified'
refresh = (


	| oldContent |
	(contentSource isBlock and: [hasVisual])
		ifTrue:
			[oldContent:: actualContent.
			actualContent 
				noticeConcealment;
				parent: nil.
			actualContent:: nil.
			content (* creates and sets actualContent *)
				noticeImminentExposure.
			actualContent parent: self.
			visual content: actualContent visual.
			actualContent noticeExposure.
			actualContent = oldContent ifTrue: [actualContent refresh]]
		ifFalse:
			[actualContent refresh]
)'private'
createVisual = (


	^Wrapper with: content visual
)) : ()
class MoreOrLessComposer = TwoStateComposer (| lessDefinition moreDefinition lessPresenter morePresenter 
moreCaption::= 'more...'.
	lessCaption::= 'less...'.
	leftAlignToggleLink::= false.
 toggleLink |)
('as yet unclassified'
childrenDo: aBlock = (


	lessPresenter ifNotNil: aBlock.
	morePresenter ifNotNil: aBlock
)'initialize-release'
lessDefinition: block1 moreDefinition: block2 = (


	lessDefinition:: block1.
	moreDefinition:: block2
)'private'
createControlBar = (


	| wrapper |
	toggleLink:: Hyperlink new font: Font tiny.
	toggleLink
		label: (isExpanded ifTrue: [lessCaption] ifFalse: [moreCaption]).
	toggleLink
		action: [toggle].
	wrapper:: Wrapper with: toggleLink.
	leftAlignToggleLink
		ifTrue: [toggleLink area beLeftCenter]
		ifFalse: [toggleLink area beRightCenter].
	^wrapper
)
createVisual = (


	| column |
	column:: Column new.
	column add:
		(isExpanded
			ifTrue: [ensureMorePresenter]
			ifFalse: [ensureLessPresenter]) visual.
	column add: createControlBar.
	^column
)
ensureLessPresenter = (


	lessPresenter ifNil:
		[lessPresenter:: lessDefinition value.
		lessPresenter parent: self].
	^lessPresenter
)
ensureMorePresenter = (


	morePresenter ifNil:
		[morePresenter:: moreDefinition value.
		morePresenter parent: self].
	^morePresenter
)
privateCollapse = (


	| presenter |
	morePresenter noticeConcealment; noticeRemoval.
	morePresenter:: nil.
	presenter:: ensureLessPresenter.
	presenter noticeImminentExposure.
	visual at: 1 put: presenter visual.
	presenter noticeExposure.
)
privateExpand = (


	| presenter |
	lessPresenter noticeConcealment; noticeRemoval.
	lessPresenter:: nil.
	presenter:: ensureMorePresenter.
	presenter noticeImminentExposure.
	visual at: 1 put: presenter visual.
	presenter noticeExposure.
)
updateToggleWidget = (


	toggleLink label:
		(isExpanded
			ifTrue: [lessCaption]
			ifFalse: [moreCaption])
)) : ()
class PaddedFrameComposer = FrameComposer (| 
	paddingLeft::= 0.
	paddingTop::= 0.
	paddingRight::= 0.
	paddingBottom::= 0. |)
('as yet unclassified'
contentAreaClass = (

	^Frame
)
setupContentArea: anArea = (

	anArea
		leftFraction: 0 offset: paddingLeft
		topFraction: 0 offset: paddingTop
		rightFraction: 1 offset: paddingRight negated
		bottomFraction: 1 offset: paddingBottom negated.
)) : ()
class RowComposer definitions: fragments = SequenceComposer definitions: fragments ()
('private'
visualClass = (


	^Row
)) : ()
class SequenceComposer definitions: fragments = Composer (
(* An abstract superclass of composers that hold onto a list of children and somehow arrange them visually--for example, as a row or as a column. *)| childrenX::= OrderedCollection new. definitionsX |privateSetChildren: fragments)
('accessing'
add: fragment = (


	childrenX add: fragment.
	fragment parent: self.
	hasVisual ifTrue:
		[visual add: fragment visual]
)
add: fragment <Fragment> beforeIndex: index <Integer> = (


	childrenX add: fragment beforeIndex: index.
	fragment parent: self.
	hasVisual ifTrue:
		[visual add: fragment visual beforeIndex: index]
)
addFirst: fragment = (


	childrenX addFirst: fragment.
	fragment parent: self.
	hasVisual ifTrue:
		[visual addFirst: fragment visual]
)
children = (


	^childrenX
)
children: fragmentsWithNils <OrderedCollection[Fragment | nil]> = (

	(* A wholesale update of the content. The content needs to be updated carefully, though. If there are children already, we don't want to remove those that are in the collection to avoid unmapping and mapping their visuals. The sequence may contain nils, which are filtered out. *)

	| fragments removed added |
	fragments:: fragmentsWithNils reject: [:each | each == nil].
	removed:: childrenX reject: [:each | fragments includes: each].
	added:: fragments reject: [:each | childrenX includes: each].
	childrenX:: fragments asMutableArrayList.
	added do: [:each | each parent: self].
	hasVisual ifTrue:
		[visual blockIncrementalLayoutUpdatesWhile:
			[removed do: [:each | visual remove: each visual].
			added do: [:each | visual add: each visual].
			visual reorder: (fragments collect: [:each | each visual])]]
)
childrenDo: aBlock = (


	childrenX do: aBlock
)
privateSetChildren: fragmentsWithNils <OrderedCollection[Fragment | nil]> = (


	children:: (fragmentsWithNils reject: [:each | each == nil])
		asMutableArrayList
)
remove: fragment = (


	childrenX remove: fragment.
	hasVisual ifTrue:
		[visual remove: fragment visual]
)
removeAt: index <Integer> = (


	childrenX removeAt: index.
	hasVisual ifTrue:
		[visual removeAt: index]
)
reorder: fragments = (

	(* Change the order of elements to match that of the argument. The argument must include all the elements currently in the receiver. *)

	(childrenX difference: fragments) isEmpty ifFalse:
		[error: 'bad arguments'].
	childrenX: fragments asOrderedCollection.
	hasVisual ifTrue:
		[visual reorder: (fragments collect: [:each | each visual])]
)
replace: fragment with: newFragment = (


	| index |
	index:: childrenX indexOf: fragment.
	index = 0 ifTrue: [error: 'fragment is not a child'].
	childrenX at: index put: newFragment.
	newFragment parent: self.
	hasVisual ifTrue:
		[visual at: index put: newFragment visual]
)'decorating'
color: aColor = (


	addDecorator::
		ColorDecorator new color: aColor
)'private'
createVisual = (


	| visual |
	visual:: visualClass new.
	visual children: (children collect: [:each | each visual]).
(*	children keysAndValuesDo: 
		[:index :each | | elasticity |
		visual add: each visual]. *)
	^visual
)
visualClass = (


	subclassResponsibility
)) : ()
class SplitterComposer left: left <Fragment> right: right <Fragment> = Composer (
(* WORK IN PROGRESS. A composer that puts two fragments side by side with a draggable sash in between.

A known issue with this implementation is that when the fragments are resized to an extreme so that one of them becomes very narrow and then the container is made smaller, the smallest fragment may end up being invisible. Setting the fragments' minimum size doesn't help (and should not be attempted) because that affects the natural extent measurement. *)|
	protected left = left.
	protected right = right.

	protected ratioValue ::= 1.
	protected widthDelta ::= 0.
	protected sash <RectangleShape>
	
	protected mouseDownLocation
	protected widthDeltaOnMouseDown
	protected leftWidthOnMouseDown
	protected rightWidthOnMouseDown
|)
('as yet unclassified'
childrenDo: aBlock = (
	aBlock value: left.
	aBlock value: right.
)
createSash = (
	| rectangle |
	rectangle:: RectangleShape new.
	rectangle
		color: Color transparent;
		mouseDownLeftResponse: [noticeMouseDown];
		mouseMoveResponse: [noticeMouseMove];
		mouseUpLeftResponse: [noticeMouseUp].
	^rectangle.
)
createVisual ^<Visual> = (
	| row |
	row:: Row new.
	row
		add: left visual;
		add: (sash:: createSash);
		add: right visual.
	row children first area
		width: 0;
		elasticity: ratioValue.
	sash area width: 5.
	row children last area
		width: 0;
		elasticity: 1.
	^row
)
noticeMouseDown = (
	mouseDownLocation:: visual mousePoint.
	widthDeltaOnMouseDown:: widthDelta.
	leftWidthOnMouseDown:: left visual extent x.
	rightWidthOnMouseDown:: right visual extent x.
)
noticeMouseMove = (
	| move limitedMove |
	move:: (visual mousePoint - mouseDownLocation) x.
	limitedMove:: (move max: leftWidthOnMouseDown negated + 50) min: rightWidthOnMouseDown - 50.
	widthDelta:: widthDeltaOnMouseDown + limitedMove.
	updateLayout
)
noticeMouseUp = (
	noticeMouseMove
)
ratio: newRatioValue <Number> = (
	(* The ratio value should be a positive number expressing the initial width of the left half relative to the right half. For example, the value of 2 makes the left half twice as wide as the left. *)
	ratioValue: newRatioValue.
	hasVisual ifTrue: [updateLayout]
)
updateLayout = (
	(* Bring the layout in sync with the current value of ratioValue and widthDelta. *)
	| leftArea = visual children first area. |
	leftArea elasticity ~= ratioValue ifTrue:
		[leftArea elasticity: ratioValue].
	leftArea width: widthDelta.
	visual children last area width: widthDelta negated.
)) : ()
class SpyingHolderComposer withContent: definition = HolderComposer withContent: definition (
(* This is a layout debugging tool that allows inserting a SpyingWrapper in the rendered tree of visuals in order to track layout negotiation requests. *))
('as yet unclassified'
createVisual = (


	^SpyingWrapper with: content visual
)) : ()
class ToggleComposer = TwoStateComposerWithToggleIcon (
(* Appears as a disclosure triangle that toggles between two fragments, one for the expanded and one for the collapsed state. *)| expandedDefinition collapsedDefinition expandedPresenter collapsedPresenter contentHolder |)
('accessing'
childrenDo: aBlock = (


	collapsedPresenter notNil ifTrue:
		[aBlock value: collapsedPresenter].
	expandedPresenter notNil ifTrue:
		[aBlock value: expandedPresenter].
)
collapsedPart = (


	^collapsedPresenter
)
expandedPart = (


	^expandedPresenter
)
replaceChild: aFragment with: replacement <Fragment> = (


	expandedPresenter == aFragment ifTrue:
		[expandedPresenter:: replacement.
		expandedPresenter parent: self.
		isExpanded ifTrue:
			[installContentVisual:: expandedPresenter visual].
		^self].
	collapsedPresenter == aFragment ifTrue:
		[collapsedPresenter:: replacement.
		collapsedPresenter parent: self.
		isExpanded ifFalse:
			[installContentVisual:: collapsedPresenter visual].
		^self].
	error: 'the argument is not a child of the receiver'
)
visiblePart = (


	^isExpanded
		ifTrue: [expandedPresenter]
		ifFalse: [collapsedPresenter]
)'initialize-release'
collapsedDefinition: block2 expandedDefinition: block1 = (


	expandedDefinition:: block1.
	collapsedDefinition:: block2.
)'private'
createVisual = (


	| wrappedIcon row |
	wrappedIcon:: Wrapper with: toggleIcon.
	wrappedIcon content area yOffset: 2.
	row:: Row new.
	row
		add: wrappedIcon;
		addBlankSize: 3.
	contentHolder:: row addNew: Wrapper setup:
		[:wrapper |
		wrapper area elasticity: 1].
	isExpanded
		ifTrue: [installExpandedPresenter]
		ifFalse: [installCollapsedPresenter].
	^row
)
installCollapsedPresenter = (


	collapsedPresenter ifNil: 
		[collapsedPresenter:: collapsedDefinition value.
		collapsedPresenter parent: self].
	collapsedPresenter noticeImminentExposure.
	installContentVisual: collapsedPresenter visual.
)
installContentVisual: aVisual = (


	aVisual areaClass: Frame.
	aVisual area fullyCoverParent.
	contentHolder content: aVisual.
)
installExpandedPresenter = (


	expandedPresenter ifNil:
		[expandedPresenter:: expandedDefinition value.
		expandedPresenter parent: self].
	expandedPresenter noticeImminentExposure.
	installContentVisual: expandedPresenter visual.
)
privateCollapse = (


	expandedPresenter ifNotNil: [:it | it noticeConcealment].
	installCollapsedPresenter.
	collapsedPresenter noticeExposure
)
privateExpand = (


	collapsedPresenter ifNotNil: [:it | it noticeConcealment].
	installExpandedPresenter.
	expandedPresenter noticeExposure.
)) : ('instance creation'
collapsedDefinition: block1 expandedDefinition: block2 = (


	^self new
		collapsedDefinition: block1
		expandedDefinition: block2
))
class TwoStateComposer = Composer (
(* TwoStateComposer is an abstract superclass of composers that hold onto two fragments, showing them in a particular way depending on the ''expanded'' or ''collapsed'' state of the composer. This superclass provides the mechanism for managing the current state of the interface and provides hooks to install code to run when the user or a program toggles the state, or to enable or disable the switching of states. *)| expandedX::=false. togglePermission::=[true]. onAboutToToggle onToggled retainInvisiblePart |)
('accessing'
collapse = (


	expanded: false
)
expand = (


	expanded: true
)
expanded: state <Boolean> = (


	(expandedX ~= state and: [togglePermission value]) ifTrue:
		[onAboutToToggle value.
		expandedX:: state.
		hasVisual ifTrue:
			[state
				ifTrue: [privateExpand]
				ifFalse: [privateCollapse].
			updateToggleWidget].
		onToggled value]
)
toggle = (


	expanded: isExpanded not.
	parent class = OutlineItemPresenter ifFalse:
		[notifyOfPossibleOutlineChange]
)'private'
privateCollapse = (

	(* Do whatever is necessary to switch the visuals to the collapsed appearance. *)
	
	subclassResponsibility
)
privateExpand = (

	(* Do whatever is necessary to switch the visuals to the expanded appearance. *)
	
	subclassResponsibility
)
updateToggleWidget = (

	(* Subclasses must redefine this to bring the state of the UI element used for switching the states in sync with the current state of the receiver. *)

	subclassResponsibility
)'testing'
isExpanded = (


	^expandedX
)) : ()
class TwoStateComposerWithToggleIcon = TwoStateComposer (| toggleIconX onUserToggled useExplorerLikeImages::=false. |)
('as yet unclassified'
userToggle = (


	toggle.
	onUserToggled value
)'private'
closedImage = (


	^useExplorerLikeImages
		ifTrue: [HopscotchImages default disclosurePlusImage]
		ifFalse: [HopscotchImages default disclosureClosedImage]
)
createToggleIcon = (


	^ActiveIcon new action: [userToggle]
)
openImage = (


	^useExplorerLikeImages
		ifTrue: [HopscotchImages default disclosureMinusImage]
		ifFalse: [HopscotchImages default disclosureOpenImage]
)
toggleIcon = (


	toggleIconX isNil ifTrue:
		[toggleIconX:: createToggleIcon.
		updateToggleWidget].
	^toggleIconX
)
transitionImage = (


	^useExplorerLikeImages
		ifTrue: [HopscotchImages default disclosurePlusImage]
		ifFalse: [HopscotchImages default disclosureTransitionImage]
)
updateToggleWidget = (


	^isExpanded 
		ifTrue:
			[toggleIcon
				image: openImage;
				hoverImage: openImage;
				downImage: transitionImage] 
		ifFalse:
			[toggleIcon
				image: closedImage;
				hoverImage: closedImage;
				downImage: transitionImage]
)) : ()
class ZebraDecorator firstColor: firstColor secondColor: secondColor = Decorator (|
	firstColor::= firstColor.
	secondColor::= secondColor.
	sequenceDefinition
|)
('private'
decorate: aVisual = (


	aVisual children keysAndValuesDo:
		[:index :each |
		(each respondsTo: #color) ifTrue:
			[each color = Color transparent ifTrue:
				[each color:
					(index odd
						ifTrue: [firstColor]
						ifFalse: [secondColor])]]].
	^aVisual
)) : ('as yet unclassified'
darkerColorFirst = (
	^self firstColor: (Color gray: 0.97) secondColor: Color white
)
lighterColorFirst = (
	^self firstColor: Color white secondColor: (Color gray: 0.97)
))'as yet unclassified'
postInit = (
	OutlineItemPresenter:: outline OutlineItemPresenter
)) : ()
class CoreClasses = (|
	CanvasComposer
	CanvasItem
	CanvasItemGrabArea

	AdHocRoundedCornersHolderComposer
	CellLayoutDecorator
	CenteringFrameComposer
	ColorDecorator
	ColumnComposer
	DeferredContentComposer
	DisclosureComposer
	DragSubjectHolderComposer
	DropTargetHolderComposer
	FloatingHeaderComposer
	FloatingPanelComposer
	FlowComposer
	HolderComposer
	MoreOrLessComposer
	PaddedFrameComposer
	RowComposer
	SplitterComposer
	SpyingHolderComposer
	ToggleComposer
	ZebraDecorator

	BlankFragment
	ButtonFragment
	CollapsibleLabelFragment
	DropDownMenuFragment
	HyperlinkFragment
	HyperlinkImageFragment
	ImageButtonFragment
	ProgressFragment
	StaticImageFragment
	StaticLabelFragment
	TextDisplayFragment

	Outliner
|)
(
class Composer = Fragment (
(* Composer is the abstract superclass of all fragments that combine a number of children in a particular way, and often give them particular behavior. For example, ColumnComposer arranges the visuals representing its children as a column, while DisclosureComposer shows an expandable panel with a permanently displayed heading and a body that can be hidden or displayed. *))
() : ()
class Decorator = (
(* A Decorator is attached to a fragment and is called by the fragment to change the various attributes of the Brazil visual created by the fragment itself. *))
('accessing'
decorate: aVisual = (

	(* Change properties of aVisual or wrap it into a new visual that applies whatever decorating we represent to aVisual. Answer aVisual or the new visual. *)
	
	subclassResponsibility
)) : ()
class DownwardRequestDispatcher = (
(* Responsible for delivering requests in a fragment hierarchy in the direction from parents to children. Typically created by sending the #sendDown message to a fragment. Unlike the upward dispatcher, the message is delivered to all children who care to receive it rather than to the first one. The children are traversed in some unspecified order (which happens to be depth-first :). *)| sender message |)
('as yet unclassified'
arguments ^<Array> = (


	^message arguments
)
deliverToChildrenOf: object = (

	object childrenDo:
		[:each |
		each receiveRequestFrom: self.
		deliverToChildrenOf: each]
)
doesNotUnderstand: aMessage = (


	message:: aMessage.
	deliverToChildrenOf: sender.
)
selector ^<Symbol> = (


	^message selector
)) : ()
class DropEnabledPresenterList = PresenterList (
(* This is the variant of PresenterList that allows dropping things between the items, presumably to insert. Instances are usually created using the #list:dropExpecting:action: combinator provided by presenters.

Slots:

expectedSelector <Symbol> The selector a drop source accepted by this list should identify itself with.

dropAction <[Integer Array]> The block that gets invoked when an acceptable drag source is dropped within the list. The first argument is the index of the element after which the drop occurred (i.e. 0 if dropped before the first element). The second argument is the array of arguments supplied by the source's data identification message (the one specified by expectedSelector).

cachedTarget - used internally by the implementation.
*)| expectedSelector dropAction cachedTarget |)
('accessing'
insertionIndexForCurrentMousePointWithMarker: marker <Fragment | nil>  ^<Integer> = (

	(* This method determines where the drop local marker should be positioned for the current mouse pointer position. The returned value is the index preceding the desired index of the marker (i.e. it can be used with the add:afterIndex: message). The argument is the marker currently inserted in the presenter list, or nil if the list has no marker now. The result is in the 0..N range, where N is the current number of presenters if marker is nil, or in the 0..N-1 range if marker is not nil. *)
	| mousePoint y index |
	mousePoint:: visual mousePoint.
	y:: mousePoint y.
	index:: 0.
	presenters do:
		[:each | | eachBounds |
		each == marker ifFalse:
			[eachBounds:: each visual bounds translateFrom: each visual parent to: visual.
			y < eachBounds center y ifTrue: [^index].
			index:: index + 1.
			y <= eachBounds bottom ifTrue: [^index]]].
	^index
)
target = (

	^cachedTarget ifNil:
		[cachedTarget: createTarget.
		cachedTarget]
)'notifications'
ifInterestedInDragAt: windowRelativePoint <Point> 
forSession: session <DragDropSession>
doWithTarget: targetBlock = (

	(visualContainsPoint: windowRelativePoint) ifTrue:
		[targetBlock value: target]
)
receiveRequestFrom: dispatcher ^<Boolean> = (

	(* Receive and process a notice coming from one of the children (usually as the result of using #sendUp or #sendDown). *)

	(self respondsTo: dispatcher selector) ifTrue: 
		[dispatcher message sendTo: self.
		^true].
	^false
)'private'
createTarget = (

	^DropTargetForPresenterList new
		owner: self
)
invokeDropActionFrom: dragSource <DragSource>
withArguments: subjectReportedArguments <Array>
afterIndex: index <Integer> = (

	dropAction ifNotNil:
		[:it | 
		it reentrant 
			value: index 
			value: subjectReportedArguments]
)
visualContainsPoint: windowRelativePoint <Point> ^<Boolean> = (

	^visual windowRelativeBounds containsPoint: windowRelativePoint
)'restricted'
discardTarget = (

	cachedTarget:: nil
)
dropFrom: dragSource <DropSource> afterIndex: index <Integer> = (

	(* This message is sent by a drop target created for this list when something has been dropped onto the list. *)
	dragSource identifyPayloadTo:
		(AdHocMessageReceiver new
			receive: expectedSelector
			using: 
				(ArbitraryArityBlockWrapper block:
					[:arguments | 
					invokeDropActionFrom: dragSource 
					withArguments: arguments 
					afterIndex: index]))
)) : ()
class DropTargetForPresenterList = DropTarget (
(* This drop target specializes in handling the drag-and-drop interaction of DropEnabledPresenterLists. In particular, it manages the display of the drop location marker displayed when a dragged thing is hovering over a drop-enabled list.

Slots:

owner <DropEnabledPresenterList> The presenter handled by target.

dropLocationMarker <Fragment | nil> The fragment or presenter temporarily inserted by this target into the owner in order to show drop location feedback. If the slot is nil, no such fragment is currently inserted.

markerIndex <Integer | nil> If not nil, the current index of the drop location marker in the owner list.
*)| owner dropLocationMarker markerIndex |)
('notifications'
dragDropFrom: source <DragSource> = (

	| dropAfterIndex |
	if: source isDraggingExpectedSelectorDo: 
		[dropAfterIndex:: markerIndex - 1.
		removeDropLocationMarker.
		owner discardTarget.
		owner dropFrom: source afterIndex: dropAfterIndex]
)
dragEnterFrom: source <DragSource> = (

	||
	if: source 
	isDraggingExpectedSelectorDo: 
		[showDropLocationMarker]
)
dragExitFrom: source <DragSource> = (

	||
	if: source 
	isDraggingExpectedSelectorDo: 
		[removeDropLocationMarker.
		owner discardTarget].
)
dragStepFrom: source <DragSource> = (

	||
	if: source 
	isDraggingExpectedSelectorDo: 
		[updateDropLocationMarkerPosition]
)'parameters'
markerBackgroundColor ^<Color> = (

	^Color gray: 0.7
)
markerText ^<String> = (

	^'drop here'
)
markerTextColor ^<Color> = (

	^Color gray: 1
)'private'
createDropLocationMarker = (

	(* This is the guy that appears as the drop marker, but not having the usual presenter combinators we have to build it by hand. *)
	dropLocationMarker:: 
		ColumnComposer definitions:
			{BlankFragment size: 3.
			RowComposer definitions:
				{BlankFragment size: 10.
				(StaticLabelFragment text: markerText) color: markerTextColor.
				BlankFragment elasticity: 2}.
			BlankFragment size: 3}.
	dropLocationMarker color: markerBackgroundColor.
)
if: source <DragSource> isDraggingExpectedSelectorDo: aBlock <[:Array]> = (

	source identifyPayloadTo:
		(AdHocMessageReceiver new
			receive: owner expectedSelector
			using: 
				(ArbitraryArityBlockWrapper block: 
					[:ignoredArguments | aBlock value]))
)
removeDropLocationMarker = (

	owner removeAt: markerIndex.
	dropLocationMarker:: nil.
	markerIndex:: nil.
)
showDropLocationMarker = (

	| insertionIndex |
	createDropLocationMarker.
	insertionIndex:: owner insertionIndexForCurrentMousePointWithMarker: dropLocationMarker.
	owner add: dropLocationMarker afterIndex: insertionIndex.
	markerIndex:: insertionIndex + 1.
)
updateDropLocationMarkerPosition = (

	| newIndex insertionIndex |
	newIndex:: owner insertionIndexForCurrentMousePointWithMarker: dropLocationMarker.
	(newIndex = (markerIndex - 1) or:
		[newIndex = owner presenters size and: [markerIndex = newIndex]])
			(* same position, inside or at the bottom of the list *)
			ifTrue: [^self].
	owner removeAt:  markerIndex.
	insertionIndex:: newIndex min: owner presenters size.
	owner add: dropLocationMarker afterIndex: insertionIndex.
	(* {newIndex. markerIndex. insertionIndex} trace. *)
	markerIndex:: insertionIndex + 1
)) : ()
class Fragment = (
(* A Fragment is the basic unit of a Hopscotch tool (document). This class is the abstract superclass defining the traits common to all fragments:

	* The parent/child hierarchy of fragments and its maintenance.
	* The visual created by the fragment, if any.
	
Slots:
	parentX <Fragment> The parent of this fragment.
	visualX <Visual | nil> The rendition of this fragment as a Brazil Visual, if exists. The rendition is created lazily by the #createVisual method on receipt of the #visual message by an instance.
	decorators <nil | Collection[Decorator]> Decorators that are to be applied to the rendition of the fragment to complete its presentation.
*)| parentX visualX decorators |)
('BOGUS-compatibility'
value = (
	BOGUS. (* expected when these classes extended the Squeak Object *)
	^self
)
~~ other = (
	BOGUS. (* expected by Set>>includes: *)
	^(self == other) not
)'accessing'
addDecorator: newDecorator <Decorator> = (

	(* The argument is added last to the collection of our decorators, meaning it will be applied after all the other decorators we might have. *)
	
	decorators
		ifNil: [decorators:: OrderedCollection with: newDecorator]
		ifNotNil: [decorators addLast: newDecorator]
)
addOutlineItemsTo: parentItem = (


	childrenDo: [:each | each addOutlineItemsTo: parentItem]
)
children ^<Collection[Fragment]> = (


	| result |
	result:: OrderedCollection new.
	childrenDo: [:each | result add: each].
	^result
)
childrenDo: aBlock = (


	subclassResponsibility
)
enableInspection = (

)
error: msg <String> = (
	^Error signal: msg
)
flash = (


	visualX ifNotNil: [:it | it flash]
)
notifyOfPossibleOutlineChange = (

	sendUp deliveryOptional outlineMayHaveChanged
)
parent ^<Fragment> = (


	^parentX
)
replaceChild: aFragment with: anotherFragment = (


	subclassResponsibility
)
requestVisibility = (
	(* Notify the parent chain of this fragment that it wants to be visible. *)
	requestVisibilityOfRectangle: self visual localBounds
)
requestVisibilityOfRectangle: rect <Rectangle> = (
	(* Notify whoever is responsible for scrolling up the parent chain of this fragment that the specified range of Y coordinates (relative to the fragment's top left corner) should be made visible. *)
	sendUp deliveryOptional
		ensureVisibilityOfRectangle: rect within: self
)
shell ^<Hopscotch> = (

	(* Answer the top-level navigator application. Fail if there is no path to it. *)

	^parent isNil
		ifTrue: [error: 'hierarchy not installed in a shell']
		ifFalse: [parent shell]
)
title = (

	^'anonymous fragment'
)
visual ^<Visual> = (

	(* Render the receiver as a hierarchy of Brazil visuals. *)

	visualX == nil ifTrue:
		[visualX:: decorate: createVisual.
		noticeVisualCreation].
	^visualX
)
withAllChildrenDo: aBlock = (


	aBlock value: self.
	childrenDo: [:each | each withAllChildrenDo: aBlock]
)'decorating'
compressibility: compressibility <Number> = (
	addDecorator::
		CellLayoutDecorator new
			compressibility: compressibility
)
elasticity: elasticityNumber <Number> = (
	addDecorator::
		CellLayoutDecorator new
			expansibility: elasticityNumber;
			compressibility: elasticityNumber
)
expansibility: expansibility <Number> = (
	addDecorator::
		CellLayoutDecorator new
			expansibility: expansibility
)
minimumWidth: pixels <Number> = (
	addDecorator::
		CellLayoutDecorator new
			minimumSize: pixels
)
width: anInteger = (
	addDecorator::
		CellLayoutDecorator new size: anInteger
)
width: anInteger elasticity: elasticityNumber = (
	addDecorator::
		CellLayoutDecorator new
			size: anInteger;
			expansibility: elasticityNumber;
			compressibility: elasticityNumber
)'notices'
noticeAbandonment = (

	(* Sent to all fragments of a hierarchy just before it is forgotten by a top-level navigation-enabling parent. *)
	
	childrenDo: [:each | each noticeAbandonment]
)
noticeAdoption = (

	(* Sent to all fragments of a hierarchy after it has been adopted by a top-level navigation-enabling parent. *)
	
	childrenDo: [:each | each noticeAdoption]
)
noticeConcealment = (

	(* Propagated down the fragment hierarchy after the hierarchy has become invisible because the navigator or the the containing composer such as a toggle has hidden the root. At the time the message is received, the fragment's visual is not visible anymore. A fragment may receive this message multiple times over its life. *)
	
	childrenDo: [:each | each noticeConcealment]
)
noticeExposure = (

	(* Propagated down the fragment hierarchy just after the hierarchy has been made visible. A fragment may receive this message multiple times over its life. *)
	
	childrenDo: [:each | each noticeExposure]
)
noticeImminentExposure = (

	(* Propagated down the fragment hierarchy just before the hierarchy is made visible. A fragment may receive this message multiple times over its life. *)
	
	childrenDo: [:each | each noticeImminentExposure]
)
noticeInstallation = (

	(* Sent to the root fragment of a hierarchy after the hierarchy has been attached to a composer in another hierarchy or a browser. *)

	noticeAdoption.
	scheduleDeferredContentInstallation
)
noticeRemoval = (

	(* Sent to the root fragment of a hierarchy when the hierarchy is removed from a composer in another hierarchy or from a browser. *)
	
	noticeAbandonment
)
noticeVisualCreation = (

	(* Received after the receiver's visual has been created and stored in the corresponding slot. *)
)
sendDown ^<RequestDispatcher> = (

	(* Create and answer a RequestDispatcher that can deliver a downward request on behalf of the receiver. *)

	^DownwardRequestDispatcher new sender: self
)
sendUp ^<RequestDispatcher> = (

	(* Create and answer a RequestDispatcher that can deliver a request on behalf of the receiver. *)

	^UpwardRequestDispatcher sender: self
)'parameters'
viewportColor = (

	^Color white
)'private'
createViewportWithVisual ^<Viewport> = (
	| wrapper viewport |	
	wrapper:: Wrapper with: (decorate: createVisual).
	wrapper content areaClass: Frame.
	wrapper content area
		fullyCoverParent;
		leftOffset: 3;
		topOffset: 3;
		rightOffset: -3.	
	viewport:: VerticalViewport new color: viewportColor.
	viewport add: wrapper.
	viewport scrollPositionH changed
		=> [:p | sendDown respondToScrollingInViewport: viewport].
	^viewport
)
createVisual ^<Visual> = (


	subclassResponsibility
)
decorate: aVisual = (

	(* The argument is a visual freshly created by the #createVisual or #createViewportWithVisual method. If we have any decorators attached, apply them now to arrive at the final decorated visual. *)
	
	| decorated |
	decorated:: aVisual.
	decorators ifNotNil:
		[decorators do: [:each | decorated:: each decorate: decorated]].
	^decorated
)
scheduleDeferredContentInstallation = (

	(* Collect all children that are deferred-constructed and fork a background process to construct them. *)

	| deferredFragments |
	deferredFragments:: OrderedCollection new.
	collectDeferredContentInto: deferredFragments.
	deferredFragments isEmpty not ifTrue:
		[sendUp deliveryOptional navigatorDo:
			[:shell |
			shell addDeferredContent: deferredFragments]]
)
viewport ^<Visual> = (

	(* Normally presenters render themselves in response to the #visual message, producing a block visual. In some situations, for example when the presenter is the top-level presenter in a Hopscotch shell application, the presenter is instead asked to produce a scrollable viewport.
	Subclasses that never want to render as a viewport will want to redefine this method. It is not *required* to answer a viewport -- the message simply indicates that the sender intends to use the result in a context where a viewport is more appropriate. *)
	
	visualX == nil ifTrue: 
		[visualX:: createViewportWithVisual.
		noticeVisualCreation].
	^visualX
)'requests'
receiveRequestFrom: dispatcher <RequestDispatcher> ^<Boolean> = (

	(* Process the request to execute a 'vertical' message carrried by the dispatcher and answer true, or answer false if the request is not recognized. *)
	
	^false
)'restricted'
collectDeferredContentInto: aCollection = (

	(* A downward request to collect all deferred content composers in the hierarchy into the collection passed as the argument. *)

	childrenDo: [:each | each collectDeferredContentInto: aCollection]
)
findTargetForDragAt: windowRelativePoint <Point> forSession: session <DragDropSession> ^<DropTarget> = (

	^nil
)
parent: newParent <Fragment | nil> = (

	(* This message is sent to a child by its parent right after the child is registered as a child of the parent, of (when the argument is nil) just before it is removed from the parent's records. *)
	
	parentX:: newParent.
	newParent isNil
		ifTrue: [noticeRemoval]
		ifFalse: [newParent isInstalledInShell ifTrue: [noticeInstallation]]
)
refresh = (

	(* Fragments that dynamically retrieve their information should reimplement this to update their visuals accordingly. *)

	childrenDo: [:each | each refresh]
)'testing'
hasChildren ^<Boolean> = (

	(* Return true if the receiver has any children. This is the generic catch-all implementation in terms of childrenDo:. A subclass may redefine this to perform the test more efficiently. *)

	childrenDo: [:any | ^true].
	^false
)
hasParent = (


	^parentX notNil
)
hasPendingChanges ^<Boolean> = (

	(* Answer whether the fragment at this time displays any changes made by the user which haven't yet been applied to the displayed objects (for example, method edits). *)

	childrenDo: [:any | any hasPendingChanges ifTrue: [^true]].
	^false
)
hasVisual ^<Boolean> = (

	(* Answer true if the visual for this fragment has already been created and remembered. *)

	^visualX notNil
)
isInstalledInShell = (


	^parent notNil and: [parent isInstalledInShell: self]
)
isInstalledInShell: aChild = (


	^parent notNil and: [parent isInstalledInShell: self]
)) : ()
class HistoryPresenter onSubject: s = Presenter onSubject: s (
(*  *)|  |)
('actions'
forgetAll = (

	sendUp navigatorDo: [:shell | shell eraseHistory]
)'appearance'
indentedBlock: body = (

	^column: {
		mediumBlank.
		row: {
			mediumBlank.
			elastic: body
			}.
		mediumBlank
		}
)
majorHeadingBlock: body = (

	^(padded: body with: {10. 10. 5. 10.})
		color: majorHeadingColor
)
majorHeadingColor = (
	^Gradient 
		from: (Color h: 240 s: 0.05 v: 0.92) 
		to: (Color h: 240 s: 0.05 v: 0.86)
)'as yet unclassified'
forgetEntry: aPresenter = (
	sendUp navigatorDo: [:sh | sh eraseHistoryEntry: aPresenter].
)
forgetEntryUIFor: aPresenter = (
	^(link: '[forget]'
		action: [forgetEntry: aPresenter. parent refresh])
			tinyFont color: (Color gray: 0.8).
)'definition'
definition = (

	^column: {
		majorHeadingBlock:
			(row: {
				label: 'Viewed in this Browser' asText allBold.
				filler.
				button: 'Forget All' action: [forgetAll].
				}).
		blank: 2.
		zebra: (column: presentersForHistoryEntries).
		}
)'private'
presentersForHistoryEntries ^<Collection[Presenter]> = (

	| presenters |
	presenters:: OrderedCollection new: 20.
	subject historyDo:
		[:each |
		presenters add: 
			(row: {
				elastic: each listElementMetapresenter.
				blank: 5.
				forgetEntryUIFor: each.
				blank: 5.
				})].
	^presenters
)'testing'
isTransient = (
	(* Should not be recorded in navigation history. *)

	^true
)) : ()
class HistorySubject onModel: m = Subject onModel: m (
(*  *)|  |)
('accessing'
historyDo: aBlock = (
(* Evaluate the argument for all presenters in the history I represent, most recently visited one first. *)

^model reverseDo: aBlock
)
title = (

	^'History'
)'private'
createPresenter = (

	^HistoryPresenter onSubject: self
)) : ()
class HomePresenter onSubject: s = Presenter onSubject: s (|
|)
('as yet unclassified'
definition = (
	^label: 'Home'
)) : ()
class HomeSubject onModel: m = Subject onModel: m (|
|)
('as yet unclassified'
createPresenter = (
	^HomePresenter onSubject: self
)) : ('as yet unclassified'
new = (
	^onModel: nil
))
class HopscotchShell = (
(* This abstract class captures the top-level browser functionality of history tracking and back/forward navigation. It also supports the basic rendering of presenters as Brazil visuals and installing the rendition of the currentPresenter as the content of the contentHolder. Subclasses will provide fancier facilities such as the actual window with the contentHolder, the toolbar, etc.
*)| 
	navigator::= NavigationHistory new
		transientTestBlock: [:presenter | presenter isTransient].
	deferredContentQueue::= SharedQueue new.
	showOutline ::= false.
	homeSubject ::= HomeSubject new.
	currentPresenterX
	contentHolder
	deferredContentInstaller
	outliner
|)
('accessing'
currentPresenter = (


	^currentPresenterX
)
currentSubject = (


	^currentPresenter subject
)
enterPresenter: aPresenter <Presenter> ^<Presenter> = (

	(* This is the workhorse of navigation, the primary means of requesting a browser to display a particular presenter. If the browser already has a presenter in its visit history equal (=) to the argument, the presenter from the history is displayed instead of the argument. The method returns the actual displayed presenter, so (result = aPresenter) is always true while (result == aPresenter) may be false. *)

	| presenterToDisplay |
	shiftWasPressed
		ifTrue: (* open in a new window *)
			[openPresenterInNewWindow: aPresenter.
			^aPresenter]
		ifFalse: (* open here and record in history *)
			[presenterToDisplay:: navigator equalVisitOr: aPresenter.
			navigator visit: presenterToDisplay.
			displayPresenter: presenterToDisplay.
			^presenterToDisplay]
)
isInstalledInShell = (

	(* This is the shell. *)
	
	^true
)
parent = (


	^nil
)
shell = (


	^self
)'actions'
eraseHistory = (

	(* Forget all visits in the history and show the home page. *)

	navigator erase.
	goHome
)
goBack = (


	| presenterToGoTo |
	navigator isPastEmpty ifFalse:
		[shiftWasPressed ifTrue:
			[^openSubjectInNewWindow: navigator previous refreshmentSubject].
		navigator goBack.
		displayPresenter: navigator current]
)
goForward = (


	| presenterToGoTo |
	navigator isFutureEmpty ifFalse:
		[shiftWasPressed ifTrue:
			[^openSubjectInNewWindow: navigator next refreshmentSubject].
		navigator goForward.
		displayPresenter: navigator current]
)
goHome = (
	atHome ifFalse:
		[enterSubject: homeSubject]
)
refresh = (

	(* Since refreshing forces a new copy of the current presenter into the browser, we need to massage it into the history as well. *)

	| newSubject |
	newSubject:: currentPresenter subject refreshmentSubject.
	displaySubject: newSubject.
	navigator replaceCurrentWith: newSubject presenter.
)
showHistory = (


	enterPresenter: (HistoryPresenter onSubject: (HistorySubject onModel: navigator allVisits))
)
toggleOutline = (


	outliner ifNotNil: [:it | it toggleOutline]
)'as yet unclassified'
addDeferredContent: fragments <Collection[DeferredFragment]> = (

	(* In some debugging situations there may not be a deferred content installer because we decided not to start it to isolate concurrency issues. *)

	deferredContentInstaller ifNotNil:
		[fragments do: [:each | deferredContentQueue nextPut: each]]
)
atHome = (
	^homeSubject = currentPresenter subject
)
childrenDo: aBlock = (

	aBlock value: currentPresenter
)
desktop = (

	^brazil theDesktop
)
eraseHistoryEntry: aPresenter = (
	navigator eraseEntry: aPresenter.
)
navigateTo: subject <Subject> = (
	(* Intended to be sent through the sendUp mechanism as the way to have the shell go to a different place. May be intercepted along the way to change the default behavior. *)
	enterSubject: subject
)
openPresenterInNewWindow: aPresenter = (


	(self class new presenter: aPresenter) openOnDesktop: desktop
)
openSubjectInNewWindow: aSubject = (


	(self class new subject: aSubject) openOnDesktop: desktop
)
resetDeferredContentInstaller = (

	(* This action is performed when a new presenter replaces the old one in the shell view. There may still be deferred content pending installation. We cannot simply flush the queue and keep the existing installer process because the incorrect implementation of SharedQueue in Squeak makes it possible for the flush to cause a synchronization error if it happens when the installer process is past the semaphore but has not yet grabbed the next element.
	To avoid that we create a brand new queue and installer process. If the old one is still processing input, it will break our of the loop and complete on finding that it is no longer the official installer for this shell. If it is stopped on a semaphore of an empty queue, it is not runnable and will be garbage-collected together with the queue.
	If there is no installer process to begin with, we don't want one for debugging reasons. *)

	deferredContentInstaller ifNotNil:
		[deferredContentQueue:: SharedQueue new.
		startDeferredContentInstaller]
)
sendDown ^<RequestDispatcher> = (

	(* Create and answer a RequestDispatcher that can deliver a downward request on behalf of the receiver. *)

	^DownwardRequestDispatcher new sender: self
)
setupOutliner ^<Outliner> = (

	outliner:: Outliner new presenter: currentPresenter.
	^outliner
)
startDeferredContentInstaller = (


	deferredContentInstaller::
	[
		(* See the comment in #resetDeferredContentInstaller. *)
		[Processor activeProcess == deferredContentInstaller] whileTrue:
			[ | fragment |	
			fragment:: deferredContentQueue next.
			fragment createDeferredContent.
			fragment visual desktop ifNotNil:
				[:desktop |
				desktop scheduleUIInstallment:
					[fragment installDeferredContent] fixTemps]]
	]
		forkAt: Processor userBackgroundPriority
)
stopDeferredContentInstaller = (


	deferredContentInstaller ifNotNil:
		[:it |
		it terminate.
		deferredContentInstaller: nil].
	deferredContentQueue flush
)'initialize-release'
presenter: aPresenter = (


	currentPresenter:: aPresenter
)
subject: aSubject = (


	presenter:: aSubject presenter.
)'private'
buildContentHolder = (


	contentHolder:: Wrapper new.
	^contentHolder
)
buildDropDown: actionBlock = (


	| button images |
	button:: ActiveIcon new.
	images:: HopscotchImages default.
	button
		image: images hsDropdownImage;
		disabledImage: images hsDropdownOutImage;
		hoverImage: images hsDropdownOverImage;
		downImage: images hsDropdownDownImage;
		actOnMouseDown: true;
		action: actionBlock.
	^button
)
computeScrollYToShowFrom: desiredStart to: desiredEnd between: visibleStart and: visibleEnd = (

	(* The workhorse of handling scroll requests; computes where to scroll to display what we want with the minimal disturbance of the view. desiredStart and desiredEnd are the Y coordinates of what we want visible, visibleStart and visibleEnd are what's visible with the current scroll. What the method returns becomes the new visibleStart. *)

	| canSeeTop canSeeBottom overshoot |
	canSeeTop:: desiredStart between: visibleStart and: visibleEnd.
	canSeeBottom:: desiredEnd between: visibleStart and: visibleEnd.
	overshoot:: 3. (* How many pixels too many to scroll for better appearance. *)
	canSeeTop & canSeeBottom ifTrue:
		(* Peachy. *)
		[^visibleStart].
	canSeeTop & canSeeBottom not ifTrue:
		(* Scroll down just a little to make the thing completely visible. *)
		[^visibleStart + (desiredEnd - visibleEnd) + overshoot
			min: desiredStart - overshoot].
	canSeeTop not & canSeeBottom ifTrue:
		(* Scroll up just a little to make the thing completely visible. *)
		[^desiredStart - overshoot].
	(* Neither the top nor the bottom are visible, scroll just enough to show. *)
	^desiredStart < visibleStart
		ifTrue: (* Scrolling up *)
			[desiredStart - overshoot]
		ifFalse: (* Scrolling down *)
			[visibleStart + (desiredEnd - visibleEnd) + overshoot]
)
displayPresenter: aPresenter = (

	(* Make the presenter the currently displayed one. This presenter change does not get recorded as a navigation event in navigation history. Use #enterPresenter: for that. *)

	| oldPresenter fragmentToInstall |
	oldPresenter:: currentPresenter.
	oldPresenter noticeConcealment.
	currentPresenter:: aPresenter.
	fragmentToInstall:: showOutline
		ifTrue: [setupOutliner]
		ifFalse: [currentPresenter].
	resetDeferredContentInstaller.
	Cursor wait showWhile:
		[fragmentToInstall parent == self ifFalse:
			[fragmentToInstall parent: self].
		currentPresenter noticeImminentExposure.
		(* Instrumentation to benchmark the creation of visuals. *)
		flag: #profile.
		(* MessageTally spyOn: [contentHolder content: currentPresenter viewport]. *)
		contentHolder content: fragmentToInstall viewport].
	currentPresenter noticeExposure
)
displaySubject: aSubject = (

	(* Make the default presenter of the subject the currently displayed one. This presenter change is not recorded in the navigation history. *)

	self displayPresenter: aSubject presenter
)
prepareToForget: aPresenter = (


	aPresenter noticeRemoval
)
prepareToForgetAllPresenters = (


	currentPresenter noticeConcealment.
	navigator do: [:each | prepareToForget: each]
)
selectFutureItem: aPresenter = (


	| index |
	shiftWasPressed ifTrue:
		[^openSubjectInNewWindow: aPresenter subject refreshmentSubject].
	navigator goToFutureItem: aPresenter.
	displayPresenter: navigator current
)
selectPastItem: aPresenter = (


	| index |
	shiftWasPressed ifTrue:
		[^openSubjectInNewWindow: aPresenter subject refreshmentSubject].
	navigator goToPastItem: aPresenter.
	displayPresenter: navigator current
)
shiftWasPressed = (


	^desktop modifierKeyStateForCurrentEvent shiftPressed
)
wrapToAlignToBottomCenter: aVisual = (


	| wrapper |
	wrapper:: Wrapper new.
	wrapper content: aVisual.
	aVisual area beBottomCenter.
	^wrapper
)'requests'
ensureVisibilityOf: aFragment = (

	(* Scroll the viewport to make the requestor visible. *)

	| viewport position requestorVisual requestorBounds finalScrollY |
	flag: #BOGUS. (* this is ugly and fragile *)
	viewport:: showOutline
		ifTrue: [contentHolder content children last]
		ifFalse: [contentHolder content].
	requestorVisual:: aFragment visual.
	(requestorVisual isDescendantOf: viewport) ifFalse: [^self].
	position:: viewport scrollPosition.
	requestorBounds:: requestorVisual bounds
		translateFrom: requestorVisual parent to: (viewport at: 1).
	finalScrollY::
		computeScrollYToShowFrom: requestorBounds top
		to: requestorBounds bottom
		between: position y
		and: position y + viewport innerExtent y.
	viewport scrollPosition: position x @ finalScrollY
)
ensureVisibilityOfRectangle: spotlight <Rectangle> within: requestor <Fragment> = (
	(* Scroll the viewport to make the specified rectangle within the requestor visible (if it isn't already). *)
	| viewport position requestorVisual spotlightInViewport finalScrollY |
	flag: #BOGUS.
	(* [vassili 9/13/2012 10:38] perhaps we want to take out the showOutline nonsense *)
	viewport:: showOutline
		ifTrue: [contentHolder content children last]
		ifFalse: [contentHolder content].
	requestorVisual:: requestor visual.
	(requestorVisual isDescendantOf: viewport) ifFalse: [^self].
	position:: viewport scrollPosition.
	spotlightInViewport:: spotlight
		translateFrom: requestorVisual to: (viewport at: 1).
	finalScrollY::
		computeScrollYToShowFrom: spotlightInViewport top
		to: spotlightInViewport bottom
		between: position y
		and: position y + viewport innerExtent y.
	viewport scrollPosition: position x @ finalScrollY
)
navigatorDo: aBlock = (

	(* Process a request sent from somewhere in the presenter hierarchy to communicate with the navigator. The argument is a block that should be invoked with a navigator instance. *)

	^aBlock value: self
)
receiveRequestFrom: dispatcher ^<Boolean> = (


	(self respondsTo: dispatcher selector) ifTrue:
		[dispatcher message sendTo: self.
		^true].
	^false
)
replaceChild: aFragment <Fragment> with: replacement <Fragment> = (


	aFragment == currentPresenter
		ifTrue: 
			[navigator replaceCurrentWith: replacement.
			displayPresenter: replacement]
		ifFalse: [navigator replace: aFragment with: replacement]
)'restricted'
currentPresenter: aPresenter = (


	navigator visit: aPresenter.
	currentPresenterX:: aPresenter
)
enterSubject: aSubject = (
	(* Enter the default presenter for the subject. *)

	self enterPresenter: aSubject presenter
)
isInstalledInShell: child = (


	^child == currentPresenter
)
spawn = (


	(self class new subject: currentPresenter subject copy) open
)) : ('private'
withSubjectFromBlock: aBlock = (


	| instance |
	instance:: self new.
	instance subject: (aBlock value: instance).
	^instance
))
class HopscotchWindow = HopscotchShell (
(* Builds on the basic HopscotchShell to add the ''real'' window displaying the current presenter, with a toolbar showing back and forward buttons and other navigational gadgets. *)| initialOriginX initialExtentX window toolbar forwardButton backButton pastButton futureButton homeButton |)
('accessing'
desktop = (

	^window desktop
)
displayPresenter: aPresenter = (

	(* Also update the window elements that depend on the current presenter. *)
	
	super displayPresenter: aPresenter.
	updateToolbar.
	updateWindowTitle
)
open = (

	openOnDesktop: brazil theDesktop.
)
openOnDesktop: aDesktop = (

	| screenBounds windowBounds fragmentToInstall |
	screenBounds:: Rectangle origin: 0@0 extent: aDesktop extent.
	windowBounds:: initialBounds translatedToBeWithin: screenBounds.
	windowBounds:: windowBounds intersect: screenBounds.
	buildWindow.
	fragmentToInstall:: showOutline
		ifTrue: [setupOutliner]
		ifFalse: [currentPresenter].
	fragmentToInstall parent: self.
	currentPresenter noticeImminentExposure.
	contentHolder content: fragmentToInstall viewport.
	aDesktop add: window.
	windowBounds:: window agent outerToInner:  windowBounds.
	window area bounds: windowBounds.
	window on: #closed do: [respondToClose].
	currentPresenter
		noticeExposure.
	updateToolbar.
	updateWindowTitle.
	window visible: true.
	startDeferredContentInstaller.
)'actions'
forceCloseWindow = (


	window closePermission: nil.
	window close
)
respondToNew = (
	(* The New button has been clicked. Respond by opening a new browser. If the Shift key is down, show a copy of the current page in the new browser. *)
	
	openSubjectInNewWindow:
		(shiftWasPressed
			ifTrue:
				[currentPresenter subject refreshmentSubject]
			ifFalse: 
				[homeSubject refreshmentSubject])
)'as yet unclassified'
authorizeUnsavedChanges = (
	^false
)
notifyAllPresentersOfRemoval = (
	navigator allVisits do: [:each | each noticeRemoval]
)'drag/drop'
acceptDropOfHopscotchSubject: subject = (

	self enterSubject: subject refreshmentSubject
)
dropFrom: dragSource <DragSource> = (

	dragSource identifyPayloadTo:
		(AdHocMessageReceiver new
			receive: #draggingHopscotchSubject:
			using: [:subject | acceptDropOfHopscotchSubject: subject])
)
findTargetForDragAt: windowRelativePoint <Point> forSession: session <DragDropSession> = (

	(* A HopscotchWindow registers itself as the dragDropDispatcher of its Brazil window, so it is here that we direct target search to look among the fragments. *)
	sendDown 
		ifInterestedInDragAt: windowRelativePoint
		forSession: session
		doWithTarget: [:target | ^target].
	^viewpointSwitchingDropTarget
)
viewpointSwitchingDropTarget = (

	| target |
	target:: DropTarget new
		dropAction: [:source | dropFrom: source].
	^target
)'notifications'
respondToClose = (


	stopDeferredContentInstaller.
	prepareToForgetAllPresenters.
)'parameters'
initialBounds ^<Rectangle> = (

	(* Return the bounds on the screen the receiver should occupy when first opened. *)

	^initialOrigin extent: initialExtent
)
initialBounds: newValue <Rectangle> = (
	(* Set the position and size of the receiver when first opened. *)
	initialOrigin: newValue origin.
	initialExtent: newValue extent.
)
initialExtent ^<Point> = (

	(* Return the size the receiver should have when first opened. *)

	^initialExtentX ifNil:
		[showOutline
			ifTrue: [800 @ 800]
			ifFalse: [600 @ 800]]
)
initialExtent: newValue ^<Point> = (
	(* Set the size of the receiver when first opened. *)

	initialExtentX:: newValue
)
initialOrigin ^<Point> = (

	(* Return the position the receiver should have when first opened. *)

	^initialOriginX ifNil: [200 @ 100]
)
initialOrigin: theOrigin ^<Point> = (
	(* Set the position of the receiver when first opened. *)

	initialOriginX:: theOrigin
)'private-UI'
buildWindow = (


	window:: Window new title: 'Hopscotch'.
	window 
		owner: self;
		dragDropDispatcher: self;
		closePermission: [checkWindowClosePermission];
		on: #closed do: [notifyAllPresentersOfRemoval].
	window content: Column new.
	window content
		addBlankSize: 3;
		add: buildToolbar;
		addBlankSize: 5;
		add: buildContentHolder.
	contentHolder area elasticity: 1.
	buildMenuBar ifNotNil: [:it | window menuBarMenu: it].
	^window
)
checkWindowClosePermission ^<Boolean> = (


	^(navigator allVisits select: [:each | each hasPendingChanges]) isEmpty not
		ifTrue:
			[authorizeUnsavedChanges]
		ifFalse:
			[true]
)
selectFromFuture = (


	| menu |
	menu:: Menu forVisual: window.
	navigator future do:
		[:each | | item |
		item:: MenuItem 
			label: each title 
			action: [selectFutureItem: each] fixTemps.
		item icon: each icon.
		menu add: item].
	menu 
		openIn: window desktop 
		at: (0 @ futureButton extent y
				translateFrom: futureButton
				to: window desktop)
)
selectFromPast = (


	| menu |
	menu:: Menu forVisual: window.
	navigator past reverseDo:
		[:each | | item |
		item:: MenuItem 
			label: each title 
			action: [selectPastItem: each] fixTemps.
		item icon: each icon.
		menu add: item].
	menu 
		openIn: window desktop 
		at: (0 @ pastButton extent y
				translateFrom: pastButton
				to: window desktop)
)'private-toolbar'
addMenuBarItemsTo: menu <Menu> = (


	menu add: (SubmenuItem
		label: '&Navigator'
		submenu: (Menu new
			add: (MenuItem label: '&New' action: [respondToNew]);
			add: SeparatorItem new;
			add: (MenuItem label: '&Refresh' action: [refresh]);
			add: (MenuItem label: '&Close' action: [respondToClose]);
			yourself
		)).
	menu add: (SubmenuItem
		label: '&Go'
		submenu: (Menu new
			add: (MenuItem label: '&Back' action: [goBack]);
			add: (MenuItem label: '&Forward' action: [goForward]);
			add: SeparatorItem new;
			add: (MenuItem label: '&Home' action: [goHome]);
			add: (MenuItem label: 'Hi&story' action: [showHistory]);
			yourself
		)).
	menu add: (SubmenuItem
		label: '&Help'
		submenu: (Menu new
			add: (MenuItem label: 'User''s Guide' action: []);
			add: SeparatorItem new;
			add: (MenuItem label: 'About' action: []);
			yourself
		)).
)
addToolbarItemsTo: toolbar = (


	pastButton:: buildDropDown: [selectFromPast].
	toolbar add: (wrapToAlignToBottomCenter: pastButton).
	toolbar addBlankSize: 3.
	backButton:: toolbar add: buildBackButton.
	forwardButton:: toolbar add: buildForwardButton.
	toolbar addBlankSize: 3.
	futureButton:: buildDropDown: [selectFromFuture].
	toolbar add: (wrapToAlignToBottomCenter: futureButton).
	
	toolbar addBlankSize: 10.
	toolbar add: buildHistoryButton.
	toolbar addBlankSize: 2.
	homeButton:: toolbar add: buildHomeButton.

	toolbar addBlankSize: 10.	
	toolbar add: buildRefreshButton.
	toolbar addBlankSize: 2.
	toolbar add: buildNewButton.
	
	showOutline ifTrue:
		[toolbar addBlankSize: 10.
		toolbar add: buildToggleOutlineButton]
)
buildBackButton = (


	| button images |
	button:: ActiveIcon new.
	images:: HopscotchImages default.
	button
		image: images hsBackImage;
		disabledImage: images hsBackOutImage;
		hoverImage: images hsBackOverImage;
		downImage: images hsBackDownImage;
		action: [goBack].
	^button 
)
buildForwardButton = (


	| button images |
	button:: ActiveIcon new.
	images:: HopscotchImages default.
	button
		image: images hsForwardImage;
		disabledImage: images hsForwardOutImage;
		hoverImage: images hsForwardOverImage;
		downImage: images hsForwardDownImage;
		action: [goForward].
	^button 
)
buildHistoryButton = (


	| button images |
	button:: ActiveIcon new.
	images:: HopscotchImages default.
	button
		image: images hsHistoryImage;
		hoverImage: images hsHistoryOverImage;
		downImage: images hsHistoryDownImage;
		action: [showHistory].
	^button 
)
buildHomeButton = (


	| button images |
	button:: ActiveIcon new.
	images:: HopscotchImages default.
	button
		image: images hsHomeImage;
		disabledImage: images hsHomeOutImage;
		hoverImage: images hsHomeOverImage;
		downImage: images hsHomeDownImage;
		action: [goHome].
	^button 
)
buildMenuBar ^<Menu | nil> = (

	(* The method should answer the menu to use as the menu bar, or nil if the window should have no menu bar. *)

	| menu |
	menu:: Menu new.
	addMenuBarItemsTo: menu.
	^menu
)
buildNewButton = (


	| button images |
	button:: ActiveIcon new.
	images:: HopscotchImages default.
	button
		image: images hsNewImage;
		hoverImage: images hsNewOverImage;
		downImage: images hsNewDownImage;
		action: [respondToNew].
	^button 
)
buildRefreshButton = (


	| button images |
	button:: ActiveIcon new.
	images:: HopscotchImages default.
	button
		image: images hsRefreshImage;
		hoverImage: images hsRefreshOverImage;
		downImage: images hsRefreshDownImage;
		action: [refresh].
	^button 
)
buildToggleOutlineButton = (


	| button images |
	button:: ActiveIcon new.
	images:: HopscotchImages default.
	button
		image: images hsNewImage;
		hoverImage: images hsNewOverImage;
		downImage: images hsNewDownImage;
		action: [toggleOutline].
	^button 
)
buildToolbar = (


	toolbar:: Row new.
	toolbar addBlankSize: 5.
	addToolbarItemsTo: toolbar.
	toolbar addBlankSize: 5.
	^toolbar
)'restricted'
updateToolbar = (

	(* Update the state of toolbar controls that depend on the current state of the browser. *)

	backButton enabled: navigator isPastEmpty not.
	forwardButton enabled: navigator isFutureEmpty not.
	pastButton enabled: navigator isPastEmpty not.
	futureButton enabled: navigator isFutureEmpty not.
	homeButton enabled: atHome not.
)
updateWindowTitle = (


	| title |
	title:: currentPresenter title.
	title isEmpty ifTrue: 
		[title:: 'Hopscotch'].
	window desktop isWindows ifTrue:
		[title:: title, ' - Newspeak'].
	window title: title
)) : ('as yet unclassified'
withSubjectFromBlock: aBlock = (
	| instance |
	instance:: self new.
	instance subject: (aBlock value: instance).
	^instance
)'opening'
openSubject: aSubject <Subject> = (


	^openSubjectFromBlock: [:instance | aSubject]
)
openSubjectFromBlock: aBlock = (


	^(withSubjectFromBlock: aBlock) open
))
class LeafFragment = Fragment (
(* This is the abstract superclass of all leaf fragments, that is those without any children of their own.
*))
('accessing'
children = (

	
	^Array new
)
childrenDo: aBlock = (

	(* No children. *)
)'as yet unclassified'
replaceChild: aFragment with: anotherFragment = (


	error: 'a leaf fragment should never receive this'
)'testing'
hasChildren = (

	(* Never. *)

	^false
)
hasPendingChanges ^<Boolean> = (

	(* For simplicity, we assume that most leaf fragments can never have pending changes. Those for which it is not true should override this method. *)

	^false
)) : ()
class NavigationHistory = (
(* NavigationHistory is a richly structured collection that maintains a web browser-like history of ''visits''. Visits are arbitrary objects. NavigationHistory makes no assumptions about visits other than that they can be compared using #=.

The important attributes of a history are: the ''current'' visit, the ''past'', the ''future'' and ''allVisits''. A history starts off empty. To visit an object, send the #visit: message to the history with the object as the argument. This makes the object the ''current'' object of the history.

The ''past'' is a queue of visits that used to be the current (most recently current object last). Sending the #goBack message makes the most recently current object from the past the current again, while the current object becomes the first member of the ''future'' queue. Sending the #goForward message reverses the process. Visiting an object other than the first element of the ''future'' queue erases the future queue.

All visits visited by a history are remembered in the ''allVisits'' set. This set is never emptied, other than on an explicit request.

A history can optionally be configured with a transientTestBlock. The test block is applied to visits to determine whether they are transient or not. Transient visits are not recorded in the ''past'' and ''future'' queues and in the ''allVisits'' set. By default all visits are considered to be non-transient.
*)| currentVisitX allVisits past future transientTestBlock::= [:element | false]. |erase)
('accessing'
current = (


	^currentVisitX
)
do: aBlock = (


	(* Do the current visit separately if transient because it's not among allVisits. *)
	(isTransient: currentVisitX) ifTrue:
		[aBlock value: currentVisitX].
	allVisits do: aBlock
)
equalVisitOr: anObject = (

	(* Return a visit from the history equal to the argument, or the argument itself if there is no equal visit in the history. *)

	^allVisits detect: [:some | some = anObject] ifNone: [anObject]
)
erase = (


	currentVisitX:: nil.
	allVisits:: OrderedCollection new.
	erasePast.
	eraseFuture.	
)
eraseFuture = (


	future:: OrderedCollection new.
)
erasePast = (


	past:: OrderedCollection new.
)
next = (

	(* Answer the closest visit from the future. Fail if the future is empty. *)
	
	^future first
)
previous = (

	(* Answer the most recent visit from the past. Fail if the past is empty. *)
	
	^past last
)
replace: anObject with: replacement = (

	(* Replace all references to anObject that we have with references to 'replacement'. *)

	allVisits remove: anObject ifAbsent: [].
	(isTransient: replacement) ifFalse: [allVisits add: replacement].
	currentVisitX = anObject ifTrue: [currentVisitX:: replacement].
	past keysAndValuesDo:
		[:index :each | each = anObject ifTrue: [past at: index put: replacement]].
	future keysAndValuesDo:
		[:index :each | each = anObject ifTrue: [future at: index put: replacement]]
)
replaceCurrentWith: anObject = (


	self replace: currentVisitX with: anObject
)'as yet unclassified'
eraseEntry: anObject = (
	allVisits remove: anObject.
	past remove: anObject ifAbsent: [].
	future remove: anObject ifAbsent: []. (* can it ever be in the future list? *)
)'navigating'
goBack = (


	isPastEmpty ifFalse:
		[(isTransient: currentVisitX) ifFalse:
			[future addFirst: currentVisitX].
		currentVisitX:: past removeLast]	
)
goForward = (


	isFutureEmpty ifFalse:
		[(isTransient: currentVisitX) ifFalse:
			[past addLast: currentVisitX].
		currentVisitX:: future removeFirst]	
)
goToFutureItem: anObject = (


	[currentVisitX = anObject or: [isFutureEmpty]]
		whileFalse: [goForward]
)
goToPastItem: anObject = (


	[currentVisitX = anObject or: [isPastEmpty]]
		whileFalse: [goBack]
)
visit: anObject = (

	(* Make the argument the current object of the history. The prior current object becomes the last object of the 'past' queue. The 'future' queue is erased, unless the visit is equal to the first element of the future. *)

	currentVisitX = anObject ifTrue: [^self].
	(currentVisitX notNil and: [(isTransient: currentVisitX) not]) ifTrue:
		[past addLast: currentVisitX].
	currentVisitX:: anObject.
	(isTransient: anObject) ifFalse:
		[allVisits 
			remove: anObject ifAbsent: [];
			add: anObject].
	future isEmpty not ifTrue:
		[future first = currentVisitX
			ifTrue: [future removeFirst]
			ifFalse: [eraseFuture]].
)'testing'
includesVisit: anObject = (


	^allVisits includes: anObject
)
isEmpty = (


	^allVisits isEmpty
)
isFutureEmpty = (


	^future isEmpty
)
isPastEmpty = (


	^past isEmpty
)
isTransient: anObject = (


	^transientTestBlock value: anObject
)) : ()
class Presenter onSubject: aSubject = Fragment (
(* A Presenter is a semantic Fragment, aware of the thing it presents (held onto by its subject). *)|
	subject::=aSubject.
	substanceX
	noticeHandlerSelectorsX
|)
('accessing'
childrenDo: aBlock = (


	substanceX ifNotNil: [:it | aBlock value: it]
)
extraInformationMetapresenter ^<Presenter> = (

	^nothing
)
icon ^<Form | nil> = (

	(* The icon, if not nil, can be displayed together with the title where appropriate to better identify the presenter. *)

	^nil
)
listElementMetapresenter ^<Presenter> = (
(* A presenter that can represent the receiver in a list of presenters such as the History. *)

	^row: {
		minimalMetapresenter.
		mediumBlank.
		deferred: 
			[hasPendingChanges 
				ifTrue: [label: 'has unsaved edits' asText allBold]
				ifFalse: [nothing]].
		filler compressibility: 0.
		(deferred: [extraInformationMetapresenter]) compressibility: 1.
	}
)
majorUpdate: aBlock = (

	(* aBlock is evaluated so that the UI avoids any incremental layout adjustments while the block is runs and does a single wholesale update afterwards. *)

	^showWaitCursorWhile:
		[visual blockIncrementalLayoutUpdatesWhile: aBlock]
)
minimalMetapresenter ^<Presenter> = (
(* A minimal presenter that can represent the receiver in places such as the History. *)

	^row: {
		icon 
			ifNotNil: 
				[:it | 
				draggableImage: it forSubject: subject]
			ifNil: 
				[blank: 17].
		blank: 5.
		link: title action: [enterPresenter: self].
	}
)
outlineItem ^<OutlineItem | nil> = (

	(* Create and answer an outline item that represents the presenter. Answer nil if the presenter should not be displayed in outlines. *)
	^nil
)
replaceChild: aFragment with: anotherFragment = (


	error: 'should never receive this'
	(* The only child of a presenter is its substance, and the substance is a simple presentational fragment such as a HolderFragment or a Composer that we expect to handle any replacement requests within itself. *)
)
substance = (


	ensureSubstance. 
	^substanceX
)
title ^<String> = (

	(* The title identifies the presenter in places such as the browser title bar or the history menu. *)

	^subject title
)'actions'
enterPresenter: aPresenter = (
	(* Look into getting rid of this. *)
	sendUp navigatorDo:
		[:navigator | navigator enterPresenter: aPresenter]
)
fork: workAction <[T]> thenUpdateUI: uiAction <[] | [:T]> = (

	(* Perform workAction in a separate thread of control then schedule uiAction in the UI event loop with the result of the work. *)
	[
		isInstalledInShell ifTrue:
			[ | work |
			work:: workAction value.
			schedule: [uiAction valueWithPossibleArgument: work]]
	] forkAt: Processor userBackgroundPriority named: 'UI Worker'
)
refreshWhenDone: action <[]> = (

	(* Perform action in a separate thread of control, then schedule a refresh unless the result of the action is nil. *)
	||
	fork: action thenUpdateUI:
		[:result |
		result ifNotNil:
			[self refresh]]
)
respondToOutlineSelection = (

	requestVisibility
)
schedule: uiAction = (

	(* Schedule uiAction to be performed in the UI event loop. The uiAction will not be performed if this presenter is not installed in a shell. *)
	visual ifNotNil:
		[:v|
		v desktop ifNotNil:
			[:d |
			d scheduleUIAction:
				[isInstalledInShell ifTrue:
					[majorUpdate:	
					[uiAction value]]]]]
)
unimplemented = (


	self error: 'not implemented yet'
)'as yet unclassified'
adviseOnViewportScrollPosition: requestor = (	
	(* Expected to be sent using sendUp from a contaned presenter; respond by directly invoking the standard viewport scrolling notification. *)
	(visual isKindOf: VerticalViewport) ifTrue:
		[requestor respondToScrollingInViewport: visual]
)
alert: message <String> = (


	MessageBox new ok: message; open
)
dropTarget: fragment expecting: selector dropAction: aBlock = (

	^(DropTargetHolderComposer content: fragment)
		expectedSelector: selector;
		dropAction: aBlock;
		yourself
)
enterSubject: aSubject = (

	sendUp
		ifUndelivered: [core HopscotchWindow openSubject: aSubject];
		navigateTo: aSubject
)
floatingHeader: header <Fragment> body: body <Fragment> minimumRatio: ratio <Integer> = (
	^(FloatingHeaderComposer header: header body: body)
		minimumBodyToHeaderRatio: ratio;
		yourself
)
floatingPanel: fragment <Fragment> = (
	^FloatingPanelComposer panel: fragment
)
printOn: aStream = (


	super printOn: aStream.
	aStream 
		nextPut: $(;
		print: subject;
		nextPut: $)
)
progress = (

	^ProgressFragment new
)
progress: percentComplete = (

	^ProgressFragment new percentComplete: percentComplete
)
request ^<Request> = (

	(* Use this to request a file, newFile, or directory using native dialog if available *)
	^Request usingPlatform: cachedPlatform
)
resizableLeft: left <Fragment> right: right <Fragment> = (
	^SplitterComposer left: left right: right
)'combinators-containers'
at: location <Point> display: presenter <Presenter> ^<CanvasItem> = (


	^CanvasItem withContent: presenter at: location
)
canvas: elements <Collection[CanvasElementAnchor | CanvasElementFrame]>
dropTargetCreationBlock: block <Block> ^<CanvasComposer> = (


	^(CanvasComposer elements: elements)
		dropTargetCreationBlock: block
)
canvas: elements <Collection[CanvasElementAnchor | CanvasElementFrame]> ^<CanvasComposer> = (


	^CanvasComposer elements: elements
)
column: definitions <Collection[Block]> ^<Composer> = (


	^ColumnComposer definitions: definitions
)
deferred: contentSource <Block> ^<DeferredContentComposer> = (


	^DeferredContentComposer new contentSource: contentSource
)
draggable: content <Fragment> subject: subject <Subject> image: image <Form | nil> = (


	^(DragSubjectHolderComposer withContent: content) 
		subject: subject;
		image: image
)
elastic: aFragment = (
	aFragment elasticity: 1.
	^aFragment
)
floatingHeader: header <Fragment> body: body <Fragment> = (
	^FloatingHeaderComposer header: header body: body
)
flow: definitions <Collection[Block]> ^<Block> = (


	^FlowComposer definitions: definitions
)
grabArea: content <Fragment> = (


	^CanvasItemGrabArea withContent: content
)
holder: definition = (


	^HolderComposer withContent: definition
)
incrementalList: presenterSource <[:WriteStream[HPresenter]]> ^<PresenterList> = (


	^PresenterList new presenterSource:
		[Array streamContents: presenterSource]
)
initially: initialFragment <Fragment> deferred: contentSource <Block> ^<DeferredContentComposer> = (


	^DeferredContentComposer new 
		initialContent: initialFragment;
		contentSource: contentSource
)
list = (


	^PresenterList new
)
list: presenterSource <Collection | Block> ^<PresenterList> = (


	^PresenterList new presenterSource: presenterSource
)
list: presenterSource <Collection | Block> dropExpecting: dropSelector action: dropAction = (


	^DropEnabledPresenterList new
		presenterSource: presenterSource;
		expectedSelector: dropSelector;
		dropAction: dropAction;
		yourself
)
padded: definition with: offsets = (

	(* Wrapping in a Column so that the color of the whole thing can be set. *)

	^column: {
		PaddedFrameComposer new
			content: definition;
			paddingLeft: (offsets at: 1);
			paddingTop: (offsets at: 2);
			paddingRight: (offsets at: 3);
			paddingBottom: (offsets at: 4)
		}
)
padded: definition with: offsets roundedCornersColor: color = (

	(* Wrapping in a Column so that the color of the whole thing can be set. *)

	| composer |
	composer:: AdHocRoundedCornersHolderComposer
		withContent: 
			(PaddedFrameComposer new
				content: definition;
				paddingLeft: (offsets at: 1);
				paddingTop: (offsets at: 2);
				paddingRight: (offsets at: 3);
				paddingBottom: (offsets at: 4)).
	composer color: color.
	^composer
)
row: definitions <Collection[Fragment]> ^<Fragment> = (


	^RowComposer definitions: definitions
)
sequence: definitions <Collection[Block]> ^<Block> = (


	^column: definitions
)
spy: definition <Fragment> ^<Fragment> = (


	^SpyingHolderComposer content: definition
)'combinators-decoration'
zebra: sequence = (
	sequence addDecorator: ZebraDecorator lighterColorFirst.
	^sequence
)'combinators-disclosure'
collapsed: collapsed <Block> expanded: expanded <Block> ^<Block> = (


	^	collapsed: collapsed 
		expanded: expanded
		initiallyExpanded: false
)
collapsed: collapsed <Block> expanded: expanded <Block> initiallyExpanded: flag <Boolean>
^<Block> = (


	^ToggleComposer new
		collapsedDefinition: collapsed expandedDefinition: expanded;
		expanded: flag
)
expanded: expanded <Block> collapsed: collapsed <Block> ^<Block> = (


	^	collapsed: collapsed 
		expanded: expanded
		initiallyExpanded: true
)
heading: heading <Block> details: details <Block> ^<Block> = (


	^heading: heading details: details initiallyExpanded: false
)
heading: heading <Block> details: details <Block> initiallyExpanded: flag <Boolean>
^<Block> = (


	^DisclosureComposer new
		header: heading value bodyDefinition: details;
		expanded: flag
)
heading: heading <Block> detailsExpanded: details <Block> ^<Block> = (


	^heading: heading details: details initiallyExpanded: true
)
less: less <Block> label: showMoreLabel <String>
more: more <Block> label: showLessLabel <String>
^<Block> = (


	^	less: less label: showMoreLabel
		more: more label: showLessLabel
		initiallyMore: false
)
less: less <Block> label: showMoreLabel <String>
more: more <Block> label: showLessLabel <String>
initiallyMore: flag <Boolean>
^<Block> = (


	^MoreOrLessComposer new
		lessDefinition: less moreDefinition: more;
		lessCaption: showLessLabel;
		moreCaption: showMoreLabel;
		expanded: flag
)
less: less <Block> more: more <Block> ^<Block> = (


	^	less: less label: 'more...'
		more: more label: 'less...'
		initiallyMore: false
)
more: more <Block> label: showLessLabel <String>
less: less <Block> label: showMoreLabel <String>
^<Block> = (



	^	less: less label: showMoreLabel
		more: more label: showLessLabel
		initiallyMore: false
)
more: more <Block> less: less <Block> ^<Block> = (



	^	less: less label: 'more...'
		more: more label: 'less...'
		initiallyMore: true
)'combinators-misc'
blank: size <Number> = (


	^BlankFragment size: size
)
button: label <String> action: block = (


	^ButtonFragment new
		label: label; 
		action: block
)
centered: content <Fragment> = (

	^CenteringFrameComposer content: content
)
collapsibleLabel: label <String | nil> = (


	^CollapsibleLabelFragment new text: label
)
draggableImage: image <Form | Block> forSubject: subjectOrBlock <Subject | [Subject]> = (


	^draggable: (image: image) subject: subjectOrBlock image: image
)
dropDownMenu: menuSupplier <Block> = (


	^DropDownMenuFragment new
		menuSupplier: menuSupplier
)
filler = (


	^BlankFragment elasticity: 1
)
image: image <Form | Block> = (


	^StaticImageFragment new
		image: image;
		yourself
)
imageButton: images <Array> action: block = (


	^ImageButtonFragment new
		images: images;
		action: block
)
imageButton: images <Array> action: block actOnMouseDown: shouldActOnMouseDown <Boolean> = (


	^ImageButtonFragment new
		images: images;
		actOnMouseDown: shouldActOnMouseDown;
		action: block
)
label: label <String> = (


	^StaticLabelFragment text: label
)
link: labelOrBlock <String | Block> 
action: block <Block>
dragSourceCreationBlock: dragSourceBlock <[DragSource]> = (


	^HyperlinkFragment new
		label: labelOrBlock; 
		action: block;
		dragSourceCreationBlock: dragSourceBlock
)
link: labelOrBlock <String | Block> 
action: block <Block>
dragSubject: dragSubject <Subject | [Subject]>
withImage: dragImage <Form> = (


	^HyperlinkFragment new
		label: labelOrBlock; 
		action: block;
		dragSubject: dragSubject;
		dragImage: dragImage.
)
link: labelOrBlock <String | Block> action: block <Block> = (


	^HyperlinkFragment new
		label: labelOrBlock; 
		action: block
)
linkImage: image <Form> action: block = (


	^HyperlinkImageFragment image: image action: block
)
menuWithLabelsAndActions: labelsAndActions = (


	| menu |
	menu:: Menu forVisual: visual.
	labelsAndActions do:
		[:each |
		menu add: (#separator = each
			ifTrue: [SeparatorItem new]
			ifFalse: [MenuItem key: nil label: each key action: each value])].
	^menu
)
nothing = (


	^BlankFragment new
)
openMenu: aMenu = (


	aMenu openIn: visual desktop
)
openMenuWithLabelsAndActions: labelsAndActions = (


	openMenu: (menuWithLabelsAndActions: labelsAndActions)
)
textDisplay: aString <String> = (


	^TextDisplayFragment text: aString
)'comparing'
= anotherPresenter = (


	^anotherPresenter class = class and: [anotherPresenter subject = subject]
)
hash = (


	^subject hash
)'definition'
definition = (


	subclassResponsibility
)'layout'
mediumBlank = (

	^blank: 10
)'notices'
noticeSubstanceCreation = (

	(* Received after the #definition method of the receiver has been invoked and the result remembered as its substance. The substance hasn't been asked to create a visual yet. *)
)
receiveRequestFrom: dispatcher ^<Boolean> = (

	(* Receive and process a notice coming from one of the children (usually as the result of using #sendUp). *)

	(self respondsTo: dispatcher selector)
		ifTrue: 
			[dispatcher message sendTo: self.
			^true]
		ifFalse:
			[^false]
)'private'
createVisual = (


	ensureSubstance.
	^substanceX visual
)
ensureSubstance = (


	substanceX ifNil:
		[substanceX:: self definition.
		substanceX parent: self.
		noticeSubstanceCreation]
)'testing'
hasSubstance ^<Boolean> = (


	^substanceX ~~ nil
)
isTransient = (

	(* Should visits of this presenter be omitted from the navigation history? *)
	
	^false
)'utilities'
copyToClipboard: object = (


	Clipboard clipboardText: object asString
)
showWaitCursorWhile: action <BlockContext> = (


	World activeHand showTemporaryCursor: Cursor wait.
	World displayWorldSafely.
	^action ensure: [World activeHand showTemporaryCursor: nil]
)) : ()
class PresenterList = Fragment (
(* PresenterList is a fragment that manages a sequence of Presenters, displaying them as a column. The interesting functionality it provides beyond that is updating itself intelligently when receiving a new sequence of presenters to display. New presenters equal (as determined by #=) to those currently displayed remain displayed as before, with any state they had unaffected even if their order in the list has changed.

The presenters can be given to the list either as a collection or as a niladic block that evaluates to a collection. In the latter case, a PresenterList will re-evaluate the block and update itself from the result each time it receives the #refresh message.

Slots:

presenterSourceX <SequenceableCollection | Block> The presenters to display or the block providing them, as given to this instance when it was created.

presentersX <SequenceableCollection> If presenterSourceX is a collection, this slot holds the same object as presenterSourceX. It it is the block, it holds the last result produced by the block.
*)| 
	presenterSourceX::= OrderedCollection new.
	presentersX 
|)
('accessing'
add: aPresenter <Presenter> = (

	(* Append the argument to the end of the list of displayed presenters. If there is an equal presenter already displayed, remove it. *)

	(presenters includes: aPresenter) ifTrue:
		[presenters remove: aPresenter].
	presenters:: presenters copyWith: aPresenter
)
add: aPresenter <Presenter> afterIndex: index <Integer> = (


	| newList |
	newList:: presenters copy.
	newList add: aPresenter afterIndex: index.
	presenters: newList.
)
addFirst: aPresenter <Presenter> = (

	(* Add the argument at the beginning of the end of the list of displayed presenters. If there is an equal presenter already displayed, remove it. *)

	(presenters includes: aPresenter) ifTrue:
		[presenters remove: aPresenter].
	presenters:: {aPresenter}, presenters.
)
childrenDo: aBlock = (


	presentersX ifNotNil: [:they | they do: aBlock]
)
detectPresenter: aBlock = (


	^presentersX detect: aBlock
)
detectPresenter: aBlock ifNone: noneBlock = (


	^presentersX detect: aBlock ifNone: noneBlock
)
presenters ^<Collection [Presenter]> = (

	(* Return the presenters we are currently showing, pulling them from the source if needed. *)

	presentersX == nil ifTrue:
		[setPresenters: presenterSourceX value].
	^presentersX
)
refresh = (


	| newPresenters |
	newPresenters:: refreshPresenterList asSet.
	presenters do:
		[:each |
		(newPresenters includes: each) ifFalse: [each refresh]]
)
refreshPresenters = (


	presenters do: [:each | each refresh]
)
remove: aPresenter = (


	presenters:: presenters copyWithout: aPresenter
)
removeAt: index <Integer> = (


	| copy |
	copy:: presenters copy.
	copy removeAt: index.
	presenters:: copy.
)'as yet unclassified'
addAll: additionalPresenters <{Presenter}> = (
	presenters: (presenters concatenate: additionalPresenters)
)
color: aColor = (


	addDecorator::
		ColorDecorator new color: aColor
)
findFirst: aBlock = (
	(* Answer the index of my first element for which aBlock evaluates as true. *)
	^presentersX findFirst: aBlock
)
findLast: aBlock = (
	(* Answer the index of my last element for which aBlock evaluates as true. *)
	^presentersX findLast: aBlock
)'initialize-release'
presenterSource: niladicValuable <Sequence[Presenter] | [Presenter]> = (


	presenterSourceX:: niladicValuable.
	presentersX ifNotNil: [refreshPresenterList]
)
presenters: newPresenterList <Sequence[Presenter]> = (


	self presenterSource: newPresenterList
)'private'
createVisual = (


	| column |
	column:: Column new.
	updateColumn: column 
		removingIndices: {} 
		addingPresenters: presenters.
	^column
)
refreshPresenterList = (

	(* Make it so that the displayed presenters match those provided by the source. For a list initialized with a presenter collection, this only does anything non-trivial when the instance is brand new. For a list initialized with a block, this re-evaluates the block and updates the list. *)

	^setPresenters: presenterSourceX value
)
setPresenters: newPresenterList <Sequence[Presenter]> = (

	(* This is the workhorse of intelligent updates: massage the argument presenters into the currently displayed list, making sure that if there is an element of newPresenterList equal to a currently displayed presenter, we continue using the current presenter. *)

	| currentPresenters oldPresentersAndIndices removedPresenters removedIndices addedPresenters newFinalList |
	currentPresenters:: presentersX ifNil: [OrderedCollection new].
	oldPresentersAndIndices:: Dictionary new: currentPresenters size.
	currentPresenters keysAndValuesDo:
		[:index :each | oldPresentersAndIndices at: each put: index].
	addedPresenters:: OrderedCollection new: newPresenterList size.
	newFinalList:: OrderedCollection new: newPresenterList size.
	
	newPresenterList do:
		[:each | | oldIndex |
		oldIndex:: oldPresentersAndIndices at: each ifAbsent: [nil].
		oldIndex notNil 
			ifTrue: (* reusing a presenter we already have for this subject *)
				[newFinalList add: (presenters at: oldIndex).
				oldPresentersAndIndices removeKey: each]
			ifFalse:
				[newFinalList add: each.
				addedPresenters add: each]].

	removedPresenters:: oldPresentersAndIndices keys.
	removedIndices:: (1 to: currentPresenters size) select:
		[:index | removedPresenters includes: (currentPresenters at: index)].
	
	presentersX:: newFinalList.
	addedPresenters do: [:each | each parent: self].
	hasVisual ifTrue:
		[updateColumn: visualX
		 removingIndices: removedIndices 
		 addingPresenters: addedPresenters].
	^addedPresenters
)
updateColumn: column removingIndices: indices addingPresenters: newPresenters = (


	indices asSortedCollection reverseDo:
		[:each | column removeAt: each].
	newPresenters do:
		[:each | column add: each visual].
	column reorder:
		(presenters collect: [:each | each visual])
)'requests'
replaceChild: aFragment with: anotherFragment = (


	| index newPresenters |
	(presentersX includes: aFragment) ifTrue:
		[index:: presenters indexOf: aFragment.
		newPresenters:: presenters copy.
		newPresenters at: index put: anotherFragment.
		^presenters: newPresenters].
	error: 'the fragment is not a child'
)) : ()
class Subject onModel: aModel = (
(* A Subject is the perspective of looking at a certain object in a particular way. The object, or the information necessary to retrieve it, is stored in the 'model' slot.
*)| model::=aModel. presenterX |)
('accessing'
presenter = (

	(* The approved API for getting the current, or the default, presenter for this subject. *)

	presenterX ifNil:
		[presenterX:: createPresenter].
	^presenterX
)
refreshmentSubject ^<Subject> = (

	(* Answer a new subject representing the same thing as the receiver. *)
	
	^self class onModel: model
)
title ^<String> = (
(* Return a string that can be shown to the user to identify this subject. A subclass will typically want to override this to return something more descriptive than the printString. *)

	^self printString
)'printing'
printOn: aStream = (


	super printOn: aStream.
	aStream 
		nextPut: $(;
		print: model;
		nextPut: $)
)'private'
createPresenter = (

	(* Subclasses should define this to create their presenter. In the future this process can be further factored so that presenter creation is controlled by a policy object, say to display the same subjects differently under different hardware constraints. For now, to keep things simple subjects themselves create their presenters. *)

	subclassResponsibility
)) : ()
class UpwardRequestDispatcher = (
(* Responsible for delivering requests inside a fragment hierarchy from children to parents. Typically created by sending the #sendUp message to a fragment and then sending to the result the message to deliver as a request to parents. For example, in a method of a fragment:

	sendUp deleteSlotInPresenter: self.
	
The message #deleteSlotInPresenter: sent to the instance is catched by the doesNotUnderstand: method of the dispatcher. The dispatcher then walks the chain of parents of the instance sending to each the #receiveRequestFrom: message, searching for one that would return true from the message to indicate acceptance of the request. The argument of the #receiveRequestFrom: message is the dispatcher itself. A parent can communicate with the dispatcher to retrieve and examine the sender, the selector, and/or the arguments of the request.

What exactly constitutes the acceptance and handling of a request is up to each particular parent to define. However, the interpretation common to presenters is to accept a request with the selector understood by the presenter, and process it by sending the selector to the presenter.

By default, a request is delivered to the first (in the bottom-up order) presenter that accepts it, and the delivery finishes. A dispatcher can be flagged as #toAll by sending it this message before asking it to deliver a request. Such a presenter will deliver its requests to all interested parents of the sender.

If none of the parents of a presenter accept a request, an error is signaled by default. However, a dispatcher can be flagged as delivery-optional by sending to it the #deliveryOptional message after creation and before using it to send a request. A delivery-optional dispatcher will silently ignore an undelivered request. Alternatively, the user can provide a dispatcher with an #ifUndelivered: block (again, before using it to send requests).

The category ''SqueakCrap'' has a number of methods that must be present to avoid having the debugger croak.
*)| sender sendToAll::=false. message ifUndelivered delivered::=false. |)
('SqueakCrap'
asExplorerString = (

	^ self printString
)
printStringLimitedTo: ignored = (


	^'a RequestDispatcher'
)'accessing'
arguments ^<Array> = (


	^message arguments
)
doesNotUnderstand: aMessage = (


	message:: aMessage.
	sendToAll
		ifTrue: [deliverToAll]
		ifFalse: [deliverToFirst].
	^delivered
		ifTrue: [sender]
		ifFalse:
			[ifUndelivered notNil
				ifTrue: [ifUndelivered value]
				ifFalse: [sender error: 'Undelivered notice']]
)
selector ^<Symbol> = (


	^message selector
)'initialize-release'
deliveryOptional = (

	(* Configure the receiver so that if a request is undelivered, no error is signaled. *)

	ifUndelivered: []
)
optional = (

	(* Configure the receiver so that if a request is undelivered, no error is signaled. *)

	ifUndelivered: []
)
toAll = (

	(* Configure the receiver so that it delivers requests to all parents of the sender, rather than only to the first one that will accept the request. *)

	sendToAll:: true
)'private'
deliverToAll = (


	| here |
	delivered:: false.
	here:: sender parent.
	[here notNil] whileTrue:
		[delivered:: delivered | (here receiveRequestFrom: self).
		here:: here parent]
)
deliverToFirst = (


	| here |
	delivered:: false.
	here:: sender parent.
	[here notNil] whileTrue:
		[(here receiveRequestFrom: self) ifTrue:
			[^delivered:: true].
		here:: here parent]
)) : ('instance creation'
sender: aPresenter = (


	^self new sender: aPresenter
))'as yet unclassified'
postInit = (
	CanvasComposer:: canvas CanvasComposer.
	CanvasItem:: canvas CanvasItem.
	CanvasItemGrabArea:: canvas CanvasItemGrabArea.

	AdHocRoundedCornersHolderComposer:: composers AdHocRoundedCornersHolderComposer.
	CellLayoutDecorator:: composers CellLayoutDecorator.
	CenteringFrameComposer:: composers CenteringFrameComposer.
	ColorDecorator:: composers ColorDecorator.
	ColumnComposer:: composers ColumnComposer.
	DeferredContentComposer:: composers DeferredContentComposer.
	DisclosureComposer:: composers DisclosureComposer.
	DragSubjectHolderComposer:: composers DragSubjectHolderComposer.
	DropTargetHolderComposer:: composers DropTargetHolderComposer.
	FlowComposer:: composers FlowComposer.
	FloatingHeaderComposer:: composers FloatingHeaderComposer.
	FloatingPanelComposer:: composers FloatingPanelComposer.
	HolderComposer:: composers HolderComposer.
	MoreOrLessComposer:: composers MoreOrLessComposer.
	PaddedFrameComposer:: composers PaddedFrameComposer.
	RowComposer:: composers RowComposer.
	SplitterComposer:: composers SplitterComposer.
	SpyingHolderComposer:: composers SpyingHolderComposer.
	ToggleComposer:: composers ToggleComposer.
	ZebraDecorator:: composers ZebraDecorator.

	BlankFragment:: fragments BlankFragment.
	ButtonFragment:: fragments ButtonFragment.
	CollapsibleLabelFragment:: fragments CollapsibleLabelFragment.
	DropDownMenuFragment:: fragments DropDownMenuFragment.
	HyperlinkFragment:: fragments HyperlinkFragment.
	HyperlinkImageFragment:: fragments HyperlinkImageFragment.
	ImageButtonFragment:: fragments ImageButtonFragment.
	ProgressFragment:: fragments ProgressFragment.
	StaticImageFragment:: fragments StaticImageFragment.
	StaticLabelFragment:: fragments StaticLabelFragment.
	TextDisplayFragment:: fragments TextDisplayFragment.

	Outliner:: outline Outliner.
)) : ()
class FragmentClasses = (|

	LeafFragment = core LeafFragment.
	Presenter = core Presenter.

|)
(
class BlankFragment = LeafFragment (
(* A fragment displayed as white space in the document, created typically by the #blank: and #filler definition entries. *)| sizeX elasticityX |)
('accessing'
elasticity = (


	^elasticityX
)
elasticity: newValue <Number> = (


	elasticityX:: newValue.
	hasVisual ifTrue:
		[visual area elasticity: elasticityX]
)
size = (


	^sizeX
)
size: newSize <Integer> = (


	sizeX:: newSize.
	hasVisual ifTrue:
		[visual area principalSize: sizeX]
)'private'
createVisual = (

	(* Only set area parameters if we in fact have them--this allows blanks with no parameters function outside of the visual sequence context. *)

	| blank |
	blank:: Blank new.
	size ifNotNil: [blank area principalSize: size].
	elasticity ifNotNil: [blank area elasticity: elasticity].
	^blank
)) : ('instance creation'
elasticity: elasticity <Number> = (


	^self new elasticity: elasticity
)
size: size <Number> = (


	^self new size: size
))
class ButtonFragment = LeafFragment ((*
*)| labelX action enabledX |)
('accessing'
label ^<String> = (


	^labelX
)
label: newLabel <String> = (


	labelX:: newLabel.
	hasVisual ifTrue: [visual label: label]
)'as yet unclassified'
enabled = (

	^(enabledX == false) not
)
enabled: newValue <Boolean> = (


	enabledX:: newValue.
	hasVisual ifTrue: [visual enabled: enabled]
)'private'
createVisual ^<Visual> = (


	| button |
	button:: Button new.
	button
		label: label;
		enabled: enabled;
		action: action.
	^button
)) : ()
class CollapsibleLabelFragment = LeafFragment (
(* Similar to LabelFragment, but allows the label to be set to nil in which case the fragment collapses to the size 0 x 0 and the space it occupied becomes available.
*)| labelX textX |)
('accessing'
text ^<Text> = (


	^textX ifNil: [String new]
)
text: newContent <Text | nil> = (


	textX:: newContent.
	hasVisual ifTrue: 
		[visual content: buildWrapperContent]
)'private'
buildWrapperContent = (


	^text isEmpty 
		ifTrue: [Blank new]
		ifFalse: [Label new text: text]
)
createVisual = (


	^Wrapper with: buildWrapperContent
)
currentContent = (


	^label isNil 
		ifTrue: [Blank new]
		ifFalse: [Label new label: label]
)) : ()
class DragSourceFragment = LeafFragment (
(* OBSOLETE, should be removed.
An icon representing a subject that can be dragged.
*)| imageX subjectOrBlock responderX |)
('as yet unclassified'
createDragSource = (

	^HopscotchSubjectDragSource new
		subject: subject;
		draggedImage: image;
		wastelandTarget: HopscotchWastelandDropTarget new
)
createVisual ^<Visual> = (


	| icon |
	icon:: SensitiveIcon new image: image.
	responderX:: DragDropTracker new 
		attachTo: icon;
		sourceCreationBlock: [createDragSource].
	^icon
)
image = (

	^imageX value
)
image: imageOrBlock = (

	imageX:: imageOrBlock.
	refresh.
)
refresh = (


	(imageX isBlock and: [hasVisual]) ifTrue:
		[visualX image: image]
)
subject ^<Subject> = (

	^subjectOrBlock isBlock
		ifTrue: [subjectOrBlock value] 
		ifFalse: [subjectOrBlock]
)
subject: newSubject <Subject | [Subject]> = (

	subjectOrBlock:: newSubject
)) : ()
class DropDownMenuFragment = LeafFragment (
(*
*)| menuSupplier |)
('as yet unclassified'
createVisual = (


	| button images |
	button:: ActiveIcon new.
	images:: HopscotchImages default.
	button
		image: images hsDropdownImage;
		disabledImage: images hsDropdownOutImage;
		hoverImage: images hsDropdownOverImage;
		downImage: images hsDropdownDownImage;
		actOnMouseDown: true;
		action: 
			[menuSupplier value ifNotNil: 
				[:menu | 
				menu
					ownerVisual: visual;
					openIn: visual desktop]].
	^button	
)) : ()
class EditableLinePresenter onSubject: s = Presenter onSubject: s (
(* The superclass of presenters that display as a line of text (or other static representation) which can be transformed into an single-line text editor. A subclass will have to implement the logic that defines what the static display looks like, how the edit state is entered, and how the result of editing is mapped back onto the model state.
*)| isEditing::=false. editor |)
('as yet unclassified'
definition = (


	^holder: 
		[isEditing
			ifTrue: [editorDefinition]
			ifFalse: [viewerDefinition]]
)
definitionText = (


	subclassResponsibility
)
editorDefinition = (

		
	editor:: TextLineEditorFragment new.
	editor
		text: definitionText;
		cancelResponse: [respondToCancel];
		acceptResponse: [respondToAccept].
	^editor
)
enterEditState = (


	isEditing:: true.
	refresh
)
leaveEditState = (


	isEditing:: false.
	refresh
)
respondToAccept = (

	(* A subclass must redefine this to do whatever is needed to be done with <editor text> to save its as the new state of the subject, and send #leaveEditState if the save was successful. *)

	subclassResponsibility
)
respondToCancel = (


	leaveEditState
)
viewerDefinition = (


	subclassResponsibility
)) : ()
class HopscotchSubjectDragSource = DragSource (
(* A generic Hopscotch drag source that allows dragging around the subject or a presenter.
*)| subject |)
('as yet unclassified'
identifyPayloadTo: identificationReceiver = (

	^identificationReceiver
		try: [identificationReceiver draggingHopscotchSubject: subject]
		or: [super identifyPayloadTo: identificationReceiver]
)) : ()
class HopscotchWastelandDropTarget = (
(* This the drop target used by default to represent the wasteland, i.e. the space not occupied by any civilized Hopscotch or Brazil windows. Dropping things such as subjects onto the wasteland results in opening them in new Hopscotch windows.
*))
('as yet unclassified'
acceptDropOfHopscotchSubject: subject <Subject> onto: desktop <Desktop> = (

	| newBrowser |
	newBrowser:: core HopscotchWindow withSubjectFromBlock:
		[:instance | subject refreshmentSubject].
	newBrowser initialOrigin: desktop mousePoint.
	newBrowser openOnDesktop: desktop
)
dragStepFrom: dragSource <GenericDragSource> = (

	(* Do nothing for now. *)
)
dropFrom: dragSource <GenericDragSource> = (

	dragSource identifyPayloadTo: 
		(AdHocMessageReceiver new
			receive: #draggingHopscotchSubject: 
			using: 
				[:subject | 
				acceptDropOfHopscotchSubject: subject 
					onto: dragSource visual desktop])
)
isInterestedInDragSource: dragSource <DragSource> ^<Boolean> = (

	dragSource identifyPayloadTo: 
		(AdHocMessageReceiver new
			receive: #draggingHopscotchSubject: 
			using: [:subject | ^true]).
	^false
)) : ()
class HyperlinkFragment = LeafFragment (
(* Renders itself as a clickable link in the document.
*)| labelX fontX colorX action dragSourceCreationBlock dragSubjectOrBlock dragTracker dragImage |)
('accessing'
color	^<Color> = (


	^colorX
)
color: newColor <Color> = (


	colorX:: newColor.
	hasVisual ifTrue: [visual color: newColor]
)
font	^<Font> = (


	^fontX
)
font: newFont <Font> = (


	fontX:: newFont.
	hasVisual ifTrue: [visual font: newFont]
)
hugeFont = (


	font: Font huge
)
label = (


	^labelX value
)
label: aStringOrBlock = (


	labelX:: aStringOrBlock.
	hasVisual ifTrue: [visual label: label]
)
largeFont = (


	font: Font large
)
smallFont = (


	font: Font small
)
tinyFont = (


	font: Font tiny
)'as yet unclassified'
createDragSource = (

	^dragSourceCreationBlock notNil
		ifTrue: [dragSourceCreationBlock value]
		ifFalse: [HopscotchSubjectDragSource new
			subject: dragSubject;
			draggedImage: dragImage;
			wastelandTarget: HopscotchWastelandDropTarget new]
)
dragSubject = (

	^dragSubjectOrBlock isBlock
		ifTrue: [dragSubjectOrBlock value]
		ifFalse: [dragSubjectOrBlock]
)
dragSubject: newValue = (

	dragSubjectOrBlock:: newValue
)
refresh = (


	(labelX isString not and: [hasVisual]) ifTrue:
		[visual label: label]
)'private'
createVisual = (


	| link tracker |
	link:: Hyperlink new label: label; action: action.
	fontX ifNotNil: [link font: fontX].
	colorX ifNotNil: [link color: colorX].
	(dragSubject notNil | dragSourceCreationBlock notNil) ifTrue:
		[tracker:: DragDropTracker new
			visual: link;
			sourceCreationBlock: [createDragSource].
		link dragTracker: tracker].
	^link
)) : ('instance creation'
label: string action: block = (


	^self new
		label: string;
		action: block
))
class HyperlinkImageFragment = LeafFragment (
(*
*)| imageX actOnMouseDownX action |)
('accessing'
image = (


	^imageX
)
image: aForm = (


	imageX:: aForm.
	hasVisual ifTrue:
		[visual 
			image: imageX;
			hoverImage: imageX;
			downImage: imageX]
)'private'
createVisual = (


	^ActiveIcon new
		image: imageX;
		hoverImage: imageX;
		downImage: imageX;
		action: [action value]
)) : ('instance creation'
image: form action: block = (


	^self new
		image: form;
		action: block
))
class ImageButtonFragment = LeafFragment (| stateImages action shouldActOnMouseDown::=false. |)
('as yet unclassified'
actOnMouseDown: newState <Boolean> = (

	shouldActOnMouseDown:: newState.
	hasVisual ifTrue: [visual actOnMouseDown: newState]
)
createVisual = (

	^ActiveIcon new
		image: (stateImages at: 1);
		hoverImage: (stateImages at: 2);
		downImage: (stateImages at: 3);
		disabledImage: (stateImages at: 4);
		actOnMouseDown: shouldActOnMouseDown == true;
		action: [action value]
)
images: imageArray = (

	(* Set the images used for the various states of the button. The array should contain them in the following order: normal, hover, down, disabled. *)
	
	stateImages:: imageArray, (Array new: 3 withAll: nil).
	(* Appending three nils so that we can always send #at: with an index between 1 and 4 and expect it not to fail. *)
)) : ()
class ProgressFragment = LeafFragment (| percentCompleteX |)
('as yet unclassified'
barWithColor: color andWidth: width = (

	| box |
	box:: (* Rounded *)RectangleShape new.
	box size: 0@20.
	box color: color.
	box area elasticity: width.
	^box
)
createVisual ^<Visual> = (

	| row |
	row:: Row new.
	row add: (barWithColor: (Color h: 240 s: 0.3 v: 0.5) andWidth: 0.0 + percentComplete).
	row add: (barWithColor: Color transparent andWidth: 100.0 - percentComplete).
	^row
)
percentComplete = (

	^percentCompleteX ifNil: [0.0]
)
percentComplete: newValue = (


	percentCompleteX:: newValue.
	hasVisual ifTrue: [
		visual desktop ifNotNil:
			[:d |
			d scheduleUIAction:
				[isInstalledInShell ifTrue:
					[(visual at: 1) area elasticity: 0.0 + percentComplete.
					(visual at: 2) area elasticity: 100.0 - percentComplete]]]]
)) : ()
class SimpleTextEntryFragment = LeafFragment (
(* A line of text that the user can edit. The changeResponse block is invoked every time the text changes, with the current text passed as an (optional) argument. *)|
	editor
	changeResponse <Block>
|)
('private'
createVisual = (
	
editor:: TextView new.
	editor hasEditsFromUserChannel
		=> [:hasChanges | changeResponse ifNotNil: [:it | it cull: editor
 text asString]].
	^editor
)) : ()
class StaticImageFragment = LeafFragment (| imageX |)
('as yet unclassified'
createVisual = (


	^Icon new
		image: image;
		yourself
)
image = (


	^imageX value
)
image: imageOrBlock = (


	imageX:: imageOrBlock.
	(imageOrBlock isBlock and: [hasVisual]) ifTrue:
		[visualX image: image]
)
refresh = (


	(imageX isBlock and: [hasVisual]) ifTrue:
		[visualX image: image]
)) : ()
class StaticLabelFragment = LeafFragment (| textX fontX colorX |)
('accessing'
color	^<Color> = (


	^colorX
)
color: newColor <Color> = (


	colorX:: newColor.
	hasVisual ifTrue: [visual color: newColor]
)
font	^<Font> = (


	^fontX
)
font: newFont <Font> = (


	fontX:: newFont.
	hasVisual ifTrue: [visual font: newFont]
)
hugeFont = (


	font: Font huge
)
largeFont = (


	font: Font large
)
smallFont = (


	font: Font small
)
text	^<Text> = (


	^textX value
)
text: newText <Text | Block> = (

	(* If the text is a block, the block is evaluated to retrieve the text every time the label receives the #refresh message. *)

	textX:: newText.
	hasVisual ifTrue: [visual text: text]
)
tinyFont = (


	font: Font tiny
)'as yet unclassified'
refresh = (

	(* If the text is actually a text-providing monadic block, run it to retrieve the current content. *)
	
	(textX isString not and: [hasVisual]) ifTrue:
		[visual text: text]
)'private'
createVisual = (


	| label |
	label:: Label new text: text.
	fontX ifNotNil: [label font: fontX].
	colorX ifNotNil: [label color: colorX].
	^label
)) : ('instance creation'
text: text = (


	^self new text: text
))
class TextDisplayFragment = LeafFragment (| textX fontX |)
('accessing'
text = (


	^textX value (* textX may be a monadic block *)
)
text: aStringOrBlock = (


	textX:: aStringOrBlock.
	hasVisual ifTrue:
		[visual text: text]
)'as yet unclassified'
font	^<Font> = (


	^fontX
)
font: newFont <Font> = (


	fontX:: newFont.
	hasVisual ifTrue: [visual font: newFont]
)
largeFont = (


	font: Font large
)
refresh = (


	(textX isString not and: [hasVisual]) ifTrue:
		[visual text: text]
)
smallFont = (


	font: Font small
)
tinyFont = (


	font: Font tiny
)'private'
createVisual = (


	| textDisplay |
	textDisplay:: TextDisplay new text: text.
	fontX ifNotNil: [textDisplay font: fontX].
(*	colorX ifNotNil: [textDisplay color: colorX]. *)
	^textDisplay
)) : ('instance creation'
text: aString = (


	^self new text: aString
))
class TextEditorFragment = LeafFragment (| 
	textX::= String new.
	public acceptLabelText ::= 'save'.
	public cancelLabelText ::= 'cancel'.
	public controlBarColor ::= Color h: 45 s: 0.7 v: 1.
	public changeResponse
	public acceptResponse
	public cancelResponse
	public enterKeyResponse
	public escapeKeyResponse
	public menuBlock

	textBeingAccepted
	editor
	messagesContainer
	leftColumn
	editModeControls
	readOnlyVisual_
	isInReadOnlyState = false.
|)
('accessing'
addMessage: aString = (
	| messageLabel messageHolder |
	messageLabel:: Label new text: aString.
	messageLabel font: Font small.
	messageHolder:: Row new.
	messageHolder 
		addBlankSize: 3;
		add: messageLabel.
	messagesContainer add: messageHolder
)
editedText = (

	(* On a second thought, this is a more palatable name. *)

	^textBeingAccepted
)
enterReadOnlyState = (
	leftColumn at: 1 put: readOnlyVisual.
	isInReadOnlyState:: true.
)
leaveReadOnlyState = (
	leftColumn at: 1 put: editor.
	isInReadOnlyState:: false.
)
maybeSelectCurrentLine ^<String> = (
	^editor maybeSelectCurrentLine
)
removeLastMessage = (
	messagesContainer children size > 0 ifTrue:  [
		messagesContainer removeAt: messagesContainer children size]
)
removeMessages = (
	[messagesContainer children size > 0]
		whileTrue: [messagesContainer removeAt: 1]
)
selectedText ^<String> = (
	^hasVisual
		ifTrue: [editor selectedText]
		ifFalse: ['']
)
showMessage: aString = (
	removeMessages.
	addMessage: aString
)
text ^<String> = (
(* Answer the displayed text (or the text to be displayed, if the fragment hasn't been displayed yet). While the editor is in edit mode, including when acceptResponse is invoked, the result is the 'old' unedited text. *)
	^textX asString
)
text: newText <Text | String> = (
	textX:: newText.
	setVisualText: textX.
)'actions'
confirm: label ifConfirmed: block = (
	| menu |
	menu:: Menu forVisual: visual.
	menu add: (MenuItem key: #ok label: label action: block).
	menu openIn: visual desktop
)
defaultAcceptResponse = (
	textX:: textBeingAccepted.
	leaveEditState
)
defaultCancelResponse = (
	setVisualText: textX.
	leaveEditState
)
defaultChangeResponse = (
	enterEditState
)
respondToAccept = (
	textBeingAccepted:: editor text asString withSqueakLineEndings.
	acceptResponse 
		ifNil: [defaultAcceptResponse]
		ifNotNil: [acceptResponse clone valueWithPossibleArgument: self]
)
respondToCancel = (
	confirm: 'Confirm Cancel' ifConfirmed:
		[cancelResponse 
			ifNil: [defaultCancelResponse]
			ifNotNil: [cancelResponse clone valueWithPossibleArgument: self]]
)
respondToChange = (
	changeResponse 
		ifNil: [defaultChangeResponse]
		ifNotNil: [changeResponse valueWithPossibleArgument: self]
)'as yet unclassified'
controlsPadding ^<Integer> = (
	(* This accept/cancel buttons are displayed with this many pixels between them and the top of the yellow controls bar. *)
	^5
)
editorWidgetClass = (
	^TextView
)
receiveRequestFrom: dispatcher <RequestDispatcher> ^<Boolean> = (
	(* Receive a request sent from somewhere using sendDown or sendUp. We are interested specifically in the scrolling notifications sent by the top-level presenter that manages the main viewport. *)
	^dispatcher selector = #respondToScrollingInViewport:	
		and: [dispatcher message sendTo: self. true]
)
requestVisibilityOfTextInterval: range <Interval> = (
	requestVisibilityOfTextInterval: range withExtraLines: 0
)
requestVisibilityOfTextInterval: range <Interval> withExtraLines: extraLines <Integer> = (
	| startLine endLine textRectangle |
	editor linesDo:
		[:visibleLine :physicalLine :startPosition :endPosition |
		startPosition < range first ifTrue:
			[startLine:: visibleLine].
		(range last < endPosition and: [endLine isNil]) ifTrue:
			[endLine:: visibleLine]].
	(startLine isNil or: [endLine isNil]) ifTrue: [^self].
	textRectangle::
		0 @ ((startLine - 1 - extraLines) * editor lineHeight)
			corner: (0 @ ((endLine + extraLines) * editor lineHeight)).
	requestVisibilityOfRectangle: textRectangle
)
respondToScrollingInViewport: viewport <VerticalViewport> = (
	(* When the visible area of the viewport changes, adjust the position of the accept/cancel buttons so they stay visible if at all possible. All currently existing editors receive this message, so be sure to bail out early if there's nothing to adjust. *)
	| visibleBounds firstBlankHeight |
	editModeControls isNil ifTrue: [^self].
	(* editModeControls is a column with at least 2 cells: a blank and a row with buttons *)
	visibleBounds:: editModeControls localBounds
		translateFrom: editModeControls to: viewport.
	visibleBounds bottom < 0 ifTrue: 
		(* Scrolled up out of sight, don't bother adjusting. *)
		[^self].
	visibleBounds top > viewport localBounds bottom ifTrue:
		(* Scrolled down out of sight, don't bother adjusting. *)
	[^self].
	firstBlankHeight::
		((visibleBounds top negated + controlsPadding)
			min: editModeControls localBounds bottom - 30 (* BOGUS, but it's too much hassle to measure the controls properly *))
				max: controlsPadding.
	editModeControls children first area height: firstBlankHeight
)'private'
setVisualText: aText = (
	hasVisual ifTrue: [editor text: aText copy]
)'private-edit state'
enterEditState = (
	isInEditState ifFalse:
		[buildEditModeControls.
		visual add: editModeControls].
	sendUp deliveryOptional adviseOnViewportScrollPosition: self
	(* The controls may be position outside the visible area. Holler up the chain to get a scroll position update from whoever owns the viewport. The update will come as the standard #respondToScrollingInViewport: message. *)
)
isInEditState = (
	^editModeControls notNil
)
leaveEditState = (
	isInEditState ifTrue:
		[visual remove: editModeControls.
		editModeControls:: nil.
		removeMessages]
)'private-visuals'
buildEditModeControls = (
	editModeControls:: Column new.	
	(* NOTE: the #respondToScrollingInViewport: method makes assumptions about the structure of editModeControls. *)
	editModeControls
		addBlankSize: controlsPadding;
		addNew: Row setup:	
			[:row | 	
			row
				addBlankSize: 3;
				add: createAcceptLabel.
			cancelLabelText ifNotNil:
					[row				
						addBlankSize: 3;
						add: createCancelLabel].	
			row	
				addBlankSize: 3].
	controlBarColor ifNotNil:
		[editModeControls color: controlBarColor]
)
createAcceptLabel = (
	^ActiveIcon new
		image: (HopscotchImages default accept16px);
		hoverImage: (HopscotchImages default accept16pxOver);
		downImage: (HopscotchImages default accept16pxDown);
		action: [respondToAccept]
)
createCancelLabel = (
	^ActiveIcon new
		image: (HopscotchImages default cancel16px);
		hoverImage: (HopscotchImages default cancel16pxOver);
		downImage: (HopscotchImages default cancel16pxDown);
		action: [respondToCancel]
)
createEditor = (
	editor:: editorWidgetClass new.
	editor suppressScrollbars: true.
	editor text: text copy.
	editor hasEditsFromUserChannel => 
		[:hasChanges |
		textBeingAccepted:: editor text copy.
		hasChanges ifTrue: [respondToChange]].
	editor acceptKeyResponse:
		[:defaultResponse |
		respondToAccept].
	editor enterKeyResponse:
		[:defaultResponse |
		enterKeyResponse notNil
			ifTrue: [enterKeyResponse cull: self]
			ifFalse: [defaultResponse value]].
	editor escapeKeyResponse:
		[:defaultResponse |
		escapeKeyResponse notNil
			ifTrue: [escapeKeyResponse cull: self]
			ifFalse: [defaultResponse value]].
	editor menuBlock: menuBlock.
	^editor
)
createLeftColumn = (
	leftColumn:: Column new.
	leftColumn add: createEditor.
	messagesContainer:: Column new.
	messagesContainer color: (Color h: 40 s: 0.3 v: 1).
	leftColumn add: messagesContainer.
	^leftColumn
)
createVisual = (
	| row |
	row:: Row new.
	row add: createLeftColumn.
	(row at: 1) area elasticity: 1.
	^row
)
readOnlyVisual = (
	readOnlyVisual_ isNil ifTrue:
		[readOnlyVisual_:: TextDisplay new].
	readOnlyVisual_ text: text.
	^readOnlyVisual_
)'restricted'
setText: newText = (
	(* Set the text remembered by the fragment as the original, without affecting the displayed text. *)
	textX:: newText
)'testing'
hasPendingChanges ^<Boolean> = (
	^isInEditState
)) : ()
class TextLineEditorFragment = LeafFragment (| text::= String new. acceptResponse cancelResponse textView |)
('as yet unclassified'
controlBarColor = (


	^Color h: 40 s: 0.5 v: 0.95
)
hasPendingChanges ^<Boolean> = (

	(* Line editors are used in such a manner that they always have pending changes. When accepted, they are replaced with other fragments. *)

	^true
)'private'
createAcceptButton = (


	^ActiveIcon new
		image: (HopscotchImages default accept16px);
		hoverImage: (HopscotchImages default accept16pxOver);
		downImage: (HopscotchImages default accept16pxDown);
		action:
			[text:: textView text.
			acceptResponse valueWithPossibleArgument: self]
)
createCancelButton = (


	^ActiveIcon new
		image: (HopscotchImages default cancel16px);
		hoverImage: (HopscotchImages default cancel16pxOver);
		downImage: (HopscotchImages default cancel16pxDown);
		action:
			[cancelResponse valueWithPossibleArgument: self]
)
createTextView = (


	textView:: TextView new.
	textView
		suppressScrollbars: true;
		text: text;
		enterKeyResponse: 
			[:defaultResponse |
			text:: textView text.
			acceptResponse valueWithPossibleArgument: self];
		acceptKeyResponse:
			[:defaultResponse |
			text:: textView text.
			acceptResponse valueWithPossibleArgument: self];
		escapeKeyResponse: 
			[:defaultResponse | 
			cancelResponse valueWithPossibleArgument: self];
		selectAll.
	^textView
)
createVisual = (


	^Row new
		add: createTextView;
		addBlankSize: 2;
		addNew: Wrapper setup:
			[:wrapper |
			wrapper content: createAcceptButton.
			wrapper content area beCentered];
		addBlankSize: 2;
		addNew: Wrapper setup:
			[:wrapper |
			wrapper content: createCancelButton.
			wrapper content area beCentered];
		addBlankSize: 2;
		color: controlBarColor;
		yourself
)) : ()) : ()
class OutlineClasses = (|
	Subject = core Subject.
	Presenter = core Presenter.
	Composer = core Composer.
|)
(
class OutlineItem onModel: m = Subject onModel: m (
(* OutlineItems are created by those presenters that want to include themselves in outlines. An item identifies the owner presenter, the image and the text to display in the outline, and the child items. It is also a subject, so that a presenter can be created on it directly. *)| text image noImageBlankSize::=0. childrenX |)
('accessing'
addChild: newChild <OutlineItem> = (

	childrenX ifNil: [childrenX:: OrderedCollection new].
	childrenX add: newChild.
	^newChild
)
children = (

	^childrenX ifNil: [Array new]
)'as yet unclassified'
createPresenter = (

	^OutlineItemPresenter subject: self
)
hasChildren ^<Boolean> = (

	^childrenX notNil
)) : ()
class OutlineItemPresenter onSubject: s = Presenter onSubject: s (
(* Displays an OutlineItem as an expandable/collapsible list.
*))
('actions'
respondToClick = (

	sendUp selectOutlineItem: subject
)'initialize-release'
definition = (

^
	subject hasChildren
		ifTrue: [expandableDefinition]
		ifFalse: [
			subject text isNil
				ifTrue: [nothing]
				ifFalse: [row: {blank: 12. leafDefinition}]]
)
expandableDefinition = (

^
	subject text notNil
		ifTrue: [fullExpandableDefinition]
		ifFalse: [list: (subject children collect: [:each | each presenter])]
)
fullExpandableDefinition = (

^
	(heading:
		leafDefinition
	details: (
		list: (subject children collect: [:each | each presenter])
		)
	initiallyExpanded: true)
		useExplorerLikeImages: true
)
leafDefinition = (

^
	row: {
			subject image
				ifNil: [blank: subject noImageBlankSize]
				ifNotNil: [image: subject image].
			blank: 3.
			(link: subject text action: [respondToClick]) color: Color black
	}
)) : ()
class Outliner = Composer (
(* Responsible for displaying and managing an outline of a presenter. Displays as a two-part visual: the outline on the left and the actual content on the right.
*)| outlinedPresenter outlinePresenter outlinedViewport outlineViewport refreshingOutline::=true. isOutlineHidden::=false. |)
('accessing'
childrenDo: aBlock = (


	aBlock value: outlinedPresenter
)'actions'
selectOutlineItem: theItem <OutlineItem> = (

	theItem model respondToOutlineSelection
)
toggleOutline = (

	isOutlineHidden:: isOutlineHidden not.
	updateOutlineVisibility
)'initialize-release'
presenter: aPresenter <Presenter> = (

	outlinedPresenter:: aPresenter.
	outlinedPresenter parent: self.
)'parameters'
outlineViewportElasticity = (

	^0.25
)
outlinedViewportElasticity = (

	^0.75
)'private'
createOutline = (

	outlinePresenter:: createRootItem presenter.
	outlinePresenter parent: self
)
createRootItem = (

	| root |
	root:: (OutlineItem onModel: outlinedPresenter) text: outlinedPresenter title.
	outlinedPresenter addOutlineItemsTo: root.
	^root children size = 1
		ifTrue: [root children first]
		ifFalse: [root]
)
updateOutlineVisibility = (

	outlineViewport area 
		width: 0;
		elasticity:
			(isOutlineHidden
				ifTrue: [0]
				ifFalse: [outlineViewportElasticity])
)'restricted'
createVisual ^<Visual> = (

	| row |
	outlinedViewport:: outlinedPresenter viewport.
	(* It's important that the outline is created at the last possible moment,
	i.e. after the visuals of the outlinedPresenter have been created,
	to be sure that the presenter tree has been fully materialized. *)
	createOutline.
	outlineViewport:: Viewport new color: Color white.
	outlineViewport add: outlinePresenter visual in: Anchor.
	row:: Row new.
	row add: outlineViewport.
	row add: outlinedViewport.
	outlinedViewport area
		width: 0;
		elasticity: outlinedViewportElasticity.
	updateOutlineVisibility.
	refreshingOutline: false.
	^row
)
outlineMayHaveChanged = (

	refreshingOutline ifFalse:
		[refreshingOutline:: true.
		[refreshOutline] ensure: [refreshingOutline:: false]]
)
receiveRequestFrom: dispatcher ^<Boolean> = (

	(* Receive and process a notice coming from one of the children (usually as the result of using #sendUp). *)

	(self respondsTo: dispatcher selector)
		ifTrue: 
			[dispatcher message sendTo: self.
			^true]
		ifFalse:
			[^false]
)
refresh ^<Visual> = (

	outlinedPresenter refresh.
	refreshOutline
)
refreshOutline = (

	createOutline.
	outlineViewport remove: outlineViewport children first.
	outlineViewport add: outlinePresenter visual in: Anchor.
)
replaceChild: aFragment with: replacement = (

	outlinedPresenter == aFragment ifFalse: 
		[^error: 'the argument is not a child of the receiver'].
	outlinedPresenter
		noticeConcealment;
		parent: nil.
	presenter: replacement.
	hasVisual ifTrue:
		[outlinedViewport:: outlinedPresenter viewport.
		visual at: 2 put: outlinedViewport.
		outlinedViewport area
			width: 0;
			elasticity: outlinedViewportElasticity].
	refresh.
)
viewport = (

	(* Even when the parent invites us to create a viewport, we display ourselves in a regular visual because both of our components are viewports. *)
	^visual
)) : ()) : ()'as yet unclassified'
BOGUS = ()) : ()