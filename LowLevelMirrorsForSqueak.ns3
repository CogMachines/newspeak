Newspeak3
'Mirrors'
class LowLevelMirrorsForSqueak usingLib: platform = (
(* The LowLevelMirrors module defines a mirror library at the level of abstraction of the virtual machine - in this case, Squeak.  Ideally, the high level mirror library will depend on the low level mirror API, and be largely isolated from the details of Squeak.


   Copyright 2008 Cadence Design Systems, Inc.
   Copyright 2011 Ryan Macnak
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|  
protected Smalltalk = platform squeak Smalltalk.
protected CompiledMethod = platform squeak CompiledMethod.
protected MethodProperties = platform squeak MethodProperties.
protected OrderedCollection = platform squeak OrderedCollection.
protected Dictionary = platform squeak Dictionary.
protected CompiledMethodTrailer = platform squeak CompiledMethodTrailer.
protected AdditionalMethodState = platform squeak AdditionalMethodState.
protected EncoderForNewsqueakV4 = platform squeak EncoderForNewsqueakV4.
protected MirrorGroup = (platform namespace MirrorGroups usingLib: platform) MirrorGroup.
|)
(
class CompiledMixinMirror header: h mirror: llm = (
(* Represents a compiled (but uninstalled) NS3 class declaration. *)|
	header <String> ::= h.
	lowLevelMirror <LowLevelMixinMirror> = llm.
	commentString
|)
('as yet unclassified'
category = (
	^ lowLevelMirror category
)
category: c = (
	lowLevelMirror category: c.
)
comment = (
	commentString ifNil: [^''].
	^ commentString.
)
comment: c = (
	commentString: c.
)
name = (
	^ lowLevelMirror name
)) : ()
class InstanceVariableMirror named: n <String> mutable: m <Boolean> accessModifier: am <Symbol> = Mirror (
(* A mirror on an instance variable *)|
	name <String> = n.
	mutable <Boolean> = m.
	accessModifier <Symbol> = am.
|)
('as yet unclassified'
generateGetterForSlot: n <Integer> ^ <LowLevelMethodMirror> = (
  | method llmm |
  method:: (Smalltalk at: #CompiledMethod) newGetterForSlot: n accessModifier: accessModifier.
  llmm:: (LowLevelMethodMirror new)
      selector: name asSymbol;
      accessModifier: accessModifier;
      method: method.
  llmm metadata at: #isSynthetic put: true.
  (name endsWith: '`slot') ifTrue: [
    llmm metadata at: #isNestedClassAccessor put: true.
  ].
  ^ llmm
)
generateSetterForSlot: n <Integer> ^ <LowLevelMethodMirror> = (
  | method llmm |
  method:: (Smalltalk at: #CompiledMethod) newSetterForSlot: n accessModifier: accessModifier.
  llmm:: (LowLevelMethodMirror new)
      selector: setterName;
      accessModifier: accessModifier;
      method: method.
  llmm metadata at: #isSynthetic put: true.
  (name endsWith: '`slot') ifTrue: [
    llmm metadata at: #isNestedClassAccessor put: true.
  ].
  ^ llmm
)
isMutableSlot ^ <Boolean> = (
	(* This method added to match the protocol of SlotDefAST. It is used by Newspeak3Compilation`Compiler. *)
	^mutable.
)
setterName ^<Symbol>= (
  (* Yuck! This is a copy of Compiler#setterSelectorFor: *)
  ^ ((isMutableSlot ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), name, ':') asSymbol
)
simpleName = (
	^name
)) : ('as yet unclassified'
named: n <String> mutable: m <Boolean> = (
	^ self named: n mutable: m accessModifier: #public
))
class LowLevelMethodMirror = Mirror (
(* A Squeak specifiic method mirror. Mainly a wrapper for CompiledMethod. Why do we not simply use CompiledMethod directly?  We want to handle some details differently, for example, debugging information. In Squeak, the debugging information is accessed via the MethodNode, an excuse for an AST, which in turn uses the Encoder. We don't want anything to do with MethodNodes and the old Squeak compiler. 

This approach also minimizes changes to the compiler when targeting another platform. *)|
	method <CompiledMethod>
	debugInfo
	maxStack <Integer>
	maxLocals <Integer>
	argCount <Integer>
	literals <OrderedCollection[Object]>
	bytes <OrderedCollection[Byte]> ::= OrderedCollection new. 
	selector <Symbol>
	klass <Class>
	src <String>
	pragmas
	accessModifier <Symbol> (* Method header won't be touched when accessModifier is nil. I promise. *)
|)
('as yet unclassified'
public bci ^<Integer> = (
	^bytes size
)
public byte: b <Integer> = (
	assert: [0 <= b and: [b <= 255]] message: 'Bytecode out of range'.
	bytes add: b  
)
public byteAt: index <Integer> ^<Integer> = (
	^bytes at: index
)
public byteAt: index <Integer> put: datum <Integer> = (
	bytes at: index put: datum  
)
public cleanup = (
	literals:: nil.
	bytes:: nil
)
compiledMethod ^<CompiledMethod> = (
	| properties <MethodProperties> offset <Integer> |
	method isNil ifFalse: [^method].

	assert: [argCount <= maxLocals] message: ''.
		
	method:: instantiateMethodV4.
		
	(1 to: literals size)
		with: literals asOrderedCollection
		do: [:i :lit | method literalAt: i put: lit]. 

	method selector: selector.
	(pragmas isNil or: [pragmas isEmpty]) ifFalse:
		[properties:: AdditionalMethodState forMethod: method selector: selector.
		pragmas do: [:p | properties:: properties copyWith: p].
		method properties: properties].

	(metadata includesKey: #isSubinitializer) ifTrue:
		[method properties isNil ifTrue: 
			[properties:: MethodProperties new selector: selector.
		      method properties: properties].
			method properties at: #isSubinitializer put: true.
			(metadata includesKey:#hasBody)
				ifTrue: [method properties at: #hasBody put: (metadata at: #hasBody)]].
			
	method literalAt: literals size + 2 put: klass name -> klass.
	(* association pointing at the mixin that declared this method (aka method class) *)

	(* Pointer for each literal, plus the header, the selector or method properties, and the method class association. *)
	offset:: (literals size + 3) * 4.
	1 to: bytes size do:
		[:i | method basicAt: i + offset put: (bytes at: i)].

	setSourceAndCategory.
	cleanup.
		
	^method
)
compiledMethodSize ^ <Integer> = (
	(* 3 = header + properties/selector + method class assocation *)
	^((literals size + 3) * Smalltalk wordSize) + bytes size	
)
instantiateMethodV4 ^<CompiledMethod> = (
	| header cmethod |	
	header:: EncoderForNewsqueakV4 basicNew
		computeMethodHeaderForNumArgs: argCount
		numTemps: maxLocals
		numLits: literals size + 2
		primitive: 0
		accessModifier: accessModifier.
		
	cmethod:: CompiledMethodTrailer empty
		createMethod: bytes size
		class: CompiledMethod
		header: header.
		
	cmethod needsFrameSize: 
		(maxStack min: CompiledMethod fullFrameSize - maxLocals). (*Suppress warning about frame too big, which apparently is not checked in the constructor used by instantiateMethodV3 and is actually exceeded in some Newspeak code.*)
	
	^cmethod
)
public isConstructor = (
	^ metadata at: #isConstructor ifAbsent: [ false ]
)
public isNestedClassAccessor = (
	^ metadata at: #isNestedClassAccessor ifAbsent: [ false ]
)
isSlotAccessor = (
	^ metadata at: #isSlotAccessor ifAbsent: [ false ]
)
isSubinitializer = (
	^ metadata at: #isSubinitializer ifAbsent: [ false ]
)
isSuperConstructor = (
	^ metadata at: #isSuperConstructor ifAbsent: [ false ]
)
isSynthetic = (
	^ metadata at: #isSynthetic ifAbsent: [ false ]
)
name ^ <Symbol> = (
	selector isNil ifTrue: [selector: compiledMethod selector].
	^selector
)
setSourceAndCategory = (
	(* This is horrible, but in Squeak access to source is via the compiled method, which stores the information in itself. To make matters worse, the class and category are required. *)
	| cat <String> |
	assert: [klass isNil not] message: 'Missing methodMixin'.
	cat:: metadata at: #category ifAbsent: [ (* Should be able to assert method is synthetic... *) ^self].
	assert: [cat isNil not] message: 'Missing category'.
	method putSource: src fromParseNode: nil class: klass category: cat inFile: 2 priorMethod: nil.
)
simpleName = (
	^name
)) : ()
class LowLevelMixinMirror named:  n <Symbol> isMeta: b <Boolean> = Mirror (|
	name <Symbol> = n.
	instVars <MirrorGroup> = MirrorGroup group: {}.
	methods <MirrorGroup> = MirrorGroup group: {}.
  	category <Symbol>
  	cachedClassMixin <LowLevelMixinMirror>
  	isMeta <Boolean> = b.
|)
('as yet unclassified'
classMixin = (
	assert: [isMeta not] message: 'Attempt to use a meta-meta-mixin'.
	cachedClassMixin isNil ifTrue:
		[cachedClassMixin:: LowLevelMixinMirror named: (name, ' class') asSymbol isMeta: true].
	^cachedClassMixin	 
)) : ()
class Mirror = (
(* Common base class for low level mirrors. *)|
protected metadata <MutableMap[Symbol, Object]> = Dictionary new.
|)
() : ()) : ()