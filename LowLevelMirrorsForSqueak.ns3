Newspeak3
'Mirrors'
class LowLevelMirrorsForSqueak usingLib: platform = (
(* The LowLevelMirrors module defines a mirror library at the level of abstraction of the virtual machine - in this case, Squeak.  Ideally, the high level mirror library will depend on the low level mirror API, and be largely isolated from the details of Squeak.


   Copyright 2008 Cadence Design Systems, Inc.
   Copyright 2011 Ryan Macnak
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|  
private Smalltalk = platform blackMarket Smalltalk .
private CompiledMethod = platform blackMarket Kernel CompiledMethod.
private MethodProperties = platform blackMarket Kernel MethodProperties.
private OrderedCollection = platform blackMarket Collections OrderedCollection.
private Dictionary = platform blackMarket Collections Dictionary.
private MirrorGroup <MirrorGroup class> = (platform namespace MirrorGroups usingLib: platform) MirrorGroup.
|)
(
class CompiledMixinMirror language: l header: h mirror: llm = (
(* Represents a compiled (but uninstalled) NS3 class declaration. *)|
	language <Language> = l.
	header <String> ::= h.
	lowLevelMirror <LowLevelMixinMirror> = llm.
	commentString
|)
('as yet unclassified'
category = (
	^ lowLevelMirror category
)
category: c = (
	lowLevelMirror category: c.
)
comment = (
	commentString ifNil: [^''].
	^ commentString.
)
comment: c = (
	commentString: c.
)
name = (
	^ lowLevelMirror name
)) : ()
class InstanceVariableMirror named: n <String> mutable: m <Boolean> = Mirror (
(* A mirror on an instance variable *)|
	name <String> = n.
	mutable <Boolean> = m.
|)
('as yet unclassified'
isMutableSlot ^ <Boolean> = (
	(* This method added to match the protocol of SlotDefAST. It is used by Newspeak3Compilation`Compiler. *)
	^mutable.
)
simpleName = (
	^name
)) : ()
class LowLevelMethodMirror = Mirror (
(* A Squeak specifiic method mirror. Mainly a wrapper for CompiledMethod. Why do we not simply use CompiledMethod directly?  We want to handle some details differently, for example, debugging information. In Squeak, the debugging information is accessed via the MethodNode, an excuse for an AST, which in turn uses the Encoder. We don't want anything to do with MethodNodes and the old Squeak compiler. 

This approach also minimizes changes to the compiler when targeting another platform. *)|
	method <CompiledMethod>
	debugInfo
	maxStack <Integer>
	maxLocals <Integer>
	argCount <Integer>
	literals <OrderedCollection[Object]>
	bytes <OrderedCollection[Byte]> ::= OrderedCollection new. 
	selector <Symbol>
	klass <Class>
	src <String>
	pragmas
	usesAlternateBytecodeSet ::= false.
|)
('as yet unclassified'
addAllBytes: bs <SequenceableCollection[Integer]> = (
(* A convenience method for adding a bunch of bytes at once *)
	bs do: [ :b | bytes add: b]
)
byte: b <Integer> = (
	assert:[ 0 <= b and:[b<= 255]].
	bytes add: b  
)
byteArray ^ <ByteArray>  = (
	^bytes asByteArray.
)
byteAt: index <Integer> ^ <Integer> = (
	^bytes at: index - literals size
)
byteAt: index <Integer> put: datum <Integer> = (
	bytes at: index - literals size put: datum  
)
cleanup = (
	literals:: nil.
	bytes:: nil
)
compiledMethod ^ <CompiledMethod> = (
| properties <MethodProperties> offset <Integer> |
	method isNil ifTrue:[
		
		assert:[maxStack isNil not].
		assert:[maxLocals isNil not].
		assert:[argCount isNil not].
		assert:[argCount <= maxLocals].
		
		method:: usesAlternateBytecodeSet 
			ifTrue: [instantiateMethodV4]
			ifFalse: [instantiateMethodV3].
		
		(1 to: literals size) with: literals asOrderedCollection do: [:i :lit | method literalAt: i put: lit]. 

		(Smalltalk includesKey: #AdditionalMethodState) ifTrue: [	
			method selector: selector.

			(pragmas isNil or: [pragmas isEmpty]) ifFalse: [
				properties:: (Smalltalk at: #AdditionalMethodState) 
					forMethod: method
					selector: selector.
				pragmas do: [:p | properties:: properties copyWith: p].
				method properties: properties.
			].
		] ifFalse: [
			properties:: MethodProperties new selector: selector.
			method properties: properties.
		].

		method literalAt: literals size + 2 put: klass name -> klass.
		 (* association pointing at the mixin that declared this method (aka method class) *)
		offset:: (literals size + 3) * 4. 
		(* (1 word per literal + 2 words for method properties and method class + 1 word for header) * 4 is number of bytes before code starts *)
		1 to: bytes size do:
			[:i | method basicAt: i + offset put: (bytes at: i)].
		setSourceAndCategory.
		cleanup.
		].
	^method
)
compiledMethodSize ^ <Integer> = (
	^4 (* header *) 
	+ (literals size * 4)
	+ 8 (* properties and selector->mixin literals added at creation of actual CM *)
	+ byteArray size
)
emptyTrailer = (
	^(Smalltalk includesKey: #CompiledMethodTrailer)
	ifTrue: [ (Smalltalk at: #CompiledMethodTrailer) empty  ]
	ifFalse: [ {0. 0. 0. 0} ]
)
instantiateMethodV3 ^ <CompiledMethod> = (

	assert: [argCount between: 0 and: 15] message: 'Too many arguments'.

	^CompiledMethod
		newBytes: bytes size
		trailerBytes: emptyTrailer
		nArgs: argCount
		nTemps: maxLocals
		nStack: maxStack
		nLits: literals size + 2 (*properties/selector and methodClass added later*)
		primitive: 0.	
)
instantiateMethodV4 ^<CompiledMethod> = (
	| header cmethod |
	(* Note the header is different in V4 to accommodate larger literal frames. *)
	assert: [argCount between: 0 and: 15] message: 'Too many arguments'.

	header:: (Smalltalk at: #EncoderForNewsqueakV4) basicNew
		computeMethodHeaderForNumArgs: argCount
		numTemps: maxLocals
		numLits: literals size + 2
		primitive: 0.
		
	cmethod:: emptyTrailer
		createMethod: bytes size
		class: CompiledMethod
		header: header.
		
	cmethod needsFrameSize: 
		(maxStack min: CompiledMethod fullFrameSize - maxLocals). (*Suppress warning about frame too big, which apparently is not checked in the constructor used by instantiateMethodV3 and is actually exceeded in some Newspeak code.*)
	
	^cmethod
)
isConstructor = (
	^ metadata at: #isConstructor ifAbsent: [ false ]
)
isNestedClassAccessor = (
	^ metadata at: #isNestedClassAccessor ifAbsent: [ false ]
)
isSlotAccessor = (
	^ metadata at: #isSlotAccessor ifAbsent: [ false ]
)
isSubInitializer = (
	^ metadata at: #isSubInitializer ifAbsent: [ false ]
)
isSuperConstructor = (
	^ metadata at: #isSuperConstructor ifAbsent: [ false ]
)
isSynthetic = (
	^ metadata at: #isSynthetic ifAbsent: [ false ]
)
name ^ <Symbol> = (
	selector isNil ifTrue:[selector: compiledMethod selector].
	^selector
)
returnOnlyField: n <Integer>source: source <String> = (
(* create a method that returns instance variable #n *)
| properties <MethodProperties> |
	method:: CompiledMethod toReturnField: n trailerBytes: source asByteArray.
	properties:: MethodProperties new selector: selector.
	method properties: properties.
)
returnOnlySelf: source <String> = (
(* Create a method that only returns the receiver *)
| properties <MethodProperties> |
      src:: source.
	method:: CompiledMethod toReturnSelfTrailerBytes: source asByteArray.
	properties:: MethodProperties new selector: selector.
	method properties: properties.
)
setSourceAndCategory ^ <Boolean> = (
(* Returns whether any action was taken *)
(* This is horrible, but in Squeak access to source is via the compiled method, which stores the information in itself. To make matters worse, the class and category are required. *)
| cat <String> |
	assert:[klass isNil not].
	assert:[method isNil not].
	cat:: metadata at: #category ifAbsent:[^false].
	assert:[cat isNil not].
	method putSource: src fromParseNode: nil class: klass category: cat inFile: 2 priorMethod: nil.
	^true. 
)
simpleName = (
	^name
)
size ^ <Integer> = (
	^literals size + byteArray size
)) : ()
class LowLevelMixinMirror named:  n <Symbol> isMeta: b <Boolean> = Mirror (
(* Represents a Squeak Class. *)|
  name <Symbol> = n.
  instVars <MirrorGroup> = MirrorGroup group:{}.
  methods  <MirrorGroup> = MirrorGroup group:{}.
  category <Symbol>
  cachedClassMixin
  isMeta = b.
|)
('as yet unclassified'
classMixin = (
	assert:[isMeta not].
	cachedClassMixin isNil ifTrue:[
		cachedClassMixin:: self class named: (name, ' class') asSymbol isMeta: true
		].
	^cachedClassMixin
		 
)) : ()
class Mirror = (
(* Common base class for low level mirrors. *)|
	metadata <MutableMap[Symbol, Object]> = Dictionary new.
|)
() : ()'as yet unclassified'
assert: b = (
	^self assert: b message: 'Assert failed'
)) : ()