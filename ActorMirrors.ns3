Newspeak3
'Actors'
class ActorMirrors usingPastime: p usingDispatcher: d = (
(*The actor mirrors module.*)|
	private pastime = p.
	private dispatcher = d.
|)
(
class AbstractMirror of: r = (
(*Base class with common functionality for actor mirrors.*)|
	protected reflectee = r.
|)
('as yet unclassified'
= other <AbstractMirror> = (
	^self class == other class and: [ self reflectee == other reflectee ].
)
isMirror = (
	^true.
)) : ()
class ActorMessageMirror of: m = AbstractMirror of: m (
(*A mirror reflecting a pending message in an actor's mailbox.*)|
|)
('as yet unclassified'
arguments = (
	^reflectee args.
)
receiver = (
	^reflectee receiverNearRef.
)
resolver = (
	^reflectee resolver.
)
selector = (
	^reflectee selector.
)) : ()
class ActorMirror of: a = AbstractMirror of: a (
(*A mirror reflecting an actor.*)|
|)
('as yet unclassified'
pendingMessages ^ <List[ActorMessageMirror]> = (
	^reflectee pendingMessages collect: [ :m | ActorMessageMirror of: m ].
)) : ()
class BrokenRefMirror of: r = ReferenceMirror of: r (
(*A mirror of a broken reference.*)|
|)
('as yet unclassified'
actor = (
	(*As per the E reference states, broken refs are not vat-crossing.*)
	^currentActor.
)
exception ^ <Exception> = (
	 (*TODO how do we access private slots securely?*)
	^reflectee exception.
)
isBrokenReference = (
	^true.
)
isResolvedReference = (
	^true.
)) : ()
class EventualSendProxy for: t = (
(*A proxy that converts immediate-sends to eventual-sends.
This class works in conjunction with the ESEND method in Kernel`Object.
Together they form a temporary scaffolding to enable a simple way of coding 
eventual-sends until full compiler support is provided.*)|
	private target = t.
|)
('as yet unclassified'
doesNotUnderstand: message <Message> ^ <Promise> = (
	^eventualSendTo: target selector: message selector args: message arguments.
)) : ()
class FarRefMirror of: r = ReferenceMirror of: r (
(*A mirror of a far reference.*)|
|)
('as yet unclassified'
actor = (
	^ActorMirror of: reflectee actor.
)
isEventualReference = (
	^true.
)
isFarReference = (
	^true.
)
isResolvedReference = (
	^true.
)
referent = (
	(*TODO how do we access private slots securely?*)
	^reflectee target.
)) : ()
class NearRefMirror of: r = ReferenceMirror of: r (
(*A mirror of a near reference.*)|
|)
('as yet unclassified'
actor ^ <ActorMirror> = (
	(*No need to save the actor mirror in a slot. NearRefMirror is a non-value object and 
	this method will always be invoked inside the same actor as the referent.*)
	^currentActor.
)
isNearReference ^ <Boolean> = (
	^true.
)
isResolvedReference = (
	^true.
)
referent = (
	^reflectee.
)) : ()
class PromiseChainMessageMirror of: m = AbstractMirror of: m (
(*A mirror of a promise chain message (whenResolved:catch: listener).*)|
|)
('as yet unclassified'
catchBlock = (
	^reflectee catchHandler.
)
resolver = (
	^reflectee resolver.
)
whenBlock = (
	^reflectee whenHandler.
)) : ()
class PromiseMirror of: r = ReferenceMirror of: r (
(*A mirror of a promise reference.*)|
|)
('as yet unclassified'
actor = (
	(*The actor of a promise is the actor where the resolver of the promise resides.
	For local promises this is always the current actor. The promise can resolve to an
	object that lives in a different actor.*)
	^currentActor.
)
awaiters = (
	^(reflectee pendingMessages select: [ :m | m isChainMessage ]) collect: [ :m | PromiseChainMessageMirror of: m ].
)
bufferedMessages = (
	^(reflectee pendingMessages select: [ :m | m isPipelineMessage ]) collect: [ :m | PromisePipelineMessageMirror of: m ].
)
isEventualReference = (
	^true.
)
isLocalPromise = (
	^true.
)
isPromise = (
	^true.
)
isUnresolvedReference = (
	^true.
)) : ()
class PromisePipelineMessageMirror of: m = AbstractMirror of: m (
(*A mirror on a message buffered in a promise.*)|
|)
('as yet unclassified'
arguments = (
	^reflectee args.
)
resolver = (
	^reflectee resolver.
)
selector = (
	^reflectee selector.
)) : ()
class ReferenceMirror of: r = AbstractMirror of: r (
(*The base class for all reference mirrors.*)|
|)
('as yet unclassified'
esendProxy = (
	^EventualSendProxy for: reflectee.
)) : ()'as yet unclassified'
currentActor ^ <ActorMirror> = (
	^ActorMirror of: dispatcher currentActor.
)
eventualSendOneWayTo: receiver <Object> selector: selector <String> args: args <{}> ^ <self type> = (
	pastime postMessageTo: receiver selector: selector args: args resolver: nil.
)
eventualSendTo: receiver <Object> selector: selector <String> args: args <{}> ^ <Promise> = (
	| resolver = pastime Resolver new. |
	pastime postMessageTo: receiver selector: selector args: args resolver: resolver.
	^resolver promise
)
forReference: ref <Object> ^ <ReferenceMirror> = (
	| unwrapped = pastime unwrapPromise: ref. |
	(pastime isPromise: unwrapped) ifTrue: [
		(pastime isBrokenRef: unwrapped) 
			ifTrue: [ ^BrokenRefMirror of: unwrapped. ]
			ifFalse: [ ^PromiseMirror of: unwrapped. ].
	].
	(dispatcher isFarReference: unwrapped) ifTrue: [ ^FarRefMirror of: unwrapped. ].
	^NearRefMirror of: unwrapped.
)) : ()