Newspeak3
'NS2Dart'
class KernelForDart = ("Definitions for the built-in types of Newspeak on Dart. When compiled, all sends to the receiver 'vmmirror' are evaluated at compile time by an instance of VMMirrorIntrinsics and transformed to the appropriate Dart code. Unlike the corresponding KernelForSqueak, the instance initializer of this class is not run because without pre-existing Object/Class/Metaclass/String the initialization is divergent.

*Adding or removing classes here or changing superclasses will require corresponding changes in NS2DartCompilation`Infrastructure kernelInit.*

Derived from the NS2JS Phase1Platform classes.

Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0")
(
class Array wrapping: d = (|
	dartList = d.
|)
('as yet unclassified'
= other = (
	self == other ifTrue: [^true].
	other isArray ifFalse: [^false].
	self size = other size ifFalse: [^false].
	1 to: size do: [:index |
		(self at: index) = (other at: index) ifFalse: [^false]].
	^true
)
at: index = (
	^vmmirror list: self dartList at: (index - 1) dartNumber
)
at: index put: value = (
	^vmmirror list: self dartList at: (index - 1) dartNumber put: value
)
do: block = (
	1 to: size do: [:n | block value: (self at: n)].
)
do: block separatedBy: betweenBlock = (
	| firstTime ::= true. |

	self do: [:element |
		firstTime ifTrue: [ firstTime:: false ] ifFalse: [betweenBlock value].
		block value: element].
)
doWithIndex: block = (
	1 to: size do: [:n | block value: (self at: n) value: n].
)
isArray = (
	^true
)
printString = (
	| x ::= '{'. |
	self do: [:ea | x:: x , ea printString] separatedBy: [x:: x, '. '].
	^x , '}'
)
size = (
	^self Number wrapping: (vmmirror lengthOf: self dartList)
)) : ('as yet unclassified'
new: size = (
	| a = self wrapping: (vmmirror newList: size dartNumber). |
	1 to: size do: [:i | a at: i put: nil].
	^a
)
new: size withAll: initialElement = (
	| a = self wrapping: (vmmirror newList: size dartNumber). |
	1 to: size do: [:i | a at: i put: initialElement].
	^a
))
class Behavior = (|
	superclass ::= nil.
	mixin
	enclosingObject
|)
() : ()
class Block wrapping: f = (|
	dartFunction = f.
	"numArgs = n."
|)
('as yet unclassified'
ensure: block = (
	"We do not include a ^ here because try clauses are not expressions in Dart. The VMMirror intrinsic must handle the return specially."
	vmmirror try: self ensure: block
)
ifError: handlerBlock = (
	^self on: Error do: [:ex | handlerBlock value: ex]
)
isBlock = (
	^true
)
numArgsError: calledWith = (
	(self Error description: 'This block accepts ', numArgs printString,
		' arguments but was called with ',calledWith printString) signal
)
on: error do: handlerBlock = (
	"We do not include a ^ here because try clauses are not expressions in Dart. The VMMirror intrinsic must handle the return specially."
	vmmirror try: self on: error do: handlerBlock
)
printString = (
	^'[closure] in SomeNewspeakContext'
)
repeat = (
	[true] whileTrue: self
)
value = (
	^vmmirror invoke: dartFunction
)
value: arg1 = (
	^vmmirror invoke: dartFunction with: arg1
)
value: arg1 value: arg2 = (
	^vmmirror invoke: dartFunction with: arg1 with: arg2
)
value: arg1 value: arg2 value: arg3= (
	^vmmirror invoke: dartFunction with: arg1 with: arg2 with: arg3
)
value: arg1 value: arg2 value: arg3 value: arg4 = (
	^vmmirror invoke: dartFunction with: arg1 with: arg2 with: arg3 with: arg4
)
valueWithArguments: argArray = (
	^asYetUnimplemented
	"^vmmirror invoke: dartFunction withAll: argArray"
)
whileFalse = (
	self whileFalse: []
)
whileFalse: aBlock = (
	#FLAG. "BOGUS recursion"
	^self value ifFalse: [
		aBlock value.
		self whileFalse: aBlock]
)
whileTrue = (
	self whileTrue: []
)
whileTrue: aBlock = (
	#FLAG. "BOGUS recursion"
	^self value ifTrue: [
		aBlock value.
		self whileTrue: aBlock]
)) : ()
class Boolean = ()
('as yet unclassified'
clone = (
	^self
)
value = (
	^self
)) : ()
class Class = Behavior (|
	name
|)
('as yet unclassified'
printString = (
	^name
)) : ()
class Error description: d <String> = (| description = d. |)
('as yet unclassified'
printString = (
	^'NewspeakError: ',description
)
signal = (
	vmmirror throw: self.
)) : ('as yet unclassified'
signal: description = (
	^(self description: description) signal
))
class False doNotInstaniate = Boolean ()
('as yet unclassified'
& other <Boolean> ^ <Boolean> = (
	^false
)
and: f <[^Boolean]> ^ <Boolean> = (
	^false
)
ifFalse: else = (
	^else value
)
ifFalse: else ifTrue: then = (
	^else value
)
ifTrue: then = (
	^nil
)
ifTrue: then ifFalse: else = (
	^else value
)
not = (
	^true
)
or: f <[^Boolean]> ^ <Boolean> = (
	^f value
)
printString = (
	^'false'
)
| other <Boolean> ^ <Boolean> = (
	^other
)) : ()
class Message selector: s arguments: a = (|
	selector = s.
	arguments = a.
|)
() : ()
class MessageNotUnderstood receiver: r message: m = Error description: 'MessageNotUnderstood: #', m selector (|
receiver = r.
message = m.
|)
('as yet unclassified'
printString = (
	^description
)) : ()
class Metaclass = Behavior (|
	thisClass
|)
('as yet unclassified'
printString = (
	^thisClass name, ' class'
)) : ()
class Number wrapping: n = (|
	dartNumber = n.	
|)
('as yet unclassified'
* other = (
	^self Number wrapping: (vmmirror multiply: self dartNumber by: other dartNumber)
)
** other = (
	^asYetUnimplemented
)
+ other = (
	^self Number wrapping: (vmmirror to: self dartNumber add: other dartNumber)
)
- other = (
	^self Number wrapping: (vmmirror from: self dartNumber subtract: other dartNumber)
)
/ other = (
	^self Number wrapping: (vmmirror divide: self dartNumber by: other dartNumber)
)
// other = (
	^self Number wrapping: (vmmirror intDivide: self dartNumber by: other dartNumber)
)
< other = (
	^vmmirror is: self dartNumber lessThan: other dartNumber
)
<= other = (
	^vmmirror is: self dartNumber lessOrEqual: other dartNumber
)
= other = (
	^vmmirror is: self dartNumber equalTo: other dartNumber
)
> other = (
	^vmmirror is: self dartNumber greaterThan: other dartNumber
)
>= other = (
	^vmmirror is: self dartNumber greaterOrEqual: other dartNumber
)
bitAnd: other = (
	^self Number wrapping: (vmmirror bitAnd: self dartNumber with: other dartNumber)
)
bitOr: other = (
	^self Number wrapping: (vmmirror bitOr: self dartNumber with: other dartNumber)
)
bitXor: other = (
	^self Number wrapping: (vmmirror bitXor: self dartNumber with: other dartNumber)
)
isNumber = (
	^true
)
printString = (
	^self String wrapping: (vmmirror toString: dartNumber)
)
sqrt = (
	^self Number wrapping: (vmmirror sqrt: self dartNumber)
)
timesRepeat: aBlock = (
	1 to: self do: [:i | aBlock value]
)
to: stop by: step do: aBlock = (
	| nextValue |
	nextValue: self.
	step = 0 ifTrue: [self error: 'step must be non-zero'].
	step < 0
		ifTrue: [[stop <= nextValue]
				whileTrue: 
					[aBlock value: nextValue.
					nextValue: nextValue + step]]
		ifFalse: [[stop >= nextValue]
				whileTrue: 
					[aBlock value: nextValue.
					nextValue: nextValue + step]]
)
to: stop do: aBlock = (
	| nextValue |
	nextValue: self.
	[nextValue <= stop]
		whileTrue: 
			[aBlock value: nextValue.
			nextValue: nextValue + 1]
)
value = (
	^self
)) : ()
class Object = Top ()
('as yet unclassified'
public = other = (
	^self == other
)
public == other = (
	^vmmirror is: self identicalTo: other
)
protected Array = (
	^vmmirror Array
)
protected Block = (
	^vmmirror Block
)
protected ByteArray = (
	asYetUnimplemented
)
protected Error = (
	^outer KernelForDart Error
)
protected Future = (
	asYetUnimplemented
)
protected Number = (
	^vmmirror Number
)
protected Object = (
	^vmmirror Object
)
protected String = (
	^vmmirror String
)
assert: condition <[^Boolean]> message: message = (
	"Raises an error with the given message if and only if condition evaluates to false."
	condition isBlock ifFalse: [Error signal: 'Block required'].
	condition value ifFalse: [Error signal: message]
)
class = (
	^vmmirror classOf: self
)
protected doesNotUnderstand: message = (
	^(MessageNotUnderstood receiver: self message: message) signal
)
hash = (
	^self identityHash
)
identityHash = (
	^Number wrapping: (vmmirror identityHashOf: self)
)
ifNil: nilBlock = (
	^self.
)
ifNil: nilBlock ifNotNil: notNilBlock = (
	^notNilBlock value
)
ifNotNil: notNilBlock = (
	^notNilBlock value
)
print: obj = (
	"Dart debugging: not part of the real Object API"
	^vmmirror print: obj
)
printString = (
	^'some Newspeak object'
)
yourself = (
	^self
)) : ('as yet unclassified'
printString = (
	^'Object'
))
class String wrapping: s = (| dartString = s. |)
('as yet unclassified'
, other = (
	^self String wrapping: (vmmirror concatenate: self dartString and: other dartString)
)
= other = (
	^vmmirror is: self dartString equalTo: other dartString
)
at: index = (
	^self String wrapping: (vmmirror list: self dartString at: (index - 1) dartNumber)
)
do: block = (
	1 to: size do: [:n | block value: (self at: n)].
)
hash = (
	^asYetUnimplemented
)
isString = (
	^true
)
printString = (
	#FLAG. "Need to escape single quotes in self"
	^'''', self, ''''
)
size = (
	^self Number wrapping: (vmmirror lengthOf: self dartString)
)) : ()
class True doNotInstaniate = Boolean ()
('as yet unclassified'
& other <Boolean> ^ <Boolean> = (
	^other
)
and: f <[^Boolean]>	 ^ <Boolean> = (
	^f value
)
ifFalse: else = (
	^nil
)
ifFalse: else ifTrue: then = (
	^then value
)
ifTrue: then = (
	^then value
)
ifTrue: then ifFalse: else = (
	^then value
)
not ^<Boolean> = (
	^false
)
or: f <[^Boolean]> ^ <Boolean> = (
	^true
)
printString = (
	^'true'
)
| other <Boolean> ^ <Boolean> = (
	^true
)) : ()
class UndefinedObject doNotInstaniate = ()
('as yet unclassified'
clone = (
	^self
)
ifNil: nilBlock = (
	^nilBlock value
)
ifNil: nilBlock ifNotNil: notNilBlock = (
	^nilBlock value
)
ifNotNil: notNilBlock = (
	^nil
)
isNil = (
	^true
)
notNil = (
	^false
)
printString = (
	^'nil'
)) : ()) : ()