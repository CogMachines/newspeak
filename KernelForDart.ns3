Newspeak3
'NS2Dart'
class KernelForDart = (
"Definitions for the built-in types of Newspeak on Dart. All sends to the receiver 'vmmirror' are evaluated at compile time by an instance of VMMirrorIntrinsics and transformed to the appropriate Dart code. Unlike the corresponding KernelForSqueak, the instance initializer of this class is never run because without pre-existing Object/Class/Metaclass/String the initialization is divergent.

**Changes to the names or superclass of the built-in types will require corresponding changes to the kernel initialization code in NS2DartCompilation`Infrastructure.**

Derived from the NS2JS Phase1Platform classes.

Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0")
(
class Array wrapping: d = (|
	dartList = d.
|)
('as yet unclassified'
= other = (
	self == other ifTrue: [^true].
	other isArray ifFalse: [^false].
	self size = other size ifFalse: [^false].
	1 to: size do: [:index |
		(self at: index) = (other at: index) ifFalse: [^false]].
	^true
)
at: index = (
	^vmmirror list: self dartList at: (index - 1)
)
at: index put: value = (
	^vmmirror list: self dartList at: (index - 1) put: value
)
binarySearchFor: el between: start and: end toCompare: compare = (
	"This does a binary search for the index such that if el was inserted before it
	  the receiver would remain sorted.  The receiver must be sorted relative to the
	  comparison block.  The comparison block should return true if the first block argument
	  cannot appear after the second block argument"

	| low high |
	low:: start.
	high:: end.
	[ low <= high ]
		whileTrue:
				[	| mid |
					mid:: (low + high) // 2.
	  				(compare value: (self at: mid) value: el)
						ifTrue: [ low:: mid + 1 ]	
						ifFalse: [ high:: mid - 1 ].
				].
	^low
)
collect: block = (
	| result = Array new: size. |
	1 to: size do: [:n |
		result at: n put: (block value: (self at: n))].
	^result
)
copyWithSize: s = (
	| safeself |
	safeself:: self.
	^(Array new: s) replaceFrom: 1 to: (s min: self size) with: safeself
)
do: block = (
	1 to: size do: [:n | block value: (self at: n)].
)
do: block separatedBy: betweenBlock = (
	| firstTime ::= true. |

	self do: [:element |
		firstTime ifTrue: [ firstTime:: false ] ifFalse: [betweenBlock value].
		block value: element].
)
doWithIndex: block = (
	1 to: size do: [:n | block value: (self at: n) value: n].
)
first = (
	^self at: 1
)
isArray = (
	^true
)
last = (
	^self at: self size
)
printString = (
	| x ::= '{'. |
	#FLAG. "This is not safe for arrays that contain themselves."
	self do: [:ea | x:: x , ea printString] separatedBy: [x:: x, '. '].
	^x , '}'
)
replaceFrom: start to: stop with: replacement = (
	"This destructively replaces elements from start to stop in the receiver. 
	Answer the receiver itself. Use copyReplaceFrom:to:with: for 
	insertion/deletion which may alter the size of the result."

	replacement size = (stop - start + 1)
		ifFalse: [self error: 'Size of replacement doesnt match'].
	^self replaceFrom: start to: stop with: replacement startingAt: 1
)
replaceFrom: start to: stop with: replacement startingAt: repStart = (
	"This destructively replaces elements from start to stop in the receiver 
	starting at index, repStart, in the sequenceable collection, 
	replacementCollection. Answer the receiver. No range checks are 
	performed."

	| index repOff |
	repOff:: repStart - start.
	index:: start - 1.
	[(index:: index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]
)
size = (
	^vmmirror lengthOf: self dartList
)) : ('as yet unclassified'
new: size = (
	| a = self wrapping: (vmmirror newList: size). |
	1 to: size do: [:i | a at: i put: nil].
	^a
)
new: size withAll: initialElement = (
	| a = self wrapping: (vmmirror newList: size). |
	1 to: size do: [:i | a at: i put: initialElement].
	^a
)
with: element = (
	| a = self new: 1. |
	a at: 1 put: element.
	^a
))
class Behavior = (|
	superclass ::= nil.
	mixin
	enclosingObject
	hasStaticChain ::= true.
|)
('as yet unclassified'
isMeta = (
	^false
)) : ()
class Block wrapping: f = (|
	dartFunction = f.
	"numArgs = n."
|)
('as yet unclassified'
ensure: block = (
	"We do not include a ^ here because try clauses are not expressions in Dart. The VMMirror intrinsic must handle the return specially."
	vmmirror try: self ensure: block
)
ifError: handlerBlock = (
	^self on: Error do: [:ex | handlerBlock value: ex]
)
isBlock = (
	^true
)
numArgsError: calledWith = (
	(self Error description: 'This block accepts ', numArgs printString,
		' arguments but was called with ',calledWith printString) signal
)
on: error do: handlerBlock = (
	"We do not include a ^ here because try clauses are not expressions in Dart. The VMMirror intrinsic must handle the return specially."
	vmmirror try: self on: error do: handlerBlock
)
printString = (
	^'[closure] in SomeNewspeakContext'
)
repeat = (
	[true] whileTrue: self
)
value = (
	^vmmirror invoke: dartFunction
)
value: arg1 = (
	^vmmirror invoke: dartFunction with: arg1
)
value: arg1 value: arg2 = (
	^vmmirror invoke: dartFunction with: arg1 with: arg2
)
value: arg1 value: arg2 value: arg3= (
	^vmmirror invoke: dartFunction with: arg1 with: arg2 with: arg3
)
value: arg1 value: arg2 value: arg3 value: arg4 = (
	^vmmirror invoke: dartFunction with: arg1 with: arg2 with: arg3 with: arg4
)
valueWithArguments: argArray = (
	^asYetUnimplemented
	"^vmmirror invoke: dartFunction withAll: argArray"
)
whileFalse = (
	self whileFalse: []
)
whileFalse: aBlock = (
	vmmirror whileFalse: self dartFunction do: aBlock dartFunction.
	^nil
)
whileTrue = (
	self whileTrue: []
)
whileTrue: aBlock = (
	vmmirror whileTrue: self dartFunction do: aBlock dartFunction.
	^nil
)) : ()
class Boolean = ()
('as yet unclassified'
clone = (
	^self
)
value = (
	^self
)) : ()
class Class = Behavior (|
	name
|)
('as yet unclassified'
mixinApply: superclass = (
	^vmmirror mixinApply: self to: superclass
)
printString = (
	^self name
)) : ()
class Error description: d <String> = (| description = d. |)
('as yet unclassified'
printString = (
	^'NewspeakError: ',description
)
signal = (
	vmmirror throw: self.
)) : ('as yet unclassified'
signal: description = (
	^(self description: description) signal
))
class False doNotInstaniate = Boolean ()
('as yet unclassified'
& other <Boolean> ^ <Boolean> = (
	^false
)
and: f <[^Boolean]> ^ <Boolean> = (
	^false
)
ifFalse: else = (
	^else value
)
ifFalse: else ifTrue: then = (
	^else value
)
ifTrue: then = (
	^nil
)
ifTrue: then ifFalse: else = (
	^else value
)
not = (
	^true
)
or: f <[^Boolean]> ^ <Boolean> = (
	^f value
)
printString = (
	^'false'
)
| other <Boolean> ^ <Boolean> = (
	^other
)) : ()
class Future computing: block <[^E]> = (
"The simplest possible future. It evalutes its closure in response to nearly every message."|
	private blockOrValue000 <[^E] | E> ::= block.
	private state000 <Symbol> ::= #unresolved.
|)
('as yet unclassified'
protected doesNotUnderstand: message = (
	^message sendTo: self resolve
)
public isFuture ^<Boolean> = (
	^true
)
public printString = (
	^self resolve printString
)
public yourself = (
	"See InstanceMixin>>apply:withName:"
	^self resolve
)'restricted'
resolve = (
	state000 = #resolving ifTrue: [
		Error signal: 'Divergent evalutation of ', blockOrValue000 printString].
	state000 = #unresolved ifTrue: [
		state000: #resolving.
		blockOrValue000: blockOrValue000 value.
		[blockOrValue000 isFuture] whileTrue:
			[blockOrValue000: blockOrValue000 resolve].
		state000: #resolved.
	].
	^blockOrValue000
)) : ('as yet unclassified'
computation: block = (
	^self computing: block
))
class Message selector: s arguments: a = (|
	public selector = s.
	public arguments = a.
|)
('as yet unclassified'
sendTo: newReceiver = (
	^vmmirror 
		on: newReceiver
		invoke: selector dartString
		with: arguments dartList
)) : ()
class MessageNotUnderstood receiver: r message: m = Error description: 'MessageNotUnderstood: ', r class name, ' ', m selector (|
receiver = r.
message = m.
|)
('as yet unclassified'
printString = (
	^description
)) : ()
class Metaclass = Behavior (|
	thisClass
|)
('as yet unclassified'
isMeta = (
	^true
)
name = (
	^thisClass name, ' class'
)
printString = (
	^thisClass name, ' class'
)) : ()
class Number wrapping: n = (|
	dartNumber = n.	
|)
('as yet unclassified'
* other = (
	^self Number wrapping: (vmmirror multiply: self dartNumber by: other dartNumber)
)
** other = (
	^asYetUnimplemented
)
+ other = (
	^self Number wrapping: (vmmirror to: self dartNumber add: other dartNumber)
)
- other = (
	^self Number wrapping: (vmmirror from: self dartNumber subtract: other dartNumber)
)
/ other = (
	^self Number wrapping: (vmmirror divide: self dartNumber by: other dartNumber)
)
// other = (
	^self Number wrapping: (vmmirror intDivide: self dartNumber by: other dartNumber)
)
< other = (
	^vmmirror is: self dartNumber lessThan: other dartNumber
)
<= other = (
	^vmmirror is: self dartNumber lessOrEqual: other dartNumber
)
= other = (
	^vmmirror is: self dartNumber equalTo: other dartNumber
)
> other = (
	^vmmirror is: self dartNumber greaterThan: other dartNumber
)
>= other = (
	^vmmirror is: self dartNumber greaterOrEqual: other dartNumber
)
bitAnd: other = (
	^self Number wrapping: (vmmirror bitAnd: self dartNumber with: other dartNumber)
)
bitOr: other = (
	^self Number wrapping: (vmmirror bitOr: self dartNumber with: other dartNumber)
)
bitXor: other = (
	^self Number wrapping: (vmmirror bitXor: self dartNumber with: other dartNumber)
)
exp = (
	^self Number wrapping: (vmmirror exp: self dartNumber)
)
isNumber = (
	^true
)
ln = (
	^self Number wrapping: (vmmirror ln: self dartNumber)
)
printString = (
	^self String wrapping: (vmmirror toString: dartNumber)
)
sqrt = (
	^self Number wrapping: (vmmirror sqrt: self dartNumber)
)
timesRepeat: aBlock = (
	1 to: self do: [:i | aBlock value]
)
to: stop by: step do: aBlock = (
	| nextValue |
	nextValue: self.
	step = 0 ifTrue: [self error: 'step must be non-zero'].
	step < 0
		ifTrue: [[stop <= nextValue]
				whileTrue: 
					[aBlock value: nextValue.
					nextValue: nextValue + step]]
		ifFalse: [[stop >= nextValue]
				whileTrue: 
					[aBlock value: nextValue.
					nextValue: nextValue + step]]
)
to: stop do: aBlock = (
	| nextValue |
	nextValue: self.
	[nextValue <= stop]
		whileTrue: 
			[aBlock value: nextValue.
			nextValue: nextValue + 1]
)
value = (
	^self
)) : ()
class Object = Top ()
('as yet unclassified'
public = other = (
	^self == other
)
protected Array = (
	^vmmirror Array
)
protected Block = (
	^vmmirror Block
)
protected ByteArray = (
	asYetUnimplemented
)
protected Delay = (
	^outer KernelForDart Future
)
protected Error = (
	^outer KernelForDart Error
)
protected Future = (
	^outer KernelForDart Future
)
protected Number = (
	^vmmirror Number
)
protected Object = (
	^vmmirror Object
)
protected String = (
	^vmmirror String
)
assert: condition <[^Boolean]> message: message = (
	"Raises an error with the given message if and only if condition evaluates to false."
	condition isBlock ifFalse: [Error signal: 'Block required'].
	condition value ifFalse: [Error signal: message]
)
class = (
	^vmmirror classOf: self
)
protected doesNotUnderstand: message = (
	^(MessageNotUnderstood receiver: self message: message) signal
)
hash = (
	^self identityHash
)
identityHash = (
	^vmmirror identityHashOf: self
)
ifNil: nilBlock = (
	^self.
)
ifNil: nilBlock ifNotNil: notNilBlock = (
	^notNilBlock value
)
ifNotNil: notNilBlock = (
	^notNilBlock value
)
isAlien = (
	#FLAG. "Subsumed by as-yet-unimplemented auto isFoo"
	^false
)
isDictionary = (
	#FLAG. "Subsumed by as-yet-unimplemented auto isFoo"
	^false
)
isExpat = (
	#FLAG. "Subsumed by as-yet-unimplemented auto isFoo"
	^false
)
isFuture = (
	#FLAG. "Subsumed by as-yet-unimplemented auto isFoo"
	^false
)
isNil = (
	^false
)
notNil = (
	^true
)
out = (
	print: self.
)
print: obj = (
	"Dart debugging: not part of the real Object API"
	^vmmirror print: obj
)
printString = (
	^'a ', self class name
)
yourself = (
	^self
)) : ()
class String wrapping: s = (| dartString = s. |)
('as yet unclassified'
, other = (
	^self String wrapping: (vmmirror concatenate: self dartString and: other dartString)
)
= other = (
	^vmmirror is: self dartString equalTo: other dartString
)
at: index = (
	^self String wrapping: (vmmirror list: self dartString at: (index - 1))
)
do: block = (
	1 to: size do: [:n | block value: (self at: n)].
)
hash = (
	^vmmirror hashOf: self dartString
)
isString = (
	^true
)
out = (
	vmmirror print: dartString
)
printString = (
	#FLAG. "Need to escape single quotes in self"
	^'''', self, ''''
)
size = (
	^vmmirror lengthOf: self dartString
)) : ()
class True doNotInstaniate = Boolean ()
('as yet unclassified'
& other <Boolean> ^ <Boolean> = (
	^other
)
and: f <[^Boolean]>	 ^ <Boolean> = (
	^f value
)
ifFalse: else = (
	^nil
)
ifFalse: else ifTrue: then = (
	^then value
)
ifTrue: then = (
	^then value
)
ifTrue: then ifFalse: else = (
	^then value
)
not ^<Boolean> = (
	^false
)
or: f <[^Boolean]> ^ <Boolean> = (
	^true
)
printString = (
	^'true'
)
| other <Boolean> ^ <Boolean> = (
	^true
)) : ()
class UndefinedObject doNotInstaniate = ()
('as yet unclassified'
clone = (
	^self
)
ifNil: nilBlock = (
	^nilBlock value
)
ifNil: nilBlock ifNotNil: notNilBlock = (
	^nilBlock value
)
ifNotNil: notNilBlock = (
	^nil
)
isNil = (
	^true
)
notNil = (
	^false
)
printString = (
	^'nil'
)) : ()'as yet unclassified'
MutableString = (
	^String
)) : ()