Newspeak3
'NS2Dart'
class KernelForDart = (
(*Definitions for the built-in types of Newspeak on Dart. All sends to the receiver 'vmmirror' are evaluated at compile time by an instance of VMMirrorIntrinsics and transformed to the appropriate Dart code. Unlike the corresponding KernelForSqueak, the instance initializer of this class is never run because without pre-existing Object/Class/Metaclass/String the initialization is divergent.

**Changes to the names or superclass of the built-in types will require corresponding changes to the kernel initialization code in NS2DartCompilation`Infrastructure.**

Derived from the NS2JS Phase1Platform classes.

Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0*)|

|)
(
class Array wrapping: d = (|
	dartList = d.
|)
('as yet unclassified'
= other = (
	self == other ifTrue: [^true].
	other isArray ifFalse: [^false].
	self size = other size ifFalse: [^false].
	1 to: size do: [:index |
		(self at: index) = (other at: index) ifFalse: [^false]].
	^true
)
at: index = (
	^vmmirror list: self dartList at: (index - 1)
)
at: index put: value = (
	^vmmirror list: self dartList at: (index - 1) put: value
)
binarySearchFor: el between: start and: end toCompare: compare = (
	(*This does a binary search for the index such that if el was inserted before it
	  the receiver would remain sorted.  The receiver must be sorted relative to the
	  comparison block.  The comparison block should return true if the first block argument
	  cannot appear after the second block argument*)

	| low high |
	low:: start.
	high:: end.
	[ low <= high ]
		whileTrue:
				[	| mid |
					mid:: (low + high) // 2.
	  				(compare value: (self at: mid) value: el)
						ifTrue: [ low:: mid + 1 ]	
						ifFalse: [ high:: mid - 1 ].
				].
	^low
)
collect: block = (
	| result = Array new: size. |
	1 to: size do: [:n |
		result at: n put: (block value: (self at: n))].
	^result
)
copyWithSize: s = (
	| safeself |
	safeself:: self.
	^(Array new: s) replaceFrom: 1 to: (s min: self size) with: safeself
)
do: block = (
	1 to: size do: [:n | block value: (self at: n)].
)
do: block separatedBy: betweenBlock = (
	| firstTime ::= true. |

	self do: [:element |
		firstTime ifTrue: [ firstTime:: false ] ifFalse: [betweenBlock value].
		block value: element].
)
doWithIndex: block = (
	1 to: size do: [:n | block value: (self at: n) value: n].
)
first = (
	^self at: 1
)
includes: element = (

	self do: [:each | each = element ifTrue: [^true]].
	^false
)
inject: val into: f = (

	(*Taken from NSCollections*)
	| v <X> |
	v:: val.
	self do: [ :e <X> | v:: f value: v value: e ].
	^v
)
isArray = (
	^true
)
last = (
	^self at: self size
)
printString = (
	| x ::= '{'. |
	#FLAG. (*This is not safe for arrays that contain themselves.*)
	self do: [:ea | x:: x , ea printString] separatedBy: [x:: x, '. '].
	^x , '}'
)
replaceFrom: start to: stop with: replacement = (
	(*This destructively replaces elements from start to stop in the receiver. 
	Answer the receiver itself. Use copyReplaceFrom:to:with: for 
	insertion/deletion which may alter the size of the result.*)

	replacement size = (stop - start + 1)
		ifFalse: [self error: 'Size of replacement doesnt match'].
	^self replaceFrom: start to: stop with: replacement startingAt: 1
)
replaceFrom: start to: stop with: replacement startingAt: repStart = (
	(*This destructively replaces elements from start to stop in the receiver 
	starting at index, repStart, in the sequenceable collection, 
	replacementCollection. Answer the receiver. No range checks are 
	performed.*)

	| index repOff |
	repOff:: repStart - start.
	index:: start - 1.
	[(index:: index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]
)
size = (
	^vmmirror lengthOf: self dartList
)) : ('as yet unclassified'
new: size = (
	| a = self wrapping: (vmmirror newList: size). |
	1 to: size do: [:i | a at: i put: nil].
	^a
)
new: size withAll: initialElement = (
	| a = self wrapping: (vmmirror newList: size). |
	1 to: size do: [:i | a at: i put: initialElement].
	^a
)
with: element = (
	| a = self new: 1. |
	a at: 1 put: element.
	^a
))
class Behavior = (|
	superclass ::= nil.
	mixin
	enclosingObject
	hasStaticChain ::= true.
|)
('as yet unclassified'
isMeta = (
	^false
)) : ()
class Block wrapping: f = (|
	dartFunction = f.
	(*numArgs = n.*)
|)
('as yet unclassified'
ensure: block = (
	(*We do not include a ^ here because try clauses are not expressions in Dart. The VMMirror intrinsic must handle the return specially.*)
	vmmirror try: self ensure: block
)
ifError: handlerBlock = (
	^self on: Error do: [:ex | handlerBlock value: ex]
)
isBlock = (
	^true
)
numArgsError: calledWith = (
	(self Error description: 'This block accepts ', numArgs printString,
		' arguments but was called with ',calledWith printString) signal
)
on: error do: handlerBlock = (
	(*We do not include a ^ here because try clauses are not expressions in Dart. The VMMirror intrinsic must handle the return specially.*)
	vmmirror try: self on: error do: handlerBlock
)
printString = (
	^'[closure] in SomeNewspeakContext'
)
repeat = (
	[true] whileTrue: self
)
value = (
	^vmmirror invoke: dartFunction
)
value: arg1 = (
	^vmmirror invoke: dartFunction with: arg1
)
value: arg1 value: arg2 = (
	^vmmirror invoke: dartFunction with: arg1 with: arg2
)
value: arg1 value: arg2 value: arg3= (
	^vmmirror invoke: dartFunction with: arg1 with: arg2 with: arg3
)
value: arg1 value: arg2 value: arg3 value: arg4 = (
	^vmmirror invoke: dartFunction with: arg1 with: arg2 with: arg3 with: arg4
)
valueWithArguments: argArray = (
	^asYetUnimplemented
	(*^vmmirror invoke: dartFunction withAll: argArray*)
)
whileFalse = (
	self whileFalse: []
)
whileFalse: aBlock = (
	vmmirror whileFalse: self dartFunction do: aBlock dartFunction.
	^nil
)
whileTrue = (
	self whileTrue: []
)
whileTrue: aBlock = (
	vmmirror whileTrue: self dartFunction do: aBlock dartFunction.
	^nil
)) : ()
class Boolean = ()
('as yet unclassified'
clone = (
	^self
)
value = (
	^self
)) : ()
class Class = Behavior (|
	name
|)
('as yet unclassified'
mixinApply: superclass = (
	^vmmirror mixinApply: self to: superclass
)
printString = (
	^self name
)) : ()
class Error description: d <String> = (| description = d. |)
('as yet unclassified'
printString = (
	^'NewspeakError: ',description
)
signal = (
	vmmirror throw: self.
)) : ('as yet unclassified'
signal: description = (
	^(self description: description) signal
))
class False doNotInstaniate = Boolean ()
('as yet unclassified'
& other <Boolean> ^ <Boolean> = (
	^false
)
and: f <[Boolean]> ^ <Boolean> = (
	^false
)
ifFalse: else = (
	^else value
)
ifFalse: else ifTrue: then = (
	^else value
)
ifTrue: then = (
	^nil
)
ifTrue: then ifFalse: else = (
	^else value
)
not = (
	^true
)
or: f <[Boolean]> ^ <Boolean> = (
	^f value
)
printString = (
	^'false'
)
| other <Boolean> ^ <Boolean> = (
	^other
)) : ()
class Future computing: block <[E]> = (
(*The simplest possible future. It evalutes its closure in response to nearly every message.*)|
	private blockOrValue000 <[E] | E> ::= block.
	private state000 <Symbol> ::= #unresolved.
|)
('as yet unclassified'
protected doesNotUnderstand: message = (
	^message sendTo: self resolve
)
public isFuture ^<Boolean> = (
	^true
)
public printString = (
	^self resolve printString
)
public yourself = (
	(*See InstanceMixin>>apply:withName:*)
	^self resolve
)'restricted'
resolve = (
	state000 = #resolving ifTrue: [
		Error signal: 'Divergent evalutation of ', blockOrValue000 printString].
	state000 = #unresolved ifTrue: [
		state000: #resolving.
		blockOrValue000: blockOrValue000 value.
		[blockOrValue000 isFuture] whileTrue:
			[blockOrValue000: blockOrValue000 resolve].
		state000: #resolved.
	].
	^blockOrValue000
)) : ('as yet unclassified'
computation: block = (
	^self computing: block
))
class Message selector: s arguments: a = (|
	public selector = s.
	public arguments = a.
|)
('as yet unclassified'
sendTo: newReceiver = (
	^vmmirror 
		on: newReceiver
		invoke: selector dartString
		with: arguments dartList
)) : ()
class MessageNotUnderstood receiver: r message: m = Error description: 'MessageNotUnderstood: ', r class name, ' ', m selector (|
receiver = r.
message = m.
|)
('as yet unclassified'
printString = (
	^description
)) : ()
class Metaclass = Behavior (|
	thisClass
|)
('as yet unclassified'
isMeta = (
	^true
)
name = (
	^thisClass name, ' class'
)
printString = (
	^thisClass name, ' class'
)) : ()
class MutableString initialSize: n = (
(*A string whose contents (but not size) can change after it's been created. The contents are stored as an array of individual characters (which in the Dart platform means an array of 1-character strings).*)|
	private contentsArray <Array[String]> = Array new: n.
|)
('as yet unclassified'
, anotherString = (
	| newInstance |
	newInstance:: self class new: self size + anotherString size.
	newInstance
		replaceFrom: 1 to: self size with: self startingAt: 1;
		replaceFrom: self size + 1 to: self size + 1 + anotherString size with: anotherString startingAt: 1.
	^newInstance
)
asString ^<String> = (
	^String withAll: (self collect: [:each | each])
	(*this identity collect: converts undefineds in contentsArray to null characters*)
)
asSymbol ^<String> = (
	^self asString
)
at: index <Integer> = (
	^(contentsArray at: index) ifNil: [String null] 
)
at: index <Integer> put: character <String> = (
	contentsArray at: index put: character.
	^character
)
collect: aBlock = (
	^contentsArray collect: [:each | aBlock value: (each ifNil: [String null])]
)
copyFrom: start to: stop = (
(*Answer a new mutable string with a copy of the receiver contents between the two indices, inclusive. The range is not validated; the sender must ensure its correctness.*)
	| newInstance |
	newInstance:: self class new: stop - start + 1.
	newInstance
		replaceFrom: 1 to: newInstance size with: self startingAt: start.
	^newInstance
)
copyWithSize: newSize = (
	| newString |
	newString:: self class new: newSize.
	newString
		replaceFrom: 1
		to: (newString size min: self size)
		with: self
		startingAt: 1.
	^newString
)
do: aBlock = (
	contentsArray do:
		[:each | aBlock value: (each ifNil: [String null])]
)
first = (
	^self at: 1
)
includes: element <String> = (
	self do: [:each | each = element ifTrue: [^true]].
	^false
)
isString = (
	^true
)
last = (
	^self at: self size
)
printString = (
	^'''', self asString, ''''
)
replaceFrom: start to: stop with: replacement startingAt: indexInReplacement = (
(*Destructively modify the receiver by replacing the elements between the two indices (inclusive) with those of the replacement, starting at the specified index in the replacement. Ranges are not validated; the sender must ensure their correctness.*)
	| index delta |
	index:: start.
	delta:: indexInReplacement - start.
	[index <= stop] whileTrue:
		[self at: index put: (replacement at: index + delta).
		index:: index + 1]
)
size = (
	^contentsArray size
)) : ('as yet unclassified'
new = (
	^self initialSize: 0
)
new: n = (
	^self initialSize: n
)
new: size <Integer> withAll: character <String> = (
	| instance |
	instance:: self initialSize: size.
	1 to: size do: [:index | instance at: index put: character].
	^instance
)
withAll: string <String> = (
	| instance |
	instance:: self initialSize: string size.
	1 to: string size do: [:index | instance at: index put: (string at: index)].
	^instance
))
class Number wrapping: n = (|
	dartNumber = n.	
|)
('as yet unclassified'
* other = (
	^self Number wrapping: (vmmirror multiply: self dartNumber by: other dartNumber)
)
** other = (
	^asYetUnimplemented
)
+ other = (
	^self Number wrapping: (vmmirror to: self dartNumber add: other dartNumber)
)
- other = (
	^self Number wrapping: (vmmirror from: self dartNumber subtract: other dartNumber)
)
/ other = (
	^self Number wrapping: (vmmirror divide: self dartNumber by: other dartNumber)
)
// other = (
	^self Number wrapping: (vmmirror intDivide: self dartNumber by: other dartNumber)
)
< other = (
	^vmmirror is: self dartNumber lessThan: other dartNumber
)
<= other = (
	^vmmirror is: self dartNumber lessOrEqual: other dartNumber
)
= other = (
	^vmmirror is: self dartNumber equalTo: other dartNumber
)
> other = (
	^vmmirror is: self dartNumber greaterThan: other dartNumber
)
>= other = (
	^vmmirror is: self dartNumber greaterOrEqual: other dartNumber
)
bitAnd: other = (
	^self Number wrapping: (vmmirror bitAnd: self dartNumber with: other dartNumber)
)
bitOr: other = (
	^self Number wrapping: (vmmirror bitOr: self dartNumber with: other dartNumber)
)
bitXor: other = (
	^self Number wrapping: (vmmirror bitXor: self dartNumber with: other dartNumber)
)
exp = (
	^self Number wrapping: (vmmirror exp: self dartNumber)
)
isNumber = (
	^true
)
ln = (
	^self Number wrapping: (vmmirror ln: self dartNumber)
)
printString = (
	^self String wrapping: (vmmirror toString: dartNumber)
)
sqrt = (
	^self Number wrapping: (vmmirror sqrt: self dartNumber)
)
timesRepeat: aBlock = (
	1 to: self do: [:i | aBlock value]
)
to: stop by: step do: aBlock = (
	| nextValue |
	nextValue: self.
	step = 0 ifTrue: [self error: 'step must be non-zero'].
	step < 0
		ifTrue: [[stop <= nextValue]
				whileTrue: 
					[aBlock value: nextValue.
					nextValue: nextValue + step]]
		ifFalse: [[stop >= nextValue]
				whileTrue: 
					[aBlock value: nextValue.
					nextValue: nextValue + step]]
)
to: stop do: aBlock = (
	| nextValue |
	nextValue: self.
	[nextValue <= stop]
		whileTrue: 
			[aBlock value: nextValue.
			nextValue: nextValue + 1]
)
value = (
	^self
)) : ()
class Object = Top ()
('as yet unclassified'
public = other = (
	^self == other
)
public == other = (
	^vmmirror is: self identicalTo: other
)
protected Array = (
	^vmmirror Array
)
protected Block = (
	^vmmirror Block
)
protected ByteArray = (
	asYetUnimplemented
)
protected Delay = (
	^outer KernelForDart Future
)
protected Error = (
	^outer KernelForDart Error
)
protected Future = (
	^outer KernelForDart Future
)
protected Number = (
	^vmmirror Number
)
protected Object = (
	^vmmirror Object
)
protected String = (
	^vmmirror String
)
assert: condition <[Boolean]> message: message = (
	(*Raises an error with the given message if and only if condition evaluates to false.*)
	condition isBlock ifFalse: [Error signal: 'Block required'].
	condition value ifFalse: [Error signal: message]
)
class = (
	^vmmirror classOf: self
)
protected doesNotUnderstand: message = (
	^(MessageNotUnderstood receiver: self message: message) signal
)
error: description = (
	^Error signal: description
)
hash = (
	^self identityHash
)
identityHash = (
	^vmmirror identityHashOf: self
)
ifNil: nilBlock = (
	^self.
)
ifNil: nilBlock ifNotNil: notNilBlock = (
	^notNilBlock value
)
ifNotNil: notNilBlock = (
	^notNilBlock value
)
isAlien = (
	#FLAG. (*Subsumed by as-yet-unimplemented auto isFoo*)
	^false
)
isDictionary = (
	#FLAG. (*Subsumed by as-yet-unimplemented auto isFoo*)
	^false
)
isExpat = (
	#FLAG. (*Subsumed by as-yet-unimplemented auto isFoo*)
	^false
)
isFuture = (
	#FLAG. (*Subsumed by as-yet-unimplemented auto isFoo*)
	^false
)
isKindOfCollection = (
	#FLAG. (*Subsumed by as-yet-unimplemented auto isFoo*)
	^false
)
isNil = (
	^false
)
isString = (
	#FLAG. (*Subsumed by as-yet-unimplemented auto isFoo*)
	^false
)
notNil = (
	^true
)
out = (
	print: self.
)
print: obj = (
	(*Dart debugging: not part of the real Object API*)
	^vmmirror print: obj
)
printString = (
	^'a ', self class name
)
yourself = (
	^self
)) : ()
class String wrapping: s = (| dartString = s. |)
('as yet unclassified'
, other = (
	^self String wrapping: (vmmirror concatenate: self dartString and: other dartString)
)
<= str2 = (
	^(vmmirror compare: dartString to: str2 dartString) <= 0
)
= other = (
	^other isString
		and: [vmmirror is: self dartString equalTo: other dartString]
)
== other = (
	^other isString
		and: [vmmirror is: self dartString equalTo: other dartString]
)
>= str2 = (
	^(vmmirror compare: dartString to: str2 dartString) >= 0	
)
asString = (
	^self
)
asSymbol = (
	^self
)
asciiValue = (
	^vmmirror codePointOfString: dartString.
)
at: index = (
	^self String wrapping: (vmmirror list: self dartString at: (index - 1))
)
between: a and: b = (
	^self >= a and: [self <= b]
)
copyFrom: start to: end = (
	^String wrapping: (vmmirror substring: self dartString from: start -1 to: end)
)
copyWithSize: newSize = (

	(*This differes from the implementation in Array in order to not rely on mutating functions*)
	| copyCount result |
	copyCount:: newSize min: self size.
	result:: self copyFrom: 1 to: copyCount.	
	[copyCount < newSize] whileTrue: [
		copyCount:: copyCount + 1.
		result:: result, ' '].
	^ result
)
do: block = (
	1 to: size do: [:n | block value: (self at: n)].
)
hash = (
	^vmmirror hashOf: self dartString
)
identityHash = (
	^vmmirror hashOf: self dartString
)
isKindOfCharacter = (
	^size = 1
)
isLetter = (
	| value = vmmirror codePointOfString: dartString. |
	^ (value >= 97 and: [value <= 122]) or: [
		value >= 65 and: [value <= 90]]
	(*^ (self >= 'a' and: [self <= 'z']) or: [
		self >= 'A' and: [self <= 'Z']]*)
)
isSeparator ^<Boolean> = (
	| value = vmmirror codePointOfString: dartString. |
	value = 32 ifTrue: [^true].	(*space*)
	value = 13 ifTrue: [^true].	(*cr*)
	value = 9 ifTrue: [^true].	(*tab*)
	value = 10 ifTrue: [^true].	(*line feed*)
	value = 12 ifTrue: [^true].	(*form feed*)
	^false
)
isString = (
	^true
)
out = (
	vmmirror print: dartString
)
printString = (
	#FLAG. (*Need to escape single quotes in self*)
	^'''', self, ''''
)
size = (
	^vmmirror lengthOf: self dartString
)) : ('as yet unclassified'
backspace = (
	^codePoint: 16r08
)
codePoint: cp <Integer> ^<String> = (
	^wrapping: (vmmirror stringWithCodePoint: cp)
)
cr = (
	^codePoint: 16r0D
)
lf = (
	^codePoint: 16r0A
)
tab = (
	^codePoint: 16r09
)
withAll: characters = (
	| x ::= ''. |
	characters do: [:char | x: x, char].
	^x
))
class True doNotInstaniate = Boolean ()
('as yet unclassified'
& other <Boolean> ^ <Boolean> = (
	^other
)
and: f <[Boolean]>	 ^ <Boolean> = (
	^f value
)
ifFalse: else = (
	^nil
)
ifFalse: else ifTrue: then = (
	^then value
)
ifTrue: then = (
	^then value
)
ifTrue: then ifFalse: else = (
	^then value
)
not ^<Boolean> = (
	^false
)
or: f <[Boolean]> ^ <Boolean> = (
	^true
)
printString = (
	^'true'
)
| other <Boolean> ^ <Boolean> = (
	^true
)) : ()
class UndefinedObject doNotInstaniate = ()
('as yet unclassified'
clone = (
	^self
)
ifNil: nilBlock = (
	^nilBlock value
)
ifNil: nilBlock ifNotNil: notNilBlock = (
	^nilBlock value
)
ifNotNil: notNilBlock = (
	^nil
)
isNil = (
	^true
)
notNil = (
	^false
)
printString = (
	^'nil'
)) : ()) : ()