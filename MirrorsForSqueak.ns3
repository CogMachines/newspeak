Newspeak3
'Mirrors'
class MirrorsForSqueak usingPlatform: platform <Platform> vmMirror: vmm <VMMirror> = (
 (* The new Newspeak mirrors API. It is a work in progress that attempts to address weaknesses of the current API and of past mirror APIs. The mirrors here are high level mirrors: they represent language constructs in NS2 and above.

The API follows several general guidelines:

1) Operations return mirrors (an exception is getting the reflectee).
2) Operations take non-mirrors as arguments.
3) Operations take a failure block.

The motivation for (3) is that mirrors should be useful in both local and distributed settings. Forcing the user to confront the possibility of failure helps make code more robust in the distributed case.  This also contributes to (1); returned results may refer to remote values, and going through the mirror API to deal with them will help ensure failure scenarios are dealt with.

On the other hand, arguments can always be converted to mirrors by the API.  Much of the awkwardness in mirror APIs stems from the need to package arguments as mirrors - with the API often immediately extracting the reflectee afterwards.  The API should endeavor to deal with either mirrors or non-mirrors when this makes sense (e.g., when applying a mixin to a superclass, the superclass argument could be either a class or a class mirror) or to provide a separate call for mirrors (say, when adding a method - one call might accept source as a string, another a MethodMirror).

The implementation will likely change. As we reform the reflective interface, we are likely to reduce our reliance on existing code like SqueakVMMirror and NS2Reflection; either their code will migrate here or vice versa.

The API is divided into immutable and mutable parts. Mirrors are basically immutable.  As such they support introspection directly. In order to mutate code, one uses MirrorBuilders. These are created based on a mirror, and allow modifications to be accumulated without having any effect on the system.  The builder can be asked to provide a mirror reflecting its current state at any time. This allows the results of multiple builders to be batched and submitted to the atomic installer as well.

All this brings up the question of how mirrors differ from ASTs. Mirrors and ASTs should ideally be viewed as different implementations of the same interface.  Mirrors differ in how they are constructed and how they compute their subtrees. Mirrors may be connected to a live representation, or to a source base or whatever. 

MirrorBuilders also differ in supporting mutability and in what inputs can drive them (e.g, addFromSource:) so they extend the base API of mirrors and ASTs. 

It may be a while before this module realizes the ideal description given above. Also, the implementation still relies heavily on earlier reflective APIs - be they the built-in Squeak reflection classes or other efforts. Ultimately, the actual logic for this should reside here.

   Copyright 2008 Cadence Design Systems, Inc.
   Copyright (c) 2009-2010 Gilad Bracha
   Copyright 2011 Gilad Bracha, Ryan Macnak and Cadence Design Systems

   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|  
private MutableHashedMap = platform collections Dictionary.
private MutableList = platform collections OrderedCollection.
private IdentitySet = platform blackMarket IdentitySet.
private IdentityDictionary = platform blackMarket IdentityDictionary.

private Duct = platform ducts Duct.
private WeakStorage = platform ducts WeakStorage.

private Metaclass = platform kernel Metaclass.
private Language = platform blackMarket NsMultilanguage Language.
private SystemChangeNotifier = platform blackMarket SystemChangeNotifier.

private atomicInstaller = platform namespace AtomicInstaller usingPlatform: platform vmMirror: vmm.

private groups = platform namespace MirrorGroups usingLib: platform.
private intermediates = platform namespace Intermediates usingPlatform: platform.
private ImmutableMirrorGroup = groups ImmutableMirrorGroup.

private vmmirror = vmm.

parserLib = Future computing: [platform namespace CombinatorialParsing usingPlatform: platform].
(* Often imported by other module because it is annoying to get and assemble the parts to instaniate it. *)
grammar = Future computing: [platform namespace NewspeakGrammar usingPlatform: platform parsers: parserLib].
(* Used by the language adaptor for the colorizer. *)
asts = Future computing: [platform namespace NewspeakASTs usingLib: platform].
parsing = Future computing: [platform namespace NewspeakParsing
	usingPlatform: platform
	grammar: grammar
	asts: asts].
compilation = Future computing: [platform namespace Newspeak2SqueakCompilation
	usingPlatform: platform 
	newspeakParser: parsing
	intermediates: intermediates].

protected storedCompiler (* cached compiler and module *)

private mixinBasedMirrors <WeakIdentitySet[MixinMirror]> = WeakStorage new.
|) (
public class ClassDeclarationBuilder fromIntermediate: ir <IntermediateClassDeclaration> forExistingMixin: mixin <InstanceMixin> = (
(*Builders do not give an ordinary mirror representing their current state: ask the builder itself. (Although this could be done: submit to atomic install without a namespace, don't install into Smalltalk, don't update the existingMixin, and reflect on the result.)

Builders internally keep a CompiledMixinMirror that reflects the current state, including edits made but not yet installed. Queries reflect the state of this CMM.

Builders are connected up and down.  If you get a builder on a declaration, if you ask *the builder* for an enclosing or nested declaration and edit, installing any of them means installing all of them.  Builders created de novo (via reflecting: or fromSource:) remain independent.*)|
	(* Used to create the namespace for AtomicInstall so existing instances are updated *)
	public prvtExistingMixin <InstanceMixin | nil> ::= mixin.

	(* Lazy.  It should not be neccessary to always unpack an entire module definition.
	Perhaps this should be eager to complete creating-a-builder-is-like-forking semantics. *)
	public prvtEnclosingDeclaration <ClassDeclarationBuilder>
	
	(* Eager. Simplifies CDB on installed CD versus new CD.  This must be computed anyway to install. *)
	public instanceSide <MixinBuilder> = MixinBuilder 
		forClassDeclaration: self intermediate: ir instanceSide.
		
	public classSide <MixinBuilder> = MixinBuilder 
		forClassDeclaration: self intermediate: ir classSide.
	
	public prvtIntermediate <CompiledMixinMirror> ::= ir.
	
	public header <ClassHeaderBuilder> = ClassHeaderBuilder forClassDeclaration: self.
|) (
'API'
public accessModifier = (
	(*TODO: we might want to change an access modifier. Currently this is only a getter reading from the old existing mixin. *)
	^ prvtExistingMixin accessModifier
)
public enclosingClass ^<ClassDeclarationBuilder> = (
	prvtEnclosingDeclaration ifNil: [
		| enclosing <Mixin> |
		
		prvtExistingMixin isNil ifTrue: [^nil].
		
		enclosing:: prvtExistingMixin enclosingMixin.
		enclosing ifNil: [^nil].
		
		prvtEnclosingDeclaration:: ClassDeclarationBuilder reflecting: enclosing.
		
		prvtEnclosingDeclaration prvtIntermediate instanceSide nestedClasses
			removeAllSuchThat: [:e | e simpleName = prvtIntermediate simpleName].
		prvtEnclosingDeclaration prvtIntermediate instanceSide nestedClasses
			add: prvtIntermediate.
		prvtEnclosingDeclaration instanceSide nestedClasses addMirror: self.
	].
	^prvtEnclosingDeclaration
)
public headerFromSource: newHeader <String> = (
	| prefix res |
	
	#BOGUS yourself.
	(* API:
		<ClassDeclarationBuilder> headerFromSource:
		vs
		<ClassDeclarationBuilder> header source:
	
	Semantics: Do we allow the name to be changed? If so:	
		Have to check for conflicts with methods/slots of enclosing.
		If it conflicts with another class, override it?
		If it is new, does this make a copy, or replace the old one?
		
		Currently, this takes 'Foo = ()' instead of 'class Foo = ()'.  Perhaps we should do the latter since an access modifier might be specified?
	*)
	prefix:: (lazyIsTopLevel
			(* only top-level classes can specify categories *)
			ifTrue: [ 'Newspeak3 ''', header category, ''' ' ]
			ifFalse: [ ' ' ]).
			
	res:: compiler
		compileClassHeader: (prefix, newHeader) readStream
		of: self
		into: prvtIntermediate
		within: (enclosingClass ifNotNil: [:it | it prvtIntermediate]).
	prvtIntermediate:: res.
	instanceSide prvtIntermediate: res instanceSide.
	classSide prvtIntermediate: res classSide.
	
	checkForSlotConflicts: res.
		(* 
		checkForNameChange: compiledResults first.
		restory category
		*)
)
public install ^<ClassDeclarationMirror> = (
	
	^(installAtomically: {self}) first
)
public name ^<Symbol> = (
	^self qualifiedName
)
public reflectee ^<InstanceMixin | nil> = (
	#BOGUS yourself.
	(* If this builder corresponds to a class declaration that was already installed, we're okay. But this builder might represent a new class declaration that doesn't have a corresponding Mixin yet (#install will ensure it is filled, though). So, do we return a potentially nil reflectee or not support accessing a reflectee at all? *)
	
	^prvtExistingMixin
)
public simpleName ^<Symbol> = (
	^fullyQualifiedNameToSimple: qualifiedName
)
'as yet unclassifed'
public printOn: stm = (
	stm nextPutAll: 'ClassDeclarationBuilder:'; nextPutAll: qualifiedName
)
'as yet unclassified'
public qualifiedName ^<Symbol> = (
	^prvtIntermediate qualifiedName
)
public source ^<String> = (
	^String streamContents:
		[:stream |
		stream nextPutAll: prvtIntermediate headerSource.
		stream nextPutAll: ' ('; cr.
		(instanceSide nestedClasses
			asSortedList: [:a :b | a simpleName <= b simpleName])
			do: [:nc | stream nextPutAll: nc source].
		writeOrganizationOf: instanceSide on: stream.
		stream nextPutAll: ') : ('; cr.
		writeOrganizationOf: classSide on: stream.
		stream nextPut: ")"; cr]
)
private writeOrganizationOf: mixin on: stream = (
	mixin methods do:
		[:method | 
		stream nextPut: "'"; nextPutAll: method category; nextPut: "'"; cr.
		stream nextPut: method source; cr].
)
'private'
checkForNameChange: newCompiledMixinMirror = (
	
	(fullyQualifiedNameToSimple: newCompiledMixinMirror name) = self simpleName
		ifFalse: [Error signal: 'Cannot change name this way'].
)
checkForSlotConflicts: newIntermediate <IntermediateClassDeclaration> = (
	
	newIntermediate instanceSide slots do:
		[:slot <IntermediateSlotDeclaration> | 
		instanceSide
			checkNameConflictsForSlot: slot name
			mutable: slot isMutable].
)
compiledMixinMirror = (
	(* Asked for by compiler *)
	^prvtCompiledMixinMirror
)
public lazyIsTopLevel = (

	prvtEnclosingDeclaration isNil ifFalse: [^false].
	
	(* enclosingDeclaration not yet created *)
	prvtExistingMixin isNil ifTrue: [^true (* can't be created: must be new decl *)].
	^prvtExistingMixin enclosingMixin isNil
)
public notifyExistingMirrors = (
	instanceSide notifyExistingMirrors.
	classSide notifyExistingMirrors.
)
'restricted'
public collectExistingMixinsInto: map <Map[IntermediateClassDeclaration, InstanceMixin]> ^<IntermediateClassDeclaration> = (
	prvtExistingMixin ifNotNil: [map at: prvtIntermediate put: prvtExistingMixin].
	instanceSide nestedClasses do: [:ea | ea collectExistingMixinsInto: map].
	^prvtIntermediate
)
public extractReflecteeFrom: mixin <Mixin> = (

	(* For builders that already had a non-nil reflectee, this is not necessary since the old reflectee has been become:d to the new one (at least if atomic install is working right...).  But this is required for builders that have been created from source and didn't have a reflectee yet.  This will connect them to their reflectees. *)

	prvtExistingMixin:: mixin.
	
	mixin nestedMixins keysAndValuesDo: [:fullName :nestedMixin |
		| n m |
		n:: fullyQualifiedNameToSimple: fullName.
		m:: instanceSide nestedClasses findMirrorNamed: n.
		m extractReflecteeFrom: nestedMixin
	].
)
public ultimateInstallee ^<ClassDeclarationBuilder> = (

	prvtEnclosingDeclaration ifNotNil: [
		(* Modifications were made to my enclosing class, must go up to really install. *)
		^prvtEnclosingDeclaration ultimateInstallee.
	].
 
	^self
)
'testing'
public isClassDeclarationMirror ^<Boolean> = (
	^true
)
) : (
'accessing'
public fromSource: src <String> ^<ClassDeclarationBuilder> = (
	^self fromUnitSource: 'Newspeak3 ''Uncategorized'' ', src
)
'as yet unclassified'
public fromUnitSource: source <String> ^<ClassDeclarationBuilder> = (
	| ir <IntermediateClassDeclaration> |
	ir:: compiler compileClassSource: source readStream within: nil.
	^self fromIntermediate: ir forExistingMixin: nil
)
public reflecting: mixin <InstanceMixin> ^<ClassDeclarationBuilder> = (
	assert: [mixin isMixin & mixin isMeta not] message: 'Provide an instance-side mixin'.
	^self
		fromIntermediate: (buildIntermediateFor: mixin)
		forExistingMixin: mixin
)
)
public class ClassDeclarationMirror reflecting: mixin <Mixin> = Mirror reflecting: mixin (
(* A class declaration defines the instance and class sides, and a header. Each side comprises methods and nested classes. The header provides a superclass clauses, a primary factory a class comment and an instance initializer.  

This mirror provides a view of a class declaration based on its runtime representation in the Newspeak image running on Squeak. To create an instance, provide the instance-side mixin. The mirror can obtain all necessary information from that. *)|
	instanceSideLazy
	classSideLazy
|assert: [mixin isMixin & mixin isMeta not] message: 'Provide an instance-side mixin') (
'API'
public classSide ^ <MixinMirror> = (
	classSideLazy ifNil: [
		classSideLazy:: MixinMirror reflecting: reflectee classMixin].
	^classSideLazy
)
public enclosingClass ^ <ClassDeclarationMirror> = (
	| enclosing <Class> |
	enclosing:: reflectee enclosingMixin. 
	enclosing ifNil:[^nil].
	^ClassDeclarationMirror reflecting: enclosing mixin
)
public header ^ <ClassHeaderMirror> = (
	^ClassHeaderMirror reflecting: reflectee
)
initializerSource = (
	#BOGUS. (* Remove me *)
	^header source
)
public instanceSide ^ <MixinMirror> = (
	instanceSideLazy ifNil: [
		instanceSideLazy:: MixinMirror reflecting: reflectee].
	^instanceSideLazy
)
public name ^ <Symbol> = (
	^self qualifiedName
)
public simpleName ^ <Symbol> = (
	^fullyQualifiedNameToSimple: qualifiedName
)
public source ^ <String> = (
	^ (* accessModifierIfNecessary, *) (String streamContents: [ :s | reflectee printClassOn: s ]	)
)
'as yet unclassified'
public accessModifier ^ <Symbol>= (
	(*	Finding the accessModifier of a class Declaration is hell. ClassDeclarationBuilders are
		constructed from a mixin. Mixins, by definition, do not know with which accessModifier they
		are applied with. So, we ask the enclosing mixin instead and assume that top-level mixins can
		only be applied as public. *)
	^ reflectee accessModifier
)
hasBody ^ <Boolean> = (
 (* Does my reflectee have a class body *)
	(* A bit of a hack, until we have clean per-mixin metadata *)
	^instanceSide initializer metadata at: #hasBody ifAbsent:[true].
)
public qualifiedName ^ <Symbol> = (
	^reflectee name
)
'restricted'
compiledMixinMirror = (
	(* Used by the compiler.  Polymorphic with ClassDeclarationBuilder, which must answer the one that represents edits in progress. *)
	^makeCompiledMixinMirrorForMixin: reflectee
)
'testing'
public isClassDeclarationMirror ^<Boolean> = (
	^true
)
) : (
)
class ClassHeaderBuilder forClassDeclaration: decl = (|
	prvtDeclaration <ClassDeclarationBuilder> = decl.
|) (
'as yet unclassified'
public category ^<Symbol> = (
	^prvtDeclaration prvtIntermediate category ifNil: ['Uncategorized']
)
public category: c <Symbol | String> = (
	prvtDeclaration prvtCompiledMixinMirror category: c asSymbol
)
public classComment ^<String> = (
	^(compilation parser classHeader 
		parse: prvtDeclaration prvtCompiledMixinMirror header readStream) classComment
)
public classComment: newClassComment <String> = (
	| ast token newHeaderSource |
	ast:: grammar TypedNS3Grammar new classHeader
		parse: source readStream.
	token:: (ast at: 6) at: 2.
	
	newHeaderSource:: 
		(source copyFrom: 1 to: token start + 2), 
		newClassComment,
		(source copyFrom: token end - 1 to: source size).

	prvtDeclaration prvtCompiledMixinMirror
		header: newHeaderSource;
		commentString: newClassComment.
)
public name ^<Symbol> = (
	(* Is this full or simple? *)
	^prvtDeclaration name
)
public name: newSimpleName <Symbol> = (
	| token newClassSource res |

	(* check for name conflict with sibling members *)
	prvtDeclaration lazyIsTopLevel ifFalse: [
		| existing |
		existing:: prvtDeclaration enclosingClass instanceSide nestedClasses findMirrorNamed: newSimpleName.
		(existing isNil or: [existing = prvtDeclaration])
			ifFalse: [Error signal: 'A sibling already exists with the name ',newSimpleName].

		(* remove old accessors *)
		(* prvtDeclaration enclosingClass instanceSide nestedClasses
			removeSlotAndAccessorOf: prvtDeclaration. *)
	].


	(* patch header source with the new name *)
	token:: (grammar TypedNS3Grammar new classHeader parse: source readStream) at: 3.
	newClassSource::
		(prvtDeclaration lazyIsTopLevel
			(* only top-level classes can specify categories *)
			ifTrue: [ 'Newspeak3 ''', category, ''' ' ]
			ifFalse: [ ' ' ]),
		(source copyFrom: 1 to: token start - 1) ,
		newSimpleName ,
		(source copyFrom: token end + 1 to: source size).


	(* compile etc *)
	res:: compiler
		compileClassHeader: newClassSource readStream
		of: self prvtDeclaration
		into: prvtDeclaration prvtIntermediate
		within: (prvtDeclaration enclosingClass ifNotNil: [:it | it prvtIntermediate]).
		
	prvtDeclaration prvtIntermediate: res.
	prvtDeclaration instanceSide prvtIntermediate: res instanceSide.
	prvtDeclaration classSide prvtIntermediate: res classSide.
	
	(* prvtDeclaration checkForSlotConflicts: compiledResults first. *)
	
	prvtDeclaration enclosingClass ifNotNil: [:it | it instanceSide nestedClasses addMirror: prvtDeclaration].
)
public primaryFactory ^ <MethodBuiler> = (

	| factoryName intermediateMethod |
	factoryName:: prvtDeclaration prvtIntermediate factoryName.
	intermediateMethod:: prvtDeclaration prvtIntermediate classSide methods
		detect: [:im | im simpleName = factoryName].

	^MethodBuilder reflecting: intermediateMethod in: prvtDeclaration classSide
)
public source ^<String> = (
	^prvtDeclaration prvtIntermediate headerSource
)
public source: newHeaderSource <String> = (
	prvtDeclaration headerFromSource: newHeaderSource
)
) : (
)
class ClassHeaderMirror reflecting: mixin <Mixin> = Mirror reflecting: mixin ((* A class header defines the class' name, primary factory, superclass clause, class comment and instance initializer (slots and init expressions).

This mirror provides access to a class header based on the runtime representation. *)) (
'API'
public category ^ <Symbol> = (
	^reflectee category
)
public classComment ^ <String> = (
	^(compilation parser classHeader parse: source readStream) classComment
)
public declaration ^<ClassDeclarationMirror> = (
	^ClassDeclarationMirror reflecting: self reflectee
)
public primaryFactory ^ <MethodMirror> = (

	^MethodMirror reflecting: (reflectee classMixin
		methodDict at: primaryFactoryName)
)
public source ^ <String> = (
	^ reflectee cachedHeaderSource
)
'as yet unclassified'
public initializer = (
	#BOGUS.
	reflectee methodDict values do: 
		[:cm | (cm properties includesKey: #isSubinitializer)
			ifTrue: [^MethodMirror reflecting: cm]].
	halt.
)
public isClassHeaderMirror ^<Boolean> = (
	^true
)
public name ^ <Symbol> = (
	^reflectee name
)
public preamble ^<Symbol> = (
	(* Foo factory = SuperFoo superFactory *)
	| headerAst |
	headerAst:: compilation parser classHeader parse: source readStream.
	^source copyFrom: headerAst start to: headerAst superConstructorCall end
)
public primaryFactoryName ^ <Symbol> = (
	^reflectee cachedConstructorName
)
public qualifiedName ^ <Symbol> = (
	^reflectee qualifiedName
)
public sendsSelector: sel <Symbol> ^<Boolean> = (
	(* This is incomplete for the quick send selectors. *)
	(* Look through instance initializers. *)
	reflectee methodDictionary valuesDo: [:cm | 
		(cm properties includesKey: #isSubinitializer) 
			ifTrue: [(cm hasLiteral: sel) ifTrue: [^true]]].
	(* Look at the nested class accessor, if nested. *)
	reflectee enclosingMixin ifNotNil: [:parent | 
		((parent compiledMethodAt: simpleName) hasLiteral: sel) ifTrue: [^true]].
	^false
)
public simpleName ^ <Symbol> = (
	^fullyQualifiedNameToSimple: name
)
public slots ^ <MirrorGroup[SlotDeclarationMirror]> = (
	^ImmutableMirrorGroup group: 
		((reflectee slots
			reject: [:ea | ea first includes: "`"])
				collect: [:ea | SlotDeclarationMirror named: ea first mutable: ea second accessModifier: ea last])
)
superclassClause ^ <SendAST> = (
	self halt.
)
) : (
)
public class ClassMirror reflecting: c <Behavior> = Mirror reflecting: c () (
'as yet unclassified'
accessModifier = (
	warnObsolete.
	^ mixin accessModifier
)
public allSuperclasses ^ <List[ClassMirror]> = (
	| klass <Class> superclasses <List[Class]> |
	superclasses:: MutableList new.
	klass:: superclass.
	[klass isNil] whileFalse:[
		superclasses add: klass.
		klass:: klass superclass.
	].
	^superclasses
)
public canUnderstand: selector <Symbol> ^<Boolean> = (
	
	(mixin canUnderstand: selector) ifTrue: [^true].
	superclass = nil
		ifTrue: [^false]
		ifFalse: [^superclass canUnderstand: selector].
)
computeMirrorGroup: mgAccessor <[:Mirror | MirrorGroup]> ^ <MirrorGroup> = (
	(* Return a mirror group based on the mixins group and those of all superclasses. The argument mgAccessor extracts a mirror group from any mirror provided to it. *)
	| mg <MirrorGroup>  |
	mg:: MutableMirrorGroup group: {} within: self.
	(allSuperclasses reverse add: self; yourself) do:
		[:klass <ClassMirror> |
		mg addAllMirrors: (mgAccessor value: klass mixin)].
	^ImmutableMirrorGroup group: mg	
)
public enclosingObject ^<ObjectMirror> = (
	^ObjectMirror reflecting:
		(reflectee language isNewspeakLanguage3
			ifTrue: [reflectee enclosingObjectSlot]
			ifFalse: [nil])
)
public methods ^<MirrorGroup[MethodMirror]> = (
	^computeMirrorGroup: [:r | r methods]
)
public mixin ^<MixinMirror> = (
	^MixinMirror reflecting: reflectee mixin
)
public name ^ <Symbol> = (
	^reflectee name
)
public nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (
	^computeMirrorGroup: [:r | r nestedClasses]
)
public simpleName ^<Symbol> = (
	^ mixin simpleName
)
public slots ^<MirrorGroup[SlotMirror]> = (
	^computeMirrorGroup: [:r | r slots].
)
public superclass ^<ClassMirror> = (
	reflectee superclass isNil ifTrue: [^nil].
	^ClassMirror reflecting: reflectee superclass
)
) : (
)
class ImmutableMirrorGroupInMixin group: mirrorz in: mixinMirror = ImmutableMirrorGroup group: mirrorz (|
	public enclosingMixin <MixinMirror> = mixinMirror.
	public channelForChanges <Duct> = Duct new.
|channelForChanges beWeak owner: self) (
'private'
private notifyAddedMirror: newMirror = (
	channelForChanges send: (MirrorAddedEvent forNewMirror: newMirror)
)
private notifyRemovedMirror: oldMirror = (
	channelForChanges send: (MirrorRemovedEvent forOldMirror: oldMirror)
)
private notifyReplacedMirror: oldMirror with: newMirror = (
	channelForChanges send: (MirrorReplacedEvent from: oldMirror to: newMirror)
)
'restricted'
updateToContain: actualMirrors <Collection[Mirror]> = (
	

	|
	mirrorNames
	|
	(* 'update' out.
	mirrors out.
	'->' out.
	actualMirrors out. *)

	mirrorNames:: actualMirrors collect: [:newMirror |
		| oldMirror |
		oldMirror:: findMirrorNamed: newMirror simpleName.
		oldMirror == nil ifTrue: [
			mirrors addLast: newMirror.
			notifyAddedMirror: newMirror.
		] ifFalse: [
			oldMirror = newMirror ifTrue: [
				(* Unchanged *)
			] ifFalse: [
				mirrors at: (mirrors indexOf: oldMirror) put: newMirror.
				notifyReplacedMirror: oldMirror with: newMirror.
			]
		].
		newMirror simpleName.
	].

	mirrors copy do: [:oldMirror |
		(mirrorNames includes: oldMirror simpleName) ifFalse: [
			mirrors remove: oldMirror.
			notifyRemovedMirror: oldMirror.
		].
	].
)
) : (
)
class InitializerMethodMirror reflecting: m <MethodReference> = MethodMirror reflecting: m (
(* Initializers are distinnct in Newspeak and therefore require distinct mirrors. 
A mirror on an initilaizer is based upon a method, but in practice the implementation of 
the initializer is often spread across multiple methods.  The exact scheme will vary based
on details of the implementation. The knowledge of these details should be limited to the
compiler and the mirror system.  Indeed, the purpose of this class is to abstract those 
details so that tools like the IDE need not be aware of them.

 *)) (
'as yet unclassified'
public isInitializerMethodMirror ^ <Boolean> = (
	^true
)
public source ^ <String> = (
	^definingMixin declaration header source
)
) : (
)
public class MethodBuilder reflecting: ir in: mb = (|
	public prvtIntermediate <IntermediateMethod> = ir.
	prvtMixinBuilder <MixinBuilder> = mb.
|) (
'as yet unclassified'
public accessModifier ^<Symbol> = (
	^prvtIntermediate accessModifier
)
public category ^<Symbol> = (
	^prvtIntermediate category
)
public category: cat <String | Symbol> = (
	^prvtIntermediate category: cat asSymbol
)
public definingMixin ^<MixinBuilder> = (
	^prvtMixinBuilder
)
public name ^<Symbol> = (
	^prvtIntermediate selector
)
public reflectee ^<CompiledMethod> = (
	#BOGUS yourself.
	(* Poorly defined: If this a new method, the compiled method retrieved from the low level method would not be able to answer with its source.  This is because in Squeak, the compiled method has to ask for it from its class, which will fail if the method is not yet installed. Perhaps it would be better to not give access to this. *)
	(* ^lowLevelMethodMirror compiledMethod *)
	FAIL.
)
public selector ^<Symbol> = (
	^name
)
public simpleName ^<Symbol> = (
	^name
)
public source ^<String> = (
	^prvtIntermediate method 
		ifNil: [prvtIntermediate src]
		ifNotNil: [:it | it getSource]
)
) : (
)
public class MethodMirror mirroring: m <CompiledMethod> = Mirror reflecting: m (
(* A basic mirror for a language level method. *)) (
'as yet unclassified'
public accessModifier ^<Symbol> = (
	#BOGUS yourself.  (* Is the NS3 compiler setting this info?  Not that the VM respects it yet anyway... *)
	reflectee isProtected ifTrue: [^#protected].
	reflectee isPrivate ifTrue: [^#private].
	^#public
)
public category ^<Symbol> = (
	^reflectee methodClass ifNotNil: [:mc| mc organization categoryOfElement: name]
)
public definingMixin ^<MixinMirror> = (
	^MixinMirror reflecting: reflectee methodClass mixin
)
public isExpression ^<Boolean> = (
	^reflectee properties at: #isExpression ifAbsent: [false].
)
public isInitializer ^ <Boolean> = (
	^reflectee properties isNil not and:[reflectee properties at: #isSubinitializer ifAbsent:[false]].
)
public isMethodMirror ^<Boolean> = (
	^true
)
public metadata = (
	^reflectee properties
)
public name ^<Symbol> = (
	^reflectee selector
)
public sendsSelector: sel <Symbol> ^<Boolean> = (
	(* This is incomplete for the quick send selectors. *)
	^reflectee hasLiteral: sel
)
public simpleName = (
	^ name
)
public source ^<String> = (
	| sourceAvailable |
	sourceAvailable:: (reflectee properties includesKey: #source) 
	      or: [(reflectee properties includesKey: #isSubinitializer)
		or: [reflectee isSynthetic not]].
	
	^sourceAvailable ifTrue: [reflectee getSource asString] ifFalse: [nil]
)
) : (
'as yet unclassified'
public reflecting: m <CompiledMethod> = (
	^(m properties isNil not and:[m properties at: #isSubinitializer ifAbsent:[false]])
	   ifTrue:[InitializerMethodMirror reflecting: m]
	   ifFalse:[self mirroring: m]
)
)
class Mirror reflecting: r <Object> = (
(* Top of the Mirror hierarchy. An abstract class. *)|
	public reflectee <Object> = r.
|) (
'as yet unclassified'
public = other = (
	^self class = other class and: [self reflectee == other reflectee]
)
public hash = (
	^ reflectee identityHash
)
public isMirror ^<Boolean> = (
	^true
)
public printOn: stm = (
	stm nextPutAll: class simpleName.
	stm nextPutAll: ' reflecting: '.
	reflectee printOn: stm.
)
) : (
)
class MirrorAddedEvent forNewMirror: m = MirrorEvent (
(* Sent by a mirror group on its channelForUpdates when a new mirror has been added. *)|
	public newMirror = m.
|) (
'as yet unclassified'
isMirrorAddedEvent ^<Boolean> = (
	^true
)
) : (
)
class MirrorEvent = (
(*  *)|
|) (
'testing'
isMirrorEvent ^<Boolean> = (
	^true
)
) : (
)
class MirrorRemovedEvent forOldMirror: m = MirrorEvent (
(* Sent by a mirror group on its channelForUpdates when an existing mirror has been removed. *)|
	public oldMirror = m.
|) (
'as yet unclassified'
isMirrorRemovedEvent ^<Boolean> = (
	^true
)
) : (
)
class MirrorReplacedEvent from: oldM to: newM = MirrorEvent (
(* Sent by a mirror group on its channelForUpdates when an existing mirror has been replaced by a new mirror. *)|
	public oldMirror = oldM.
	public newMirror = newM.
|) (
'as yet unclassified'
isMirrorReplacedEvent ^<Boolean> = (
	^true
)
) : (
)
public class MixinBuilder forClassDeclaration: cbd intermediate: mixinIR = (
(* The mirror builder for mixins.  See MixinMirror. *)|
	public prvtIntermediate <IntermediateMixin> ::= mixinIR.
	public declaration <ClassDeclarationBuilder> = cbd.
	public isMeta <Boolean> = mixinIR isMeta.
	public methods <MutableMethodGroup> = MutableMethodGroup group: (methodsFrom: mixinIR) within: self.
	public nestedClasses <MutableNestedClassGroup> = MutableNestedClassGroup group: (nestedClassesFrom: mixinIR) within: self.
|) (
'accessing'
public canUnderstand: selector <Symbol> ^<Boolean> = (
	
	(* Slot, method, nested class, or factory method *)
	
	(methods includesMirrorNamed: selector) ifTrue: [^true].
	(nestedClasses includesMirrorNamed: selector) ifTrue: [^true].
	(slots includesMirrorNamed: selector) ifTrue: [^true].
	(selector last = ":") ifTrue: [
		#BOGUS. (* Someday immutable slots will be enforced and this won't be quite right *)
		(slots includesMirrorNamed: (selector allButLast: 1)) ifTrue: [^true].
	].
	isMeta ifTrue: [
		declaration header primaryFactory simpleName = selector ifTrue: [^true].
	].
	^false
)
public slots ^ <ImmutableMirrorGroup[SlotMirror]> = (
	| slotMirrors <Collection[SlotMirror]> | 
	slotMirrors:: (prvtIntermediate slots collect:
		[:each <IntermediateSlotDeclaration> |
		SlotDeclarationMirror
			named: each name
			mutable: each isMutable
			accessModifier: each accessModifier])
		reject:
		[:each <SlotDeclarationMirror> | each name includes: "`"].
	^ImmutableMirrorGroup group: slotMirrors
)
'as yet unclassified'
public isMixinMirror ^<Boolean> = (
	^true
)
'private'
public checkNameConflictsForMethod: selector <Symbol> = (
	(nestedClasses includesMirrorNamed: selector)
		ifTrue: [^Error signal: 'Class already has nested class named ', selector].
	(slots includesMirrorNamed: selector)
		ifTrue: [^Error signal: 'Class already has slot named ', selector].
	slots do: [:slot | (slot isMutable and: [(slot name, ':') = selector])
		ifTrue: [^Error signal: 'Class already has mutable slot named ', selector]].
	isMeta ifTrue: [declaration header primaryFactory simpleName = selector 
		ifTrue: [^Error signal: 'Class already has primary factory named ', selector]].
)
public checkNameConflictsForNestedClass: klassName <Symbol> = (
	(methods includesMirrorNamed: klassName)
		ifTrue:[^Error signal: 'Class already has method named ', klassName].
	(slots includesMirrorNamed: klassName)
		ifTrue:[^Error signal: 'Class already has slot named ', klassName]	
)
public checkNameConflictsForSlot: slotName <Symbol> mutable: isMutable <Boolean> = (
	(nestedClasses includesMirrorNamed: slotName) 
		ifTrue:[^Error signal: 'Class already has nested class named ', slotName].		
	(methods includesMirrorNamed: slotName)
		ifTrue:[^Error signal: 'Class already has method named ', slotName].
	(isMutable and: [methods includesMirrorNamed: slotName, ':'])
		ifTrue:[^Error signal: 'Class already has method named ', slotName].
)
methodsFrom: mixinIR <IntermediateMixin> ^<List[MethodBuilder]> = (
	^(mixinIR methods 
		reject: [:m <LowLevelMethodMirror> | m isSynthetic])
			collect: [:m <LowLevelMethodMirror> | MethodBuilder reflecting: m in: self]
)
nestedClassesFrom: mixinIR <IntermediateMixin> ^<List[ClassDeclarationBuilder]> = (
	^mixinIR nestedClasses collect: [:nestedClassIR <IntermediateNestedClass> | | nc nestedMixin |
		
		(* The existingMixin will be nil if this is a new (uninstalled) class declaration. *)
		(* MUST COMPUTE THIS BEFORE CONSTRUCTING! Cannot be filled in after constructing the nested CDB or CDs with more than one level of nested will not be attached to their existing mixin! *)
		declaration reflectee ifNotNil: [:mixin |
			nestedMixin:: mixin nestedMixins at: nestedClassIR qualifiedName.
		].
		
		nc:: (ClassDeclarationBuilder fromIntermediate: nestedClassIR forExistingMixin: nestedMixin).
		nc prvtEnclosingDeclaration: declaration.
		nc
	]
)
public notifyExistingMirrors = (
	isMeta
		ifTrue: [mixinChanged: declaration reflectee classMixin]
		ifFalse: [mixinChanged: declaration reflectee].

	nestedClasses do: [:ea | ea notifyExistingMirrors].
)
) : (
'as yet unclassified'
public reflecting: mxn <Mixin | ClassMixin> ^<MixinBuilder> = (
	^mxn isMeta
		ifTrue: [(ClassDeclarationBuilder reflecting: mxn instanceMixin) classSide]
		ifFalse: [(ClassDeclarationBuilder reflecting: mxn) instanceSide]
)
)
public class MixinMirror reflecting: m <Mixin> = Mirror reflecting: m (
(* A mixin is the difference between a class and its superclass: a set of additional methods, slots and nested class declarations.  Newspeak class declarations define an instance-side mixin and a class-side mixin, and Newspeak classes (other than Top) are all the result of mixin application.

What about mirroring the initializer?

Need to decide who does these things - the class declaration mirror or the mixin mirror. One should delegate to the other. *)|
	slotsLazy
	methodsLazy
	nestedClassesLazy
	accessModifierLazy
|mixinBasedMirrors add: self) (
'accessing'
public applications ^<Set[ClassMirror]> = (

	^reflectee applications collect: [:ea | ClassMirror reflecting: ea]
)
public canUnderstand: selector <Symbol> ^<Boolean> = (
	
	(* Slot, method, nested class, or factory method *)
	
	(methods includesMirrorNamed: selector) ifTrue: [^true].
	(nestedClasses includesMirrorNamed: selector) ifTrue: [^true].
	(slots includesMirrorNamed: selector) ifTrue: [^true].
	(selector last = ":") ifTrue: [
		#BOGUS. (* Someday immutable slots will be enforced and this won't be quite right *)
		(slots includesMirrorNamed: (selector allButLast: 1)) ifTrue: [^true].
	].
	isMeta ifTrue: [
		declaration header primaryFactory simpleName = selector ifTrue: [^true].
	].
	^false
)
declaration ^ <ClassDeclarationMirror> = (
	^ClassDeclarationMirror 
		reflecting: (isMeta ifFalse:[reflectee] ifTrue:[reflectee instanceMixin]) 
)
public isMeta ^ <Boolean> = (
	^self reflectee isMeta
)
public isMixinMirror ^<Boolean> = (
	^true
)
public methods ^ <MirrorGroup[MethodMirror]> = (
	methodsLazy ifNil: [
		methodsLazy:: ImmutableMirrorGroupInMixin group: computeMethods in: self].
	^methodsLazy
)
public name ^ <Symbol> = (
	^reflectee name
)
public nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (
	nestedClassesLazy ifNil: [
		nestedClassesLazy:: ImmutableMirrorGroupInMixin group: computeNestedClasses in: self].
	^nestedClassesLazy
)
public simpleName ^ <Symbol> = (

	^reflectee simpleName
)
public slots ^ <MirrorGroup[SlotMirror]> = (
	slotsLazy ifNil: [
		slotsLazy:: ImmutableMirrorGroupInMixin group: computeSlots in: self].
	^slotsLazy
)
'as yet unclassified'
public = other <Object> ^<Boolean> = (
	^other isMixinMirror and: [reflectee = other reflectee]
)
public accessModifier ^ <Symbol> = (
	accessModifierLazy ifNil: [
		accessModifierLazy:: computeAccessModifiers].
	^ accessModifierLazy
)
public classMixin ^ <MixinMirror> = (
	isMeta 
		ifFalse:[^MixinMirror reflecting: reflectee classMixin]
		ifTrue:[^MixinMirror reflecting: Metaclass mixin].
)
computeAccessModifiers = (
	^ ((ClassDeclarationMirror reflecting: reflectee) accessModifier)
)
computeMethods ^ <Collection[MethodMirror]> = (

	^(reflectee methodDictionary values
		collect: [:each <CompiledMethod> | MethodMirror reflecting: each])
			reject: [:each <MethodMirror> | each reflectee isSynthetic].
)
public initializer ^ <MethodMirror> = (
	| inits |
	inits:: (reflectee methodDictionary values
		select:[:each <CompiledMethod> | each properties isNil not
			and:[each properties at: #isSubinitializer ifAbsent:[false]]])
		collect:[:each <CompiledMethod> | MethodMirror reflecting: each].
	^inits isEmpty ifFalse:[inits first]
)
public qualifiedName ^ <Symbol> = (
	^reflectee qualifiedName
)
'private'
computeNestedClasses ^<Collection[ClassDeclarationMirror]> = (
	| metadata |
	isMeta ifTrue: [^{}].

	^reflectee nestedMixins values 
		collect: [:each | ClassDeclarationMirror reflecting: each]
)
computeSlots ^ <Collection[SlotMirror]> = (

	^(reflectee slots 
		reject: [:iv <{String.Boolean}> | iv first includes: "`"])
			collect: [:iv <{String.Boolean.Symbol}> | SlotDeclarationMirror named: iv first mutable: iv second accessModifier: iv last ].
)
'restricted'
mixinChanged = (
	slotsLazy ifNotNil: [:it | it updateToContain: computeSlots].
	methodsLazy ifNotNil: [:it | it updateToContain: computeMethods].
	nestedClassesLazy ifNotNil: [:it | it updateToContain: computeNestedClasses].
	accessModifierLazy ifNotNil: [:it | accessModifierLazy:: computeAccessModifiers].
)
) : (
)
class MutableMethodGroup group: mirrors within: mb = MutableMirrorGroup group: mirrors within: mb (
(*  *)|
|) (
'accessing'
public addFromSource: s <String> = (
	| 
	result <LowLevelMethodMirror>
	cat
	newM
	|
	result:: compiler
		compileMethodSource: s readStream 
		within: enclosingMixin.
	
	cat:: (findMirrorNamed: result simpleName)
		ifNil: [#'as yet unclassified']
		ifNotNil: [:oldMirror | oldMirror category].
	
	result category: cat.
	(* Category must be set or it will think it's synthetic and lose the source *)
	
	newM:: MethodBuilder reflecting: result in: enclosingMixin.
	addMirror: newM.
	^newM
)
public addMirror: m <MethodBuilder>= (
	
	(* What would it mean if a user of builders called this?  A MethodMirror would need to be converted to a MethodBuilder.  A MethodBuilder that already is a member of another method group may need to be copied. *)
	
	enclosingMixin checkNameConflictsForMethod: m name.
	
	super addMirror: m.
	enclosingMixin prvtIntermediate methods add: m prvtIntermediate.
	^m
)
removeMirror: m = (

	super removeMirror: m.
	enclosingMixin prvtIntermediate methods remove: m prvtIntermediate.
)
'private'
lowLevelMixin = (
	(* Cannot cache from instantiation: might be replaced by editing class header or add/remove nested class. *)	
	^enclosingMixin isMeta
		ifTrue: [enclosingMixin declaration compiledMixinMirror lowLevelMirror classMixin]
		ifFalse: [enclosingMixin declaration compiledMixinMirror lowLevelMirror].
)
) : (
)
class MutableMirrorGroup group: ms within: mb = ImmutableMirrorGroup group: ms (
(* A mirror group for high level mirrors. Takes base level elements as arguments to be added, and supports a notion of ordering, so that source declaration ordering can be preserved.

A MutableMirrorGroup knows about its enclosing mirror, because it supports adding members in source form via the #addFromSource: abstract method, which is specialized by subclasses. The source must be compiled, and that requires the enclosing mirror to provide the necessary surrounding scope.
*)| 
	public enclosingMixin <MixinBuilder> = mb.	(* definingMixin? *)
|) (
'as yet unclassified'
public addAllMirrors: mirrorGroup <MirrorGroup | Collection[Mirror]> = (
	mirrorGroup do: [:each | addMirror: each]
)
public addFromSource: s <String> = (
	self subclassResponsibility
)
public addMirror: m <Mirror>  = (
	mirrors keysAndValuesDo: [:index :mirror | 
		mirror simpleName = m simpleName ifTrue: [^mirrors at: index put: m]].
	^mirrors addLast: m
)
mirrors ^ <MutableHashedMap[Mirror]> = (
(* mirrors is also an outer scope slot; we define this method to ensure we get the inherited one. *)
	^super mirrors
)
public removeAll = (
	mirrors: MutableList new.
)
public removeAllSuchThat: blk = (
	mirrors select: blk thenDo: [ :m <Mirror> | removeMirrorNamed: m name].
)
public removeMirror: m <Mirror> = (
	^mirrors remove: m
)
public removeMirrorNamed: n <Symbol | String> = (
	| m |
	m:: findMirrorNamed: n.
	^m ifNotNil: [removeMirror: m].
)
) : (
)
class MutableNestedClassGroup group: mirrors within: mb = MutableMirrorGroup group: mirrors within: mb (
(*  *)|
|) (
'accessing'
public addFromSource: source <String> ^<ClassDeclarationBuilder> = (
	| result newCDB |
	result:: compiler 
		compileClassSource: source readStream
		within: enclosingMixin.
		
	(* enclosingDeclaration prvtCompiledMixinMirror: compiledResults first. *)
	
	newCDB:: ClassDeclarationBuilder fromIntermediate: result forExistingMixin: nil.
	newCDB prvtEnclosingDeclaration: enclosingMixin declaration.
		
	addMirror: newCDB.
	^newCDB
)
public addMirror: m <ClassDeclarationBuilder> = (

	#BOGUS yourself.
	(* What would it mean if a user of builders called this?  A ClassDeclarationMirror would need to be converted to a ClassDeclarationBuilder.  A ClassDeclarationBuilder that already has an enclosing class different than this group's would need to be deep copied. *)

	enclosingMixin checkNameConflictsForNestedClass: m simpleName.
	super addMirror: m.
	enclosingMixin prvtIntermediate nestedClasses include: m prvtIntermediate.
	^m
)
'as yet unclassified'
removeMirror: victim <ClassDeclarationBuilder> = (
	|
	victimName
	sep
	|
	(* Must patch the enclosing class of the victim *)
	removeSlotAndAccessorOf: victim.
	enclosingMixin prvtIntermediate nestedClasses remove: victim prvtIntermediate.
	
	super removeMirror: victim.
)
removeSlotAndAccessorOf: victim <ClassDeclarationBuilder> = (
	|
	victimName
	sep
	mixinIR
	|
	victimName: victim qualifiedName.
	sep:: Language newspeak3 syntheticNameSeparator.
	mixinIR:: enclosingMixin prvtIntermediate.
	mixinIR methods removeAllSuchThat: [:e | e simpleName = (victimName,sep,'slot')].
	mixinIR methods removeAllSuchThat: [:e | e simpleName =  (victimName,sep,'slot:')].
	mixinIR methods removeAllSuchThat: [:e | e simpleName =  (victim simpleName)].
	mixinIR slots removeAllSuchThat: [:e | e simpleName = (victimName,sep,'slot')].
	
	(* Indices can change if the victim's slot is not the last one *)
	compiler generateSlotAccessorsFor: mixinIR declaration.
)
) : (
)
public class ObjectMirror reflecting: r <Object> = Mirror reflecting: r (
(* A high level mirror on local objects. The API for a Newspeak object mirror is exceedingly simple. One can view or change its reflectee's class; one can send the reflectee a message; one can set the reflectee's slots; and one can request access to the reflectee.  We may later extend this with printing/safe printing, the ability to execute an arbitrary method on the reflectee, or generalized super-object access.

All of this is realized in methods of this class, except reflectee access which is inherited.

Note that there is no need to get slots - we can send a message to do that.  However, for the time being we support that as well, as there is no way to access overridden features.

The differences between #perform: on an object and a mirror are:

1. The mirror can perform private messages.
2. The mirror forces the user to deal with possible failure.
3. The result is also a mirror.

We may choose to refactor the implementation so that all the work is done by a NewspeakObjectMirorUtility. The idea is that in cases where many objects are involved, it is wasteful to allocate a dedicated mirror per object. Instead,  the utility can be shared across all the objects. This works as long as we are prepared to give out a global authority to mirror all objects; if we want fine grain security, we need a capability per object.

Copyright (c) 2009-2010 Gilad Bracha

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ''Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*)) (
'as yet unclassified'
public = other <Object> ^<Boolean> = (
	^self class == other class
		and: [vmmirror is: reflectee identicalTo: other reflectee]
)
public evaluate: expression <String>
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (
	
	(* Evaluate [expression] with the reflectee as the receiver. If [expression] cannot be compiled, activate [compilationErrorHandler] with the exception. If the evaluation of [expression] raises an error, activate [evalErrorHandler] with the error. Otherwise return an ObjectMirror on the result of [expression]. *)
	
	| cls mxn mtdMirror result |
	[cls:: vmmirror classOf: reflectee.
	mxn:: MixinMirror reflecting: cls mixin.
	mtdMirror:: compiler
		compileExpressionSource: expression readStream
		inContext: nil
		inMixin: mxn. 
		
	mtdMirror category: 'DoIts'.
	mtdMirror klass: cls mixin definingClass.
	mtdMirror compiledMethod properties
		at: #source put: expression;
		at: #debugInfo put: mtdMirror debugInfo]
			on: Error
			do: [:e | ^compilationErrorHandler cull: e ].
	
	[result:: vmmirror 
		object: reflectee 
		executeMethod: mtdMirror compiledMethod
		with: {}
		ifFail: [ ^compilationErrorHandler cull: (Error description: 'primitiveExecuteMethod failed') ]]
			on: Error
			do: [:e | ^evalErrorHandler cull: e].

	^ObjectMirror reflecting: result
)
public evaluate: expression <String> 
withBlackMarket: blackMarket <Object> 
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (

	(* Evaluate [expression] with the reflectee as the receiver. Allow [`] as an identifier, bound to [blackMarket]. If [expression] cannot be compiled, activate [compilationErrorHandler] with the exception. If the evaluation of [expression] raises an error, activate [evalErrorHandler] with the error. Otherwise return an ObjectMirror on the result of [expression]. *)
	
	| cls mxn mtdMirror result |
	[cls:: vmmirror classOf: reflectee.
	mxn:: MixinMirror reflecting: cls mixin.
	mtdMirror:: compiler
		compileExpressionSource: expression readStream
		inContext: nil
		inMixin: mxn
		allowBlackMarket: true.
		
	mtdMirror category: 'DoIts'.
	mtdMirror klass: cls mixin definingClass.
	mtdMirror compiledMethod properties
		at: #source put: expression;
		at: #debugInfo put: mtdMirror debugInfo]
			on: Error
			do: [:e | ^compilationErrorHandler cull: e ].
	
	[result:: vmmirror 
		object: reflectee 
		executeMethod: mtdMirror compiledMethod
		with: {blackMarket}
		ifFail: [ ^compilationErrorHandler cull: (Error description: 'primitiveExecuteMethod failed') ]]
			on: Error
			do: [:e | ^evalErrorHandler cull: e].

	^ObjectMirror reflecting: result
)
public getClass ^<ClassMirror>  = (
	^ClassMirror reflecting: (vmmirror classOf: reflectee)
)
public getSlot: slotName <Symbol> ^<ObjectMirror> = (
	^self class reflecting: 
		(vmmirror
			namedSlotOf: reflectee
			at: ((vmmirror classOf: reflectee) instVarIndexFor: slotName)
			ifFail: [halt])
)
public hash ^<Integer> = (
	^self class hash bitXor: (vmmirror identityHashOf: reflectee)
)
public indexedSlotAt: index <Integer> = (
	(* Provisional *)
	^self class reflecting:
		(vmmirror indexedSlotOf: reflectee at: index ifFail: [halt])
)
public indexedSlotAt: index <Integer> put: value <Object> = (
	(* Provisional *)
	vmmirror indexedSlotOf: reflectee at: index put: value ifFail: [halt]
)
public indexedSlotSize ^<Integer> = (
	(* Provisional *)
	^vmmirror indexedSlotsOf: reflectee
)
public perform: selector <Symbol> with: args <Array[Object]> ifFail:  fblk <[:Exception]>  ^ <ObjectMirror> = (
	| result <Object> |
	result:: [reflectee perform: selector withArguments: args] on: Error do: [:ex <Error> | ^fblk value: ex].
	^self class reflecting: result
)
public safePrintOn: stream <WriteStream> = (
	#BOGUS. (* Sending #name is not guarenteed safe. *)
	stream nextPutAll:
		([String streamContents: [:s | reflectee printOn: s]]
			on: Error
			do: ['an instance of ', (vmmirror classOf: reflectee) name])
)
public safePrintString ^<String> = (
	^String streamContents: [:s | safePrintOn: s]
)
public safePrintStringLimitedTo: limit <Integer> ^<String> = (
	#BOGUS. (* Sending #name is not guarenteed safe. *)
	^[reflectee printStringLimitedTo: limit]
		on: Error
		do: ['an instance of ', (vmmirror classOf: reflectee) name]
)
public setClass: newClass <ClassMirror> = (
	vmmirror changeClassOf: reflectee to: newClass reflectee ifFail: [halt].
)
public setSlot: slotName <Symbol> to: obj <Object> = (
	vmmirror
		namedSlotOf: reflectee
		at: ((vmmirror classOf: reflectee) instVarIndexFor: slotName)
		put: obj
		ifFail: [halt]
)
) : (
)
class SlotDeclarationMirror named: n <String> mutable: m <Boolean> accessModifier: am <Symbol> = Mirror reflecting: n (|
	private mutable = m.
	public accessModifier = am.
|) (
'as yet unclassified'
public = other = (
	^super = other and: [self mutable == other mutable] and: [self accessModifier == other accessModifier]
)
public isMutable = (
	(* Used by compiler in scope building *)
	^mutable
)
public name ^ <String> = (
	#BOGUS yourself.
	^reflectee
)
public simpleName = (

	^ name
)
public source = (
	^name
)
) : (
)
'API'
public installAtomically: builders <List[ClassDeclarationBuilder]> 
^<List[ClassMirrorBuilder]> = (
(*	
mirrors:: platform mirrors.

a:: mirrors ClassDeclarationBuilder reflecting: A mixin.
b:: mirrors ClassDeclarationBuilder reflecting: B mixin.

a headerFromSource: 'A = (|  aa bb |)'.
b headerFromSource: 'B = (| cc dd |)'.

mirrors installAtomically: {a. b}
*)

	| 
	topmostBuilders <List[CDB]> = builders collect: [:ea | ea ultimateInstallee].
	reps <List[IntermediateClassDeclaration]>
	existingMixinMap <IdentityMap[MixinRep,InstanceMixin]> = IdentityDictionary new.
	mixinResults <List[InstanceMixin]>
	|
	
	#BOGUS. (* We should check that the set of builders is disjoint *)
	
	(* Have builders construct their new IntermediateClassDeclaration and fill in existing mixins *)
	reps:: topmostBuilders collect: [:b | b collectExistingMixinsInto: existingMixinMap].

	(* Submit to atomic install *)
	mixinResults:: atomicInstaller install: reps withExistingMixins: existingMixinMap.
	
	(* Fill-in reflectees, important for builders that were created from source *)
	topmostBuilders with: mixinResults do: 
		[:builder :newMixin |	builder extractReflecteeFrom: newMixin].

	(* Notify those listening on the mirrors' Ducts (the IDE) *)
	topmostBuilders do: [:b | b notifyExistingMirrors]. 
	
	#BOGUS yourself.
	(* Notify those listening for Squeak change notifications (VCS image source mirror cache) *)
	mixinResults do: [:mixin |
		SystemChangeNotifier uniqueInstance
			classDefinitionChangedFrom: mixin definingClass
			to: mixin definingClass].
	
	^builders collect: [:b | ClassDeclarationMirror reflecting: b reflectee]
)
'as yet unclassified'
compiler ^ <Newspeak3Compilation Compiler> = (
	storedCompiler ifNil: [storedCompiler:: compilation Compiler new].
	^storedCompiler
)
fullyQualifiedNameToSimple: name = (
	^(name subStrings: {"`"}) last asSymbol
)
mixinChanged: mixin = (
	mixinBasedMirrors do: [:mirror | 
		mirror reflectee = mixin ifTrue: [mirror mixinChanged]].
)
'construct-intermediate'
buildIntermediate: i <IntermediateMixin> from: mixin <AbstractMixin> = (
	
	mixin methodDictionary keysAndValuesDo: 
		[:selector :method |
		|
		imethod = intermediates IntermediateMethod new.
		category = mixin organization categoryOfElement: selector.
		|
		imethod method: method. 
		imethod klass: mixin.
		imethod selector: selector.
		imethod accessModifier: method accessModifier.
		imethod isSynthetic: category isNil.
		imethod category: category.
		imethod isSynthetic ifTrue: 
			[imethod isNestedClassAccessor: (isNestedClassAccessorSelector: selector forMixin: mixin).
			imethod isConstructor: (isConstructorSelector: selector forMixin: mixin)].
		i methods add: imethod].
	
	mixin isMeta ifTrue: [^self].
	
	mixin slots do:
		[:tuple |
		| slot = intermediates IntermediateSlotDeclaration new. |
		slot name: (tuple at: 1).
		slot isMutable: (tuple at: 2).
		slot accessModifier: (tuple at: 3).
		i slots add: slot.].
	
	mixin nestedMixins valuesDo:
		[:nestedMixin <InstanceMixin> |
		i nestedClasses add: (buildIntermediateFor: nestedMixin)].
)
buildIntermediateFor: mixin <InstanceMixin> ^<IntermediateClassDeclaration> = (
	| i = intermediates IntermediateClassDeclaration new. |
	i simpleName: mixin simpleName.
	i qualifiedName: mixin name.
	i headerSource: mixin cachedHeaderSource.
	i factoryName: mixin cachedConstructorName.
	i comment: nil.
	i category: mixin category.
	buildIntermediate: i instanceSide from: mixin.
	buildIntermediate: i classSide from: mixin classMixin.
	^i
)
isConstructorSelector: selector forMixin: mixin <AbstractMixin> = (
	mixin isMeta ifFalse: [^false].
	^mixin instanceMixin cachedConstructorName = selector
)
isNestedClassAccessorSelector: selector forMixin: mixin <AbstractMixin> = (
	mixin isMeta ifTrue: [^false].
	#BOGUS. (* Consult namer *)
	(selector endsWith: '`slot') ifTrue: [^true].
	^mixin nestedMixins includesKey: (mixin name, '`', selector)
)
) : (
)
