Newspeak3
'OrthogonalSynchronization'
class Versioning usingPlatform: platform clientModule: aClientModule clientServerModule: aClientServerModule= (
|
	List = platform collections List.
	Map = platform collections Map.
	Set = platform collections Set.
	clientModule = aClientModule.
	clientServerModule = aClientServerModule.
	
|
) (
class CompoundVersionId principal: aPrincipalId version: aVersionId  = (
|
	principalId = aPrincipalId.
	versionId = aVersionId.
|
) (
) : (
)
public class DefinitionsToObjectVersionsMaterializer objectStore: aStore = ObjectsMaterializer objectStore: aStore (
|

|
) (
createInstanceFrom:   definitionWithId  = (
	| initialVersion  newVersion definition |
	
	initialVersion:: InitialVersion id: objectStore newGuid.

	definition:: definitionWithId definition.
	
	newVersion::  ObjectVersion withParent: initialVersion versionedData: nil.
	

(* 	definition enclosingObjectReference: (definition enclosingObjectReference asGlobalReferenceUsing: objectStore).  *)

	^ newVersion


)
fillNewInstance: anInstance fromDefinition: aDefinition = (

	anInstance versionedData: (aDefinition  asGlobalReferenceUsing: objectStore).
	
)
) : (
)
class IdGenerator seed: aSeed nextIdBlock: aBlock = (
|
	lastValue ::= aSeed.
	nextIdBlock = aBlock.
|
) (
public newId = (
	lastValue::  nextIdBlock value: lastValue.
	^ lastValue.
)
) : (
)
class InitialVersion id:  anId    = (
|
	
	public versionId = 0.
	public principalId	= anId.
	idGenerator = IdGenerator seed: 0 nextIdBlock: [:x | x + 1].
	public childVersions = List new.

 |
) (
public generateNextVersionId  = (
	^ idGenerator newId.
)
public hasChildVersionWithId: anId = (
	^ childVersions anySatisfy: [:x | x versionId = anId] 
)
public initialVersion  = (
	^ self.
)
public registerChild: aVersion = (
	childVersions add: aVersion.
)
public versionsUpTo: anotherVersion = (
	^ (self = anotherVersion) 
					ifTrue: [ { self } ]
					ifFalse: [  error  ]  

)
) : (
)
class ObjectVersion withParent: aParent versionedData: dataToVersion  = Version withParent: aParent (
|
	public versionedData ::= dataToVersion.
|
) (
) : (
)
class Store name: aName identifiedBy: anId  = (
|
	public name = aName.
	initialVersion = InitialVersion id: anId.
	versionsById = Map new.
	objectsIdGenerator =  IdGenerator seed: 0 nextIdBlock: [:x | x + 1].
	public anchorVersionId
|
	registerVersion: initialVersion.
	defineAsAnchor: initialVersion.
) (
anchorVersion  = (
	^  versionIdentifiedBy: anchorVersionId.
)
computeChangesFrom: startVersion to: endVersion mappingLocalsWith: localToGlobalIds  = (

	| versionsToConsider changeRecords newObjectDefinitions |
	
	 versionsToConsider:: (endVersion versionsUpTo: startVersion) allButFirst.

	changeRecords:: List new.
	newObjectDefinitions:: List new.
		
	versionsToConsider do: [ :eachStoreVersion |
		
		eachStoreVersion newVersionsDo: [ :eachVersion |
		
		| data |
	
		data:: eachVersion  versionedData.
		
		(data isKindOfObjectChangeRecord)  
			ifTrue: [ changeRecords add: data ].
			
		(data isKindOfObjectDefinition)  
			ifTrue: [ newObjectDefinitions add: (clientServerModule ObjectDefinitionWithIdentification 
													id: eachVersion principalId 
													definition: data)  
				
		].
	].
			
		
		
		
	].	



	^ServerToClientChangeLog mappingIdsWith: localToGlobalIds changeRecords: changeRecords  newObjects: newObjectDefinitions versionId: anchorVersionId.  



)
createClientUpdaterFor: aStoreVersion = (
	^ ClientUpdater materializingObjectsWith: [ :aStore |  DefinitionsToObjectVersionsMaterializer objectStore: aStore  ] forContext: aStoreVersion endPoint: self.
)
public createNewInitialObjectVersion = (
	 ^ InitialVersion id: generateNextGuid.
)
public defineAsAnchor: aVersion = (
	anchorVersionId:: aVersion versionId.
)
public generateNextGuid = (
	^ objectsIdGenerator newId.
)
public id = (
	^ initialVersion principalId.
)
public initialVersionId = (
	^ initialVersion versionId.
)
public isVersion: aVersionId childOf: aParentVersionId   = (
	^ (versionIdentifiedBy: aVersionId)  parentVersionId  =  aParentVersionId.
)
public isVersion: aParentVersionId parentOf: aVersionId   = (
	^ (versionIdentifiedBy: aParentVersionId) hasChildVersionWithId:  aVersionId.
)
public newVersionFromAnchor = (
	| newVersion |
	newVersion:: StoreVersion withParent: anchorVersion newVersions: {} deletedIds: {}.
	registerVersion: newVersion.
	
	^ newVersion
)
public register: changeLog asChildOfVersionIdentifiedBy: anId  = (
	| parentVersion newVersion |
	parentVersion:: versionIdentifiedBy: anId.
	
	newVersion:: StoreVersion withParent: parentVersion  newVersions: {}  deletedIds: {}.
	registerVersion: newVersion.
	^ newVersion versionId.
)
registerNewVersionFrom: aChangeLogFromClient 	ifNewVersionCreated:  newVersionCreatedBlock ifNone: noneBlock = (
	| previousClientVersion |
	
	previousClientVersion:: versionIdentifiedBy: aChangeLogFromClient versionId.	
	
	aChangeLogFromClient hasNoChanges 
							ifTrue: [ noneBlock value: previousClientVersion ] 
							ifFalse: [
									| newStoreVersion updater localToGlobalIds  |
									newStoreVersion:: StoreVersion withParent: anchorVersion  newVersions: {} deletedIds: {}.
									registerVersion: newStoreVersion.
									updater:: createClientUpdaterFor: newStoreVersion. 
									localToGlobalIds::  updater updateServerFrom: aChangeLogFromClient.
									newVersionCreatedBlock value: newStoreVersion value: localToGlobalIds.
								].

)
registerVersion: aVersion  = (
	versionsById at: aVersion versionId  put: aVersion.
)
public synchronizeWith: aChangeLogFromClient = (
	|  newClientVersion updater localToGlobalIds  |

	localToGlobalIds:: Map new.
	
	registerNewVersionFrom: aChangeLogFromClient 
					ifNewVersionCreated: [ :newVersion :localToGlobalMap | 
							localToGlobalIds:: localToGlobalMap.
							newClientVersion:: newVersion.

							(anchorVersion  isParentOf: newVersion)  
								ifTrue: [
									defineAsAnchor: newVersion.
									]
								ifFalse: [
										| mergedVersion |
										mergedVersion:: merge: anchorVersion with: newVersion.
										defineAsAnchor: mergedVersion. 
										 ].
						
						 ] 
					ifNone: [ :v | newClientVersion:: v. ].
						

 	^ computeChangesFrom: newClientVersion to: anchorVersion mappingLocalsWith: localToGlobalIds.  

)
public versionIdentifiedBy: aVersionId   = (
	^ versionsById at: aVersionId.
	
)
) : (
)
class StoreVersion withParent: aParent newVersions: aVersionsCollection deletedIds: deletedIds = Version withParent: aParent (
|
	newVersionsById = Map new.
	deletedVersionIds = Set withAll: deletedIds.
|
	initializeVersionsMapFrom: aVersionsCollection. 
) (
public addObjectVersion: aVersion   = (
	newVersionsById at: aVersion principalId put: aVersion.
)
public addObjectVersionWithParent: aParentVersion versionedData: dataToVersion = (
	| newVersion |
	 newVersion:: ObjectVersion withParent: aParentVersion versionedData: dataToVersion.
	addObjectVersion: newVersion.
	^ newVersion
)
initializeVersionsMapFrom: aVersionsCollection = (
	newVersionsById = Map new.
	aVersionsCollection do: [ :each |  addObjectVersion: each ]
	
)
public newVersionsDo: aBlock = (
	^ newVersionsById values do: aBlock.
)
public versionById: anId = (
	^ newVersionsById at: anId ifAbsent: [ parentVersion versionById: anId ].
)
) : (
)
class Version withParent: aParent  = (
|
	public versionId = aParent initialVersion generateNextVersionId.
	public parentVersion = aParent.
	childVersions = List new.
|
	aParent registerChild: self.
) (
public createChildVersionIn: aUnitOfWork  = (
	error.
)
public hasChildVersionWithId: anId = (
	^ childVersions anySatisfy: [:x | x versionId = anId] 
)
public initialVersion = (
	^ parentVersion initialVersion.
)
public isParentOf: aVersion  = (
	^ hasChildVersionWithId: aVersion versionId.
)
public parentVersionId  = (
	^ parentVersion versionId
)
public principalId = (
	^ parentVersion principalId.
)
public printOn: aStream = (
	aStream nextPutAll: ' Version: '.
	aStream print: uniqueId.
	aStream nextPutAll: ' for: '.
	aStream print: versionType.
)
public registerChild: aVersion = (
	childVersions add: aVersion.
)
public uniqueId = (
	^ CompoundVersionId principal: parentVersion principalId versionId: versionId.
)
public versionType = (
	^ initialVersion versionType.
)
public versionsUpTo: anotherVersion = (
	^ (self = anotherVersion) 
					ifTrue: [ { self } ]
					ifFalse: [   (parentVersion versionsUpTo: anotherVersion) , { self }  ]  

)
) : (
)
public class VersionsServer = (
|

	storesById = Map new.
	idGenerator = IdGenerator seed: 0 nextIdBlock: [:x | x + 1]. 
|
) (
public containsStoreNamed: aName  = (
	^ storesById values anySatisfy: [:each | each name = aName].
)
public createStoreNamed: aName  = (
	| newStore |
	newStore:: Store name: aName identifiedBy: idGenerator newId. 
	storesById at: newStore id put: newStore. 
	^ newStore.
)
public storeIdentifiedBy: anId  = (
	^ storesById at: anId.
)
public storesCount  = (
	^ storesById size.
)
) : (
)
ClientUpdater = (
	^ clientModule ClientUpdater
)
ObjectsMaterializer = (
	^ clientModule ObjectsMaterializer
)
ServerToClientChangeLog = (
	^ clientServerModule ServerToClientChangeLog
)
) : (
)
