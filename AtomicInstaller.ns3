Newspeak3
'Mirrors'
class AtomicInstaller usingPlatform: p <Platform> vmMirror: vmm <VMMirror> = (
(* This handles adding, removing and modifying stuff. 

What remains unaddressed is changing classes of individual objects, and changing superclasses of individual classes. These can of course be handled elsewhere, but not as part of a broader atomic transaction as is done here. The API of this class should be extended to deal with these requirements.

The process of an atomic install is as follows:

We construct a map, upodateMap, of old objects to revised objects. Eventually, we will do a one way become: of 
the old objects into the new ones. The map is populated with mixins, classes and instances that need to be modified
as keys, and their revised version as values.

The input consists of a tuple of IntermediateClassDeclarations, and a map, existingMixinMap, associating each IntermediateClassDeclaration with its corresponding existing mixin (if it has one). Each element in the tuple describes an ''outermost'' mixin and its nested mixins. By ''outermost mixin'' we mean a mixin that is not nested within any other mixin being processed at this time. It could be a top level mixin, but it could also be a nested mixin provided its enclosing mixins are not subject to change.

We distinguish between new and existing mixins. We use the map in order to do this.  This is essential, since we cannot assume a global namespace in which to look up mixins to see if they exist or not. 

New mixins are simply created per their description, recursively including their nested mixins. These new mixins are gathered in the results list returned by the nsyallation process (#install:withExistingMixins:), as are the mixins created to replace existing ones (described below).

For each existing top level mixin, we add any nested mixins that correspond to nested mixins of the revised mixin to existingMixinMap in #augmentExistingMixinMap:withNestedClasses:inExistingMixin: recursively, before any other processing. We then process each top level mixin in order.

If the mixin described by the IntermediateClassDeclaration exists, we store the existing mixin as a key in updateMap, and create a new one per the description, stored as the corresponding value in updateMap.  

For each existing mixin, we also go through all its invocations. 
 We  collect the invocation and all its subclasses in a map called existingClasses, which maps  depth in the inheritance hierarchy to sets of existing classes classes at that depth. This gives us the set of existing classes that will require modification - either because their mixin has changed, or their superclass has changed. The data structure allows us to easily traverse the set of existing classes in order, base classes first.

We then recursively process the nested mixins of each mixin being processed. 

Next, we go through the existing classes. For each class we produce a new class which we store in updateMap, keyed by the old class.  It is important not to use the class name as a key, as we cannot assume a global namespace in Newspeak.
The new class may differ in its own structure (because its mixin differs) or only in having a revised superclass,
or both. 

Because we traverse the classes in increasing depth order we are assured that a class' superclass has either already been processed, and can be looked up in  updateMap, or it has not changed. This is essential, because the new class points at its up-to-date superclass and uses data derived from it.

If the layout of a class has changed, we also process all its instances. For each existing instance of an old class whose shape has changed, we create an instance of the new class, taking care to copy the data of fields shared between the old and new classes from the old instance to the new one. Each such processed object is placed as a key in updateMap, with the new version as the corresponding value.

At this point, we can do the one way become:  and the installation is complete.

(Somewhat out of date: 
One concern is the involvement of this class with metadata issues such as the class organization. For new code,  AtomicInstaller produces an organization based on the information available in the mirrors provided.  For existing ones it copies the information that was already in place.  

Now it seems that, ideally, a higher level layer should be dealing with this kind of metadata and AtomicInstaller should be completely oblivious to it.  Alas, it isn't quite so simple.

The installer processes classes whose mixin has not been modified, it is important that it clones them in their entirety so that their organization does not get lost.  Higher level layers aren't in a good position to deal with these classes without replicating much of the installer's work.  

Likewise, high level layers aren't really well situated to track down mixin applications of mixins that have been modified.  They only deal with the mixins themselves. However, the organization of a mixin invocation is a special object that actually bases its definitions on the organization of the defining class. So copying these is ok as well.

In principle, metadata should be kept at the mixin level, and individual classes should just refer to their mixin for it. In that case, higher level mirrors could deal with the metadata, and the installer would not have to do anything at all about it  - neither for new or old code.
In that scenario, even if a class has unique metadata, then it would only change of the class itself were changed individually (which amounts to changing its superclass) and then the higher layers would know about it and deal with it.

Until that happy day, it looks like the installer has no choice but to take care of this. That is why low level squeak mirrors carry metadata such as category information with them, making it available to the installer. 

What could be improved is the handling of new mixins. Higher level mirrors could take care of setting up the organization of these.  This is part of the pending overall mirror reform.  Then we could take #setOrganizationOfClass;BasedOn: out of AtomicInstaller, along with the import of ClassOrganizer.
)
 
With the new mixin and class resentation (Kernel`Mixin and Class), Newspeak classes now delegate their category and organization to the mixin.


( * :bug: Rename doesn't propagate down.
AA -> BB
but 
AA`Nested stays AA`Nested should be BB`Nested* )

Copyright (c) 2009-2010 Gilad Bracha
Copyright (c) 2011-2015 Ryan Macnak

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ''Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*)|
private IdentityMap = p squeak IdentityDictionary.
private IdentitySet = p squeak IdentitySet.
private InstanceMixin = p kernel InstanceMixin.
private ClassMixin = p kernel ClassMixin.
private MethodDictionary = p squeak MethodDictionary.
private ClassOrganizer = p squeak ClassOrganizer.

private vmmirror = vmm.

private updateMap <IdentityMap[OldObject,NewObject]>
private existingClasses <IdentityMap[HierarchyDepth,Set[Class]]>
private hadLayoutChange <Boolean>
|) (
'private'
private augmentExistingMixinMap: map withNestedClasses: nestedClasses inExistingMixin: mixin  = (
	nestedClasses do:
		[:nestedClass <IntermediateClassDeclaration> |
		| name existingNestedMixin |
		name:: nestedClass qualifiedName.
		existingNestedMixin:: mixin nestedMixins at: name ifAbsent: [nil].
		existingNestedMixin notNil ifTrue:
			[map at: nestedClass put: existingNestedMixin.
			augmentExistingMixinMap: map
				withNestedClasses: nestedClass instanceSide nestedClasses
				inExistingMixin: existingNestedMixin]]
)
private cleanup = (
	updateMap: nil.
	existingClasses: nil
)
private installAll = (

	| oldObjects newObjects i |	
	oldObjects:: Array new: updateMap size.
	newObjects:: Array new: updateMap size.
	i: 1.

	updateMap keysAndValuesDo: [:oldObj :newObj |
		oldObjects at: i put: oldObj.
		newObjects at: i put: newObj.
		i: i + 1.
	].

	oldObjects elementsForwardIdentityToEvenIfImmutable: newObjects.
	
	(* As of 2673, the VM ensures objects whose references are deleted in a one-way become cannot be resurrected by allInstances/allObjects.
	hadLayoutChange ifTrue: [vmmirror fullGC]. (* Ensure that objects newly made unreachable by the one-way become will not be enumerated by future uses of someInstance/nextInstance. See discussion of issue #82 and comments in ClassBuilder update:to:. *) *)
)
private setup = (
	updateMap: IdentityMap new.
	existingClasses: IdentityMap new.
	hadLayoutChange: false.
)
'private-classes'
private depthFor: klassArg <Class> ^<Integer> = (
	| klass d |
	d: 0.
	klass: klassArg.
	[klass isNil] whileFalse: [klass: klass superclass. d: d+1].
	^d
)
private layoutHasChangedBetween: oldClass <Behavior> and: newClass <Behavior> ^<Boolean> = (
	^oldClass allInstVarNames ~= newClass allInstVarNames
)
private newClassFor: oldClass <Class> ^<Class> = (
	
	| newSuperclass newMixin newClass |

	newSuperclass:: updateMap at: oldClass superclass ifAbsent: [oldClass superclass].
	newMixin:: updateMap at: oldClass mixin ifAbsent: [oldClass mixin].

#BOGUS yourself. (* Name not quite right.  Should reflect new name, but should keep the same form as the old name if it's like This`9087#450 *)
	newClass:: newMixin apply: newSuperclass withName: newMixin simpleName.
	newClass setEnclosingObjectSlot: oldClass enclosingObjectSlot.
	(* organization and category: they live in the mixin *)

	^newClass
)
private processExistingClass: oldClass <Class> = (
	| newClass <Class> |
	newClass:: newClassFor: oldClass.
	
	updateMap at: oldClass put: newClass.
	updateMap at: (vmmirror classOf: oldClass) put: (vmmirror classOf: newClass).
		
	(layoutHasChangedBetween: oldClass and: newClass) 
		ifTrue: [processInstancesOf: oldClass withNewClass: newClass]
)
private processExistingClasses = (
	(* Process superclasses before subclasses *)
	existingClasses keys asSortedCollection do:
		[:inheritanceDepth <Integer> |
		(existingClasses at: inheritanceDepth) do:
			[:c <Class> | processExistingClass: c]].
)
private sortClass: app <Class> = (
	| classes depth |
	depth:: depthFor: app.
	classes:: existingClasses at: depth ifAbsentPut: [IdentitySet new].
	classes add: app.
	app subclassesDo: [:sc | sortClass: sc].
)
'private-instances'
private processInstancesOf: oldClass <Class> withNewClass: newClass <Class> = (

	| oldInstVarNames newInstVarNames sharedInstVarNames |
	
	hadLayoutChange: true.
	
	oldInstVarNames:: oldClass allInstVarNames.
	newInstVarNames:: newClass allInstVarNames.
	
	sharedInstVarNames:: oldInstVarNames
		select: [:n <String> | newInstVarNames includes: n ].
	(* find intersection of slots names between oldObj and newObj *)

	oldClass allInstancesDo: [:oldObj | | newObj |
		
		newObj:: newClass basicNew.
		
		(* copy state from oldObj to newObj *)
		
		sharedInstVarNames do: [:n <String> | 
			| oldIndex newIndex val |
			oldIndex:: oldInstVarNames lastIndexOf: n.
			newIndex:: newInstVarNames lastIndexOf: n.
			val:: vmmirror namedSlotOf: oldObj at: oldIndex ifFail: [self halt].
			vmmirror namedSlotOf: newObj at: newIndex put: val ifFail: [self halt].
		]. 

		updateMap at: oldObj put: newObj.
	].
)
'private-mixins'
private methodDictionaryFor: mixin <AbstractMixin> from: imixin <IntermediateMixin> ^<MethodDictionary> = (
	| mdict = MethodDictionary new: imixin methods size. |
	imixin methods do:
		[:imethod <IntermediateMethod> | 
		imethod klass: mixin.  
		mdict at: imethod selector put: imethod compiledMethod].
	^mdict
)
private noteUpdateOf: existingMixin <InstanceMixin | nil> to: newMixin <InstanceMixin> = (
	
	existingMixin isNil ifTrue: [^self].
	
	updateMap at: existingMixin put: newMixin.
	updateMap at: existingMixin classMixin put: newMixin classMixin.
	
	existingMixin applications do: [:app | sortClass: app].
)
private processClassDeclaration: classDecl <IntermediateClassDeclaration>
 in: existingMixinMap <IdentityMap[IntermediateClassDeclaration, InstanceMixin]>
 ^<InstanceMixin> = (
	
	|
	mixin <Mixin>
	classMixin <ClassMixin>
	existingMixin <Mixin>
	|

	mixin:: InstanceMixin new.
	classMixin:: ClassMixin new.
	
	mixin cachedHeaderSource: classDecl headerSource.
	mixin cachedConstructorName: classDecl factoryName.
	assert: [classDecl factoryName notNil] message: 'Missing factory name'.
	mixin category: classDecl category.
	mixin name: classDecl qualifiedName.
	mixin classMixin: classMixin.
	mixin methodDictionary: (methodDictionaryFor: mixin from: classDecl instanceSide).
	mixin slots: (classDecl instanceSide slots collect:
		[:s <IntermediateSlotDeclaration> | {s simpleName. s isMutable. s accessModifier}]) asArray.
	
	classMixin instanceMixin: mixin.
	classMixin methodDictionary: (methodDictionaryFor: classMixin from: classDecl classSide).

	setOrganizationFor: mixin basedOn: classDecl instanceSide.
	setOrganizationFor: classMixin basedOn: classDecl classSide.
	
	existingMixin:: existingMixinMap at: classDecl ifAbsent: nil.
	noteUpdateOf: existingMixin to: mixin.
	
	existingMixin == nil ifFalse: [
		(* If this is the top-most thing changed in this installation and not a top level class, the enclosingMixin won't otherwise be set and would incorrectly end up nil. *)
		mixin enclosingMixin: existingMixin enclosingMixin.
		mixin classMixin enclosingMixin: existingMixin enclosingMixin].
	
	classDecl instanceSide nestedClasses do:
		[:nestedClassDecl <IntermediateClassDeclaration> |
		| nestedMixin <InstanceMixin> |
		nestedMixin:: processClassDeclaration: nestedClassDecl in: existingMixinMap.
		mixin nestedMixins at: nestedMixin name put: nestedMixin.
		nestedMixin enclosingMixin: mixin.
		nestedMixin classMixin enclosingMixin: mixin].
	
	^mixin
)
private setOrganizationFor: mixin <AbstractMixin> basedOn: intermediate <IntermediateMixin> = (
	| org = ClassOrganizer defaultList: {}. |
	intermediate methods do:
		[:imethod <IntermediateMethod> |
		imethod isSynthetic ifFalse: 
			[assert: [imethod category notNil] message: 'Missing category'. 
			org classify: imethod selector under: imethod category.]].
	mixin organization: org.
)
'public access'
public install: intermediates <List[IntermediateClassDeclaration]>
 withExistingMixins: existingMixinMap <Map[IntermediateClassDeclaration, InstanceMixin]> = (
	
	| results |
	setup.
	results:: intermediates collect: 
		[:classDecl <IntermediateClassDeclaration> |
		(existingMixinMap includesKey: classDecl) ifTrue:
			[augmentExistingMixinMap: existingMixinMap
				withNestedClasses: classDecl instanceSide nestedClasses
				inExistingMixin: (existingMixinMap at: classDecl)].
		processClassDeclaration: classDecl in: existingMixinMap].
	processExistingClasses.
	installAll.
	vmmirror flushCache. (* Clear all lookup caches *)
	cleanup.

	^results (* <List[InstanceMixin]> *)
)
) : (
)
