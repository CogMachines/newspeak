Newspeak3
'Mirrors'
class AtomicInstaller usingPlatform: p <Platform> vmMirror: vmm <VMMirror> = (
(* This handles adding, removing and modifying stuff. 

What remains unaddressed is changing classes of individual objects, and changing superclasses of individual classes. These can of course be handled elsewhere, but not as part of a broader atomic transaction as is done here. The API of this class should be extended to deal with these requirements.

The process of an atomic install is as follows:

We construct a list of old objects, and another of revised objects.  These two lists parallel each other: the i'th element of the revised object list is the revised version of the i'th element in the old objects list. Eventually, we will do a one way become: of the old objects into the new ones.
The list is populated with mixins, classes and instances that need to be modified.

The input consists of a tuple of MixinReps, and a map containing associating each MixinRep with its corresponding existing mixin (if it has one). Each element in the tuple describes an ''outermost'' mixin and its nested mixins. By ''outermost mixin'' we mean a mixin that is not nested within any other mixin being processed at this time. It could be a top level mixin, but it could also be a nested mixin provided its enclosing mixins are not subject to change.

(Optimization note: Ryan plans to allow the elements to be optionally be Mixins, so that if a some mixin is changed, we need not wastefully generate a MixinRep for all its nested mixins in the mirrors and then rebuild Mixins from the rep here.)

We distinguish between new and existing mixins. We use the map in order to do this.  This is essential, since we cannot assume a global namespace in which to look up mixins to see if they exist or not. 

New mixins are simply created per their description, recursively including their nested mixins. These new mixins are gathered in the newMixins array.

If the mixin described by the MixinRep exists, we store the existing mixin in the old object array, and create a new one per the description. The new mixin is then placed in the revised objects array.  

For each existing mixin, we also go through all its invocations. We note that the invocation is associated with a modified mixin by adding an entry to a map, definingMirrors, that maps classes to mirrors that describe their mixin. We also collect the invocation and all its subclasses  These are stored in a map called existingClasses, which maps  depth in the inheritance hierarchy to sets of existing classes classes at that depth. This gives us the set of existing classes that will require modification - either because their mixin has changed, or their superclass has changed. The data structure allows us to easily traverse the set of existing classes in order, base classes first.

We then recursively process the nested mixins of each mixin being processed. Each nested mixin is processed with a namespace consisting of the nested mixins of its enclosing mixin (which allows us again to determine whether a mixin being described is new or pre-existing).

Next, we go through the existing classes. For each class we produce a new class, which we store in a map, newClasses, keyed by the old class.  It is important not to use the class name as a key, as we cannot assume a global namespace in Newspeak.
The new class may differ in its own structure (because its mixin differs) or only in having a revised superclass. 

We also store the old class in the old objects array, and the new class in the revised objects array. Because we traverse the classes in increasing depth order we are assured that a class' superclass has either already been processed, and can be looked up in newClasses, or it has not changed. This is essential, because the new class points at its up-to-date superclass and uses data derived from it.

If the layout of a class has changed, we also process all its instances. For each existing instance of an old class whose shape has changed, we create an instance of the new class, taking care to copy the data of fields shared between the old and new classes from the old instance to the new one. Each such processed object is placed in the old objects array, with the new version in the revised objects array.

At this point, we can do the one way become:  and the installation is complete.

(Somewhat out of date: 
One concern is the involvement of this class with metadata issues such as the class organization. For new code,  AtomicInstaller produces an organization based on the information available in the mirrors provided.  For existing ones it copies the information that was already in place.  

Now it seems that, ideally, a higher level layer should be dealing with this kind of metadata and AtomicInstaller should be completely oblivious to it.  Alas, it isn't quite so simple.

The installer processes classes whose mixin has not been modified, it is important that it clones them in their entirety so that their organization does not get lost.  Higher level layers aren't in a good position to deal with these classes without replicating much of the installer's work.  

Likewise, high level layers aren't really well situated to track down mixin applications of mixins that have been modified.  They only deal with the mixins themselves. However, the organization of a mixin invocation is a special object that actually bases its definitions on the organization of the defining class. So copying these is ok as well.

In principle, metadata should be kept at the mixin level, and individual classes should just refer to their mixin for it. In that case, higher level mirrors could deal with the metadata, and the installer would not have to do anything at all about it  - neither for new or old code.
In that scenario, even if a class has unique metadata, then it would only change of the class itself were changed individually (which amounts to changing its superclass) and then the higher layers would know about it and deal with it.

Until that happy day, it looks like the installer has no choice but to take care of this. That is why low level squeak mirrors carry metadata such as category information with them, making it available to the installer. 

What could be improved is the handling of new mixins. Higher level mirrors could take care of setting up the organization of these.  This is part of the pending overall mirror reform.  Then we could take #setOrganizationOfClass;BasedOn: out of AtomicInstaller, along with the import of ClassOrganizer.
)
 
With the new mixin and class resentation (Kernel`Mixin and Class), Newspeak classes now delegate their category and organization to the mixin.


( * :bug: Rename doesn't propagate down.
AA -> BB
but 
AA`Nested stays AA`Nested should be BB`Nested* )

Copyright (c) 2009-2010 Gilad Bracha
Copyright (c) 2011 Ryan Macnak

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ''Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*)|
private IdentityMap = p blackMarket IdentityDictionary.
private IdentitySet = p blackMarket IdentitySet.
private InstanceMixin = p kernel InstanceMixin.
private ClassMixin = p kernel ClassMixin.
private MethodDictionary = p blackMarket MethodDictionary.
private ClassOrganizer = p blackMarket ClassOrganizer.

private vmmirror = vmm.

private updateMap <IdentityMap[OldObject,NewObject]>
private existingClasses <IdentityMap[HierarchyDepth,Set[Class]]>
private hadLayoutChange <Boolean>
|)
('private'
augmentExistingMixinMap: map withNestedReps: reps inExistingMixin: mixin  = (
	reps do:
		[:eachNestedRep |
		| name existingNestedMixin |
		name:: eachNestedRep first name.
		existingNestedMixin:: mixin nestedMixins at: name ifAbsent: [nil].
		existingNestedMixin notNil ifTrue:
			[map at: eachNestedRep put: existingNestedMixin.
			augmentExistingMixinMap: map
				withNestedReps: eachNestedRep last
				inExistingMixin: existingNestedMixin]]
)
private cleanup = (
	updateMap: nil.
	existingClasses: nil
)
private installAll = (

	| oldObjects newObjects i |	
	oldObjects:: Array new: updateMap size.
	newObjects:: Array new: updateMap size.
	i: 1.

	updateMap keysAndValuesDo: [:oldObj :newObj |
		oldObjects at: i put: oldObj.
		newObjects at: i put: newObj.
		i: i + 1.
	].

	oldObjects elementsForwardIdentityToEvenIfImmutable: newObjects.
	
	(* As of 2673, the VM ensures objects whose references are deleted in a one-way become cannot be resurrected by allInstances/allObjects.
	hadLayoutChange ifTrue: [vmmirror fullGC]. (* Ensure that objects newly made unreachable by the one-way become will not be enumerated by future uses of someInstance/nextInstance. See discussion of issue #82 and comments in ClassBuilder update:to:. *) *)
)
private setup = (
	updateMap: IdentityMap new.
	existingClasses: IdentityMap new.
	hadLayoutChange: false.
)'private-classes'
private depthFor: klassArg <Class> ^<Integer> = (
	| klass d |
	d: 0.
	klass: klassArg.
	[klass isNil] whileFalse: [klass: klass superclass. d: d+1].
	^d
)
private layoutHasChangedBetween: oldClass <Class> and: newClass <Class> ^<Boolean> = (
	^oldClass allInstVarNames ~= newClass allInstVarNames
)
private newClassFor: oldClass <Class> ^<Class> = (
	
	| newSuperclass newMixin newClass |

	newSuperclass:: updateMap at: oldClass superclass ifAbsent: [oldClass superclass].
	newMixin:: updateMap at: oldClass mixin ifAbsent: [oldClass mixin].

#BOGUS yourself. (* Name not quite right.  Should reflect new name, but should keep the same form as the old name if it's like This`9087#450 *)
	newClass:: newMixin apply: newSuperclass withName: newMixin simpleName.
	newClass enclosingObjectSlot: oldClass enclosingObjectSlot.
	newClass class enclosingObjectSlot: oldClass class enclosingObjectSlot.
	(* organization and category: they live in the mixin *)

	^newClass
)
private processExistingClass: oldClass <Class> = (
	| newClass <Class> |
	newClass:: newClassFor: oldClass.
	
	updateMap at: oldClass put: newClass.
	updateMap at: oldClass class put: newClass class.
		
	(layoutHasChangedBetween: oldClass and: newClass) 
		ifTrue:[processInstancesOf: oldClass withNewClass: newClass]
)
private processExistingClasses = (
	(* Process superclasses before subclasses *)
	existingClasses keys asSortedCollection do:[: k <Integer> |
		(existingClasses at: k) do:[:c <Class> | processExistingClass: c]
	].
)
private sortClass: app <Class> = (
	| classes depth |
	depth:: depthFor: app.
	classes:: existingClasses at: depth ifAbsentPut: [IdentitySet new].
	classes add: app.
	app subclassesDo: [:sc | sortClass: sc].
)'private-instances'
private processInstancesOf: oldClass <Class> withNewClass: newClass <Class> = (

	| oldInstVarNames newInstVarNames sharedInstVarNames |
	
	hadLayoutChange: true.
	
	oldInstVarNames:: oldClass allInstVarNames.
	newInstVarNames:: newClass allInstVarNames.
	
	sharedInstVarNames:: oldInstVarNames
		select: [:n <String> | newInstVarNames includes: n ].
	(* find intersection of slots names between oldObj and newObj *)

	oldClass allInstancesDo: [:oldObj | | newObj |
		
		newObj:: newClass basicNew.
		
		(* copy state from oldObj to newObj *)
		
		sharedInstVarNames do: [:n <String> | 
			| oldIndex newIndex val |
			oldIndex:: oldInstVarNames lastIndexOf: n.
			newIndex:: newInstVarNames lastIndexOf: n.
			val:: vmmirror namedSlotOf: oldObj at: oldIndex ifFail: [self halt].
			vmmirror namedSlotOf: newObj at: newIndex put: val ifFail: [self halt].
		]. 

		updateMap at: oldObj put: newObj.
	].
)'private-mixins'
private constructorNameFrom: cmm <CompiledMixinMirror> ^<Symbol> = (
	^(cmm lowLevelMirror classMixin methods mirrors
		detect: [:mirror | mirror isConstructor]
		ifNone: [self halt.^nil (* shouldn't happen but does *)]) simpleName.
)
private methodDictionaryFor: mixin <Mixin> from: m <LowLevelMixinMirror> ^ <MethodDictionary> = (
	| md <MethodDictionary> methods <List[LowLevelMethodMirror]> |
	methods:: m methods collect:[:mtd <LowLevelMethodMirror> | mtd].
	md:: MethodDictionary new: methods size.
	methods do:[:cm <LowLevelMethodMirror> | 
		cm klass: mixin.  
		md at: cm selector put: cm compiledMethod
		].
	^md
)
private noteUpdateOf: existingMixin <InstanceMixin | nil> to: newMixin <InstanceMixin> = (
	
	existingMixin isNil ifTrue: [^self].
	
	updateMap at: existingMixin put: newMixin.
	updateMap at: existingMixin classMixin put: newMixin classMixin.
	
	existingMixin applications do: [:app | sortClass: app].
)
private processRep: rep <MixinRep> in: existingMixinMap <IdentityMap[MixinRep,InstanceMixin]> ^<InstanceMixin> = (
	
	|
	mixin <Mixin>
	classMixin <ClassMixin>
	cmm <CompiledMethodMirror>
	llmm <LowLevelMixinMirror>
	existingMixin <Mixin>
	|
	rep isArray ifFalse: [self halt. ^rep]. (* If a builder includes a Mixin instead of a MixinRep, it means don't delete and don't mutate. *)	

	mixin:: InstanceMixin new.
	classMixin:: ClassMixin new.
	
	cmm:: rep first.
	mixin cachedHeaderSource: cmm header.
	mixin cachedConstructorName: (constructorNameFrom: cmm).
	mixin category: cmm category.
	llmm:: cmm lowLevelMirror.
	
	mixin name: llmm name.
	mixin classMixin: classMixin.
	mixin methodDictionary: (methodDictionaryFor: mixin from: llmm).
	mixin slots: (llmm instVars collect:[:ivm <InstanceVariableMirror> | {ivm name. ivm mutable. ivm accessModifier}]) asArray.
	
	classMixin instanceMixin: mixin.
	classMixin methodDictionary: (methodDictionaryFor: classMixin from: llmm classMixin).

	setOrganizationFor: mixin basedOn: llmm.
	setOrganizationFor: classMixin basedOn: llmm classMixin.
	
	existingMixin:: existingMixinMap at: rep ifAbsent: nil.
	noteUpdateOf: existingMixin to: mixin.
	
	existingMixin == nil ifFalse: [
		(* If this is the top-most thing changed in this installation and not a top level class, the enclosingMixin won't otherwise be set and would incorrectly end up nil. *)
		mixin enclosingMixin: existingMixin enclosingMixin.
		mixin classMixin enclosingMixin: existingMixin enclosingMixin].
	
	rep last do: [:nestedRep <MixinRep> |

		| nestedMixin <Mixin> |
		nestedRep isArray not ifTrue: [
			self halt.
			nestedMixin:: nestedRep.
			mixin nestedMixins at: nestedMixin name put: nestedMixin.
			(* Do not set enclosing mixin here for an existing Mixin: that would be non-atomic! *)
		] ifFalse: [
			nestedMixin:: processRep: nestedRep in: existingMixinMap.
			mixin nestedMixins at: nestedMixin name put: nestedMixin.
			nestedMixin enclosingMixin: mixin.
			nestedMixin classMixin enclosingMixin: mixin.
		].
	].
	
	^mixin
)
private setOrganizationFor: mixin <Mixin|ClassMixin>
basedOn: lm <LowLevelMixinMirror> = (
	| nonSyntheticMethods <LowLevelMethodMirror> |
	nonSyntheticMethods:: (lm methods select: [ :mt | mt isSynthetic not]).
	
	(* manually set organization, excluding synthetic methods *)
	mixin organization: (ClassOrganizer defaultList: (nonSyntheticMethods collect: [:ea | ea selector])).

	(* classify (non-synthetic) elements if mirror includes category information *)
	(nonSyntheticMethods 
		select: [ :um | um metadata includesKey: #category ])
		do: [ :cm | mixin organization
						classify: cm selector
						under: (cm metadata at: #category) ].
)'public access'
public install: reps <List[MixinRep]> withExistingMixins: existingMixinMap <Map[MixinRep,InstanceMixin]> = (
	
	| results |
	setup.
	results:: reps collect: 
		[:rep |
		(existingMixinMap includesKey: rep) ifTrue:
			[augmentExistingMixinMap: existingMixinMap
				withNestedReps: rep last
				inExistingMixin: (existingMixinMap at: rep)].
		processRep: rep in: existingMixinMap].
	processExistingClasses.
	installAll.
	vmmirror flushCache. (* Clear all lookup caches *)
	cleanup.

	^results (* <List[InstanceMixin]> *)
)) : ()