Newspeak3
'Hopscotch-Core'
class HopscotchForHTML5 usingPlatform: p = (|
	private Color = p graphics Color.
	private Context = p graphics Context.
	private Timer = p time Timer.
	private List = p collections OrderedCollection.

	private window = p aliens global.
	private document = window at: 'document'.
	private body = document at: 'body'.
	
	private accept16px = p namespace accept16px.
	private cancel16px = p namespace cancel16px.
	private disclosureClosedImage = p namespace disclosureClosedImage.
	private disclosureTransitionImage = p namespace disclosureTransitionImage.
	private disclosureOpenImage = p namespace disclosureOpenImage.
	
	private deferredContentQueue = List new.
	
	public core = self.
	public fragments = self.
|)
(
class BlankFragment = LeafFragment (|
|)
('as yet unclassified'
createVisual = (
	^document createElement: 'div'
)) : ()
class ButtonFragment label: l action: a = LeafFragment (|
	label = l.
	action = a.
|)
('as yet unclassified'
createVisual = (
	^(document createElement: 'button')
		appendChild: (document createTextNode: label);
		at: 'onclick' put: [action value. false];
		yourself
)) : ()
class CanvasFragment withExtent: e = LeafFragment (|
private alien = document createElement: 'canvas'.
|alien at: 'width' put: e x.
alien at: 'height' put: e y.
(alien at: 'style') at: 'position' put: 'relative')
('as yet unclassified'
context = (
	^Context on: (alien getContext: '2d')
)
createVisual = (
	^alien
)
keyDownAction: onKeyPressed <[:String]> = (
	(* The canvas element itself doesn't seem to get key events. *)
	body
		addEventListener: 'keydown'
		with: [:e | onKeyPressed value: (String fromCharCode: (e at: 'keyCode'))]
)
mouseDownAction: onMouseDown <[:Point]> = (
	alien
		addEventListener: 'mousedown'
		with: [:e | onMouseDown value: (e at: 'offsetX') @ (e at: 'offsetY')].
)
mouseMovedAction: onMouseMoved <[:Point]> = (
	alien
		addEventListener: 'mousemove'
		with: [:e | onMouseMoved value: (e at: 'offsetX') @ (e at: 'offsetY')].
)) : ()
class ColumnComposer definitions: fragments = SequenceComposer definitions: fragments (|
|)
('as yet unclassified'
flexDirection = (
	^'column'
)) : ()
class Composer = Fragment ()
() : ()
class DeferredContentComposer initialContent: ic contentSource: cs = Composer (|
	initialContent <Fragment> = ic.
	contentSource <[Fragment]> = cs.
|)
('as yet unclassified'
createVisual = (
	| div initialVisual |
	div:: document createElement: 'div'.
	initialVisual:: initialContent visual.
	div appendChild: initialVisual.
	deferAction: [
		| deferredVisual = contentSource value visual. |
		(* replace: new with: old due to stupid DOM argument ordering *)
		div replaceChild: deferredVisual with: initialVisual].
	^div
)) : ()
class Fragment = (| visualX size ::= nil. expansibility ::= 0. compressibility ::= 0. |)
('as yet unclassified'
createVisual = (
	subclassResponsibility
)
hasVisual = (
	^visualX isNil not
)
visual = (
	visualX isNil ifTrue: [visualX:: createVisual].
	^visualX
)) : ()
class HolderComposer withContent: definition = Composer (|
	contentSource ::= definition.
	actualContent
|)
('as yet unclassified'
content ^<Fragment> = (
	actualContent isNil ifTrue: [actualContent:: contentSource value].
	^actualContent
)
createVisual = (
	| div |
	div:: document createElement: 'div'.
	div appendChild: content visual.
	^div
)
refresh = (
	(contentSource isBlock and: [hasVisual])
		ifTrue:
			[ | oldContent newContent |
			oldContent:: actualContent.
			actualContent:: nil.
			newContent:: content.
			(* replace: new with: old due to stupid DOM argument ordering *)
			visual replaceChild: newContent visual with: oldContent visual]
		ifFalse:
			[actualContent refresh].
)) : ()
class HopscotchWindow openSubject: s = (|
	public currentPresenter ::= s presenter.

	private alien = document createElement: 'div'.
|body appendChild: alien.
	alien appendChild: currentPresenter visual)
() : ()
class HyperlinkFragment label: l action: a = LeafFragment (|
	label = l.
	action = a.
|)
('as yet unclassified'
createVisual = (
	^(document createElement: 'a') 
		at: 'href' put: '#';
		appendChild: (document createTextNode: label);
		at: 'onclick' put: [action value. false];
		yourself
)) : ()
class LeafFragment = Fragment ()
() : ()
class Presenter onSubject: aSubject = Fragment (|
subject ::= aSubject.
|)
('as yet unclassified'
alert: text = (
	window alert: text
)
button: label <String> action: block <[]>= (
	^ButtonFragment label: label action: block
)
canvas: extent <Point> = (
	^CanvasFragment withExtent: extent
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> ^<Fragment> = (
	^	collapsed: collapsed 
		expanded: expanded
		initiallyExpanded: false
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> initiallyExpanded: flag <Boolean>
^<Fragment> = (
	^ToggleComposer
		collapsedDefinition: collapsed
		expandedDefinition: expanded
		initiallyExpanded: flag
)
column: definitions = (
	^ColumnComposer definitions: definitions
)
createVisual = (
	^definition visual
)
deferred: contentSource <[Fragment]> ^<Fragment> = (
	#BOGUS yourself. (* default initial content should be a blank *)
	^DeferredContentComposer initialContent: (label: '') contentSource: contentSource
)
definition ^<Fragment> = (
	subclassResponsibility
)
filler = (
	^BlankFragment new expansibility: 1; compressibility: 1
)
holder: definition <[Fragment]> = (
	^HolderComposer withContent: definition
)
image: image = (
	^StaticImageFragment image: image
)
initially: initialContent <Fragment> deferred: contentSource <[Fragment]> ^<Fragment> = (
	^DeferredContentComposer initialContent: initialContent contentSource: contentSource
)
label: label <String> = (
	^StaticLabelFragment text: label
)
link: label <String> action: block <[]> = (
	^HyperlinkFragment label: label action: block
)
nothing = (
	^BlankFragment new
)
row: definitions = (
	^RowComposer definitions: definitions
)) : ()
class RowComposer definitions: fragments = SequenceComposer definitions: fragments (|
|)
('as yet unclassified'
flexDirection = (
	^'row'
)) : ()
class SequenceComposer definitions: fragments = Composer (|
	definitions = fragments.
	color
|)
('as yet unclassified'
createVisual = (
	| container |
	container:: document createElement: 'div'.
	(container at: 'style')
		at: 'display' put: '-webkit-flex';
		at: 'display' put: 'flex';
		at: '-webkit-flex-direction' put: flexDirection;
		setProperty: 'flex-direction' to: flexDirection.
	color isNil ifFalse: 
		[(container at: 'style') setProperty: 'background-color' to: color asCSSString].
	definitions do: [:fragment |
		| cell |
		cell:: document createElement: 'div'.
		cell appendChild: fragment visual.
		(cell at: 'style')
			at: '-webkit-flex-grow' put: fragment expansibility;
			setProperty: 'flex-grow' to: fragment expansibility;
			at: '-webkit-flex-shrink' put: fragment compressibility;
			setProperty: 'flex-shrink' to: fragment compressibility.
		container appendChild: cell].
	^container
)) : ()
class StaticImageFragment image: i = LeafFragment (|
	image = i.
|)
('as yet unclassified'
createVisual = (
	^image cloneNode: false (* Not deep *)
)) : ()
class StaticLabelFragment text: t = LeafFragment (|
	text = t.
|)
('as yet unclassified'
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style') 
		at: 'overflow' put: 'hidden';
		setProperty: 'white-space' to: 'nowrap'.
	div appendChild: (document createTextNode: text).
	^div
)) : ()
class Subject onModel: aModel = (|
model ::= aModel.
presenterX
|)
('as yet unclassified'
createPresenter = (
	subclassResponsibility
)
presenter = (
	presenterX isNil ifTrue: [presenterX:: createPresenter].
	^presenterX
)) : ()
class TextEditorFragment = LeafFragment (|
|)
('as yet unclassified'
controlBarColor = (
	^Color r: 0.95 g: 0.792 b: 0.475
)
createVisual = (
	| frame editor editorWrapper counterfactualBar accept cancel |
	frame:: document createElement: 'div'.
	(frame at: 'style')
		at: 'display' put: '-webkit-flex';
		at: 'display' put: 'flex';
		at: 'margin' put: '2px'.
	editor:: document createElement: 'div'.
	editor at: 'contentEditable' put: 'true'.
	(editor at: 'style')
		at: 'borderStyle' put: 'solid';
		at: 'borderWidth' put: '1px';
		at: 'borderColor' put: 'gray';
		setProperty: 'background-color' to: 'white';
		at: 'flex' put: 1;
		at: '-webkit-flex' put: 1;
		at: '-moz-flex' put: 1;
		at: 'display' put: 'block'.
	counterfactualBar:: document createElement: 'span'.
	(counterfactualBar at: 'style')
		at: 'backgroundColor' put: controlBarColor asCSSString;
		at: 'flex' put: 'none';
		at: '-webkit-flex' put: 'none';
		at: '-moz-flex' put: 'none'.
	accept:: document createElement: 'img'.
	accept at: 'src' put: (accept16px yourself at: 'src').
	(accept at: 'style') at: 'margin' put: '3px'.
	accept at: 'onclick' put: [userAccept].
	cancel:: document createElement: 'img'.
	cancel at: 'src' put: (cancel16px yourself at: 'src').
	(cancel at: 'style') at: 'margin' put: '3px'.
	cancel at: 'onclick' put: [userCancel].
	counterfactualBar appendChild: accept.
	counterfactualBar appendChild: cancel.
	frame appendChild: editor.
	frame appendChild: counterfactualBar.
	^frame
)) : ()
class ToggleComposer collapsedDefinition: collapsed
 expandedDefinition: expanded
 initiallyExpanded: flag = Composer (|
expandedDefinition = expanded.
collapsedDefinition = collapsed.
isExpanded ::= flag.
expandedPresenter
collapsedPresenter
contentHolder
toggleWidget
|)
('as yet unclassified'
createVisual = (
	| toggleDiv div |
	contentHolder:: document createElement: 'div'.
	
	toggleDiv:: document createElement: 'div'.
	toggleWidget:: document createElement: 'img'.
	toggleWidget at: 'onclick' put: [userToggle].
	toggleDiv appendChild: toggleWidget.
	
	(contentHolder at: 'style') 
		at: 'display' put: 'inline-block'.
	(toggleDiv at: 'style') 
		at: 'display' put: 'inline'.
	toggleWidget at: 'align' put: 'top'.
	
	isExpanded
		ifTrue: [installExpandedPresenter]
		ifFalse: [installCollapsedPresenter].
		
	div:: document createElement: 'div'.
	div appendChild: toggleDiv.
	div appendChild: contentHolder.
	^div
)
installCollapsedPresenter = (
	collapsedPresenter isNil ifTrue: 
		[collapsedPresenter:: collapsedDefinition value].
	installContentVisual: collapsedPresenter visual.
	toggleWidget at: 'src' put: (disclosureClosedImage at: 'src').
)
installContentVisual: newVisual = (
	contentHolder hasChildNodes
		ifTrue:
			[ | oldVisual = contentHolder at: 'firstChild'. |
			contentHolder replaceChild: newVisual with: oldVisual]
		ifFalse: [contentHolder appendChild: newVisual].
)
installExpandedPresenter = (
	expandedPresenter isNil ifTrue:
		[expandedPresenter:: expandedDefinition value].
	installContentVisual: expandedPresenter visual.
	toggleWidget at: 'src' put: (disclosureOpenImage at: 'src').
)
userToggle = (
	isExpanded:: isExpanded not.
	isExpanded
		ifTrue: [installExpandedPresenter]
		ifFalse: [installCollapsedPresenter].
)) : ()'as yet unclassified'
deferAction: action = (
	deferredContentQueue add: action.
	deferredContentQueue size = 1 ifTrue:
		[nextFrameDo: [nextDeferredAction]].
)
nextDeferredAction = (
	| action = deferredContentQueue removeFirst. |
	deferredContentQueue size > 0 ifTrue:
		[nextFrameDo: [nextDeferredAction]].
	action value.
)
nextFrameDo: action = (
	(* Our goal is to run the argument after images have been loaded and rendered. window.requestAnimationFrame runs the callback *before* the next frame. We register another callback in the callback so the first deferred action runs *after* the next frame. We register *that* callback in another RAF callback to let new images added from a deferred block load and render before the next deferred block runs. RAF is also a relative new feature, so simply schedule a timer if it is not available. *)
	(window at: 'requestAnimationFrame') isUndefined
		ifTrue: [Timer after: 200 do: action]
		ifFalse: [window requestAnimationFrame: [
					window requestAnimationFrame: [
						window requestAnimationFrame: action]]].
)) : ()