Newspeak3
'Hopscotch-Core'
class HopscotchForHTML5 usingPlatform: p = (|
	private Color = p graphics Color.
	private Context = p graphics Context.
	private Timer = p time Timer.
	private List = p collections OrderedCollection.
	private Map = p collections Dictionary.

	private window = p aliens global.
	private document = window at: 'document'.
	private body = document at: 'body'.
	private history = window at: 'history'.
	
	private accept16px = p namespace accept16px.
	private cancel16px = p namespace cancel16px.
	private disclosureClosedImage = p namespace disclosureClosedImage.
	private disclosureTransitionImage = p namespace disclosureTransitionImage.
	private disclosureOpenImage = p namespace disclosureOpenImage.
	
	private deferredContentQueue = List new.
	
	public core = self.
	public fragments = self.
|)
(
class BlankFragment = LeafFragment (|
|)
('as yet unclassified'
createVisual = (
	^document createElement: 'div'
)) : ()
class ButtonFragment label: l action: a = LeafFragment (|
	label = l.
	action = a.
|)
('as yet unclassified'
createVisual = (
	^(document createElement: 'button')
		appendChild: (document createTextNode: label);
		at: 'onclick' put: [action value. false];
		yourself
)) : ()
class CanvasFragment withExtent: e = LeafFragment (|
private alien = document createElement: 'canvas'.
|alien at: 'width' put: e x.
alien at: 'height' put: e y.
(alien at: 'style') at: 'position' put: 'relative')
('as yet unclassified'
context = (
	^Context on: (alien getContext: '2d')
)
createVisual = (
	^alien
)
keyDownAction: onKeyPressed <[:String]> = (
	(* The canvas element itself doesn't seem to get key events. *)
	body
		addEventListener: 'keydown'
		with: [:e | onKeyPressed value: (String fromCharCode: (e at: 'keyCode'))]
)
mouseDownAction: onMouseDown <[:Point]> = (
	alien
		addEventListener: 'mousedown'
		with: [:e | onMouseDown value: (e at: 'offsetX') @ (e at: 'offsetY')].
)
mouseMovedAction: onMouseMoved <[:Point]> = (
	alien
		addEventListener: 'mousemove'
		with: [:e | onMouseMoved value: (e at: 'offsetX') @ (e at: 'offsetY')].
)) : ()
class ColumnComposer definitions: fragments = SequenceComposer definitions: fragments (|
|)
('as yet unclassified'
flexDirection = (
	^'column'
)) : ()
class Composer = Fragment ()
() : ()
class DeferredContentComposer initialContent: ic contentSource: cs = Composer (|
	initialContent <Fragment> = ic.
	contentSource <[Fragment]> = cs.
|)
('as yet unclassified'
createVisual = (
	| div initialVisual |
	div:: document createElement: 'div'.
	initialVisual:: initialContent visual.
	div appendChild: initialVisual.
	deferAction: [
		| deferredFragment = contentSource value. |
		deferredFragment parent: self.
		(* replace: new with: old due to stupid DOM argument ordering *)
		div replaceChild: deferredFragment visual with: initialVisual].
	^div
)) : ()
class Fragment = (| visualX parent size ::= nil. expansibility ::= 0. compressibility ::= 0. |)
('as yet unclassified'
createVisual = (
	subclassResponsibility
)
elasticity: x = (
	expansibility: x.
	compressibility: x.
)
hasVisual = (
	^visualX isNil not
)
shell = (
	^parent isNil
		ifTrue: [Error signal: 'hierarchy not installed in a shell']
		ifFalse: [parent shell]
)
visual = (
	visualX isNil ifTrue: [visualX:: createVisual].
	^visualX
)) : ()
class Gradient from: a to: b = (|
	topColor = a.
	bottomColor = b.
|)
('as yet unclassified'
applyToStyle: style = (
	| value |
	value:: '(top,', topColor asCSSString, ',', bottomColor asCSSString, ')'.
	style setProperty: 'background-image' to: '-webkit-linear-gradient', value.
	style setProperty: 'background-image' to: '-moz-linear-gradient', value.
)) : ()
class HolderComposer withContent: definition = Composer (|
	contentSource ::= definition.
	actualContent
|)
('as yet unclassified'
content ^<Fragment> = (
	actualContent isNil ifTrue: 
		[actualContent:: contentSource value.
		actualContent parent: self].
	^actualContent
)
createVisual = (
	| div |
	div:: document createElement: 'div'.
	div appendChild: content visual.
	^div
)
refresh = (
	(contentSource isBlock and: [hasVisual])
		ifTrue:
			[ | oldContent newContent |
			oldContent:: actualContent.
			actualContent:: nil.
			newContent:: content.
			(* replace: new with: old due to stupid DOM argument ordering *)
			visual replaceChild: newContent visual with: oldContent visual]
		ifFalse:
			[actualContent refresh].
)) : ()
class HopscotchShell = (|
	navigator = NavigationHistory new.
	currentPresenterX
	contentHolder = document createElement: 'div'.
|window at: 'onpopstate' put: [:e | userBack: e])
('as yet unclassified'
displayPresenter: p = (
	(* TODO: noticeX events *)
	p parent: self.
	contentHolder hasChildNodes
		ifTrue: [contentHolder replaceChild: p visual from: (contentHolder at: 'firstChild')]
		ifFalse: [contentHolder appendChild: p visual]
)
enterPresenter: p = (
	(* TODO: History stuff *)
	
	history pushState: (navigator idFor: p) title: p title.
	displayPresenter: p
)
enterSubject: s = (
	self enterPresenter: s presenter
)
shell = (
	^self
)
userBack: e = (
	| p = navigator presenterFor: (e at: 'state'). |
	displayPresenter: p
)) : ()
class HopscotchWindow openSubject: s = HopscotchShell (body appendChild: contentHolder.
	enterSubject: s)
('as yet unclassified'
displayPresenter: p = (
	super displayPresenter: p.
	document at: 'title' put: p title.
)) : ()
class HyperlinkFragment label: l action: a = LeafFragment (|
	label = l.
	action = a.
	color ::= Color r: 0 g: 0 b: 1.
|)
('as yet unclassified'
createVisual = (
	| anchor |
	anchor:: document createElement: 'a'.
	anchor at: 'href' put: '#'.
	anchor appendChild: (document createTextNode: label).
	anchor at: 'onclick' put: [action value. false].
	(anchor at: 'style')
		at: 'textDecoration' put: 'none'. (* No underline *)
	color isNil ifFalse:
		[(anchor at: 'style') setProperty: 'color' to: color asCSSString].
	^anchor
)) : ()
class LeafFragment = Fragment ()
() : ()
class NavigationHistory = (| nextId ::= 1. ids = Map new. |)
('as yet unclassified'
idFor: x = (
	^ids at: x ifAbsentPut: [nextId:: nextId + 1]
)
presenterFor: x = (
	^ids keyAtValue: x
)) : ()
class PaddedFrameComposer content: c offsets: o = Composer (|
	content = c.
	offsets = o.
	color
|)
('as yet unclassified'
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style')
		at: 'paddingLeft' put: (offsets at: 1) printString, 'px';
		at: 'paddingTop' put: (offsets at: 2) printString, 'px';
		at: 'paddingRight' put: (offsets at: 3) printString, 'px';
		at: 'paddingBottom' put: (offsets at: 4) printString, 'px'.
	color isNil ifFalse: [color applyToStyle: (div at: 'style')].
	content parent: self.
	div appendChild: content visual.
	^div
)) : ()
class Presenter onSubject: aSubject = Fragment (|
subject ::= aSubject.
|)
('as yet unclassified'
alert: text = (
	window alert: text
)
blank: size = (
	^BlankFragment new size: size
)
button: label <String> action: block <[]>= (
	^ButtonFragment label: label action: block
)
canvas: extent <Point> = (
	^CanvasFragment withExtent: extent
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> ^<Fragment> = (
	^	collapsed: collapsed 
		expanded: expanded
		initiallyExpanded: false
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> initiallyExpanded: flag <Boolean>
^<Fragment> = (
	^ToggleComposer
		collapsedDefinition: collapsed
		expandedDefinition: expanded
		initiallyExpanded: flag
)
column: definitions = (
	^ColumnComposer definitions: definitions
)
createVisual = (
	| substance = definition. |
	substance parent: self.
	^substance visual
)
deferred: contentSource <[Fragment]> ^<Fragment> = (
	^DeferredContentComposer initialContent: nothing contentSource: contentSource
)
definition ^<Fragment> = (
	subclassResponsibility
)
enterSubject: s = (
	(* TODO: use sendUp and open a new window if undelivered *)
	^shell enterSubject: s
)
filler = (
	^BlankFragment new expansibility: 1; compressibility: 1
)
holder: definition <[Fragment]> = (
	^HolderComposer withContent: definition
)
image: image = (
	^StaticImageFragment image: image
)
initially: initialContent <Fragment> deferred: contentSource <[Fragment]> ^<Fragment> = (
	^DeferredContentComposer initialContent: initialContent contentSource: contentSource
)
label: label <String> = (
	^StaticLabelFragment text: label
)
link: label <String> action: block <[]> = (
	^HyperlinkFragment label: label action: block
)
mediumBlank = (
	^blank: 10
)
nothing = (
	^BlankFragment new
)
padded: definition with: offsets = (
	^PaddedFrameComposer content: definition offsets: offsets
)
row: definitions = (
	^RowComposer definitions: definitions
)
textDisplay: string = (
	^TextDisplayFragment text: string
)
title ^<String> = (
	^subject title
)) : ()
class RowComposer definitions: fragments = SequenceComposer definitions: fragments (|
|)
('as yet unclassified'
flexDirection = (
	^'row'
)) : ()
class SequenceComposer definitions: fragments = Composer (|
	definitions = fragments.
	color
|)
('as yet unclassified'
createVisual = (
	| container |
	container:: document createElement: 'div'.
	(container at: 'style')
		at: 'overflow' put: 'hidden';
		at: 'display' put: '-webkit-flex';
		at: 'display' put: 'flex';
		at: '-webkit-flex-direction' put: flexDirection;
		setProperty: 'flex-direction' to: flexDirection.
	color isNil ifFalse: 
		[color applyToStyle: (container at: 'style')].
	definitions do: [:fragment |
		| cell |
		fragment parent: self.
		cell:: document createElement: 'div'.
		cell appendChild: fragment visual.
		(cell at: 'style')
			at: '-webkit-flex-grow' put: fragment expansibility;
			setProperty: 'flex-grow' to: fragment expansibility;
			at: '-webkit-flex-shrink' put: fragment compressibility;
			setProperty: 'flex-shrink' to: fragment compressibility.
		fragment size isNil ifFalse:
			[(cell at: 'style') at: 'flexBasis' put: fragment size printString, 'px'].
		container appendChild: cell].
	^container
)) : ()
class StaticImageFragment image: i = LeafFragment (|
	image = i.
|)
('as yet unclassified'
createVisual = (
	^image cloneNode: false (* Not deep *)
)) : ()
class StaticLabelFragment text: t = LeafFragment (|
	text = t.
	color
|)
('as yet unclassified'
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style') 
		at: 'overflow' put: 'hidden';
		setProperty: 'white-space' to: 'nowrap'.
	div appendChild: (document createTextNode: text).
	color isNil ifFalse:
		[(div at: 'style') setProperty: 'color' to: color asCSSString].
	^div
)) : ()
class Subject onModel: aModel = (|
model ::= aModel.
presenterX
|)
('as yet unclassified'
createPresenter = (
	subclassResponsibility
)
presenter = (
	presenterX isNil ifTrue: [presenterX:: createPresenter].
	^presenterX
)
title ^<String> = (
	^self printString
)) : ()
class TextDisplayFragment text: t = LeafFragment (|
	textX ::= t.
|)
('as yet unclassified'
createVisual = (
	| div = document createElement: 'div'. |
	div at: 'innerText' put: textX. (* This handles newlines. *)
	^div
)
text = (
	^textX
)
text: newText = (
	textX: newText.
	hasVisual ifTrue: [visual at: 'innerText' put: textX]
)) : ()
class TextEditorFragment = LeafFragment (|
	textX ::= ''.
	editorX
	changeResponse
|)
('as yet unclassified'
controlBarColor = (
	^Color r: 0.95 g: 0.792 b: 0.475
)
createVisual = (
	| frame editorWrapper counterfactualBar accept cancel |
	frame:: document createElement: 'div'.
	(frame at: 'style')
		at: 'display' put: '-webkit-flex';
		at: 'display' put: 'flex';
		at: 'margin' put: '2px'.
	editorX:: document createElement: 'div'.
	editorX at: 'contentEditable' put: 'true'.
	(editorX at: 'style')
		at: 'borderStyle' put: 'solid';
		at: 'borderWidth' put: '1px';
		at: 'borderColor' put: 'gray';
		setProperty: 'background-color' to: 'white';
		at: 'flex' put: 1;
		at: '-webkit-flex' put: 1;
		at: '-moz-flex' put: 1;
		at: 'display' put: 'block'.
	editorX addEventListener: 'input' with: [userChange].
	counterfactualBar:: document createElement: 'span'.
	(counterfactualBar at: 'style')
		at: 'backgroundColor' put: controlBarColor asCSSString;
		at: 'flex' put: 'none';
		at: '-webkit-flex' put: 'none';
		at: '-moz-flex' put: 'none'.
	accept:: document createElement: 'img'.
	accept at: 'src' put: (accept16px yourself at: 'src').
	(accept at: 'style') at: 'margin' put: '3px'.
	accept at: 'onclick' put: [userAccept].
	cancel:: document createElement: 'img'.
	cancel at: 'src' put: (cancel16px yourself at: 'src').
	(cancel at: 'style') at: 'margin' put: '3px'.
	cancel at: 'onclick' put: [userCancel].
	counterfactualBar appendChild: accept.
	counterfactualBar appendChild: cancel.
	frame appendChild: editorX.
	frame appendChild: counterfactualBar.
	^frame
)
text = (
	^textX
)
textBeingAccepted = (
	^editorX at: 'innerText'
)
userChange = (
	changeResponse isNil ifFalse: [changeResponse value: self]
)) : ()
class ToggleComposer collapsedDefinition: collapsed
 expandedDefinition: expanded
 initiallyExpanded: flag = Composer (|
expandedDefinition = expanded.
collapsedDefinition = collapsed.
isExpanded ::= flag.
expandedPresenter
collapsedPresenter
contentHolder
toggleWidget
|)
('as yet unclassified'
collapse = (
	installCollapsedPresenter
)
createVisual = (
	| toggleDiv div |
	contentHolder:: document createElement: 'div'.
	
	toggleDiv:: document createElement: 'div'.
	toggleWidget:: document createElement: 'img'.
	toggleWidget at: 'onclick' put: [userToggle].
	toggleDiv appendChild: toggleWidget.
	
	(contentHolder at: 'style') 
		at: '-webkit-flex-grow' put: 1;
		setProperty: 'flex-grow' to: 1;
		at: '-webkit-flex-shrink' put: 1;
		setProperty: 'flex-shrink' to: 1.
	(toggleDiv at: 'style') 
		at: '-webkit-flex-grow' put: 0;
		setProperty: 'flex-grow' to: 0;
		at: '-webkit-flex-shrink' put: 0;
		setProperty: 'flex-shrink' to: 0.
	toggleWidget at: 'align' put: 'top'.
	
	isExpanded
		ifTrue: [installExpandedPresenter]
		ifFalse: [installCollapsedPresenter].
		
	div:: document createElement: 'div'.
	(div at: 'style')
		at: 'display' put: '-webkit-flex';
		at: 'display' put: 'flex';
		at: '-webkit-flex-direction' put: 'row';
		setProperty: 'flex-direction' to: 'row'.
	div appendChild: toggleDiv.
	div appendChild: contentHolder.
	^div
)
expand = (
	installExpandedPresenter
)
installCollapsedPresenter = (
	collapsedPresenter isNil ifTrue: 
		[collapsedPresenter:: collapsedDefinition value.
		collapsedPresenter parent: self].
	installContentVisual: collapsedPresenter visual.
	toggleWidget at: 'src' put: (disclosureClosedImage at: 'src').
)
installContentVisual: newVisual = (
	contentHolder hasChildNodes
		ifTrue:
			[ | oldVisual = contentHolder at: 'firstChild'. |
			contentHolder replaceChild: newVisual with: oldVisual]
		ifFalse: [contentHolder appendChild: newVisual].
)
installExpandedPresenter = (
	expandedPresenter isNil ifTrue:
		[expandedPresenter:: expandedDefinition value.
		expandedPresenter parent: self].
	installContentVisual: expandedPresenter visual.
	toggleWidget at: 'src' put: (disclosureOpenImage at: 'src').
)
userToggle = (
	isExpanded:: isExpanded not.
	isExpanded
		ifTrue: [installExpandedPresenter]
		ifFalse: [installCollapsedPresenter].
)) : ()'as yet unclassified'
deferAction: action = (
	deferredContentQueue add: action.
	deferredContentQueue size = 1 ifTrue:
		[nextFrameDo: [nextDeferredAction]].
)
nextDeferredAction = (
	| action = deferredContentQueue removeFirst. |
	deferredContentQueue size > 0 ifTrue:
		[nextFrameDo: [nextDeferredAction]].
	action value.
)
nextFrameDo: action = (
	(* Our goal is to run the argument after images have been loaded and rendered. window.requestAnimationFrame runs the callback *before* the next frame. We register another callback in the callback so the first deferred action runs *after* the next frame. We register *that* callback in another RAF callback to let new images added from a deferred block load and render before the next deferred block runs. RAF is also a relative new feature, so simply schedule a timer if it is not available. *)
	(window at: 'requestAnimationFrame') isUndefined
		ifTrue: [Timer after: 200 do: action]
		ifFalse: [window requestAnimationFrame: [
					window requestAnimationFrame: [
						window requestAnimationFrame: action]]].
)) : ()