Newspeak3
'HopscotchIDE'
class SystemScope usingPlatform: platform = (
(*
Copyright 2008 Cadence Design Systems, Inc.
Copyright 2012 Cadence Design Systems, Inc.
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)|
	IdentityDictionary = platform blackMarket IdentityDictionary.
	IdentitySet = platform blackMarket IdentitySet.
	SystemChangeNotifier = platform blackMarket SystemChangeNotifier.
	theSystemNavigation = platform blackMarket SystemNavigation default.
	Smalltalk = platform blackMarket Smalltalk.
	SmalltalkImage = platform blackMarket SmalltalkImage.
	private vmMirror = platform blackMarket SqueakVmMirror usingPlatform: platform.
	private allLiteralReferences_slot
	exemplarInstances <Map[Class, Object]> = IdentityDictionary new.
|SystemChangeNotifier uniqueInstance notify: self ofAllSystemChangesUsing: #respondToSystemChange)
('as yet unclassified'
accessesToInstanceVariableIndex: index <Integer> from: cls <Class> do: action  = (
	cls methodDict keysAndValuesDo: [ :selector :method |
		((method readsField: index) or: [method writesField: index]) ifTrue: [
			action value: cls value: selector]]
)
allAccessesToInstanceVariableNamed: varName <String> from: cls <Class> do: action = (
	| index |
	index:: vmMirror classUtil indexOfInstanceVariableNamed: varName of: cls ifAbsent: [^self].
	cls allSuperclassesDo: [ :ea | accessesToInstanceVariableIndex: index from: ea do: action].
	accessesToInstanceVariableIndex: index from: cls do: action.
	cls allSubclassesDo: [ :ea | accessesToInstanceVariableIndex: index from: ea do: action].
)
allBehaviors ^<Array[Behavior]> = (
	(* Answer an array of all behaviors (both classes and metaclasses) in the scope, in an undefined order. *)
	^Array streamContents: [ :s | allBehaviorsDo: [ :cls | s nextPut: cls ]]
)
allBehaviorsDo: action <[:Behavior]> = (
	(* Enumerate the argument block over all behaviors (classes and metaclasses) in the scope, in an undefined order. *)
	allSmalltalkBehaviorsDo: action.
	allMixinsAndClassMixinsDo: action.
)
allClasses ^<Array[Class]> = (
	(* Answer an array of all classes (not metaclasses) in the scope, in an undefined order. *)
	^Array streamContents: [ :s | allClassesDo: [ :cls | s nextPut: cls ]]
)
allClassesDo: action <[:Class]> = (
	(* Enumerate the argument block over all classes (not metaclasses) in the scope, in an undefined order. *)
	allBehaviorsDo: [:each | each isMeta ifFalse: [action value: each]].
	allMixinsDo: action.
)
allImplementorsOf: selector <String> = (
	^Array streamContents:
		[ :s |
		allImplementorsOf: selector do:
			[ :cls <Class> :sel <Symbol> | s nextPut: {cls,sel} ]]
)
allImplementorsOf: selector <String> do: action <[:Class:Symbol]> = (
	allBehaviorsDo:
		[ :cls | (cls includesSelector: selector) ifTrue: [ action value: cls value: selector ]]
)
allLiteralReferences = (
	| map |
	allLiteralReferences_slot ifNotNil: [ :m | ^m].
	map:: IdentityDictionary new.
	allBehaviorsDo: [ :cls |
		allLiteralsOf: cls do: [ :lit :sender |
			(map at: (lit isVariableBinding ifTrue: [lit key] ifFalse: [lit]) ifAbsentPut: [IdentitySet new]) add: sender]].
	allLiteralReferences_slot:: map.
	^allLiteralReferences_slot
)
allLiteralsOf: cls <Behavior> do: action <[:(Symbol | LookupKey) :Class | CompiledMethod]> = (
	cls superclass ifNotNil: [ :sc | action value: sc theNonMetaClass name value: cls].
	cls methodDictionary valuesDo: [ :cm <CompiledMethod> |
		1 to: cm numLiterals - 2 do: [:i |  | lit = cm literalAt: i. |
			(lit isSymbol or: [lit isVariableBinding]) ifTrue: [
				action value: lit value: cm]]]
)
allMixinsAndClassMixinsDo: action <[:Mixin]> = (
	| blk |
	blk: [:mxn | 
		action value: mxn.
		action value: mxn classMixin.
		mxn nestedClasses do: [:inner | blk value: inner]].
	
	Smalltalk values do: [:cls |
		([cls language isNewspeakLanguage3 
			and: [cls mixin == cls mixin definingClass]]
			ifError: [false]) ifTrue: [blk value: cls mixin]
	].
)
allMixinsDo: action <[:Mixin]> = (
	allMixinsAndClassMixinsDo: [:mxn | mxn isMeta ifFalse: [action value: mxn]]
)
allSelect: block <[:CompiledMethod | Boolean]> = (
	^Array streamContents:
		[ :s |
		allBehaviorsDo:
			[ :b <Behavior> |
			b selectorsAndMethodsDo:
				[ :sel <Symbol> :m <CompiledMethod> |
				(block value: m) ifTrue:
					[s nextPut: { b. sel }]]]]
)
allSendersOf: literalIn <String | Symbol | Association> do: action <[:Class:Symbol]> = (
	(* Derived from SystemNavigation class>>allCallsOn: *)
	| thorough special literal byte |
	thorough:: literalIn isSymbol or: [ literalIn isString ].
	literal:: thorough
		ifTrue: [#BOGUS yourself. (* Should not require interning *) literalIn asSymbol ]
		ifFalse: [ literalIn ].
	special:: Smalltalk
				hasSpecialSelector: literal
				ifTrueSetByte: [:b | byte:: b].
	literal isSymbol ifTrue: [
		(Smalltalk associationAt: literal ifAbsent: []) ifNotNil:
			[ :assoc | allSendersOf: assoc do: action]].
	allBehaviorsDo:
		[ :cls <Class> |
		(thorough
				ifTrue: [cls thoroughWhichSelectorsReferTo: literal special: special byte: byte]
				ifFalse: [cls whichSelectorsReferTo: literal special: special byte: byte])
			do: [ :sel | action value: cls value: sel ]]
)
allSendersOf: selector <String> = (
	^Array streamContents:
		[ :s |
		allSendersOf: selector do:
			[ :cls <Class> :sel <Symbol> | s nextPut: {cls. sel} ]]
)
allSmalltalkBehaviorsDo: action <[:Behavior]> = (
	(* Enumerate the argument block over all behaviors (classes and metaclasses) in the scope, in an undefined order. *)
	theSystemNavigation allBehaviorsDo:
		[ :cls <Behavior> | cls isMixinApplication not ifTrue: [ action value: cls ]].
)
allSymbolsMatching: pattern <String> = (
	^Array streamContents:
		[ :s |
		allSymbolsMatching: pattern do:
			[ :cls <Class> :sel <Symbol> | s nextPut: {cls,sel} ]]
)
allSymbolsMatching: pattern <String> do: action <[:Class:Symbol]> = (
	halt
)
allUndeclared = (
	^(Smalltalk at: #Undeclared) removeUnreferencedKeys; associations
)
allUsersOfUndeclared = (
	^Array streamContents: [ :s |
		allUndeclared do: [ :ea |
			s nextPutAll: (theSystemNavigation allCallsOn: ea)]]
)
computeExemplarClassFor: aMixin <Mixin>  ^ <Class> = (
aMixin applications  isEmpty ifTrue:[
   	aMixin enclosingMixin = nil ifTrue:[^aMixin apply: Object].
  	 ^(vmMirror ObjectMirror on:(exemplarInstanceFor: (exemplarClassFor: aMixin enclosingMixin))) perform: aMixin simpleName
	].
   ^aMixin applications asOrderedCollection first ifNil:[
   	aMixin enclosingMixin = nil ifTrue:[^aMixin apply: Object].
  	 (vmMirror ObjectMirror on:(exemplarInstanceFor: (exemplarClassFor: aMixin enclosingMixin))) perform: aMixin simpleName
	]
)
computeExemplarInstanceFor: aClass <Class>  = (
   ^aClass basicNew
)
exemplarClassFor: aMixin <Mixin> ^ <Class> = (
  ^aMixin isMeta 
	ifFalse:[computeExemplarClassFor: aMixin]
	ifTrue:[(computeExemplarClassFor: aMixin instanceMixin) class]
)
exemplarInstanceFor: aClass <Class>  = (
  ^exemplarInstances at: aClass ifAbsent:[
	exemplarInstances
				at: aClass
				put: (computeExemplarInstanceFor: aClass)
			]
)
packagesWithUndeclared = (
	^(allUsersOfUndeclared
		collect: [:ea |
			((Smalltalk at: #PackageOrganizer) default packageOfMethod: ea) packageName])
				asSet asSortedCollection asArray
)
respondToSystemChange = (
	allLiteralReferences_slot: nil
)
systemName = (
	| vmName i |
	vmName:: SmalltalkImage current vmVersion.
	^(vmName last isDigit and: [(i:: vmName lastIndexOf: Character space) > 1])
		ifTrue: [vmName copyFrom: 1 to: i - 1]
		ifFalse: [vmName]
)
systemVersion = (
	| vmName i |
	vmName:: SmalltalkImage current vmVersion.
	^(vmName last isDigit and: [(i:: vmName lastIndexOf: Character space) > 1])
		ifTrue: [vmName allButFirst: i]
		ifFalse: ['?']
)) : ()