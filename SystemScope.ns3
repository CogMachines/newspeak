Newspeak3
'HopscotchIDE'
class SystemScope usingPlatform: platform = (
(*
Copyright 2008 Cadence Design Systems, Inc.
Copyright 2012 Cadence Design Systems, Inc.
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)|
	IdentityDictionary = platform blackMarket IdentityDictionary.
	IdentitySet = platform blackMarket IdentitySet.
	SystemChangeNotifier = platform squeak SystemChangeNotifier.
	theSystemNavigation = platform squeak SystemNavigation default.
	Smalltalk = platform squeak Smalltalk.
	SmalltalkImage = platform squeak SmalltalkImage.
	ClassDeclarationMirror = platform mirrors ClassDeclarationMirror.

	private allLiteralReferences_slot
	exemplarInstances <Map[Class, Object]> = IdentityDictionary new.
|SystemChangeNotifier uniqueInstance notify: self ofAllSystemChangesUsing: #respondToSystemChange)
('as yet unclassified'
accessesToInstanceVariableIndex: index <Integer> from: cls <Class> do: action  = (
	cls methodDict keysAndValuesDo: [ :selector :method |
		((method readsField: index) or: [method writesField: index]) ifTrue: [
			action value: cls value: selector]]
)
allAccessesToInstanceVariableNamed: varName <String> from: cls <Class> do: action = (
	| index |
	index:: cls allInstVarNames indexOf: varName ifAbsent: [^self].
	cls allSuperclassesDo: [ :ea | accessesToInstanceVariableIndex: index from: ea do: action].
	accessesToInstanceVariableIndex: index from: cls do: action.
	cls allSubclassesDo: [ :ea | accessesToInstanceVariableIndex: index from: ea do: action].
)
allBehaviors ^<Array[Behavior]> = (
	(* Answer an array of all behaviors (both classes and metaclasses) in the scope, in an undefined order. *)
	^Array streamContents: [ :s | allBehaviorsDo: [ :cls | s nextPut: cls ]]
)
allBehaviorsDo: action <[:Behavior]> = (
	(* Enumerate the argument block over all behaviors (classes and metaclasses) in the scope, in an undefined order. *)
	allSmalltalkBehaviorsDo: action.
	allMixinsAndClassMixinsDo: action.
)
allClasses ^<Array[Class]> = (
	(* Answer an array of all classes (not metaclasses) in the scope, in an undefined order. *)
	^Array streamContents: [ :s | allClassesDo: [ :cls | s nextPut: cls ]]
)
allClassesDo: action <[:Class]> = (
	(* Enumerate the argument block over all classes (not metaclasses) in the scope, in an undefined order. *)
	allBehaviorsDo: [:each | each isMeta ifFalse: [action value: each]].
	(* allMixinsDo: action. *)
)
allLiteralReferences = (
	| map |
	allLiteralReferences_slot ifNotNil: [ :m | ^m].
	map:: IdentityDictionary new.
	allBehaviorsDo: [ :cls |
		allLiteralsOf: cls do: [ :lit :sender |
			(map at: (lit isVariableBinding ifTrue: [lit key] ifFalse: [lit]) ifAbsentPut: [IdentitySet new]) add: sender]].
	allLiteralReferences_slot:: map.
	^allLiteralReferences_slot
)
allLiteralsOf: cls <Behavior> do: action <[:(Symbol | LookupKey) :Class | CompiledMethod]> = (
	cls superclass ifNotNil: [ :sc | action value: sc theNonMetaClass name value: cls].
	cls methodDictionary valuesDo: [ :cm <CompiledMethod> |
		1 to: cm numLiterals - 2 do: [:i |  | lit = cm literalAt: i. |
			(lit isSymbol or: [lit isVariableBinding]) ifTrue: [
				action value: lit value: cm]]]
)
allMixinsAndClassMixinsDo: action <[:Mixin]> = (
	| blk |
	blk: [:mxn | 
		action value: mxn.
		action value: mxn classMixin.
		mxn nestedClasses do: [:inner | blk value: inner]].
	
	Smalltalk values do: [:cls |
		([cls language isNewspeakLanguage3 
			and: [cls mixin == cls mixin definingClass]]
			ifError: [false]) ifTrue: [blk value: cls mixin]
	].
)
allMixinsDo: action <[:Mixin]> = (
	allMixinsAndClassMixinsDo: [:mxn | mxn isMeta ifFalse: [action value: mxn]]
)
allSelect: block <[:CompiledMethod | Boolean]> = (
	^Array streamContents:
		[ :s |
		allBehaviorsDo:
			[ :b <Behavior> |
			b selectorsAndMethodsDo:
				[ :sel <Symbol> :m <CompiledMethod> |
				(block value: m) ifTrue:
					[s nextPut: { b. sel }]]]]
)
allSmalltalkBehaviorsDo: action <[:Behavior]> = (
	(* Enumerate the argument block over all behaviors (classes and metaclasses) in the scope, in an undefined order. *)
	theSystemNavigation allBehaviorsDo:
		[ :cls <Behavior> | cls isMixinApplication not ifTrue: [ action value: cls ]].
)
allSymbolsMatching: pattern <String> = (
	^Array streamContents:
		[ :s |
		allSymbolsMatching: pattern do:
			[ :cls <Class> :sel <Symbol> | s nextPut: {cls,sel} ]]
)
allSymbolsMatching: pattern <String> do: action <[:Class:Symbol]> = (
	halt
)
allUndeclared = (
	^(Smalltalk at: #Undeclared) removeUnreferencedKeys; associations
)
allUsersOfUndeclared = (
	^Array streamContents: [ :s |
		allUndeclared do: [ :ea |
			s nextPutAll: (theSystemNavigation allCallsOn: ea)]]
)
computeExemplarClassFor: aMixin <Mixin> ^<Class> = (
	aMixin applications do: [:ea | ^ea].
	aMixin enclosingMixin == nil ifTrue: [^aMixin apply: Object].
	^(exemplarInstanceFor: 
		(exemplarClassFor: aMixin enclosingMixin))
			perform: aMixin simpleName
)
computeExemplarInstanceFor: aClass <Class>  = (
   ^aClass basicNew
)
exemplarClassFor: aMixin <Mixin> ^ <Class> = (
  ^aMixin isMeta 
	ifFalse:[computeExemplarClassFor: aMixin]
	ifTrue:[(computeExemplarClassFor: aMixin instanceMixin) class]
)
exemplarInstanceFor: aClass <Class>  = (
  ^exemplarInstances at: aClass ifAbsent:[
	exemplarInstances
				at: aClass
				put: (computeExemplarInstanceFor: aClass)
			]
)
newspeakImplementorsOf: selector do: action <[:MethodMirror]> = (	
	newspeakTopLevelClassesDo:
		[:cdm <ClassDeclarationMirror> | newspeakImplementorsOf: selector in: cdm do: action ].
)
newspeakImplementorsOf: selector in: classDeclaration do: action <[:MethodMirror]> = (	
	(classDeclaration simpleName = selector 
		or: [classDeclaration header primaryFactoryName = selector]
		or: [classDeclaration instanceSide slots anySatisfy: [:slot |
			(* Do not intern the setter name or we won't get suspect send highlighting for slot names that are always immutable. *)
			slot name = selector or: [slot isMutable and: [(slot name, ':') = selector]]]])
				ifTrue: [action value: classDeclaration header].
	
	classDeclaration instanceSide methods do:
		[:mm | mm name = selector ifTrue: [action value: mm]].
	classDeclaration classSide methods do:
		[:mm | mm name = selector ifTrue: [action value: mm]].
	classDeclaration instanceSide nestedClasses do:
		[:nc | newspeakImplementorsOf: selector in: nc do: action].
)
newspeakSendersOf: selector do: action <[:MethodMirror]> = (	
	newspeakTopLevelClassesDo:
		[:cdm <ClassDeclarationMirror> | newspeakSendersOf: selector in: cdm do: action ].
)
newspeakSendersOf: selector in: classDeclaration do: action <[:MethodMirror]> = (	
	(classDeclaration header sendsSelector: selector) 
		ifTrue: [action value: classDeclaration header].
	classDeclaration instanceSide methods do:
		[:mm | (mm sendsSelector: selector) ifTrue: [action value: mm]].
	classDeclaration classSide methods do:
		[:mm | (mm sendsSelector: selector) ifTrue: [action value: mm]].
	classDeclaration instanceSide nestedClasses do:
		[:nc | newspeakSendersOf: selector in: nc do: action].
)
newspeakTopLevelClassesDo: action <[:ClassDeclarationMirror]> = (	
	Smalltalk values do: 
		[:cls | (cls isBehavior and: [cls language isNewspeakLanguage3])
			ifTrue: [action value: (ClassDeclarationMirror reflecting: cls mixin)]].
)
packagesWithUndeclared = (
	^(allUsersOfUndeclared
		collect: [:ea |
			((Smalltalk at: #PackageOrganizer) default packageOfMethod: ea) packageName])
				asSet asSortedCollection asArray
)
respondToSystemChange = (
	allLiteralReferences_slot: nil
)
smalltalkImplementorsOf: selector <String> do: action <[:Class:Symbol]> = (
	allSmalltalkBehaviorsDo:
		[ :cls | (cls includesSelector: selector) ifTrue: [ action value: cls value: selector ]]
)
smalltalkSendersOf: literalIn <String | Symbol | Association> do: action <[:Class:Symbol]> = (
	(* Derived from SystemNavigation class>>allCallsOn: *)
	| thorough special literal byte |
	thorough:: literalIn isSymbol or: [ literalIn isString ].
	literal:: thorough
		ifTrue: [#BOGUS yourself. (* Should not require interning *) literalIn asSymbol ]
		ifFalse: [ literalIn ].
	special:: Smalltalk
				hasSpecialSelector: literal
				ifTrueSetByte: [:b | byte:: b].
	literal isSymbol ifTrue: [
		(Smalltalk associationAt: literal ifAbsent: []) ifNotNil:
			[ :assoc | smalltalkSendersOf: assoc do: action]].
	allSmalltalkBehaviorsDo:
		[ :cls <Class> |
		(thorough
				ifTrue: [cls thoroughWhichSelectorsReferTo: literal special: special byte: byte]
				ifFalse: [cls whichSelectorsReferTo: literal special: special byte: byte])
			do: [ :sel | action value: cls value: sel ]]
)
systemName = (
	| vmName i |
	vmName:: SmalltalkImage current vmVersion.
	^(vmName last isDigit and: [(i:: vmName lastIndexOf: Character space) > 1])
		ifTrue: [vmName copyFrom: 1 to: i - 1]
		ifFalse: [vmName]
)
systemVersion = (
	| vmName i |
	vmName:: SmalltalkImage current vmVersion.
	^(vmName last isDigit and: [(i:: vmName lastIndexOf: Character space) > 1])
		ifTrue: [vmName allButFirst: i]
		ifFalse: ['?']
)) : ()