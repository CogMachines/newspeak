Newspeak3
'Actors'
class Actors2 usingPlatform: p vm: vm = (|
private SharedQueue2 = p squeak SharedQueue2.
private WeakMap = p squeak WeakKeyDictionary.
private List = p collections OrderedCollection.
private Transcript = p squeak Transcript.
private SqueakDelay = p squeak Delay.

private Processor <ProcessScheduler> = p squeak Processor.
private primitives <VMMirror> = vm.

private brazil = p brazil.
public (* bogus - temporary access to a default actor *) uiActor = UIActor new.

private internalFarReferences <WeakMap[FarReference, InternalFarReference]> = WeakMap new.
private internalResolvers <WeakMap[Promise, InternalResolver]> = WeakMap new.
|p squeak Project uiProcess actor: uiActor.
p actors2: self) (
class Actor = () (
'as yet unclassified'
public currentActor = (
	(* BOGUS. Polymorphic with other actor system. *)
	^self
)
public eventualSendTo: receiver selector: selector arguments: arguments ^<Promise> = (
	(* Sent from the compilation of an eventual send, via the same method in ProcessScheduler. *)
	| targetFuture |
	targetFuture:: InternalResolver __owner: self.
	eventualSendTo: receiver selector: selector arguments: arguments resolver: targetFuture.
	^Promise withFuture: targetFuture __owner: self.
)
public eventualSendTo: receiver selector: selector arguments: arguments resolver: resolver = (
	| message |

	(isPromise: receiver) ifTrue:
		[^(internalResolvers at: receiver) eventualSend: selector arguments: arguments resolver: resolver].
	
	(isFarReference: receiver) ifTrue:
		[^(internalFarReferences at: receiver) farEventualSend: selector arguments: arguments from: self resolver: resolver].
	
	(* Otherwise, a near reference. *)
	message:: PendingDelivery
		receiver: receiver
		selector: selector
		arguments: arguments
		resolver: resolver.
	enqueueMessage: message.
)
) : (
)
protected class EventualSendReactor selector: s arguments: a resolver: r = (
(* An eventual-send to a promise.

Note that all slots contain objects that belong to the actor which performed the eventual send. *)|
protected selector <Symbol> = s.
protected arguments <Array> = a.
protected resolver <InternalResolver> = r.
|) (
'as yet unclassified'
public reactBroken: error = (
	(* Broken promise contagion. *)	
	resolver __owner == currentActor ifFalse: [halt].
	(* Should this be immediate? *)
	(* resolver internalBreak: error. ? *)
	currentActor enqueueMessage:
		(PendingDelivery
			receiver: resolver
			selector: #internalBreak:
			arguments: {error}
			resolver: nil)
)
public reactResolved: value = (
	resolver __owner == currentActor ifFalse: [halt].
	currentActor
		eventualSendTo: value
		selector: selector
		arguments: arguments
		resolver: resolver. 
)
) : (
)
protected class FarReference wrapping: f = ((* A far reference is one that crosses actor boundaries. *)| private __internalFarReference = f. (* Debugging only *) |) (
'as yet unclassified'
protected doesNotUnderstand: message <Message> = (
	(* For the debugger/inspector. Questionable. *)
	(* Should probably override public method of Object as well. *)
	0 = message arguments size ifTrue: [(message selector startsWith: 'is') ifTrue: [^false]].

	^Error signal: 'Cannot immediate-send to an eventual reference: ', message selector.
)
public isPromise ^<Boolean> = (
	^false
)
protected yourself = (
	^super yourself
)
) : (
)
protected class InternalFarReference to: t inActor: a = (|
public target = t.
public actor <Actor> = a.
|) (
'as yet unclassified'
public farEventualSend: selector arguments: arguments from: sourceActor resolver: sourceResolver = (
	| resolverInTarget resolverInSource redirector message forked |
	
	currentActor == actor ifTrue: [halt].
	
	resolverInTarget:: InternalResolver __owner: actor.
	
	resolverInSource:: InternalResolver __owner: sourceActor.
	resolverInSource finalResolver: resolverInTarget.
	resolverInSource finalResolverActor: actor.

	message:: PendingDelivery
		receiver: target
		selector: selector
		arguments: (wrapArguments: arguments from: sourceActor to: actor)
		resolver: resolverInTarget.
	actor enqueueMessage: message.
	
	sourceResolver finalResolver: resolverInTarget.
	sourceResolver finalResolverActor: actor.
	
	redirector:: RedirectReactor
		from: actor
		to: sourceActor
		resolver: resolverInSource.

	message:: PendingDelivery
		receiver: resolverInTarget
		selector: #addReactor:
		arguments: {redirector}
		resolver: nil.
	actor enqueueMessage: message.
	
	sourceResolver internalResolve: (Promise withFuture: resolverInSource __owner: sourceActor).
)
) : (
)
protected class InternalResolver __owner: o = (|
	public __owner <Actor> = o. (* For assertions only. *)
	public resolution
	public state ::= #unresolved. (* unresolved, forwarded, resolved, smashed *)
	protected reactors <List[WhenReactor | EventualSendReactor | RedirectingReactor]> (* use linked list for randomizing scheduler? *)
	
	public finalResolver ::= self.
	public finalResolverActor ::= o.
|) (
'as yet unclassified'
public addReactor: msg = (	
	state == #resolved ifTrue:
		[^msg reactResolved: resolution].
	state == #broken ifTrue:
		[^msg reactBroken: resolution].
	state == #forwarded ifTrue: 
		[resolution:: resolution shortenResolution.
		^resolution addReactor: msg].
	state == #unresolved ifTrue:
		[nil == reactors ifTrue: [reactors:: List new].
		reactors add: msg.
		^self].
	halt.
)
doForwardingTo: sourceFuture = (
	state:: #forwarded.
	resolution:: sourceFuture shortenResolution.
	nil == reactors ifFalse:
		[reactors do: [:msg | resolution addReactor: msg].
		reactors:: nil].
)
public eventualSend: selector arguments: arguments resolver: resolver ^<Promise> = (
	__owner == currentActor ifFalse: [halt].	
	self addReactor: (EventualSendReactor selector: selector arguments: arguments resolver: resolver).
)
public internalBreak: error = (
	assert: [state == #unresolved] message: 'State error'.

	resolution:: error.
	state:: #broken.
	
	nil == reactors ifFalse:
		[reactors do: [:msg | msg reactBroken: error].
		reactors:: nil].
)
public internalResolve: value = (
	assert: [state == #unresolved] message: 'State error'.

	(isPromise: value) ifTrue: [^doForwardingTo: (internalResolvers at: value)].

	resolution:: value.
	state:: #resolved.
	
	nil == reactors ifFalse:
		[reactors do: [:msg | msg reactResolved: value].
		reactors:: nil].
)
public printOn: stream = (
	stream nextPutAll: 'InternalResolver#'.
	identityHash printOn: stream.
)
public shortenResolution = (
	state == #unresolved ifTrue: [^self].
	state == #forwarded ifTrue: [^resolution shortenResolution].
	state == #resolved ifTrue: [^self].
	state == #broken ifTrue: [^self].
	halt.
)
public whenResolved: onValue <[:V | V2 def]> whenBroken: onError <[:E | E2 def]> ^<Promise[V2, E2]> = (
	| resolver = InternalResolver __owner: __owner. |
	__owner == currentActor ifFalse: [halt].
	self addReactor: (WhenReactor onValue: onValue onError: onError resolver: resolver).
	^Promise withFuture: resolver __owner: __owner
)
) : (
)
protected class PendingDelivery receiver: r selector: s arguments: a resolver: y = (
(* A message in an actor's event queue. Every turn starts by sending #deliverIn:.

Note that all slots contain objects that belong to the actor in which the message is queued, even the resolver. *)|
protected receiver <Object> = r.
protected selector <Symbol> = s.
protected arguments <Array> = a.
protected resolver <InternalResolver> = y.
|) (
'as yet unclassified'
public deliverIn: fastCurrentActor = (
	| resolution type msg |
	
	(* Transcript print: fastCurrentActor; space; print: self; cr. *)

	[(* BOGUS: Don't rely on perform not being overridden. *)
	resolution:: receiver perform: selector withArguments: arguments.
	type:: #internalResolve:] 
		on: Error (* BOGUS: Exception? *) 
		do: [:error | 
			resolution:: error.
			type:: #internalBreak:].

	(* Transcript show: {resolver. type. resolution}; cr. *)

	nil == resolver ifTrue: [^self].
	type == #internalResolve:
		ifTrue: [resolver internalResolve: resolution]
		ifFalse: [resolver internalBreak: resolution].
)
public postedTo: actor = (
	(isFarReference: receiver) ifTrue: [halt].

	check: receiver allowedIn: actor.
	arguments do: [:arg | check: arg allowedIn: actor].
	resolver == nil ifFalse: [resolver __owner == actor ifFalse: [halt]].
)
public printOn: stream = (
	receiver printOn: stream.
	stream nextPutAll: ' <-: '.
	stream nextPutAll: selector.
	stream space.
	arguments isEmpty ifFalse: [arguments printOn: stream].
)
) : (
)
protected class ProcessActor named: n = Actor (
(* An actor whose turns run in its own Process, allowing us to suspend it individually. *)|
	protected name <String> = n.
	protected process <Process>
	protected messageQueue <SharedQueue> = SharedQueue2 new.
|) (
'as yet unclassified'
doOneTurn = (
	messageQueue next deliverIn: self.
)
public enqueueMessage: actorMessage = (
	actorMessage postedTo: self.
	messageQueue nextPut: actorMessage
)
public printOn: stream = (
	stream nextPutAll: '[Actor('.
	stream nextPutAll: name.
	stream nextPutAll: ')#'.
	identityHash printOn: stream.
	stream nextPutAll: ']'.
)
public startEventLoop = (
	process:: [[self doOneTurn] repeat] newProcess.
	process name: ('Event loop for ', name) asString.
	process priority: Processor userBackgroundPriority.
	process actor: self.
	process resume.
)
) : (
)
protected class Promise withFuture: r __owner: o = (|
	private internalResolver <InternalResolver> = r.
	public __owner <Actor> = o.  (* For assertions only. *)
|internalResolvers at: self put: r) (
'as yet unclassified'
protected doesNotUnderstand: message <Message> = (
	(* For the debugger/inspector. Questionable. *)
	(* Should probably override public method of Object as well. *)
	0 = message arguments size ifTrue: [(message selector startsWith: 'is') ifTrue: [^false]].
	
	internalResolver state == #resolved ifTrue:
		[^message sendTo: internalResolver resolution].
	
	^Error signal: 'Cannot immediate-send to an eventual reference: ', message selector.
)
public isPromise ^<Boolean> = (
	self flag: 'How transparent should promises be?'.
	^true
)
public whenResolved: onValue <[:V | V2 def]> ^<Promise[V2, E]>= (
	^internalResolver
		whenResolved: onValue
		whenBroken: [:e | e signal] (* Should we make this the behavior of a nil catch-clause instead? *)
)
public whenResolved: onValue <[:V | V2 def]> whenBroken: onError <[:E | E2 def]> ^<Promise[V2, E2]> = (
	^internalResolver whenResolved: onValue whenBroken: onError
)
protected yourself = (
	^super yourself
)
) : (
)
protected class RedirectReactor from: s to: d resolver: r = (
(* A bridge between InternalResolvers in different actors. *)|
protected sourceActor <Actor> = s.
protected destinationActor <Actor> = d.
protected resolver <InternalResolver>  = r.
|) (
'as yet unclassified'
public reactBroken: r = (
	| msg |
	currentActor == sourceActor ifFalse: [halt].
	msg:: PendingDelivery
		receiver: resolver
		selector: #internalBreak:
		arguments: {wrapArgument: r from: sourceActor to: destinationActor}
		resolver: nil.
	destinationActor enqueueMessage: msg.
)
public reactResolved: r = (
	| msg |
	currentActor == sourceActor ifFalse: [halt].
	msg:: PendingDelivery
		receiver: resolver
		selector: #internalResolve:
		arguments: {wrapArgument: r from: sourceActor to: destinationActor}
		resolver: nil.
	destinationActor enqueueMessage: msg.
)
) : (
)
public class Resolver = (
(*A Resolver represents the authority to resolve a Promise and is the control facet of the promise's eventual resolution.*)|
	private (* N.B. We must not leak access to an InternalResolver via subobjects. *) internalResolver = InternalResolver __owner: currentActor.
	public promise <Promise[V, E]> = Promise withFuture: internalResolver __owner: currentActor.
|) (
'as yet unclassified'
public break: error <E> = (
	| msg |
	internalResolver __owner == currentActor ifFalse: [halt].
	#unresolved == internalResolver state 
		ifTrue: [internalResolver internalBreak: error]
		ifFalse: [Error signal: 'Already resolved'].
)
public isPromise ^<Boolean> = (
	^false
)
public isResolver ^<Boolean> = (
	^true
)
public resolve: value <V> = (
	| msg |
	internalResolver __owner == currentActor ifFalse: [halt].
	#unresolved == internalResolver state 
		ifTrue: [internalResolver internalResolve: value]
		ifFalse: [Error signal: 'Already resolved'].
)
) : (
)
public class Timer __duration: milliseconds callback: callback repeating: repeating = (|
	protected process
	protected actor = currentActor.
	protected cancelled ::= false.
|repeating
		ifTrue: [self schedule: callback every: milliseconds] 
		ifFalse: [self schedule: callback after: milliseconds]) (
'as yet unclassified'
public cancel = (
	cancelled:: true.
	nil == process ifFalse: [process terminate. process:: nil].
)
public isActive ^<Boolean> = (
	cancelled ifTrue: [^false].
	^nil ~= process
)
public isTimer ^<Boolean> = (
	^true
)
protected schedule: callback after: ms = (
	|
	delay = SqueakDelay forMilliseconds: ms.
	msg = PendingDelivery
		receiver: [cancelled ifFalse: [callback value]]
		selector: #value
		arguments: {}
		resolver: nil.
	|
	process:: [delay wait. actor enqueueMessage: msg. process:: nil] newProcess.
	process name: 'One-shot timer for ', callback printString.
	process priority: 41.
	process resume.
)
protected schedule: callback every: ms = (
	(* When should we start ticking down for the next callback? When we schedule the callback, when the callback starts, or if-and-when the callback completes without an error? *)
	|
	delay = SqueakDelay forMilliseconds: ms.
	msg = PendingDelivery
		receiver: [cancelled ifFalse: [callback value: self]]
		selector: #value
		arguments: {}
		resolver: nil.
	|
	process:: [[delay wait. actor enqueueMessage: msg] repeat] newProcess.
	process name: 'Repeating timer for ', callback printString.
	process priority: 41.
	process resume.
)
) : (
'as yet unclassified'
public after: duration do: callback <[]> ^<Timer> = (
	^self __duration: duration callback: callback repeating: false
)
public every: duration do: callback <[:Timer]> ^<Timer> = (
	^self __duration: duration callback: callback repeating: true
)
)
protected class UIActor = Actor (
(* An actor whose turns run in the Squeak UI Process. *)) (
'as yet unclassified'
public enqueueMessage: actorMessage = (
	actorMessage postedTo: self.
	
	(* bogus - should drain an explicit queue to allow for a randomizing scheduler *)
	brazil theDesktop scheduleUIAction: [actorMessage deliverIn: self].
)
public printOn: stream = (
	stream nextPutAll: '[UIActor#'.
	identityHash printOn: stream.
	stream nextPutAll: ']'.
)
) : (
)
protected class WhenReactor onValue: v onError: e resolver: r = (
(* A when-catch for a promise.

Note that all slots contain objects that belong to the actor which sent #whenResolved:. *)|
	protected onValue <[:V] | []> = v.
	protected onError <[:E] | []> = e.
	protected resolver <InternalResolver> = r.
|) (
'as yet unclassified'
public reactBroken: value = (
	resolver __owner == currentActor ifFalse: [halt].
	currentActor enqueueMessage:
		(PendingDelivery 
			receiver: onError
			selector: #cull:
			arguments: {value}
			resolver: resolver).
)
public reactResolved: value = (
	resolver __owner == currentActor ifFalse: [halt].
	currentActor enqueueMessage:
		(PendingDelivery 
			receiver: onValue
			selector: #cull:
			arguments: {value}
			resolver: resolver).
)
) : (
)
'as yet unclassified'
private check: object allowedIn: actor = (
	assert: [nil ~= actor] message: 'Invalid actor'.
	
	(isPromise: object) ifTrue: [object __owner == actor ifFalse: [halt]].
	(isFarReference: object) ifTrue: [(internalFarReferences at: object) actor == actor ifTrue: [halt]].
	(* Otherwise near reference *)
)
public createActor: value <Value> name: debugName <String> ^<FarReference[Value]> = (
	(isValueObject: value) ifFalse: [Error signal: 'Cannot create an actor from a non-Value.'].
	^createFarReferenceTo: value in: (ProcessActor named: debugName) startEventLoop.
)
private createFarReferenceTo: target in: targetActor = (
	| internal external |
	internal:: InternalFarReference to: target inActor: targetActor.
	external:: FarReference wrapping: internal.
	internalFarReferences at: external put: internal.
	^external
)
private currentActor = (
	^Processor activeProcess actor ifNil: [uiActor].
)
private isFarReference: object <Object> ^<Boolean> = (
	^FarReference == (primitives classOf: object)
)
private isPromise: object <Object> ^<Boolean> = (
	^Promise == (primitives classOf: object)
)
private isValueObject: object <Object> ^<Boolean> = (
	nil == object ifTrue: [^true].
	true == object ifTrue: [^true].
	false == object ifTrue: [^true].
	object isString ifTrue: [^true].
	object isNumber ifTrue: [^true].
	object isCharacter ifTrue: [^true].
	object isBehavior ifTrue: [^isValueObject: object enclosingClass].
	^false
)
private wrapArgument: argument from: sourceActor to: targetActor = (
	(* [argument] lives in [sourceActor], answer the corresponding proxy that lives in [targetActor] *)

	sourceActor == targetActor ifTrue: [halt. (* We can't tell which side a near reference belongs to here, so we must have decided this earlier. *) ].

	(isFarReference: argument) ifTrue:
		[ | internalFarRef = internalFarReferences at: argument. |
		^internalFarRef actor == targetActor
			ifTrue: [internalFarRef target (* Unwrap far ref to object in target's heap: far ref becomes near ref. *)]
			ifFalse: [argument (* Pass along far ref to objects in other actors as-is (Granovetter introduction). *)]].
		
	(isPromise: argument) ifTrue:
		[^wrapPromise: argument from: sourceActor to: targetActor].
	
	(* Near ref *)
	^(isValueObject: argument)
		ifTrue: [argument (* Pass by copy *)]
		ifFalse: [createFarReferenceTo: argument in: sourceActor (* Pass by proxy *)].
)
private wrapArguments: arguments from: sourceActor to: targetActor = (
	^arguments collect: [:argument | wrapArgument: argument from: sourceActor to: targetActor].
)
private wrapPromise: promise from: sourceActor to: targetActor = (
	| resolverInSource resolverInTarget redirector msg |
	
	promise __owner == sourceActor ifFalse: [halt].	
	
	resolverInSource:: (internalResolvers at: promise) shortenResolution.
	resolverInSource __owner == targetActor ifTrue:
		[halt. (* Does E-ORDER require us to fork here as well? *)].
	
	resolverInSource state == #resolved ifTrue:
		[^wrapArgument: resolverInSource resolution from: sourceActor to: targetActor].
	
	resolverInSource finalResolverActor == targetActor ifTrue: 
		[^Promise withFuture: resolverInSource finalResolver __owner: targetActor].

	resolverInTarget:: InternalResolver __owner: targetActor.
	resolverInTarget finalResolver: resolverInSource finalResolver.
	resolverInTarget finalResolverActor: resolverInSource finalResolverActor.
	redirector:: RedirectReactor
		from: sourceActor
		to: targetActor
		resolver: resolverInTarget.
	msg:: PendingDelivery
		receiver: resolverInSource
		selector: #addReactor:
		arguments: {redirector}
		resolver: nil.
	sourceActor enqueueMessage: msg.
	
	^Promise withFuture: resolverInTarget __owner: targetActor
)
) : (
)
