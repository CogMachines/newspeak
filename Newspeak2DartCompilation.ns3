Newspeak3
'NS2Dart'
class Newspeak2DartCompilation usingPlatform: platform
	parsing: parsing
	generation: generation
	mirrors: mirrors 
	kernelClass: K = (
"Does the interesting work in Newspeak-to-Dart translation.

Throughout this module, the type annotation <Node> means a Dart AST, a subclass of DartGeneration`Syntax`Node.

Derived from the NS2JS compiler, in turn derived from the NS2Squeak compiler.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
	Dictionary = platform collections Dictionary.
	OrderedCollection = platform collections OrderedCollection.
	Set = platform collections Set.
	
	Parser = parsing Parser.
	parser = Parser new.
	
	astModule = parsing ASTModule. "Cheat-ish"
	ASTTool = astModule ASTTool.
      ASTCopier = astModule ASTCopier.
      SuperFalseVisitor = astModule FalseVisitor.
      AST = astModule AST.
	AssignmentAST = astModule AssignmentAST.
	BlockAST = astModule BlockAST.
	CascadedSendAST = astModule CascadedSendAST.
	CodeBodyAST = astModule CodeBodyAST.
	MessageAST = astModule MessageAST.
      MessagePatternAST = astModule MessagePatternAST.
	MethodAST = astModule MethodAST.
	NormalSendAST = astModule NormalSendAST.
	NumberAST = astModule NumberAST.
	ReturnStatAST = astModule ReturnStatAST.
      SendAST = astModule SendAST.
	SymbolAST = astModule SymbolAST.
	TupleAST = astModule TupleAST.
      VarDeclAST = astModule VarDeclAST.
	VariableAST = astModule VariableAST.
	
	dart = generation factory.
	DartWriter = generation Writer.
	
	LowLevelMirror = mirrors "LowLevel"Mirror.
	LowLevelMixinMirror = mirrors LowLevelMixinMirror.
	InstanceVariableMirror = mirrors InstanceVariableMirror.
	CompiledMixinMirror = mirrors CompiledMixinMirror.
	SlotMirror = mirrors SlotMirror.
	
	Kernel = K.
|)
(
class Compiler = (
"Translates Newspeak ASTs into Dart ASTs in three phases. First, scopes are computed an associated with ASTs. Second, ASTs are rewritten to capture information such as whether an implicit receiver send is an outer send or a self send, message sends that are reads and writes to locals, messages sends that are inlinable, and implied block-local returns. Third, the rewritten ASTs are translated into Dart ASTs. 

Dart ASTs are always constructed with names already mangled."|
	scopeMap <Map[AST,Scope]> ::= Dictionary new.
	scopeStack <List[Scope]> ::= OrderedCollection new.
	currentDepth <Integer>
	
	literalTable "Nix?"
	input <ReadStream>
	
	rewriter = Rewriter new.
	translator = Translator new.
	dartWriter = DartWriter new.
	
	inlineOperators ::= false.
	enableIntrinsics ::= false.
	|)
(
class Rewriter = ASTTool (
"A visitor that rewrites the AST into a form more suitable for compilation to Javascript. It may be possible to combine the pass that constructs the scopes with the rewriting pass, but this may be messy once we start inlining blocks etc."| 
	scope <Scope> 
	scopeStack <OrderedCollection[Scope]> = OrderedCollection new.
	protected readMap <Map[TemporaryAST, Integer]> = Dictionary new.
	protected writeMap <Map[TemporaryVariableAST, {Integer. Integer}]> = Dictionary new.
	protected valueExpected <Boolean> ::= true. "A flag set by visitor methods to indicate whether the parent AST uses the value of the currently visited node or not."
	protected areReturnsLocal <Boolean> ::= true. "Set to true while visiting nodes contained within a method and its inlined blocks, false in non-inlined blocks."
	protected rewritingMethodBody <Boolean> ::= true. "Set to true prior to visiting the code body of a method, to false prior to visiting one of a block."
	protected conditionalSelectors = Set withAll: {#ifTrue:ifFalse:. #ifFalse:ifTrue:. #ifTrue:. #ifFalse:}.
	protected inlinableOperators <Dictionary[String, String]> = Dictionary new.
	protected inlinableNumericOperators <Dictionary[String, String]> = Dictionary new.
|inlinableOperators
		at: #+ put: '+';
		at: #- put: '-';
		at: #* put: '*';
		at: #/ put: '/';
		at: #'==' put: '==='.
	inlinableNumericOperators	
		at: #'<' put: '<';
		at: #'<=' put: '<=';
		at: #'>' put: '>';
		at: #'>=' put: '>=')
(
class BlockLocalReturnAST expression: x start: s end: e = AST (
"This class represents a 'local return' (LR) -  a return from a block to its caller, as opposed to the caller of its enclosing method (a 'non-local return' or NLR).

An actual return statement in a block means an NLR; an LR is implicit in the source language, and occurs on the last statement of the block, unless that statement is a true return (NLR).  However, the back end of the compiler requires that this information be represented explicitly. This node does that."|
 expr <ExpressionAST> = x.
|start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool>  = (
	^aTool blockLocalReturnNode: self
)
isBlockLocalReturnAST ^<Boolean> = (
	^true
)) : ()
class BoolAST withValue: aBool <Boolean> start: s end: e = VariableAST (
""| val = aBool. |start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool boolNode: self
)
name = (
	^val printString asSymbol
)) : ()
class BoolVisitor = FalseVisitor ()
('as yet unclassified'
boolNode: node = (^true)) : ()
class ContextAST = VariableAST (
"Represents uses of thisContext. I expect these to be restricted in future versions. Currently, we use it for outer sends and super sends")
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool contextNode: self
)
name = (
	^#thisContext
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(thisContext)'
)) : ()
class ContextVisitor = FalseVisitor ()
('as yet unclassified'
contextNode: node = (^true)) : ()
class ExplicitReceiverVisitor = FalseVisitor ()
('as yet unclassified'
explicitOuterReceiverNode: aNode <ExplicitOuterRcvrAST> ^ <Boolean> = (
	^true
)) : ()
class ExplicitRecvrAST send: sym <Symbol> depth: d <Integer> = AST (
"Represents the receiver of an explicit outer send."|
	outerClassName <Symbol> = sym.
	depth <Integer> = d.
	selector <Symbol>
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool explicitOuterReceiverNode: self
)
isExplicitRcvrNode ^ <Boolean> = (
	^true
)
isExpressionNode ^ <Boolean> = (
	^true
)) : ()
class FalseVisitor = SuperFalseVisitor (
"Extends the standard FalseVisitor with methods for dealing with the node types introduced by the rewriter..")
('as yet unclassified'
boolNode: node = (^false)
contextNode: node = (^false)
ifNode: aNode <IfAST> ^ <Boolean> = (
	^false
)
implicitSendNode: aNode <ImplicitRcvrSendAST> ^ <Boolean> = (
	^false
)
loopNode: aNode <LoopAST> ^ <Boolean> = (
	^false
)
nilNode: node = (^false)
parameterNode: aNode <ParameterAST> ^ <Boolean> = (
	^false
)
receiverNode: aNode <ReceiverAST> ^ <Boolean> = (
	^false
)
returnInstVarMethodNode: aNode <ReturnInstVarMethodAST> ^ <Boolean> = (
	^false
)
returnSelfMethodNode: aNode <ReturnSelfMethodAST> ^ <Boolean> = (
	^false
)
superSendNode: aNode <SuperSendAST> ^ <Boolean> = (
	^false
)
superVarNode: aNode <SuperVarAST> ^ <Boolean> = (
	^false
)
temporaryNode: aNode <TemporaryVariableAST> ^ <Boolean> = (
	^false
)
variableNode: aNode = (
	^false
)) : ()
class ImplicitRecvrSendAST send: aMsg <MessageAST> depth: d <integer> = SendAST send: aMsg (
"
Represent a send of a message with an implicit receiver (aka a here send).
"| depth <Integer> ::= d. |)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool implicitSendNode: self
)
isExpressionNode ^ <boolean> = (
	^true
)
recv ^ <VarDeclAST> = (
  ^ assert:[false] message: 'There is no receiver node. It is implicit'
)) : ()
class ImplicitRecvrVisitor = FalseVisitor ()
('as yet unclassified'
implicitSendNode: aNode <ImplicitRcvrSendAST> ^ <Boolean> = (
	^true
)) : ()
class InlinableAsExpressionConditionalAST = NormalSendAST (
"Produced by the rewriter for the conditional messages whose value is required and which can be compiled into a Javascript ternary operator."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinableAsExpressionConditionalNode: self
)) : ()
class InlinableConditionalAST = NormalSendAST (
"Produced by the rewriter for conditional messages (ifTrue: and the like) that can be compiled into Javascript if statements instead of real message sends. To qualify, the message arguments should be literal blocks and the value of the message send should be ignored (for example, '^x ifTrue: [foo]' is not inlinable, while 'x ifTrue: [^foo]' is)."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinableConditionalNode: self
)) : ()
class InlinedOperatorAST = NormalSendAST (
"When the inlineOperators mode is on, message sends with certain selectors are replaced with this node. Javascript code generated for those nodes uses native Javascript operators instead of real message sends. The selector of the message of this AST is not a real Newspeak selector but rather the Javascript operator such as &&."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinedOperatorNode: self
)) : ()
class InstVarVisitor = FalseVisitor ()
('node traversal'
instVarNode: node = (^true)) : ()
class NilAST = VariableAST (
"")
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool nilNode: self
)
name = (
	^#nil
)) : ()
class NilVisitor = FalseVisitor ()
('as yet unclassified'
nilNode: node = (^true)) : ()
class ParameterAST name: n type: t = VarDeclAST name: n type: t (
"")
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool parameterDeclNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(', name, ')'
)'as yet unclassified'
variableClass ^ <ParameterVariableAST class> = (
	^ParameterVariableAST
)) : ()
class ParameterVariableAST name: n start: s end: e = VariableAST (
""name: n. start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool parameterNode: self
)) : ()
class ReceiverAST = VariableAST (
"")
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool receiverNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(self)'
)'as yet unclassified'
name = (
	^#self
)) : ()
class ReceiverVisitor = FalseVisitor ()
('node traversal'
receiverNode: node = (^true)) : ()
class SuperSendAST send: aMsg <MessageAST> = SendAST send: aMsg (
"This code is currently unused.  
Unlike Smalltalk, super calls in Newspeak cannot be statically bound.
Hence, we cannot use the Squeak VM's  super send byte codes. Currently, super sends are rewritten into a complex call structure by the rewriter, to ensure the correct binding of super.

When the Newspeak VM is modified to support dynamic binding of super sends, we will probably use this node and allied code,  which can easily be processed by the byte code compiler and code generator.")
('Unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool superSendNode: self
)
recv ^ <SuperVarAST> = (
  ^SuperVarAST new
)'as yet unclassified'
isExpressionNode ^ <boolean> = (
	^true
)) : ()
class SuperSendVisitor = FalseVisitor ()
('node traversal'
superSendNode: node <SuperSendAST> = (
      ^true
   )) : ()
class SuperVarAST = VarDeclAST name: #super type: nil (
"")
('Unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool superVarNode: self
)) : ()
class TemporaryAST name: n type: t = VarDeclAST name: n type: t (
""| initializer |)
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool temporaryDeclNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(', name, ')'
)'as yet unclassified'
isTemporaryAST ^ <Boolean> = (
	^true
)
variableClass ^ <TemporaryVariableAST class> = (
	^TemporaryVariableAST
)) : ()
class TemporaryVariableAST name: n start: s end: e = VariableAST (
"This node represents reference to a temporary variable."name: n.  start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool temporaryNode: self
)) : ()'as yet unclassified'
addLiteralConstant: s <Character | Number | String | Symbol> = ( 
	(literalTable includesKey: s) ifFalse: [literalTable at: s put: literalTable size].
)
addNumericLiteral: n <Number> = ( 
   addLiteralConstant: n
)
applyForEffectTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: false.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
applyForValueTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: true.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
assignmentFrom: aMsg <MessageAST> decl: vd <VarDeclAST> ^ <AssignmentNode> = (
	| var <VariableAST> varName <String> args selector <String> |
	assert: [aMsg args size = 1].
	selector:: aMsg sel asString.
	varName:: selector copyWithSize: (selector size -1).
	assert: [(currentScope at: varName asSymbol) isTemporaryAST].
	"what about setter methods - then we might have an inst var? this cannot happen, because this is only called when processing variables"
	var:: TemporaryVariableAST
		name: varName
		start: aMsg start
	 	end: aMsg end.

	args:: applyForValueTo: aMsg args first. "recurse on RHS"
	"this is where we note that a temporary is being written to; this information is necessary to determine which temporaries can be copied into closures and which have to be 'remote'"
	noteWriteOf: var.     
	"create an assignment"

	^AssignmentAST new 
		to: var assign: args;
		start: aMsg start;
		end: aMsg end                     
)
boolNode: node = (
	"Should not normally be invoked; only possible when rewriting an already rewritten tree."
	halt.
	^node
)
currentScope ^ <Scope> = (
	^scopeStack last
)
enclosingObjSendOfDepth: n <Integer> to: recv <AST> start: start <Integer> end: end <Integer>  ^ <NormalSendAST> = (
	^NormalSendAST new 
		recv: recv; 
		msg:(MessageAST new sel: (enclosingObjectMsgForDepth: n); args: {}; start: start; end: end);
		start: start; 
		end: end.
)
enclosingObjectMsgForDepth: n <Integer> ^ <String> = (
"Compute the selector necessary for obtaining the nth enclosing object wrt to the current lexical scope."
	| otable  <Dictionary[Symbol, Tuple[Class, Integer]]> ec <Class> |
	"What if n has no corresponding entry in the outer table? This should not happen, as this method is called on the basis of an n value found in the table to begin with."
	otable:: currentScope at: #outer.
	ec:: (otable values detect: [:some | (some at: 2) = (n-1)]) at: 1.
	^(Compiler new enclosingObjectMsgFor: ec) asSymbol
)
explicitOuterReceiverNode: node = (
	assert: [node apply: ExplicitReceiverVisitor new].
	^node
)
hereName = (
	^#'@here'
)
hereNode ^<AST> = (
	^VariableAST new name: hereName
)
inline: node as: sendClass selector: selector rewriteArgsAs: argRewriteBlock = (
	| receiver message |
	receiver:: applyForValueTo: node recv.
	message:: MessageAST new
		send: selector
		with: (node msg args collect: argRewriteBlock).
	^sendClass new
		to: receiver send: message;
		start: node start;
		end: node end
)
isHereNode: aNode <AST> ^ <Boolean> = (
	aNode isVariableNode ifFalse: [^false].
	(isPseudoVariableNode: aNode) ifTrue: [^false].
	assert: [aNode name = hereName].
	^true
)
isInlinableAsExpressionConditional: node <NormalSendAST> ^ <Boolean> = (
	(node msg sel = 'ifTrue:ifFalse:' and: [valueExpected]) ifFalse: [^false].
	node msg args do:
		[:each <AST> |
		((isRemovableBlock: each withArgs: 0)
			and: [each body statements size = 1
			and: [each body statements first isReturnStatNode not]])
				ifFalse: [^false]].
	^true
)
isInlinableBooleanOperator: node <NormalSendAST> = (
	| selector |
	selector:: node msg sel.
	^(selector = 'or:' or: [selector = 'and:'])
		and: [node msg args size = 1
		and: [node msg args first isBlockNode
		and: [node msg args first body statements size = 1]]]
)
isInlinableConditional: node <NormalSendAST> ^ <Boolean> = (
	((conditionalSelectors includes: node msg sel) and: [valueExpected not]) ifFalse: [^false].
	node msg args do: [:each <AST> | (isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
	^true
)
isInlinableNumericOperator: node <NormalSendAST> = (
	| args |
	args:: node msg args.
	args size = 1 ifFalse: [^false].
	(inlinableNumericOperators includesKey: node msg sel) ifFalse: [^false].
	(node recv isLiteralNode and: [node recv val isNumber]) ifTrue: [^true].
	(args first isLiteralNode and: [args first val isNumber]) ifTrue: [^true].
	^false
)
isInlinableOperator: node <NormalSendAST> = (
	^(inlinableOperators includesKey: node msg sel)
		and: [node msg args size = 1]
)
isInlineableLoop: node <NormalSendAST> ^ <Boolean>= (
	| selector <Symbol>  args |
	selector:: node msg sel.
	args:: node msg args.
	({#whileTrue. #whileFalse. #whileTrue:. #whileFalse:. #repeat} includes:  selector) ifTrue:
		[args do:
			[:each |
			(isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
		^isRemovableBlock: node recv withArgs: 0].
	
	(selector = #timesRepeat:) ifTrue:[^isRemovableBlock: args last withArgs: 0].
	({#to:do:. #to:do:by:}  includes:  selector) ifFalse:[^false].
	(isRemovableBlock: args last withArgs: 1) ifFalse:[^false].
	(selector = #to:do:) ifTrue:[^true].
	args size = 3 ifFalse:[^false].
)
isOuterNode: aNode <AST> ^ <Boolean> = (
	aNode isVariableNode ifFalse: [^false].
	^aNode name = #outer
)
isPseudoVariableNode: aNode <VariableAST> ^ <Boolean> = (
	^aNode name = #self
		or: [aNode name = #super
		or: [aNode name = #outer
		or: [aNode name = #thisContext]]]
)
isSuperNode: aNode <VariableAST> ^ <Boolean> = (
	aNode isVariableNode ifFalse:[^false].
	^aNode name =  #super 
)
mixinApplication: node <MixinApplicationAST> = (
	| msg |
"For now, just compile it as a regular message send"
	msg:: MessageAST new
			send: #apply:
			with: (OrderedCollection with: node superclassExpr);
			start: node start;
			end: node end.

	^(NormalSendAST new
		to: node mixinExpr send: msg;
		start: node start;
		end: node end) apply: self
)
nilNode: node = (
	"Should not normally be invoked; only possible when rewriting an already rewritten tree."
	halt.
	^node
)
noteReadOf: t <TemporaryAST>  = (
	| lastRead <integer> |
"earliest read nested in a closure"
	lastRead:: readMap at: t ifAbsent: [readMap at: t put: currentScope end. ^self].
	"if t has not yet been read, record this read in the map and exit; otherwise, find out what the last recorded value was"
	readMap at: t put: (lastRead min: currentScope end)
	"record the minimum of the last recorded value and the end of the current block. If a read occurs in a nested block, that block will end before the enclosing block or method,  and the block's ending will be recorded"
)
noteWriteOf: t <TemporaryVariableAST>  = (
"Location of last write, and minimal block ending."
	| lastWrite <Integer> prevBlockEnd <Integer> |
	
	prevBlockEnd:: (writeMap at: t ifAbsent:[{0. 0}]) last.
	lastWrite:: Array new: 2.
	lastWrite at:1  put: t start. "record source start index of last write"
	lastWrite at: 2 put: (currentScope end min: prevBlockEnd). "record end of block of any nested write"
	writeMap at: t put: lastWrite.
)
oldProcessExplicitOuterSend: aMsg <MessageAST> atDepth: n = (


| holder <NormalSendAST>  ctxt <VariableAST> start <Integer> end <integer> 
enclosingObj <NormalSendAST>  nonMeta  <NormalSendAST> 
 |
"For n > 0, return
thisContext methodClass enclosingObject`Cn ... C0 
                                         class enclosingObject`Cn ...`C1  ...  
                                            class enclosingObject`Cn`Cn-1 msg

which is the equivalent of

outer X msg

where X is the nth lexically enclosing class. Otherwise, do a self send"

n = 0 ifTrue:[^selfSendFrom: aMsg].
start:: aMsg start.
end:: aMsg end.
ctxt:: VariableAST new name: #thisContext; start: start; end: end.

holder:: NormalSendAST new recv: ctxt;
                                             msg: (MessageAST new sel:#lexicalClass; args: {});
                                              start: start; end: end.

nonMeta:: NormalSendAST new recv: holder;
                                             msg: (MessageAST new sel:#theNonMetaClass; args: {});
                                              start: start; end: end.

enclosingObj::  enclosingObjSendOfDepth: 1 to: nonMeta start: start end: end. 

enclosingObj:: (2 to: n) inject: enclosingObj into:[:r <NormalSendAST> :i <Integer> | 
	| csend <NormalSendAST> |
	  csend::  NormalSendAST new recv: r; 
	                                               msg:(MessageAST new sel: #class; args: {}; start: start; end: end);
	                                               start: start; 
	                                               end: end.
	 enclosingObjSendOfDepth: i to: csend start: start end: end. 
	 ].
^(NormalSendAST new recv: enclosingObj; msg: aMsg; start: start; end: end) apply: self
)
parameterNode: node <ParameterVariableAST> = (
	^node
)
processExplicitOuterReceiver: aMsg <MessageAST> = (
	| selectorBinding <AST> depth <integer> |
	assert:[aMsg args isEmpty]. "this had better be a unary message"
	selectorBinding:: currentScope at: aMsg sel.
	"assert:[selectorBinding data  isClassDeclarationAST]."
	depth: currentDepth -  selectorBinding depth -1.
	addNumericLiteral: depth. "the backend checks that depth in 0 - 256"
	^(ExplicitRecvrAST send: aMsg sel depth: depth)
		start: aMsg start;
		end: aMsg end
)
processExplicitOuterSend: aMsg <MessageAST> = (
"Unused at the moment"
)
processHereSend: aMsg <MessageAST> = (
	| binding <AST> |
	binding:: currentScope at: aMsg sel ifAbsent: [MessageAST new].
	binding isMessagePatternNode ifTrue:
		["this is a message send for a lexically defined method"
		^processImplicitOuterSend: aMsg atDepth: binding depth].
	binding isVarDeclNode
		ifTrue: [^ processVariable: aMsg decl: binding].
	({#true. #false. #nil} includes: aMsg sel) ifTrue:
		[^processVariable: aMsg decl: nil].
	^selfSendFrom: aMsg
)
processImplicitOuterSend: aMsg <MessageAST> atDepth: n <Integer> ^ <SendNode> = (
	"In this case, we don't care about the depth; but when compiling to other platforms, we might, so we maintain the API"
	| selectorBinding <AST> depth <integer> |
	selectorBinding:: currentScope at: aMsg sel.
	"assert:[selectorBinding data  isClassDeclarationAST]."
	depth: currentDepth -  selectorBinding depth.
	addNumericLiteral: depth. "the backend checks that depth in 0 - 256"
	^(ImplicitRecvrSendAST send: (aMsg apply: self) depth: depth) start: aMsg start; end: aMsg end
)
processOuterSend: aMsg <MessageAST> = (
	| holder <NormalSendAST> depth <Integer> binding <AST>  meMsg <MessageAST> |
	assert: [aMsg args isEmpty]. "this had better be a unary message"
	binding:: (currentScope at: #outer) at: aMsg sel.
	"assert binding makes sense "
	assert: [binding isKindOf: Collection].
	"assert: [binding first isKindOf: Class]." "disabled temporarily until we get the class story straight on the JS side"
	assert: [binding last isKindOf: Integer].

	meMsg:: MessageAST new sel: #yourself; args: {}; start: aMsg start; end: aMsg end. "hack!"
	^processOuterSend: meMsg atDepth: binding last
)
processOuterSend: aMsg <MessageAST> atDepth: n = (
"For n > 0, return
thisContext methodClass enclosingObject`Cn ... C0 
                                         class enclosingObject`Cn ...`C1  ...  
                                            class enclosingObject`Cn`Cn-1 msg

which is the equivalent of

outer X msg

where X is the nth lexically enclosing class. Otherwise, do a self send"

	| holder <NormalSendAST> ctxt <VariableAST> start <Integer> end <integer> 
	enclosingObj <NormalSendAST> nonMeta <NormalSendAST>  |

	n = 0 ifTrue: [^selfSendFrom: aMsg].
	start:: aMsg start.
	end:: aMsg end.
	ctxt:: VariableAST new name: #thisContext; start: start; end: end.

	holder:: NormalSendAST new
		recv: ctxt;
	 	msg: (MessageAST new sel: #lexicalClass; args: {});
		start: start; end: end.
	nonMeta:: NormalSendAST new
		recv: holder;
		msg: (MessageAST new sel: #theNonMetaClass; args: {});
		start: start; end: end.
	enclosingObj:: enclosingObjSendOfDepth: 1 to: nonMeta start: start end: end. 

	enclosingObj:: (2 to: n) inject: enclosingObj into:
		[:r <NormalSendAST> :i <Integer> | 
		| csend <NormalSendAST> |
		csend:: NormalSendAST new
			recv: r; 
			msg: (MessageAST new sel: #class; args: {}; start: start; end: end);
			start: start; 
			end: end.
		enclosingObjSendOfDepth: i to: csend start: start end: end].
	^(NormalSendAST new recv: enclosingObj; msg: aMsg; start: start; end: end) apply: self
)
processVariable: aMsg <MessageAST> decl: vd <VarDeclAST>  ^ <AssignmentNode | VariableNode> = (
	^aMsg sel last = $:
		ifTrue: "it is a temporary write"
			[assignmentFrom: aMsg decl: vd]
		ifFalse: "it is a parameter or temporary read"
			[variableFrom: aMsg decl: vd]
)
propertyCallNode: node <PropertyCallAST> ^ <PropertyCallAST> = (
	| args |
	assert: [node isMessageNode].
	args:: OrderedCollection new.
	node args do: [:each | args add: (applyForValueTo: each)].
	addLiteral: node sel.
	^PropertyCallAST new
		send: node sel with: args;
		start: node start;
		end: node end
)
returnsAreNonLocalWhile: block = (
	| originalValue |
	originalValue: areReturnsLocal.
	areReturnsLocal: false.
	^block ensure: [areReturnsLocal: originalValue]
)
rewriteInlinedBlockNode: node <BlockAST> ^ <BlockAST> = (
"An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined."
	| 
	rewrittenNode <BlockAST> 
      params <Collection[ParameterAST]>  
      bodyScope <Scope> 	
	| 
	assert: [node isBlockNode].
	"this shouldn't be handled here, but I'm not sure where the block / codebody 
	comes from."
	node body start isNumber
		ifFalse: [ node body start: node start. node body end: node end ].
	
	params:: node parameters collect:
		[:p <VarDeclAST> |
		(ParameterAST name: p name type: p type)  start: p start; end: p end].
	bodyScope:: scopeMap at: node body.
	params do: [:each | (bodyScope at: each name) data: each].
	addNumericLiteral: node parameters size.
	rewritingMethodBody: false.
	rewrittenNode:: BlockAST new body: (node body apply: self).
	rewrittenNode start: node start; end: node end.
	rewrittenNode body parameters: params.
	node body statements isEmpty ifTrue:
		[rewrittenNode body statements add: (NilAST new start: node body start; end: node body end)].
    ^rewrittenNode
)
selfSendFrom: aMsg <MessageAST>  ^ <MessageNode> = (
	^(NormalSendAST new
		msg: aMsg; 
		recv: (selfNode start: aMsg start; end: aMsg end);
		start: aMsg start; end: aMsg end) apply: self
)
setterBlockArgName = (
	^ ('setter_arg') asSymbol
)
xsetterSendNode: node <SetterSendAST> ^ <AST> = (
"Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send."
	| binding block blockArg send rewrittenSetterSend |
	assert: [node isSetterSendNode ].
	binding:: currentScope at: node msg sel ifAbsent: [MessageAST new].
	binding isVarDeclNode ifTrue:
		"This is an assignment to a temporary; no special handling is needed
		as the value of the expression is the value being assigned."
		[^processVariable: node msg decl: binding].
	valueExpected ifFalse:
		"The parent ignores the expression value; use a plain cheap here message send."
		[^processHereSend: 
			(MessageAST new
				sel: node msg sel;
				args: {applyForValueTo: node msg args first})].
	"The value is used by the parent; rewrite the whole thing as
		setter:: expr  =>  [:a | setter: a. a] value: expr"
	"a -- ok to use a constant name as long as it cannot collide with a user's name"
	blockArg:: ParameterVariableAST name: setterBlockArgName start: nil end: nil.
	"setter: a"
	send:: processHereSend:
		(MessageAST new
			sel: node msg sel;
			args: {blockArg}).
	"send:: applyForEffectTo: send."
	"[:a | setter: a. a]"
	block:: BlockAST new body:
		(CodeBodyAST new
			parameters: {ParameterAST name: setterBlockArgName type: nil}
			temporaries: {}
			statements: {
				send.
				"Need an explicit return because this is not rewritten again."
				BlockLocalReturnAST
					expression: blockArg
					start: node start
					end: node end
			}).
	"[:a | setter: a. a] value: expr"
	rewrittenSetterSend::
		NormalSendAST new
			to: block
			send: (MessageAST new
				sel: #value:;
				args: {applyForValueTo: node msg args first}).
	"TBD: What am I supposed to do with scopeMap here? Original code follows."
	"cb:: (CodeBodyAST new
			parameters: {};
			temporaries: {};
			statements: {sTempAssign. send. sTemp})."
	"scopeMap at: cb put: currentScope."
	^rewrittenSetterSend
)'closures'
currentSegment ^ <Integer> = (
	^0 "default until we implement it properly"
)
lastWriteOf: t <TemporaryAST> ^ <Integer> = (
	^0 "default for now"
)
readsOf: t <TemporaryAST> ^ <Set[Integer]> = (
	^Set new
)
segmentOf: t <TemporaryAST> ^ <Integer> = (
	^0 "default until we get a real implementation"
)
setSegmentOf: t <TemporaryAST> to: i <Integer> = (
	"default until we get a real implementation"
)'node traversal'
assignmentNode: node <AssignmentAST> ^ <AssignmentAST> = (
	assert: [node isAssignmentNode].
	"note write to target variable!"
	^AssignmentAST new
		to: (node var apply: self) assign: (applyForValueTo: node expr);
		start: node start; end: node end
)
blockLocalReturnNode: node = (
	^node
)
blockNode: node <BlockAST> ^ <BlockAST> = (
	" This method should only be called on a block that is not going to be inlined.

	There are two things that require rewriting in blocks.

	1. a.  Non-empty blocks must have their body rewritten recursively
	    b. Empty blocks need a nil expression in them.
	    c. All blocks must have their parameters rewritten from generic VarDecls to ParameterASTs. 
	2. If the last statement in a block is not a return, the block returns
	the expression to its caller. So the last expression needs to be replaced by a 'local return'.

	We accomplish (1) by calling rewriteInlinedBlockNode:, and then do  (2) explicitly.

	The reason for this separation is that step (1) is always needed; step (2) is only needed if the block is not inlined.
	"
	| rewrittenBlock <BlockAST> last <AST> |
	rewritingMethodBody: false.
	returnsAreNonLocalWhile:
		[rewrittenBlock:: rewriteInlinedBlockNode: node.
		last:: rewrittenBlock body statements last.
		(last isReturnStatNode or: [last isBlockLocalReturnAST]) ifFalse:
			["The last expression in a block is returned by it."
			rewrittenBlock body statements removeLast.
			rewrittenBlock body statements add:
				(BlockLocalReturnAST expression: last start: last start end: last end)].
  	  scopeMap at: rewrittenBlock put: (scopeMap at: node)].
    ^rewrittenBlock
)
cascadedSendNode: node <CascadeSendAST> ^ <CascadeSendAST> = ( 
	| prevSend msg |
	assert: [node isCascadedSendNode].
	prevSend:: applyForValueTo: node prevSend.
	msg:: applyForValueTo: node msg.
	^CascadedSendAST new to: prevSend cascade: msg;
							start: node start;
							end: node end;
							yourself
)
charNode: node <CharAST> = (
	addLiteralConstant: node val.
	^node
)
codeBodyNode: node <CodeBodyAST> ^ <CodeBodyAST> = (
	| 
	bodyScope <Scope>
	statements <OrderedCollection[StatementAST]>
	temps <OrderedCollection[TemporaryAST]> 
	result <CodeBodyAST>
	|
	assert: [node isCodeBodyNode].
	pushScopeForNode: node. 
	temps:: node temporaries collect:
		[:each <VarDeclAST> |
		(TemporaryAST name: each name type: each type)
			initializer: (each initializer ifNotNil: [:it | self applyForValueTo: it]);
			start: each start;
			end: each end.
		].
	bodyScope:: scopeMap at: node.
	temps do:
		[: t | (bodyScope at: t name)  data: t].
	statements:: OrderedCollection new.
	node statements keysAndValuesDo:
		[:index :statement | 
		| rewritten |
		rewritten:: (index = node statements size and: [rewritingMethodBody not])
			ifTrue: [applyForValueTo: statement]
			ifFalse: [applyForEffectTo: statement].
		statements add: rewritten].
	result:: CodeBodyAST new
		parameters: node parameters temporaries: temps statements: statements;
		start: node start;
		end: node end.
	popScope.
	scopeMap at: result put: bodyScope.
	^result.
)
genericApplicationExpressionNode: node = (
	assert: [node isGenericApplicationExpressionNode].
	^applyForValueTo: node target
)
guaranteedNode: node = (
	assert: [node isGuaranteedNode].
	^applyForValueTo: node expr
)
ifNode: node <ifAST> ^ <ifAST> = (
	assert: [ node isIfNode ].
	^node
)
implicitSendNode: node = (
    assert: [node apply: ImplicitRecvrVisitor new].
    ^node
)
loopNode: node <LoopAST> ^ <LoopAST> = (
    ^node
)
messageNode: node <MessageAST> ^ <MessageAST> = (
    | args |
    assert: [node isMessageNode].
    args:: OrderedCollection new.
    node args do: [ :arg | args add: (applyForValueTo: arg)].
    addLiteral: node sel.
    ^MessageAST new send: node sel with: args; start: node start; end: node end
)
messagePatternNode: node <MessagePatternAST> ^ <MessagePatternAST> = (
	| params <OrderedCollection[ParameterAST]>  patternScope <Scope> |
	params:: node parameters collect:
		[:p <VarDeclAST> | 
		(ParameterAST name: p name type: p type)
			start: p start;
			end: p end].
	patternScope:: scopeMap at: node.
	params do:
		[:p | (patternScope at: p name) data: p].
	^MessagePatternAST new
		selector: node selector parameters: params;
		start: node start;
		end: node end.
)
methodNode: node <MethodAST> ^<MethodAST | ReturnSelfMethodAST | ReturnInstVarMethodAST>
= (
	| 
	pattern <MessagePatternAST>  
	body <CodeBodyAST>
	result <MethodAST>
	|
	assert: [ node isMethodNode ].
	literalTable:: Dictionary new.
	pattern:: applyForValueTo: node pattern.
	rewritingMethodBody: true.
	body::  applyForValueTo: node body.
	body parameters: pattern parameters.
	body start: node start; end: node end.
	"Append ^self if there is no explicit return terminating the body.
	We are at the method level so that return should have been rewritten as a block local one."
	(body statements isEmpty not and: [body statements last isBlockLocalReturnAST]) ifFalse:
		[assert: [ body start isNumber ]. 		
		body statements addLast:
			(BlockLocalReturnAST
				expression: (ReceiverAST new start: body end; end: body end)
				start: body end
				end: body end)].
	result:: MethodAST new 
		pattern: pattern
		body: body
		visibility: node visibility;
		start: node start; end: node end; yourself.
	scopeMap at: result put: (scopeMap at: node).
	^result
)
mixinClassNode: node = (
	^node
)
normalSendNode: node <NormalSendAST> ^ <AST> = (
	| recv <AST> msg <MessageAST> sel <Symbol> |
	assert: [node isNormalSendNode].

	(isHereNode: node recv) ifTrue:
		[^processHereSend: node msg].
	(isOuterNode: node recv) ifTrue:
		[^processExplicitOuterReceiver: node msg].
	(isSuperNode: node recv) ifTrue:
		[^SuperSendAST send: (applyForValueTo: node msg)].

#FLAG.
"	(isInlinableAsExpressionConditional: node) ifTrue:
		[^inline: node as: InlinableAsExpressionConditionalAST
			selector: node msg sel
			rewriteArgsAs: [:each | rewriteInlinedBlockNode: each]].
	(isInlinableConditional: node) ifTrue:
		[^inline: node as: InlinableConditionalAST
			selector: node msg sel
			rewriteArgsAs: [:each | rewriteInlinedBlockNode: each]].
	(inlineOperators and: [isInlinableNumericOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableNumericOperators at: node msg sel)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableOperators at: node msg sel)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableBooleanOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (node msg sel = 'and:' ifTrue: ['&&'] ifFalse: ['||'])
			rewriteArgsAs: [:each <BlockAST> | applyForValueTo: each body statements first]].		
"
	recv:: applyForValueTo: node recv.
	msg:: applyForValueTo: node msg.
	sel:: msg sel.
	^NormalSendAST new
		to: recv send: msg;
		start: node start;
		end: node end
)
numberNode: node = (
	assert: [node isNumberNode].
	addNumericLiteral: node val.
	^node
)
receiverNode: node <ReceiverAST> = (
	^ node
)
returnInstVarMethodNode: node = (
	^node
)
returnStatNode: node <ReturnStatAST> ^ <ReturnStatAST> = (
	assert: [node isReturnStatNode].
	^areReturnsLocal
		ifTrue:
			[BlockLocalReturnAST
				expression: (applyForValueTo: node expr)
				start: node start
				end: node end]
		ifFalse:
			[ReturnStatAST new
				expr: (applyForValueTo: node expr); 
		 		start: node start;
				end: node end]
)
selfNode ^ <VariableAST> = (
"shouldn't this be a ReceiverAST?"
"generate a an AST representing self; used for implicit self sends"
	^VariableAST new name: #self; start: 0; end: 0
)
setterSendNode: node <SetterSendAST> ^ <AST> = (
"Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send."
	| binding block blockArg blockParam blockScope send rewrittenSetterSend |
	assert: [node isSetterSendNode ].
	binding:: currentScope at: node msg sel ifAbsent: [MessageAST new].
	binding isVarDeclNode ifTrue:
		"This is an assignment to a temporary; no special handling is needed
		as the value of the expression is the value being assigned."
		[^processVariable: node msg decl: binding].
	valueExpected ifFalse:
		"The parent ignores the expression value; use a plain cheap here message send."
		[^processHereSend: 
			(MessageAST new
				sel: node msg sel;
				args: {node msg args first};
				start: node msg start; end: node msg end)].
	"The value is used by the parent; rewrite the whole thing as
		setter:: expr  =>  [:a | setter: a. a] value: expr"
	"a -- ok to use a constant name as long as it cannot collide with a user's name"
	blockArg:: ParameterVariableAST 
					name: setterBlockArgName 
					start: node msg start 
					end: node msg end.
	blockParam:: ParameterAST name: setterBlockArgName type: nil.
	"setter: a"
	send:: NormalSendAST new to: node recv send:
		(MessageAST new sel: node msg sel; args: {blockArg};
		start: node msg start; end: node msg end; yourself);
		start: node  start; end: node  end.
	"[:a | setter: a. a]"
	block:: BlockAST new body:
		(CodeBodyAST new
			parameters: {blockParam}
			temporaries: {}
			statements: {
				send.
				blockArg
			};			
			start: node start; end: node end);
			start: node start; end: node end.
	blockScope:: Scope new.
	blockScope
		superScope: currentScope;
		at: setterBlockArgName put: (SemanticVarDecl decl: {blockParam}).
	scopeMap at: block put: blockScope.
	scopeMap at: block body put: blockScope.
	"[:a | setter: a. a] value: expr"
	rewrittenSetterSend::
		NormalSendAST new
			to: block
			send: (MessageAST new
				sel: #value:;
				args: {node msg args first};
				start: node msg start; end: node msg end);
				start: node  start; end: node  end.
	^applyForValueTo: rewrittenSetterSend
)
stringNode: node = (
	assert: [node isStringNode].
	addLiteralConstant: node val.
	^node
)
superSendNode: node = (
	assert: [node apply: SuperSendVisitor new].
	^node
)
symbolNode: node = (
	assert: [node isSymbolNode].
	addLiteralConstant: node val.
	^node
)
temporaryNode: node <TemporaryVariableAST> = (
	"Possibily " #BOGUS.
	^node
)
tupleNode: aNode <TupleAST> = (

	^TupleAST new elements: (aNode elements collect: [:e | e apply: self])

"Rewrite into a tree representing the expression
	(Array new:  n) at: 1 put:: e1 ; ...  at: n put: en; yourself
where n is the size of the tuple."
"	|
	arrayNode <NormalSendAST> 
	arrayLengthNode <NumberAST> 
	tupleInitializationNodes <List[NormalSendAST]>
	index <Integer>
	|
	arrayLengthNode:: NumberAST new val: aNode elements size.
	arrayLengthNode start: aNode start; end: aNode end.
	arrayNode:: NormalSendAST new
		to: (NormalSendAST new 
				to: hereNode 
				send:  (MessageAST new
					sel: #Array;
					args: {};
					start: aNode start;
					end: aNode end)) 
		send: (MessageAST new
				sel: #new:;
				args: {arrayLengthNode};
				start: aNode start;
				end: aNode end).
	arrayNode start: aNode start; end: aNode end.
	aNode elements size = 0 ifTrue: [^applyForValueTo: arrayNode].
	index:: 0.
	tupleInitializationNodes:: aNode elements inject: arrayNode into:
		[:r : e |  | msg <MessageAST> |
	      index:: index + 1.
	      msg:: MessageAST new
			sel: #at:put:; 
			args: 
				{NumberAST new val: index; start: aNode start; end: aNode end.
				e}.
		msg start: aNode start; end: aNode end.
	      index = 1 
			ifTrue: 
				[NormalSendAST new to: r send: msg; start: aNode start; end: aNode end] 
				
	      	ifFalse: 
				[CascadedSendAST new to: r cascade: msg; start: aNode start; end: aNode end].
				
		].
	^applyForValueTo:
		((CascadedSendAST new
			to: tupleInitializationNodes
			cascade:
					(MessageAST new
						sel: #yourself;
						args: {};
						start: aNode start;
						end: aNode end))
				start: aNode start;
				end: aNode end)"
)
variableNode: aNode <VariableAST> = (
	assert: [ aNode start isNumber ].
	aNode name = #self ifTrue:
		[^ReceiverAST new start: aNode start; end: aNode end].
	aNode name = #nil ifTrue:
		[^NilAST new start: aNode start; end: aNode end].
	aNode name = #true ifTrue:
		[^BoolAST withValue: true start: aNode start end: aNode end].
	aNode name = #false ifTrue:
		[^BoolAST withValue: false start: aNode start end: aNode end].		
	aNode name = #thisContext ifTrue:
		[^ContextAST new start: aNode start; end: aNode end].
	"recognize inst vars for accessor methods? handle temps etc."
	^aNode
)'private'
addLiteral: literal <Character | Number | String | Symbol> = ( 
	(literalTable includesKey: literal) ifFalse:
		[literalTable at: literal put: literalTable size].
)
at: node error: msg = (
	"Simple solution for now - fix this at some point"
	('error: ', msg) out.
	halt
)
isRemovableBlock: block <BlockAST> withArgs: nofArgs <Integer> ^ <Boolean> = (
"Answers true if block can be removed (inlined) within another block."
	block isBlockNode ifFalse: [^false].
	block parameters size = nofArgs ifFalse: [^false].
	^true
)
parameters: pars matchArguments: args
 = (
 | i |
	#BOGUS yourself. "appears to be unused; delete if so"
 i:: pars size.
 
 "Proceed if no. of parameter matches no. of arguments"
 pars size = args size ifFalse: [ ^ false ].
 
 "check individual arguments, starting with last one"
 i:: pars size.
 [ i > 0 ] whileTrue: [
  (args at: i) isRefNode ifFalse: [ ^ false ].
  (pars at: i) == (args at: i) decl ifFalse: [ ^ false ].
  i:: i - 1
 ].
 
 "parameters & arguments match 1-to-1, in same order"
 ^ true
)
popScope ^ <Scope> = (
	^scopeStack removeLast
)
pushScope: s <Scope> = (
	scopeStack addLast: s
)
pushScopeForNode: n <AST> = (
	scopeStack addLast: (scopeMap at: n)
)
variableFrom: message <MessageAST> decl: declaration <VarDeclAST>  ^ <VariableNode> = (
	assert: [message args isEmpty].
	declaration isNil ifTrue:
		[^(VariableAST new
			name: message sel;
			start: message start;
			end: message end)
				apply: self].
	declaration isTemporaryAST ifTrue: [noteReadOf: declaration].
	^declaration variableClass
		name: message sel
		start: message start
		end: message end                    
)) : ('as yet unclassified'
REFACTORING = (
	"This rewritter and the one used for JavaScript are likely to continue to have very similar requirements and should someday be factored out, rather than duplicated."
))
class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = ASTTool ("The scope builder is a visitor on the AST. It computes a tree of scopes that shadows the AST itself.  More precisely, it computes a mapping from ASTs to their scopes. This allows us to get to the appropriate scope for an abstract syntax node without pollluting the AST with extraneous data like scopes.

We could associate each node in the AST with the scope in which it is found, but this would be overkill. Instead, only nodes that actually introduce new scopes (such as class sides, message patterns, code bodies and blocks) actually get mapped in this manner. The intent is that later phases of compilation will visit the tree and look up the scopes at the points where they are introduced.

The builder starts at a given node, in the context of some mixin, described by a mirror.  This is because, in an incremental environment, we may not have the complete AST for a module, but instead be asked to process a part of that module, such as a nested class, slot definition or method. The surrounding scope can be computed from the mirror representing the immediately enclosing mixin.

Then we traverse the tree, creating and populating new scopes as needed. We maintain a stack of scopes (scopeStack) that initially contains only the surrounding scope.  Scopes get pushed on to the stack when we encounter a node that introduces a scope, and popped when we finish with that node. The scopes are chained to their super scopes (the scope below them on the stack).

A possible optimization is to avoid a traversal of an entire side of a class.
One can process only a side without its subtrees (i.e., methods and nested classes). These can be visited later,  as long as we ensure that the processing of the subtree begins with a proper super scope on top of the scope stack."| 
  scopeStack = OrderedCollection new.
  
  currentDepth ::= initialDepth. "The lexical nesting level of the class declaration currently 
						being visited; top level classes are level 0"
|pushScope: initialScope)
('as yet unclassified'
blockNode: aNode <BlockAST> = (
	| ps <Scope> |
	ps:: Scope new.
	"establish parameter scope"
	aNode parameters do:[:p <VarDeclAST> | ps at: p name put: (SemanticVarDecl decl: {p. currentDepth})].
	nestScope: ps.
	"visit body"
	aNode body apply: self.
	scopeMap at: aNode put: (scopeMap at: aNode body).
	popScope "pop the parameter scope, ps"
)
buildScopeFor: m <MixinMirror> ^ <Scope> = (
	^prvtScopeFor: m.
)
cascadedSendNode: aNode <CascadedSendAST> = (
"generic traversal code"
"visit receiver and messages"
	aNode prevSend apply: self.
	aNode msg apply: self.
)
charNode: aNode <CharAST> = (
"do nothing"
)
classHeaderNode: aNode = (
	aNode constructor apply: self.
	aNode slots do: [:s |  s initializer ifNotNil: [:i | i apply: self]].
	aNode initExprs do: [: e | e apply: self].
)
classNode: aNode <ClassDeclarationAST> = (
	| vs <Scope> |
	currentScope
		at: aNode name 
		put: (SymbolTableEntry for: {MessagePatternAST new selector: aNode name. currentDepth}).
	vs:: Scope new. "establish instance side scope"
	currentDepth:: currentDepth + 1.
	aNode hdr slots do:
		[:v <SlotDeclAST> | 
		vs at: v name put: (SymbolTableEntry for: {MessagePatternAST new selector: v name. currentDepth}).
		v isMutable ifTrue:
			[vs at: (v name asString, ':') asSymbol
				put: (SymbolTableEntry for: {MessagePatternAST new selector: (v name asString, ':') asSymbol. currentDepth}) "setter"]
    	 ].
	self nestScope: vs.
  	aNode instanceSide apply: self.
	popScope.
  	aNode classSide apply: self.
	currentDepth:: currentDepth - 1.
)
codeBodyNode: aNode <CodeBodyAST> = (
	| ts <Scope> |
	"establish local slot scope"
	ts:: Scope new.
	aNode temporaries do:
		[:t <SlotDefAST> | 
		ts at: t name put: (SemanticVarDecl decl:{t slotDecl. currentDepth}); " getter"
		at: (t name asString, ':') asSymbol put: t slotDecl "setter"].
	ts end: aNode end. "we need to know where this scope ends"
	nestScope: ts.
	scopeMap at: aNode put: ts.
	"visit statements"
	aNode statements do:[: s <ReturnStatementAST | SendAST>  | s apply: self].
	popScope.
)
currentScope ^ <Scope> = (
	^scopeStack last
)
enclosingMixinsOf: m <MixinMirror> ^ <Collection[MixinMirror]> = (
	| e enclosers |
	^m enclosingClassStencil enclosingClassStencils collect: [:stencil | stencil mixin]
)
isPseudoVariableNode: aNode <VariableAST> ^ <Boolean> = (
	^aNode name = #self or:
		[aNode name = #super or:
		[aNode name = #outer or:
		[aNode name = #thisContext]]]
)
messageNode: aNode <MessageAST> = (
"generic traversal code"
"visit arguments"
	aNode args do: [:a <SendAST> | a apply: self]
)
messagePatternNode: aNode <MessagePatternAST> = (
	| ps <Scope> |
	ps:: Scope new.
	"establish parameter scope"
	aNode parameters do:
		[:p <VarDeclAST> |
		ps at: p name put: (SemanticVarDecl decl: {p. currentDepth})].
	nestScope: ps.
	scopeMap at: aNode put: ps.
	"the pattern scope, ps, must be popped by the caller"
	"establish type parameter scope - skip for now"
)
methodNode: aNode <MethodAST> = (
	"register method in current scope"
	currentScope
		at: aNode pattern selector
		put: (SymbolTableEntry for: {aNode pattern. currentDepth}).
	"visit pattern"
	aNode pattern apply: self.
	"visit body"
	aNode body apply: self.
	scopeMap
		at: aNode
		put: (scopeMap at: aNode body).
	popScope "Pop pattern scope"
)
mixinApplication: node <MixinApplicationAST> = (
	node mixinExpr apply: self.
	node superclassExpr apply: self
)
mixinClassNode: aNode = (
	"do nothing"
)
nestScope: s <Scope> = (
"Hook up a new lexically nested scope, and push onto the scope stack"
	s superScope: currentScope.
	pushScope: s
)
normalSendNode: aNode <NormalSendAST> = (
"generic traversal code"
"visit recvr and msg"
	aNode recv apply: self.
	aNode msg apply: self.
)
numberNode: aNode <NumberAST> = (
"do nothing"
)
popScope ^ <Scope> = (
	^scopeStack removeLast
)
propertyCallNode: aNode <PropertyCallAST> = (
	messageNode: aNode
)
prvtScopeFor: c <MixinMirror> ^<Scope> = (
"When incrementally compiling a nested class, we need to reconstruct its scope."
	| 
	s <Scope> 
	outerMixins <Collection[MixinMirror]>
	depth <Integer>
	|
	outerMixins:: enclosingMixinsOf: c."should use a cleaner API"
	currentDepth:: outerMixins size - 1.
	depth:: 0.
	outerMixins do: [:o |
		s:: Scope new superScope: s.
		(selectorsFor: o) do:
			[: sel |
			s at: sel 
				put: (SymbolTableEntry for:{MessagePatternAST new selector: sel. depth})].
		depth:: depth + 1].
	^s
)
pushScope: s <Scope> = (
	scopeStack addLast: s
)
returnStatNode: aNode <ReturnStatAST> = (
"generic traversal code"
	"visit expression"
	aNode expr apply: self
)
selectorsFor: m <MixinMirror> ^ <Collection[Symbol]> = (
"Should add a convenience method to mirrors to do this"
	| result <Collection[Symbol]> |
	result:: m methods asOrderedCollection collect:[:s <MethodMirror> | s name].
	result addAll: (m slots asOrderedCollection collect:[: s <SlotMirror> | s name]).
	result addAll: 
		((m slots asOrderedCollection select:[: s | s isMutable]) 
			collect:[: s <SlotMirror> | s name, ':']).
	result addAll: (m classes asOrderedCollection collect:[:s <ClassStencilMirror> | s name]).
	^result
)
setterSendNode: aNode <SetterSendAST> = (
	aNode recv apply: self.
	aNode msg apply: self.
)
sideNode: aNode <SideAST> = (
	scopeMap at: aNode put: currentScope.
	"visit methods"
	aNode categories do:
		[: c <CategoryAST> | c methods do:[:m <MethodAST> | m apply: self]].
	"visit nested classes"
	aNode nestedClasses do: [:nc <ClassDeclarationAST> | nc apply: self].
)
stringNode: aNode <StringAST> = (
"do nothing"
)
symbolNode: aNode <SymbolAST> = (
"do nothing"
)
tupleNode: aNode <TupleAST> = (
"visit elements"
	aNode elements do: [:e <SendAST> | e apply: self]
)
varDeclNode: aNode <VarDeclAST> = (
"Do nothing. It could arguably add aNode's data to current scope - but in practice, the context knows better how to do this"
)
variableNode: aNode <VariableAST> = (
	assert: [aNode name = #'@here' or: [isPseudoVariableNode: aNode]]
		message: 'Unexpected variable name'.
)
visitMethod: aNode <MethodAST> within: m <MixinMirror> ^ <Dictionary[AST, Scope]> = (
	^visitNode: aNode within: m
)
visitNode: aNode <AST> within: m <MixinMirror> ^ <Dictionary[AST, Scope]> = (
	pushScope: (buildScopeFor: m).
	aNode apply: self.
	^scopeMap
)) : ('as yet unclassified'
REFACTORING = (
	"The scope builders for all the Newspeak compilation modules should someday be factored out, rather than duplicated."
)
new ^ <Instance> = (
	^self nestedIn: Scope new atLevel: 0
))
class Translator = ASTTool (
"Visits nodes of an NS AST to produce a Javascript AST. The usual translation unit is a method. Translation is initiated by sending the translateMethodNode: message. The argument is the method to translate, the returned value is the translation."|
	scopeStack
	currentSelector
	protected containsNonLocalReturn <Boolean> "Set to false at the beginning of translating a method. The code that emits a non-local return sets this to true. The top-level code checks the value to see whether to emit a try-catch wrapper for an NLR."

	vmmirror = VMMirrorIntrinsics new.
|)
(
class VMMirrorIntrinsics = (
"When compiling the Kernel, all sends to the receiver 'vmmirror' are evaluated at compile time. They are sent to an instance of this class, which answers Dart ASTs."|
|)
('as yet unclassified'
Array = (
	^dart ident: 'Array_global'
)
Block = (
	^dart ident: 'Block_global'
)
Error = (
	halt.
)
MessageNotUnderstood = (
	halt.
)
Number = (
	^dart ident: 'Number_global'
)
Object = (
	^dart ident: 'Object_global'
)
String = (
	^dart ident: 'String_global'
)
asNsBoolean: dartBoolean = (
	^dart ternaryIf: dartBoolean then: (dart ident: 'true_') else: (dart ident: 'false_')
)
classOf: o = (
	^dart memberOf: o at: 'klass_'
)
concatenate: a and: b = (
	^dart on: a invoke: (dart ident: 'concat') with: {b}
)
divide: a by: b = (
	^dart operator: '/' with: a and: b
)
doesNotUnderstand: msg = (
	super Error signal: 'Unknown intrinsic: ', msg selector
)
from: a subtract: b = (
	^dart operator: '-' with: a and: b
)
invoke: f = (
	^dart invoke: f with: {}
)
invoke: f with: a1 = (
	^dart invoke: f with: {a1}
)
invoke: f with: a1 with: a2 = (
	^dart invoke: f with: {a1. a2}
)
invoke: f with: a1 with: a2 with: a3 = (
	^dart invoke: f with: {a1. a2. a3}
)
invoke: f with: a1 with: a2 with: a3 with: a4 = (
	^dart invoke: f with: {a1. a2. a3. a4}
)
is: a equalTo: b = (
	^asNsBoolean: (dart operator: '==' with: a and: b)
)
is: a greaterOrEqual: b = (
	^asNsBoolean: (dart operator: '>=' with: a and: b)
)
is: a greaterThan: b = (
	^asNsBoolean: (dart operator: '>' with: a and: b)
)
is: a identicalTo: b = (
	^asNsBoolean: (dart operator: '===' with: a and: b)
)
is: a lessOrEqual: b = (
	^asNsBoolean: (dart operator: '<=' with: a and: b)
)
is: a lessThan: b = (
	^asNsBoolean: (dart operator: '<' with: a and: b)
)
lengthOf: n = (
	^dart memberOf: n at: 'length' 
)
list: list at: index = (
	^dart
		subscript: list
		at: index
)
list: list at: index put: value = (
	^dart
		assign: (dart subscript: list at: index)
		toBe: value
)
multiply: a by: b = (
	^dart operator: '*' with: a and: b
)
newList: size = (
	^dart new: (dart ident: 'List') with: {size}
)
print: obj = (
	^dart invoke: (dart ident: 'print') with: {obj}
)
sqrt: a = (
	^dart on: (dart ident: 'Math') invoke: (dart ident: 'sqrt') with: {a}
)
throw: exception = (
	^dart throw: exception
)
to: a add: b = (
	^dart operator: '+' with: a and: b
)
toString: a = (
	^dart on: a invoke: (dart ident: 'toString') with: {}
)
try: b1 catch: b2 = (
	halt.
)
try: b1 ensure: b2 = (
	^dart 
		try: (dart return: (dart on: b1 invoke: (dart ident: (mangleSelector: 'value')) with: {})) asBlock
		catch: nil
		with: nil
		finally: (dart on: b2 invoke: (dart ident: (mangleSelector: 'value')) with: {}) asBlock
)
try: tryblock on: expectedclass do: catchblock = (
	halt. "But non-NS exceptions (e.g., NLR exceptions) do not have a class getter..."
	
	"try {...} catch( ex_ ) {
		for(c = ex_.class; c != nil; c=c.superclass){
			if(c==exceptionclass) return catchblock.value()
		}
		throw ex_
	}"

	^dart try: tryblock catch: (dart ident: 'ex_') with: (dart block: {
		
	})
)) : ()'as yet unclassified'
assignmentNode: node <AssignmentAST> = (

	^dart assign: (node var apply: self) toBe: (node expr apply: self)
)
beginNewTranslationCycle = (
	scopeStack:: OrderedCollection new.
	containsNonLocalReturn:: false.
)
blockLocalReturnNode: node <BlockLocalReturnAST> = (
"	(node expr isNormalSendNode and: [isInlinableConditionalNode: node expr]) ifTrue:
		""Optimize the common special case of returning the value of an ifTrue:ifFalse: message send.
		The clauses already have the necessary local returns of the last expression of each clause
		inserted by the rewriter.""
		[^js if: (node expr recv apply: self)
			then: (node expr msg args first body apply: self)
			else: ((node expr msg args at: 2) body apply: self)]."
	^dart return: (node expr apply: self)
)
blockNode: node <BlockAST> = (
	^dart
		on: vmmirror Block
		invoke: (dart ident: (mangleSelector: 'wrapping:'))
		with: {dart 
			functionOf: (node parameters collect: [:each | each apply: self]) asArray
			body: (node body apply: self)}
)
boolNode: node <BoolAST> = (
	^dart ident: (node val ifTrue: ['true_'] ifFalse: ['false_'])
)
codeBodyNode: node <CodeBodyAST> = (
	| locals statements |
	locals:: node temporaries collect: [:each | each apply: self].
	statements:: node statements collect: [:each | each apply: self].
	^dart block: (locals asArray, statements) asArray
)
explicitOuterReceiverNode: node <ExplicitRecvrAST> = (
	^processOuterReceiverAtDepth: node depth
)
implicitSendNode: node <ImplicitRcvrSendNode> = (
	^processSend: node msg to: (processOuterReceiverAtDepth: node depth)
)
inlinableAsExpressionConditionalNode: node <InlinableAsExpressionConditionalAST> = (
	
	halt.
	
	"| inverseCondition condition |
	inverseCondition:: node msg sel = 'ifFalse:ifTrue:'.
	condition:: node recv apply: self.
	^dart ternaryIf: (inverseCondition ifTrue: [dart prefixOperator: '!' on: condition] ifFalse: [condition])
		then: (node msg args first body statements first apply: self)
		else: ((node msg args at: 2) body statements first apply: self)"
)
mangleVarName: name <String> ^<String> = (
	#FLAG. "How does this fit with mangling of identifiers?"
	^'l_', name
)
messageNode: node = (
	"useDnuCatcher ifTrue: [sentSelectors add: node sel]."
	^(mangleSelector: node sel)
)
messagePatternNode: node <MessagePatternAST> ^<List[String]> = (
	currentSelector:: mangleSelector: node selector.
	^node parameters collect: [:each | each apply: self]
)
methodNode: node <MethodAST> ^<Node> = (
	| translatedBody |
	translatedBody:: node body apply: self.
	^dart
		method: (mangleSelector: node pattern selector)
		params: (node pattern apply: self) asArray
		body: (containsNonLocalReturn
			ifTrue: [wrapBodyForNlrHandling: translatedBody]
			ifFalse: [wrapBodyNoNlrHandling: translatedBody]).
)
nilNode: node <NilAST> = (
	^dart ident: 'nil_'
)
nlrName = (
	^'nlr_'
)
nlrValueName = (
	^'value'
)
normalSendNode: node <NormalSendNode> = (
	^processSend: node msg to: (node recv apply: self)
)
numberNode: node <NumberAST> = (
	^dart
		on: vmmirror Number
		invoke: (dart ident: (mangleSelector: 'wrapping:'))
		with: {dart literal: node val}
)
parameterDeclNode: node <ParameterAST> = (
	^mangleSelector: node name
)
parameterNode: node <ParameterVariableAST> = (
	^dart ident: (mangleSelector: node name)
)
processIntrinsic: message = (

	^vmmirror 
		perform: message sel
		withArguments: (message args collect: [:ea | ea apply: self]) asArray
)
processOuterReceiverAtDepth: depth <Integer> = (
	| exp |
	depth = 0 ifTrue: [^dart ident: 'this'].
	
	"Since nesting chains are typically short, it seems like the simplicity of following them directly won't be too expensive. Possibly for depths 1 and 2 this is faster than the enclosing objects array scheme."
	exp:: dart memberOf: (dart ident: 'this') at: 'klass_'.
	depth timesRepeat: [
		exp:: dart memberOf: exp at: (mangleSlotName: 'enclosingObject')].
	^exp
)
processSend: message to: receiver = (

	#FLAG. "Yucky pattern matching"
	enableIntrinsics ifTrue: [
		receiver isMethodInvocation ifTrue: [
			receiver target = (dart ident: 'this') ifTrue: [
				receiver method name = 'vmmirror' ifTrue: [
					^processIntrinsic: message]]]].

	^dart 
		on: receiver
		invoke: (dart ident: (message apply: self))
		with: (message args collect: [:each | each apply: self]) asArray
)
propertyCallNode: node <PropertyCallAST> = (
	"Unmangled invocation"
	^node sel
)
receiverNode: node <ReceiverAST> = (
	^dart ident: 'this'
)
returnStatNode: node <ReturnAST> = (
	containsNonLocalReturn:: true.
	^dart block: {
		dart assign: (dart memberOf: (dart ident: nlrName) at: nlrValueName) toBe: (node expr apply: self).
		dart throw: (dart ident: nlrName)
	}
)
stringNode: node <StringAST> = (
	#FLAG. "Eventually Newspeak will not have syntax for symbol literals and treat all string literals as symbols (interned strings)"
	^dart
		on: vmmirror String
		invoke: (dart ident: (mangleSelector: 'wrapping:'))
		with: {dart literal: node val}
)
superSendNode: node <SuperSendAST> = (
	^processSend: node msg to: (dart ident: 'super')
)
symbolNode: node <SymbolAST> = (
	#FLAG. "Are string literals interned in Dart?"
	^self stringNode: node
)
temporaryDeclNode: node <TemporaryAST> = (
	^dart var: (mangleVarName: node name)
		value: (node initializer = nil
			ifTrue: [dart ident: 'nil_']
			ifFalse: [ node initializer apply: self])
)
temporaryNode: node <TemporaryVariableAST> = (
	^dart ident: (mangleVarName: node name)
)
tupleNode: node <TupleAST> = (
	^dart
		on: vmmirror Array
		invoke: (dart ident: (mangleSelector: 'wrapping:'))
		with: {dart list: (node elements collect: [:ea | ea apply: self])}
)
wrapBodyForNlrHandling: body <Block> = (
	| nlrVarNode nlrParamName nlrParamNode |
	nlrVarNode:: dart ident: nlrName.
	nlrParamName:: nlrName, 'exception_'.
	nlrParamNode:: dart ident: nlrParamName.
	^dart block: {
		dart var: nlrName value: (dart new: (dart ident: 'NLR_') with: {}).
		dart try: body catch: nlrParamName with:
			(dart block: {
				dart if: (dart operator: '===' with: nlrVarNode and: nlrParamNode)
					then: (dart return: (dart memberOf: nlrParamNode at: nlrValueName))
					else: (dart throw: nlrParamNode)
			})
	}
)
wrapBodyNoNlrHandling: body <Block> = (
	"Unlike JS's this, Dart's this scopes like Newspeak's self"

	^dart block: "{dart var: selfName value: (dart ident: 'this')}," body statements
)) : ()'as yet unclassified'
accessorForNestedClass: classDecl <ClassDeclarationAST> within: mixinMirror = (
	"Foo>> Inner {
	if(Inner_slot === null){

		var superclass = this.Super();
		var metaclass = new Foo_Inner_metamixin( Metaclass_global );
		var class = new Foo_Inner_mixin(metaclass);
		
		class.superclass__(superclass);
		class.enclosingObject__(this);
		class.name('Foo`Inner');
		class.mixin( );
		
		metaclass.superclass__( Class_global );
		metaclass.enclosingObject__(this);
		metaclass.mixin( );

		Inner_slot = class;
	}
	return Inner_slot;
	}"
	|
	simpleName = classDecl hdr name.
	fullName = fullyQualifySimpleName: simpleName with: mixinMirror name.
	slotName = mangleSlotName: fullName.
	superclass = dart 
		on: (dart ident: 'this') "should be a here send..."
		invoke: (dart ident: (mangleSelector: classDecl hdr superclassName))
		with: {}.
	metamixin = dart ident: (metamixinClassNameFor: fullName).
	mixin = dart ident: (metamixinClassNameFor: fullName).
	|
	#FLAG.
	
	
	^dart method: (dart ident: (mangleSelector: simpleName)) params: {} body: (dart block: {dart
		if: (dart 
			operator: '==='
			with: (dart ident: slotName)
			and: (dart ident: 'null'))
		then: (dart block: {
			dart 
				var: (dart ident: 'superclass') 
				value: superclass.
			dart 
				var: (dart ident: 'metaclass') 
				value: (dart 
					on: (dart ident: 'Metaclass_global') 
					invoke: (dart ident: (mangleSelector: 'new'))
					with: {}).
			dart 
				var: (dart ident: 'klass')
				value: (dart new: metamixin with: {dart ident: 'metaclass'}).
				
			dart 
				on: (dart ident: 'klass')
				invoke: (dart ident: (mangleSelector: 'superclass:'))
				with: {superclass}.
			dart 
				on: (dart ident: 'klass')
				invoke: (dart ident: (mangleSelector: 'enclosingObject:'))
				with: {dart ident: 'this'}.
			dart 
				on: (dart ident: 'klass')
				invoke: (dart ident: (mangleSelector: 'name:'))
				with: {(SymbolAST new val: simpleName) apply: translator}.
				
			dart 
				on: (dart ident: 'metaclass')
				invoke: (dart ident: (mangleSelector: 'superclass:'))
				with: {dart ident: 'Class_global'}.
			dart 
				on: (dart ident: 'metaclass')
				invoke: (dart ident: (mangleSelector: 'enclosingObject:'))
				with: {dart ident: 'this'}.
			dart 
				on: (dart ident: 'metaclass')
				invoke: (dart ident: (mangleSelector: 'thisClass:'))
				with: {dart ident: 'klass'}.
							
			dart
				assign: (dart ident: slotName)
				toBe: (dart ident: 'klass').
			}).
			
			dart return: (dart ident: slotName).
	})
)
createNestedClassAccessorFrom: classDecl <ClassDeclarationAST> within: mixinMirror <LowLevelMixinMirror> = (
"Create an accessor method for the nested class represented by the incoming class tree.
This accessor will lazily generate the nested class when its enclosing instance is first asked for it."

	| n <String>  accessorString <String> methodSrc <String>  hdr <ClassHeaderAST> accessor <MethdMirror>  |
	hdr:: classDecl hdr.
	n:: hdr name. 
	methodSrc:: 
		accessorForNestedClass: classDecl within: mixinMirror.
	accessor:: MethodMirror named: (mangleSelector: classDecl name).
	accessor method: methodSrc.
	accessor isSynthetic: true.
	mixinMirror methods addMirror: accessor.
)
hereNode ^<VariableAST> = (
	"Generates an AST representing the implicit receiver. We use a string so that we can represent a name that is not a legal identier"
	
	^VariableAST new name: #'@here'; start: 0; end: 0.
)
hereSendFrom: arg <VarDeclAST> ^<MessageNode> = (
	^NormalSendAST new
		to: hereNode
		send: (MessageAST new 
			send: arg name
			with: {};
			start: arg start; end: arg end); 
		start: arg start; end: arg end
)
language = (
	^#Newspeak3
)
nestedMixinWrapperFor: nested <ClassDeclarationAST> in: outerClass <MixinMirror>  ^ <ClassDeclarationAST> = (
"Wrap a class declaration to make it look like a nested mixin within outerClass should. This includes making the name be the fully qualified name, and hiding the superclass."

	| wrapper <ClassDeclarationAST> |
	wrapper:: nested clone.
	wrapper hdr: nested hdr clone.
	wrapper hdr name: (fullyQualifySimpleName: nested name with: outerClass name).
	^wrapper
)
resolveSuperclass: name = (
	name = 'Object' ifTrue: [^'KernelForDart`Object'].
	name = 'Class' ifTrue: [^'KernelForDart`Class'].
	name = 'Behavior' ifTrue: [^'KernelForDart`Behavior'].
	name = 'Boolean' ifTrue: [^'KernelForDart`Boolean'].
	name = 'Error' ifTrue: [^'KernelForDart`Error'].
	name = 'Top' ifTrue: [^'Top'].
	
	halt.
)
selfNode = (
	^VariableAST new name: #self; start: 0; end: 0
)
setInput: source <ReadStream> = (
	source position: 1.
	input: source. "save the input"
)
setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	^((slot isMutableSlot ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), slot name, ':') asSymbol.
)
sourceForNode: node <AST> ^ <String> = (
	| savedPos <Integer> pos <Integer> len <Integer> s <String> |
	"^String withAll: (input copyFrom: node start to: node end"
	savedPos:: input position.
	len: (node end - node start) + 1.
	s:: MutableString new: len.
	input position: node start -1.
	1 to: len do:
		[:index |
		s at: index put: input next].	
	input position: savedPos.
	^s
)'entry'
public compileClassSource: source <ReadStream> within: enclosing <MixinMirror> ^<MixinRep> = (
	|
	tree <AST>
	mixinRep <MixinRep>
	|
	tree:: parser classDefinition parse: source.
	setInput: source.
	setScopeFor: tree in: enclosing.
	mixinRep:: classNode: tree.
	scopeMap:: Dictionary new.
	^enclosing isNil ifTrue:[mixinRep] ifFalse:[{enclosing. mixinRep}].
)'factories'
initializerFor: node <ClassHeaderAST> ^<MethodAST> = (
	|
	stmts  <Collection[StatementAST]>
	start <Integer> = node superConstructorCall start.
	end <Integer> = node superConstructorCall end.
	initHdr <MessagePatternAST>
	body <CodeBodyAST> 
	copier <ASTCopier> = ASTCopier new.
	params <List[VarDeclAST]>
	|
	
	params:: node constructor parameters collect: [:formal | formal apply: copier].
	initHdr:: MessagePatternAST new 
		selector: (initializerSelectorNameFor: node constructor selector)
		parameters: params;
		start: start; end: end. 
	"set up scope with constructor parameters"
	stmts:: node slots collect: [:slot <SlotDefAST> | | aMsg <MessageAST> |
		aMsg:: MessageAST new
			send: (setterSelectorFor: slot) asSymbol
			with: {slot initializer apply: copier};
			start: slot start; end: slot end.
		NormalSendAST new msg: aMsg; 
			recv: (selfNode start: aMsg start; end: aMsg end);
			start: aMsg start; end: aMsg end.			
	].

	stmts addAll: (node initExprs collect:[:ie | ie apply: copier]).
	stmts addFirst: (superConstructorCallFor: node). "add superclass init call as first statement"
	
	body:: CodeBodyAST new
		temporaries: OrderedCollection new
		statements: stmts; 
		start: start; end: end.

	^MethodAST new 
		pattern: initHdr
		body: body
		visibility: #public; 
		start: start; end: end.
)
initializerSelectorNameFor: selector <Symbol> ^<Symbol> = (
	^'initializer`', selector
)
processFactoryFor: node <ClassAST> in: mixinMirror <LowLevelMixinMirror> = (
	| accessor <MethdMirror> argNames ast initializerName |
	accessor:: MethodMirror named: node hdr constructor selector.
	argNames:: (node hdr constructor parameters collect: [:each | translator mangleVarName: each name]) asArray.
	initializerName:: initializerSelectorNameFor: node hdr constructor selector.
	ast:: dart
		method: (mangleSelector: node hdr constructor selector)
		params: argNames
		body: (dart block: {
			dart return: (dart
				on: (dart 
					new: (dart ident: (mixinClassNameFor: node hdr name)) 
					with: {dart ident: 'this'})
				invoke: (dart ident: (mangleSelector: initializerName))
				with: (argNames collect: [:each | dart ident: each]))
		}).
	accessor method: ast.
	mixinMirror methods addMirror: accessor.
)
superConstructorCallFor: node <ClassHeaderAST> ^<NormalSendAST> = (
	"create call to super constructor method"
	| 
	var <VariableAST>
	start <Integer> = node superConstructorCall start.
	end <Integer> = node superConstructorCall end.
	copier <ASTCopier> = ASTCopier new.
	superMsg <MessageAST>
	args <List[VariableAST]> 
	|
	
	var:: VariableAST new name: #self; start: start; end: end.
	args:: node constructor parameters collect:
		[:p <VarDeclAST> | hereSendFrom: p].
	superMsg::  MessageAST new 
		send: (superConstructorNameFor: node) with: args; 
		start: start; end: end.
	^NormalSendAST new to: var send: superMsg; start: start; end: end
)
superConstructorMethodFor: node <ClassHeaderAST> ^<MethodAST> = (
	| 
	start <Integer> = node superConstructorCall start.
	end <Integer> = node superConstructorCall end.
	stmts <List[StmtAST]> 
	var  <VariableAST> 
	initHdr <MessagePatternAST>
	superMsg <MessageAST> 
	send <NormalSendAST>
	body  <CodeBodyAST>
	copier <ASTCopier> = ASTCopier new.
	params <List[VarDeclAST]>
	args <List>
	|

	params:: node constructor parameters collect: [:formal | formal apply: copier].
	initHdr:: MessagePatternAST new
		selector: (superConstructorNameFor: node)
		parameters: params;
		start: start; end: end. 
	"set up scope with constructor parameters"
	
	"create call to superclass initializer"
	stmts:: OrderedCollection new. 
	var:: VariableAST new name: #super; start: start; end: end.
	args:: node superConstructorCall args collect: [:actual | actual apply: copier].
	superMsg:: MessageAST new
		send: (initializerSelectorNameFor: node superConstructorCall sel)
		with: args; 
		start: start; end: end. 

	"only copy actual args"
	"send these as a tuple? to super instance initializer?"
	send:: NormalSendAST new 
		to: var
		send: superMsg; 
		start: start; end: end. 
	stmts addFirst: send.
	body:: CodeBodyAST new
		temporaries: OrderedCollection new
		statements: stmts;
		start: start; end: end.
		
	^MethodAST new
		pattern: initHdr
		body: body
		visibility: #private;
  		start: start; end: end	
)
superConstructorNameFor: node <ClassHeaderAST> ^<Symbol> = (
	#FLAG. "Needs full qualification"
	^'superInit`' , node name, '`', node constructor selector
)'scopes'
currentScope ^<Scope> = (
	^scopeStack last
)
nestScope: scope <Scope> = (
	"Hook up a new lexically nested scope, and push onto the scope stack"
	scope superScope: currentScope.
	pushScope: scope
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
pushScope: scope <Scope> = (
	scopeStack addLast: scope
)
setScopeFor: node <AST> in: enclosing <MixinMirror | nil> = (
	| scopeBuilder |
	pushScope: Scope new.
	enclosing notNil ifTrue: [nestScope:: ScopeBuilder new buildScopeFor: enclosing].
	currentDepth:: currentScope depth - 1.
	scopeBuilder:: ScopeBuilder nestedIn: currentScope atLevel: currentDepth.
	node apply: scopeBuilder
)'top-processing'
checkForDuplicateNames: node <ClassDeclarationAST> = (

	| namesWithDuplicates names duplicateNames |
	
	namesWithDuplicates:: OrderedCollection new.
	node instanceSide categories do: [:cat |
		cat methods do: [:each | namesWithDuplicates add: each selector]].
	
	node hdr slots do: [:each |
		namesWithDuplicates add: each name.
		each isMutable ifTrue: [namesWithDuplicates add: each name, ':']].
	
	namesWithDuplicates
		addAll: (node instanceSide nestedClasses collect: [:each | each name]).

	names:: Set new.
	duplicateNames:: Set new.
	namesWithDuplicates do: [:each | | present |
		present:: true.
		names include: each ifNew: [present:: false].
		present ifTrue: [duplicateNames add: each]].
	
	duplicateNames isEmpty ifFalse: [ | message |
		message:: String streamContents: [:s |
			s
				nextPutAll: 'Class ';
				nextPutAll: node name;
				nextPutAll: '" has multiple definitions for '.
			duplicateNames
				do: [:each | s nextPutAll: each asString]
				separatedBy: [ s nextPutAll: ','].
			s nextPutAll: '.'.].
		assert: false message: message].
)
classNode: node <ClassDeclarationAST> ^<MixinRep> = (
	|
	mixinMirror <LowLevelMixinMirror>
	nestedClasses <Collection[MixinRep]>
	
	|
	assert: [node hdr category notNil] message: 'No category for class header'.
	checkForDuplicateNames: node.
	mixinMirror:: computeMixinFrom: node hdr.

	currentDepth::currentDepth + 1.
	generateSlotAccessorsFor: mixinMirror lowLevelMirror. "Called before handling nested classes because we don't need the accessors for their synthetic slots."
	nestedClasses:: processInstanceSideOf: node ofMixin: mixinMirror lowLevelMirror.
	
	processClassSideOf: node ofMixin: mixinMirror lowLevelMirror classMixin.
	currentDepth::currentDepth - 1.

	^{mixinMirror. nestedClasses}
)
compileNestedClasses: nestedClasses <Collection[ClassDeclarationAST]> within: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	| results <OrderedCollection[MixinRep]> |
      results:: OrderedCollection new.
	nestedClasses do:
		[ :nc <ClassDeclarationAST> |  
			| nClassName <String> nSlot <InstanceVariableMirror> |
		nc hdr category: mixinMirror category, '-nested'.
		
		nClassName:: fullyQualifySimpleName: nc name 
		                   with: mixinMirror name.
		nSlot:: InstanceVariableMirror named: nClassName mutable: true.
		nSlot field: (dart var: (mangleSlotName: nClassName)).
		nSlot metadata at: #isSynthetic put: true.
		mixinMirror instVars addMirror: nSlot.
		results add: (classNode: (nestedMixinWrapperFor: nc in: mixinMirror)).
		createNestedClassAccessorFrom: nc within: mixinMirror
		].
	^results
)
compileNestedClassesOf: aNode <SideAST> within: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	"where do we check that nested classes do not conflict with each other, or with methods or slots?"
	^compileNestedClasses: aNode nestedClasses within: mixinMirror
)
computeMethod: aNode <MethodAST> inScope: s <Scope> = (
	|  scopeBuilder <ScopeBuilder>  |
	scopeBuilder:: ScopeBuilder nestedIn: s atLevel: currentDepth.
	aNode apply: scopeBuilder.
	"need to build scope for method before visiting it"
	^methodNode: aNode.
)
computeMixinFrom: aNode <ClassHeaderAST> ^<CompiledMixinMirror> = (
	| 
	mixinMirror = LowLevelMixinMirror named: aNode name isMeta: false.
	|
	
	mixinMirror superclassName: aNode superclassName.
	
	aNode slots do: [:slot |
		mixinMirror instVars addMirror: (slot apply: self)].
	
	^(CompiledMixinMirror 
		language: language
		header: (sourceForNode: aNode)
		mirror: mixinMirror)
		factoryName: aNode constructor selector;
		category: aNode category;
		comment: (aNode classComment isNil 
			ifTrue: [''] 
			ifFalse: [aNode classComment])
)
generateSlotAccessorsFor: m <MixinMirror>  = (
	"We need accessor METHODS so we can call them uniformly. Dart's special getters and setters won't do."
	m instVars do: [:iv <InstanceVariableMirror> | 
		|
		getterName <String>
		setterName <String>
		ivName <String>
		getter <MethodMirror>
		getterDart <Node>
		setter <MethodMirror>
		setterDart <Node>
		|
		getterName:: mangleSelector: iv name.
		setterName:: mangleSelector: (setterSelectorFor: iv).
		ivName:: mangleSlotName: iv name.
		
		getter:: MethodMirror named: getterName.
		getterDart:: dart method: getterName params: {} body: (dart block: {
			dart return: (dart memberOf: (dart ident: 'this') at: ivName)
			}).
		getter method: getterDart.	
		getter isAccessor: true.
		m methods addMirror:  getter.
		
		setter:: MethodMirror named: setterName.
		setterDart:: dart method: setterName params: {'v'} body: (dart block: {
			(dart assign: (dart memberOf: (dart ident: 'this') at: ivName)
				toBe: (dart ident: 'v')).
			dart return: (dart ident: 'this')
			}).
		setter method: setterDart.
		setter isAccessor: true.
		m methods addMirror:  setter.
	]
)
methodNode: aNode <MethodAST> ^ <MethodMirror> = (
	| tree <AST> dartTree |
	tree:: aNode apply: rewriter.  "rewrite ast"
	translator beginNewTranslationCycle.
	dartTree:: tree apply: translator.	 "final pass: visit rewritten ast"
	"pop scope?"
	^(MethodMirror named: translator currentSelector)
		method: dartTree;
		src: (sourceForNode: aNode);
		yourself
)
processClassSideOf: aNode <ClassAST> ofMixin: mixinMirror <LowLevelMixinMirror> = (
	processFactoryFor: aNode in: mixinMirror.
	processSide: aNode classSide ofMixin: mixinMirror. "compile class methods"
)
processInitializerFor: aNode <ClassAST> in: mixinMirror <LowLevelMixinMirror> = (
	processMethod: (superConstructorMethodFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinMirror. 
	processMethod: (initializerFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinMirror.
)
processInstanceSideOf: aNode <ClassAST> ofMixin: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	| side <SideAST> |
	processInitializerFor: aNode in: mixinMirror.
	side:: aNode instanceSide.
	processSide: side ofMixin: mixinMirror. "compile instance methods"
	^compileNestedClassesOf: side within: mixinMirror. "gather nested classes"
)
processMethod: aNode <MethodAST> inScope: s <Scope>  in: mixinMirror <LowLevelMixinMirror> = (
	|  method <MethodMirror> |
	method:: computeMethod: aNode inScope: s.
	method isSynthetic: true.
	mixinMirror methods addMirror: method.
	"install method"	
)
processSide: side <SideAST> ofMixin: mixinMirror <LowLevelMixinMirror> = (
	side categories do:
		[:cat |
		| mirror <MethodMirror> |
		cat methods do: [:m | 
			"who checks that the methods do not conflict with each other or with another slot or class in the same enclosing class? The mirror or the compiler?"
			mirror:: methodNode: m.
			mirror metadata at: #category put: cat.
			mixinMirror methods addMirror: mirror]].
)
slotDefNode: node <SlotDefAST> = (
	
	^(InstanceVariableMirror 
		named: node name
		mutable: node isMutableSlot)
		field: (dart var: (mangleSlotName: node name));
		src: (sourceForNode: node)
)'top-processing2'
outputMainForReps: reps to: stream = (

	| statements = OrderedCollection new. ast |
	reps do: [:rep <MixinRep> | | cmm = rep first. |
		statements add: (dart 
			assign: (dart ident: (mangleSelector: cmm name),'_global')
			toBe: (dart
				new: (dart ident: (mangleSelector: cmm name), '_class_mixin')
				with: {dart ident: 'null'}))].
			
	#FLAG. #REFACTORING.
	statements add: (dart 
		assign: (dart ident: 'true_')
		toBe: ((dart 
			new: (dart ident: (mangleSelector: 'True'), '_mixin') 
			with: {dart ident: 'True_global'}))).
	statements add: (dart 
		assign: (dart ident: 'false_')
		toBe: ((dart 
			new: (dart ident: (mangleSelector: 'False'), '_mixin') 
			with: {dart ident: 'False_global'}))).
	statements add: (dart 
		assign: (dart ident: 'nil_')
		toBe: ((dart 
			new: (dart ident: (mangleSelector: 'UndefinedObject'), '_mixin') 
			with: {dart ident: 'UndefinedObject_global'}))).
		
	statements add: (dart
		invoke: (dart ident: 'print')
		with: {dart 
			on: (dart ident: 'Test_global')
			invoke: (dart ident: 'main')
			with: {}}).
	
	ast:: dart method: 'main' params: {} body: (dart block: statements).

	dartWriter generateSourceFor: (dart var: 'true_') on: stream.
	dartWriter generateSourceFor: (dart var: 'false_') on: stream.
	dartWriter generateSourceFor: (dart var: 'nil_') on: stream.	

	dartWriter generateSourceFor: ast on: stream
)
outputTopLevelClass: rep <MixinRep> to: stream <WriteStream> = (
	| asts |
	asts:: translateMixinRep: rep. 
	asts do: [:ast | dartWriter generateSourceFor: ast on: stream. stream cr].
	^stream
)
translateMixinRep: rep <MixinRep> ^<List[Node]> = (
	| 
	results <Node> = OrderedCollection new.
	cmm <CompiledMixinMirror> = rep first.
	llmm <LowLevelMixinMirror> = cmm lowLevelMirror.
	|
		
	results add: (dart 
		class: (mixinClassNameFor: cmm name)
		extends: (mixinClassNameFor: (resolveSuperclass: llmm superclassName))
		fields: (llmm instVars collect: [:ea | ea field])
		constructors: {dart verbatim: (mixinClassNameFor: cmm name),'(c):super(c);'}
		methods: (llmm methods collect: [:ea | ea method])).
			
	results add: (dart
		class: (metamixinClassNameFor: cmm name)
		extends: (mixinClassNameFor: (resolveSuperclass: 'Class'))
		fields: {}
		constructors: {dart verbatim: (metamixinClassNameFor: cmm name),'(c):super(c);'}
		methods: (llmm classMixin methods collect: [:ea | ea method])).
	
	rep last do: [:each | results addAll: (translateMixinRep: each)].
	
	^results
)) : ()
class Infrastructure outputTo: stream = (|
	compiler = Compiler new enableIntrinsics: true.
	writer = DartWriter new.
|writer generateSourceFor: topClass on: stream.
	writer generateSourceFor: nlrClass on: stream.
	
	compiler outputTopLevelClass: (compileClass: Kernel) to: stream.
	
	writer generateSourceFor: kernelInit on: stream)
('as yet unclassified'
kernelInit ^<Node> = (

	#REFACTORING. #FLAG. "This is brittle"

	"Create class objects. Create metaclass objects. Link classes and metaclasses. Extract true/false/nil."

^dart verbatim: '

var true_, false_, nil_;
var Object_global, Class_global, Metaclass_global;
var String_global, Number_global, Block_global, Array_global;
var Message_global;

kernelInit(){
	var Kernel = new KernelForDart_metamixin(null);
	var kernel = Kernel.new_();
	
	//class, superclass, enclosingObject, name/thisClass

	kernel.KernelForDart_Metaclass_slot = new KernelForDart_Metaclass_metamixin(null);
	kernel.KernelForDart_False_slot = new KernelForDart_False_metamixin(null);
	kernel.KernelForDart_Boolean_slot = new KernelForDart_Boolean_metamixin(null);
	kernel.KernelForDart_Error_slot = new KernelForDart_Error_metamixin(null);
	kernel.KernelForDart_Block_slot = new KernelForDart_Block_metamixin(null);
	kernel.KernelForDart_Number_slot = new KernelForDart_Number_metamixin(null);
	kernel.KernelForDart_Array_slot = new KernelForDart_Array_metamixin(null);
	kernel.KernelForDart_UndefinedObject_slot = new KernelForDart_UndefinedObject_metamixin(null);
	kernel.KernelForDart_Object_slot = new KernelForDart_Object_metamixin(null);
	kernel.KernelForDart_Behavior_slot = new KernelForDart_Behavior_metamixin(null);
	kernel.KernelForDart_MessageNotUnderstood_slot = new KernelForDart_MessageNotUnderstood_metamixin(null);
	kernel.KernelForDart_String_slot = new KernelForDart_String_metamixin(null);
	kernel.KernelForDart_Class_slot = new KernelForDart_Class_metamixin(null);
	kernel.KernelForDart_True_slot = new KernelForDart_True_metamixin(null);
	kernel.KernelForDart_Message_slot = new KernelForDart_Message_metamixin(null);

	true_ = new KernelForDart_True_mixin(kernel.KernelForDart_True_slot);
	false_ = new KernelForDart_False_mixin(kernel.KernelForDart_False_slot);
	nil_ = new KernelForDart_UndefinedObject_mixin(kernel.KernelForDart_UndefinedObject_slot);

	kernel.KernelForDart_Object_slot.superclass_slot = nil_;
	kernel.KernelForDart_Object_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Object");
	kernel.KernelForDart_Object_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Object_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Object_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Object_slot.klass_.thisClass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Object_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_Metaclass_slot.superclass_slot = kernel.KernelForDart_Behavior_slot;
	kernel.KernelForDart_Metaclass_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Metaclass");
	kernel.KernelForDart_Metaclass_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Metaclass_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Metaclass_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Metaclass_slot.klass_.thisClass_slot = kernel.KernelForDart_Metaclass_slot;
	kernel.KernelForDart_Metaclass_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_False_slot.superclass_slot = kernel.KernelForDart_Boolean_slot;
	kernel.KernelForDart_False_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("False");
	kernel.KernelForDart_False_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_False_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_False_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_False_slot.klass_.thisClass_slot = kernel.KernelForDart_False_slot;
	kernel.KernelForDart_False_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_Boolean_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Boolean_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Boolean");
	kernel.KernelForDart_Boolean_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Boolean_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Boolean_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Boolean_slot.klass_.thisClass_slot = kernel.KernelForDart_Boolean_slot;
	kernel.KernelForDart_Boolean_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_Error_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Error_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Error");
	kernel.KernelForDart_Error_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Error_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Error_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Error_slot.klass_.thisClass_slot = kernel.KernelForDart_Error_slot;
	kernel.KernelForDart_Error_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_Block_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Block_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Block");
	kernel.KernelForDart_Block_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Block_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Block_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Block_slot.klass_.thisClass_slot = kernel.KernelForDart_Block_slot;
	kernel.KernelForDart_Block_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_Number_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Number_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Number");
	kernel.KernelForDart_Number_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Number_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Number_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Number_slot.klass_.thisClass_slot = kernel.KernelForDart_Number_slot;
	kernel.KernelForDart_Number_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_Array_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Array_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Array");
	kernel.KernelForDart_Array_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Array_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Array_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Array_slot.klass_.thisClass_slot = kernel.KernelForDart_Array_slot;
	kernel.KernelForDart_Array_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_UndefinedObject_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_UndefinedObject_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("UndefinedObject");
	kernel.KernelForDart_UndefinedObject_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_UndefinedObject_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_UndefinedObject_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_UndefinedObject_slot.klass_.thisClass_slot = kernel.KernelForDart_UndefinedObject_slot;
	kernel.KernelForDart_UndefinedObject_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_Behavior_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Behavior_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Behavior");
	kernel.KernelForDart_Behavior_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Behavior_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Behavior_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Behavior_slot.klass_.thisClass_slot = kernel.KernelForDart_Behavior_slot;
	kernel.KernelForDart_Behavior_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_MessageNotUnderstood_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_MessageNotUnderstood_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("MessageNotUnderstood");
	kernel.KernelForDart_MessageNotUnderstood_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_MessageNotUnderstood_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_MessageNotUnderstood_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_MessageNotUnderstood_slot.klass_.thisClass_slot = kernel.KernelForDart_MessageNotUnderstood_slot;
	kernel.KernelForDart_MessageNotUnderstood_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_String_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_String_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("String");
	kernel.KernelForDart_String_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_String_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_String_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_String_slot.klass_.thisClass_slot = kernel.KernelForDart_String_slot;
	kernel.KernelForDart_String_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_Class_slot.superclass_slot = kernel.KernelForDart_Behavior_slot;
	kernel.KernelForDart_Class_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Class");
	kernel.KernelForDart_Class_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Class_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Class_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Class_slot.klass_.thisClass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Class_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_True_slot.superclass_slot = kernel.KernelForDart_Boolean_slot;
	kernel.KernelForDart_True_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("True");
	kernel.KernelForDart_True_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_True_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_True_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_True_slot.klass_.thisClass_slot = kernel.KernelForDart_True_slot;
	kernel.KernelForDart_True_slot.klass_.enclosingObject_slot = kernel;

	kernel.KernelForDart_Message_slot.superclass_slot = kernel.KernelForDart_Message_slot;
	kernel.KernelForDart_Message_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Message");
	kernel.KernelForDart_Message_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Message_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Message_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Message_slot.klass_.thisClass_slot = kernel.KernelForDart_Message_slot;
	kernel.KernelForDart_Message_slot.klass_.enclosingObject_slot = kernel;

	//Used by mixin application. Replacement with here sends questionable.
	Object_global = kernel.KernelForDart_Object_slot;
	Class_global = kernel.KernelForDart_Class_slot;
	Metaclass_global = kernel.KernelForDart_Metaclass_slot;

	//Used by literal re-writes. In principle replaceable with here sends.
	String_global = kernel.KernelForDart_String_slot;
	Number_global = kernel.KernelForDart_Number_slot;
	Block_global = kernel.KernelForDart_Block_slot;
	Array_global = kernel.KernelForDart_Array_slot;

	//Needed by Top noSuchMethod
	Message_global = kernel.KernelForDart_Message_slot;
}

main(){
	kernelInit();
	var Test_class = Metaclass_global.new_();
	var Test = new Test_metamixin(Test_class);
	Test_class.thisClass_slot = Test;

	Test.main();
}
'
)'private'
compileClass: klass <Class> ^<MixinRep> = (
	| stream source |
	stream:: (super String new: 1000) writeStream.
	klass mixin printTopClassOn: stream.
	source:: stream contents.
	^compiler compileClassSource: source readStream within: nil
)
nlrClass ^<Node> = (
	"Instances of this class are thrown as the exceptions used to implement non-local returns."
	^dart 
		class: 'NLR_'
		extends: 'Object'
		fields: {dart var: 'value'}
		constructors: {}
		methods: {}
)
topClass ^<Node> = (
	"Top allows all Newspeak code to reside in mixins. In particular, it means we don't need a special case for Object. Top has one instance variable to track the Newspeak class of an object since Dart does not support asking for the runtime class of an object. Top has three methods: noSuchMethod() which wraps its arguments appropriately and delegates to #doesNotUnderstand:, toString() which delegates to #printString and unwraps the Newspeak String, and initializer_new() which is the basis case for the instance initializer scheme."
	^dart 
		class: (mixinClassNameFor: 'Top')
		extends: 'Object' "Dart's Object"
		fields: {dart var: 'klass_'}
		constructors: {dart verbatim: (mixinClassNameFor: 'Top'),'(this.klass_);'}
		methods: {
	
		dart
			method: 'noSuchMethod'
			params: {'name'. 'args'}
			body: (dart block: {
			
dart return: (dart
	on: (dart ident: 'this')
	invoke: (dart ident: 'doesNotUnderstand__')
	with: {dart 
		on: (dart ident: 'Message_global')
		invoke: (dart ident: 'selector__arguments__')
		with: {
			dart on: (dart ident: 'String_global') invoke: (dart ident: 'wrapping__') with: {dart ident: 'name'}.
			dart on: (dart ident: 'Array_global') invoke: (dart ident: 'wrapping__') with: {dart ident: 'args'} 
				}
			})
		
		}).

		dart
			method: 'toString'
			params: {}
			body: (dart block: {
				dart return: (dart 
					on: (dart 
						on: (dart ident: 'this')
						invoke: (dart ident: (mangleSelector: 'printString'))
						with: {})
					invoke: (dart ident: (mangleSelector: 'dartString'))
					with: {})}).				
		
		dart 
			method: (mangleSelector: (compiler initializerSelectorNameFor: 'new'))
			params: {}
			body: (dart block: { 
				dart return: (dart ident: 'this')}).
	}
)) : ()
class MethodMirror named: s <Symbol> = LowLevelMirror (
"A descriptor for a Dart method."| 
	selector <Symbol> = s.
	method <Node>  "Dart code"
	src <String> "Newspeak source - optional"
	|)
('as yet unclassified'
isAccessor ^ <Boolean> = (
	^metadata at: #isAccessor ifAbsent:[false]
)
isAccessor: b <Boolean> = (
	isSynthetic: b.
	metadata at: #isAccessor put: b
)
isFactory ^ <Boolean> = (
	^metadata at: #isFactory ifAbsent:[false]
)
isFactory: b <Boolean> = (
	isSynthetic: b.
	metadata at: #isFactory put: b
)
isSynthetic ^ <Boolean> = (
	^metadata at: #isSynthetic ifAbsent:[false]
)
isSynthetic: b <Boolean> = (
	metadata at: #isSynthetic put: b
)
name ^ <Symbol> = (
	^selector
)
simpleName ^ <Symbol> = (
	^selector
)) : ('as yet unclassified'
REFACTORING = (
	"Maybe this should be the class called LowLevelMethodMirror and live in the mirrors module."
))
class MixinRep first: cmm last: subreps = (
"The other compilers and mirror systems typically use tuples such that type MixinRep = {CompiledMixinMirror. List[MixinRep]}. For interoperability, this class understands #first and #last."|
	compiledMixinMirror <CompiledMixinMirror> = cmm.
	nestedReps <List[MixinRep]> = subreps.
|)
('as yet unclassified'
first = (
	^compiledMixinMirror
)
last = (
	^nestedReps
)
size = (
	^2
)) : ('as yet unclassified'
REFACTORING = (
	"Use of tuple MixinRep should be rewritten to use this class, as it makes debugging much easier"
))
class PropertyCallAST = MessageAST (
"Sepcialized node to represent applications of JS properties. In some cases (well, at least one) we need to generate ASTs that call javascript methods directly. These calls need to be translated slightly differently (their names must not be mangled). To distinguish these form normal message sends, we use this node.")
('as yet unclassified'
apply: tool <ASTTool> = (
	^tool propertyCallNode: self
)) : ()
class Scope = (
"A generic scope facility.

The text below describes the intended scheme for handling closures using the Cog VM's closure support. It is not yet implemented.

To support efficient compilation of closures, each scope tracks how many temporary variables need to ''remote''. 

A remote temporary is one that is closed over by a nested closure, and cannot reliably be copied down into the closure upon closure creation.  Any temporary that might be written to after closure creation is necessarily remote.

Remote temps are allocated in an array rather than directly in their activation. All the remote temps in a given scope are alllocated in a single array, the remote temp vector. Each remote temp is uniquely identified by an index into th eremote temp vector.

Closures nested within the scope get a reference to the remote temp vector. They can and read and write a temporary by modifying the vector using the index associated with the temporary.

Typically, the first instruction in the code of a closure or method allocates the remote temp vector (if one is needed). This is supported by a special byte code, pushArray.

Reads and writes to a remote temp take the form of at: i and at: i put: v sends where i is the index of the remote temp and v is the value being written to it.

A temporary variable is considered remote iff:

a. It is written to in a closure nested within its defining method or closure.
b. It is read in in a closure c nested within its defining method or closure, and written to after the end of c.

"| 
  superScope 
  bindings =  Dictionary new.
	public end <Integer>
 |)
('access'
at: aKey put: aValue = (


^self bindings at: aKey put: aValue
)
at: aKey put: aValue ifThere: aBlock = (

    "Associates aValue with aKey and answers aValue if aKey
    was absent. Otherwise answers the value of aBlock."
    | wasAbsent |
    self assert: [aKey isSymbol] 
	message:['Attempt to ok up non-symbol ',aKey printString, ' in scope'].
    wasAbsent:: false.
    bindings at: aKey ifAbsent: [bindings at: aKey put: aValue. wasAbsent:: true].
    ^ wasAbsent
        ifTrue: [aValue]
        ifFalse: [aBlock value]
)
at: key = (

	"Answers the value associated with aKey in this or one the super scopes or fails if aKey is absent"
	^self at: key ifAbsent: [self error: 'Key ', key, ' not found!']
)
at: key ifAbsent: blk = (

    "Answers the value associated with aKey in this or one of the superScopes or the value of aBlock if aKey is absent."

	"Optimization note: This is written using [nil] blocks to avoid passing 
		non-clean blocks dynamically down the scope structure."

	| val <T> |
	(val:: self bindings at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	self superScope isNil
		ifTrue: [ ^blk value ].
	(val:: self superScope at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	^blk value
)
clear = (


self bindings keys do:[:k | self bindings removeKey: k].
)
includesIndex: key = (
"should this search the superscope?"
    ^ self bindings includesKey: key
)
includesIndexLocally: key <NameType > ^ <Boolean> = (


^self bindings includesKey: key.
)
removeKey: key = (


self bindings removeKey: key
)
removeKey: key ifAbsent: blk = (


self bindings removeKey: key ifAbsent: blk
)
within: scope = (
    "Creates and initializes a new (sub)scope within scope."
      self superScope: scope.
  )'as yet unclassified'
depth ^ <Integer> = (
	superScope ifNil:[^0].
	^superScope depth + 1.
)) : ('as yet unclassified'
REFACTORING = (
	"This should be factored out along with ScopeBuilder. Perhaps it should also become nested within ScopeBuilder."
))
class SemanticVarDecl decl: d <VarDeclAST> = SymbolTableEntry for: d (
"Semantic info for a variable: slot, local or parameter."|
  offset <Integer>
  remote ::= false.
  remoteVector <SemanticVarDecl>
|)
('as yet unclassified'
isTemporaryAST ^ <Boolean> = (
	^data isTemporaryAST
)
setIndex: i <Integer> InVector: v <VarDeclAST> = (
	assert: remote message: 'Var Decl is not remote'.
	remoteVector:: v.
	offset:: i.
)
variableClass ^ <Class> = (
	^data variableClass
)) : ()
class SymbolTableEntry for: datum = (| 
  sym  
  data ::= datum first.  
  depth = datum last.  
|)
('as yet unclassified'
isMethodNode = (^self data  isMethodNode)'testing'
isMessagePatternNode = (^self data  isMessagePatternNode)
isVarDeclNode = (^self data isVarDeclNode)) : ()'as yet unclassified'
MutableString = (
	#FLAG.
	^String
)
REFACTORING = (
	"Rewriter, Translator, Writer are stateful visitors that have a method to reset their state. It would be less error prone if they had no such reset methods and instead a new instance was created for each use."
)
assert: block = (
	assert: block message: 'Assertion failed'
)
compile: source <ReadStream> to: output <WriteStream> = (
	|
	compiler = Compiler new.
	rep
	|
	
	Infrastructure outputTo: output.
	
	rep:: (compiler compileClassSource: source within: nil).
	compiler outputTopLevelClass: rep to: output.
	
	"compiler outputMainForReps: reps to: output."
)'names'
fullyQualifySimpleName: simpleName <Symbol> with: fullyQualifiedPackage <Symbol> = (
	^fullyQualifiedPackage, '`', simpleName
)
mangleSelector: selector <String> ^<String> = (
	"Convert a Newspeak selector into a Dart identifer."
	| res <String> ::= selector. |
	selector first = $_ ifTrue: [halt "Affects access semantics in Dart"].

	selector = 'self' ifTrue: [halt. ^'this'].
	selector = 'this' ifTrue: [^'this_'].
	selector = 'Object' ifTrue: [^'Object_'].
	selector = 'new' ifTrue: [^'new_'].
	selector = 'else' ifTrue: [^'else_'].
	selector = 'print' ifTrue: [^'print_'].	
	selector = 'class' ifTrue: [^'class_'].	
	
	
	selector = '+' ifTrue: [^'plus_'].
	selector = '-' ifTrue: [^'minus_'].
	selector = '*' ifTrue: [^'times_'].
	selector = '/' ifTrue: [^'over_'].
	selector = '**' ifTrue: [^'starstar_'].
	selector = '//' ifTrue: [^'overover_'].
	
	selector = '<' ifTrue: [^'less_'].
	selector = '>' ifTrue: [^'greater_'].
	selector = '<=' ifTrue: [^'lessequal_'].
	selector = '>=' ifTrue: [^'greaterequal_'].
	selector = '=' ifTrue: [^'equal_'].
	selector = '==' ifTrue: [^'equalequal_'].
	
	selector = '&' ifTrue: [^'amp_'].
	selector = '|' ifTrue: [^'pipe_'].
	selector = ',' ifTrue: [^'comma_'].
	
		
	res:: res copyReplaceAll: '_' with: '___'. "Must be first"
	res:: res copyReplaceAll: ':' with: '__'.
	res:: res copyReplaceAll: '`' with: '_'.
	^res
)
mangleSlotName: n = (
	^((mangleSelector: n) , '_slot') asSymbol
)
metamixinClassNameFor: fqn <String> ^<String> = (
	^(mangleSelector: fqn), '_metamixin'
)
mixinClassNameFor: fqn <String> ^<String> = (
	^(mangleSelector: fqn), '_mixin'
)) : ()