Newspeak3
'NS2Dart'
class Newspeak2DartCompilation usingPlatform: platform parsing: parsing mirrors: mirrors = (
"Does the interesting work in Newspeak-to-Dart translation.

Derived from the NS2JS compiler, in turn derived from the NS2Squeak compiler.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
	Dictionary = platform collections Dictionary.
	OrderedCollection = platform collections OrderedCollection.
	Set = platform collections Set.
	
	Parser = parsing Parser.
	parser = Parser new.
	
	astModule = parsing ASTModule. "Cheat-ish"
	ASTTool = astModule ASTTool.
      ASTCopier = astModule ASTCopier.
      SuperFalseVisitor = astModule FalseVisitor.
      AST = astModule AST.
	AssignmentAST = astModule AssignmentAST.
	BlockAST = astModule BlockAST.
	CascadedSendAST = astModule CascadedSendAST.
	CodeBodyAST = astModule CodeBodyAST.
	MessageAST = astModule MessageAST.
      MessagePatternAST = astModule MessagePatternAST.
	MethodAST = astModule MethodAST.
	NormalSendAST = astModule NormalSendAST.
	NumberAST = astModule NumberAST.
	ReturnStatAST = astModule ReturnStatAST.
      SendAST = astModule SendAST.
	SymbolAST = astModule SymbolAST.
	TupleAST = astModule TupleAST.
      VarDeclAST = astModule VarDeclAST.
	VariableAST = astModule VariableAST.
	
	LowLevelMixinMirror = mirrors LowLevelMixinMirror.
	InstanceVariableMirror = mirrors InstanceVariableMirror.
	CompiledMixinMirror = mirrors CompiledMixinMirror.
	SlotMirror = mirrors SlotMirror.
|)
(
class Compiler = (|
	scopeMap <Map[AST,Scope]> ::= Dictionary new.
	scopeStack <List[Scope]> ::= OrderedCollection new.
	currentDepth <Integer>
	
	literalTable
	input <ReadStream>
	
	currentMixinUID "Nix?"
	
	rewriter = Rewriter new.
	translator = Translator new.
	|)
(
class Rewriter = ASTTool (
"A visitor that rewrites the AST into a form more suitable for compilation to Javascript. It may be possible to combine the pass that constructs the scopes with the rewriting pass, but this may be messy once we start inlining blocks etc."| 
	scope <Scope> 
	scopeStack <OrderedCollection[Scope]> = OrderedCollection new.
	protected readMap <Map[TemporaryAST, Integer]> = Dictionary new.
	protected writeMap <Map[TemporaryVariableAST, {Integer. Integer}]> = Dictionary new.
	protected valueExpected <Boolean> ::= true. "A flag set by visitor methods to indicate whether the parent AST uses the value of the currently visited node or not."
	protected areReturnsLocal <Boolean> ::= true. "Set to true while visiting nodes contained within a method and its inlined blocks, false in non-inlined blocks."
	protected rewritingMethodBody <Boolean> ::= true. "Set to true prior to visiting the code body of a method, to false prior to visiting one of a block."
	protected conditionalSelectors = Set withAll: {#ifTrue:ifFalse:. #ifFalse:ifTrue:. #ifTrue:. #ifFalse:}.
	protected inlinableOperators <Dictionary[String, String]> = Dictionary new.
	protected inlinableNumericOperators <Dictionary[String, String]> = Dictionary new.
|inlinableOperators
		at: #+ put: '+';
		at: #- put: '-';
		at: #* put: '*';
		at: #/ put: '/';
		at: #'==' put: '==='.
	inlinableNumericOperators	
		at: #'<' put: '<';
		at: #'<=' put: '<=';
		at: #'>' put: '>';
		at: #'>=' put: '>=')
(
class BlockLocalReturnAST expression: x start: s end: e = AST (
"This class represents a 'local return' (LR) -  a return from a block to its caller, as opposed to the caller of its enclosing method (a 'non-local return' or NLR).

An actual return statement in a block means an NLR; an LR is implicit in the source language, and occurs on the last statement of the block, unless that statement is a true return (NLR).  However, the back end of the compiler requires that this information be represented explicitly. This node does that."|
 expr <ExpressionAST> = x.
|start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool>  = (
	^aTool blockLocalReturnNode: self
)
isBlockLocalReturnAST ^<Boolean> = (
	^true
)) : ()
class BoolAST withValue: aBool <Boolean> start: s end: e = VariableAST (
""| val = aBool. |start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool boolNode: self
)
name = (
	^val printString asSymbol
)) : ()
class BoolVisitor = FalseVisitor ()
('as yet unclassified'
boolNode: node = (^true)) : ()
class ContextAST = VariableAST (
"Represents uses of thisContext. I expect these to be restricted in future versions. Currently, we use it for outer sends and super sends")
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool contextNode: self
)
name = (
	^#thisContext
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(thisContext)'
)) : ()
class ContextVisitor = FalseVisitor ()
('as yet unclassified'
contextNode: node = (^true)) : ()
class ExplicitReceiverVisitor = FalseVisitor ()
('as yet unclassified'
explicitOuterReceiverNode: aNode <ExplicitOuterRcvrAST> ^ <Boolean> = (
	^true
)) : ()
class ExplicitRecvrAST send: sym <Symbol> depth: d <Integer> = AST (
"Represents the receiver of an explicit outer send."|
	outerClassName <Symbol> = sym.
	depth <Integer> = d.
	selector <Symbol>
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool explicitOuterReceiverNode: self
)
isExplicitRcvrNode ^ <Boolean> = (
	^true
)
isExpressionNode ^ <Boolean> = (
	^true
)) : ()
class FalseVisitor = SuperFalseVisitor (
"Extends the standard FalseVisitor with methods for dealing with the node types introduced by the rewriter..")
('as yet unclassified'
boolNode: node = (^false)
contextNode: node = (^false)
ifNode: aNode <IfAST> ^ <Boolean> = (
	^false
)
implicitSendNode: aNode <ImplicitRcvrSendAST> ^ <Boolean> = (
	^false
)
loopNode: aNode <LoopAST> ^ <Boolean> = (
	^false
)
nilNode: node = (^false)
parameterNode: aNode <ParameterAST> ^ <Boolean> = (
	^false
)
receiverNode: aNode <ReceiverAST> ^ <Boolean> = (
	^false
)
returnInstVarMethodNode: aNode <ReturnInstVarMethodAST> ^ <Boolean> = (
	^false
)
returnSelfMethodNode: aNode <ReturnSelfMethodAST> ^ <Boolean> = (
	^false
)
superSendNode: aNode <SuperSendAST> ^ <Boolean> = (
	^false
)
superVarNode: aNode <SuperVarAST> ^ <Boolean> = (
	^false
)
temporaryNode: aNode <TemporaryVariableAST> ^ <Boolean> = (
	^false
)
variableNode: aNode = (
	^false
)) : ()
class ImplicitRecvrSendAST send: aMsg <MessageAST> depth: d <integer> = SendAST send: aMsg (
"
Represent a send of a message with an implicit receiver (aka a here send).
"| depth <Integer> ::= d. |)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool implicitSendNode: self
)
isExpressionNode ^ <boolean> = (
	^true
)
recv ^ <VarDeclAST> = (
  ^ assert:[false] message: 'There is no receiver node. It is implicit'
)) : ()
class ImplicitRecvrVisitor = FalseVisitor ()
('as yet unclassified'
implicitSendNode: aNode <ImplicitRcvrSendAST> ^ <Boolean> = (
	^true
)) : ()
class InlinableAsExpressionConditionalAST = NormalSendAST (
"Produced by the rewriter for the conditional messages whose value is required and which can be compiled into a Javascript ternary operator."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinableAsExpressionConditionalNode: self
)) : ()
class InlinableConditionalAST = NormalSendAST (
"Produced by the rewriter for conditional messages (ifTrue: and the like) that can be compiled into Javascript if statements instead of real message sends. To qualify, the message arguments should be literal blocks and the value of the message send should be ignored (for example, '^x ifTrue: [foo]' is not inlinable, while 'x ifTrue: [^foo]' is)."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinableConditionalNode: self
)) : ()
class InlinedOperatorAST = NormalSendAST (
"When the inlineOperators mode is on, message sends with certain selectors are replaced with this node. Javascript code generated for those nodes uses native Javascript operators instead of real message sends. The selector of the message of this AST is not a real Newspeak selector but rather the Javascript operator such as &&."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinedOperatorNode: self
)) : ()
class InstVarVisitor = FalseVisitor ()
('node traversal'
instVarNode: node = (^true)) : ()
class NilAST = VariableAST (
"")
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool nilNode: self
)
name = (
	^#nil
)) : ()
class NilVisitor = FalseVisitor ()
('as yet unclassified'
nilNode: node = (^true)) : ()
class ParameterAST name: n type: t = VarDeclAST name: n type: t (
"")
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool parameterDeclNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(', name, ')'
)'as yet unclassified'
variableClass ^ <ParameterVariableAST class> = (
	^ParameterVariableAST
)) : ()
class ParameterVariableAST name: n start: s end: e = VariableAST (
""name: n. start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool parameterNode: self
)) : ()
class ReceiverAST = VariableAST (
"")
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool receiverNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(self)'
)'as yet unclassified'
name = (
	^#self
)) : ()
class ReceiverVisitor = FalseVisitor ()
('node traversal'
receiverNode: node = (^true)) : ()
class SuperSendAST send: aMsg <MessageAST> = SendAST send: aMsg (
"This code is currently unused.  
Unlike Smalltalk, super calls in Newspeak cannot be statically bound.
Hence, we cannot use the Squeak VM's  super send byte codes. Currently, super sends are rewritten into a complex call structure by the rewriter, to ensure the correct binding of super.

When the Newspeak VM is modified to support dynamic binding of super sends, we will probably use this node and allied code,  which can easily be processed by the byte code compiler and code generator.")
('Unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool superSendNode: self
)
recv ^ <SuperVarAST> = (
  ^SuperVarAST new
)'as yet unclassified'
isExpressionNode ^ <boolean> = (
	^true
)) : ()
class SuperSendVisitor = FalseVisitor ()
('node traversal'
superSendNode: node <SuperSendAST> = (
      ^true
   )) : ()
class SuperVarAST = VarDeclAST name: #super type: nil (
"")
('Unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool superVarNode: self
)) : ()
class TemporaryAST name: n type: t = VarDeclAST name: n type: t (
""| initializer |)
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool temporaryDeclNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(', name, ')'
)'as yet unclassified'
isTemporaryAST ^ <Boolean> = (
	^true
)
variableClass ^ <TemporaryVariableAST class> = (
	^TemporaryVariableAST
)) : ()
class TemporaryVariableAST name: n start: s end: e = VariableAST (
"This node represents reference to a temporary variable."name: n.  start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool temporaryNode: self
)) : ()'as yet unclassified'
addLiteralConstant: s <Character | Number | String | Symbol> = ( 
	(literalTable includesKey: s) ifFalse: [literalTable at: s put: literalTable size].
)
addNumericLiteral: n <Number> = ( 
   addLiteralConstant: n
)
applyForEffectTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: false.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
applyForValueTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: true.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
assignmentFrom: aMsg <MessageAST> decl: vd <VarDeclAST> ^ <AssignmentNode> = (
	| var <VariableAST> varName <String> args selector <String> |
	assert: [aMsg args size = 1].
	selector:: aMsg sel asString.
	varName:: selector copyWithSize: (selector size -1).
	assert: [(currentScope at: varName asSymbol) isTemporaryAST].
	"what about setter methods - then we might have an inst var? this cannot happen, because this is only called when processing variables"
	var:: TemporaryVariableAST
		name: varName
		start: aMsg start
	 	end: aMsg end.

	args:: applyForValueTo: aMsg args first. "recurse on RHS"
	"this is where we note that a temporary is being written to; this information is necessary to determine which temporaries can be copied into closures and which have to be 'remote'"
	noteWriteOf: var.     
	"create an assignment"

	^AssignmentAST new 
		to: var assign: args;
		start: aMsg start;
		end: aMsg end                     
)
boolNode: node = (
	"Should not normally be invoked; only possible when rewriting an already rewritten tree."
	halt.
	^node
)
currentScope ^ <Scope> = (
	^scopeStack last
)
enclosingObjSendOfDepth: n <Integer> to: recv <AST> start: start <Integer> end: end <Integer>  ^ <NormalSendAST> = (
	^NormalSendAST new 
		recv: recv; 
		msg:(MessageAST new sel: (enclosingObjectMsgForDepth: n); args: {}; start: start; end: end);
		start: start; 
		end: end.
)
enclosingObjectMsgForDepth: n <Integer> ^ <String> = (
"Compute the selector necessary for obtaining the nth enclosing object wrt to the current lexical scope."
	| otable  <Dictionary[Symbol, Tuple[Class, Integer]]> ec <Class> |
	"What if n has no corresponding entry in the outer table? This should not happen, as this method is called on the basis of an n value found in the table to begin with."
	otable:: currentScope at: #outer.
	ec:: (otable values detect: [:some | (some at: 2) = (n-1)]) at: 1.
	^(Compiler new enclosingObjectMsgFor: ec) asSymbol
)
explicitOuterReceiverNode: node = (
	assert: [node apply: ExplicitReceiverVisitor new].
	^node
)
hereName = (
	^#'@here'
)
hereNode ^<AST> = (
	^VariableAST new name: hereName
)
inline: node as: sendClass selector: selector rewriteArgsAs: argRewriteBlock = (
	| receiver message |
	receiver:: applyForValueTo: node recv.
	message:: MessageAST new
		send: selector
		with: (node msg args collect: argRewriteBlock).
	^sendClass new
		to: receiver send: message;
		start: node start;
		end: node end
)
isHereNode: aNode <AST> ^ <Boolean> = (
	aNode isVariableNode ifFalse: [^false].
	(isPseudoVariableNode: aNode) ifTrue: [^false].
	assert: [aNode name = hereName].
	^true
)
isInlinableAsExpressionConditional: node <NormalSendAST> ^ <Boolean> = (
	(node msg sel = 'ifTrue:ifFalse:' and: [valueExpected]) ifFalse: [^false].
	node msg args do:
		[:each <AST> |
		((isRemovableBlock: each withArgs: 0)
			and: [each body statements size = 1
			and: [each body statements first isReturnStatNode not]])
				ifFalse: [^false]].
	^true
)
isInlinableBooleanOperator: node <NormalSendAST> = (
	| selector |
	selector:: node msg sel.
	^(selector = 'or:' or: [selector = 'and:'])
		and: [node msg args size = 1
		and: [node msg args first isBlockNode
		and: [node msg args first body statements size = 1]]]
)
isInlinableConditional: node <NormalSendAST> ^ <Boolean> = (
	((conditionalSelectors includes: node msg sel) and: [valueExpected not]) ifFalse: [^false].
	node msg args do: [:each <AST> | (isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
	^true
)
isInlinableNumericOperator: node <NormalSendAST> = (
	| args |
	args:: node msg args.
	args size = 1 ifFalse: [^false].
	(inlinableNumericOperators includesKey: node msg sel) ifFalse: [^false].
	(node recv isLiteralNode and: [node recv val isNumber]) ifTrue: [^true].
	(args first isLiteralNode and: [args first val isNumber]) ifTrue: [^true].
	^false
)
isInlinableOperator: node <NormalSendAST> = (
	^(inlinableOperators includesKey: node msg sel)
		and: [node msg args size = 1]
)
isInlineableLoop: node <NormalSendAST> ^ <Boolean>= (
	| selector <Symbol>  args |
	selector:: node msg sel.
	args:: node msg args.
	({#whileTrue. #whileFalse. #whileTrue:. #whileFalse:. #repeat} includes:  selector) ifTrue:
		[args do:
			[:each |
			(isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
		^isRemovableBlock: node recv withArgs: 0].
	
	(selector = #timesRepeat:) ifTrue:[^isRemovableBlock: args last withArgs: 0].
	({#to:do:. #to:do:by:}  includes:  selector) ifFalse:[^false].
	(isRemovableBlock: args last withArgs: 1) ifFalse:[^false].
	(selector = #to:do:) ifTrue:[^true].
	args size = 3 ifFalse:[^false].
)
isOuterNode: aNode <AST> ^ <Boolean> = (
	aNode isVariableNode ifFalse: [^false].
	^aNode name = #outer
)
isPseudoVariableNode: aNode <VariableAST> ^ <Boolean> = (
	^aNode name = #self
		or: [aNode name = #super
		or: [aNode name = #outer
		or: [aNode name = #thisContext]]]
)
isSuperNode: aNode <VariableAST> ^ <Boolean> = (
	aNode isVariableNode ifFalse:[^false].
	^aNode name =  #super 
)
mixinApplication: node <MixinApplicationAST> = (
	| msg |
"For now, just compile it as a regular message send"
	msg:: MessageAST new
			send: #apply:
			with: (OrderedCollection with: node superclassExpr);
			start: node start;
			end: node end.

	^(NormalSendAST new
		to: node mixinExpr send: msg;
		start: node start;
		end: node end) apply: self
)
nilNode: node = (
	"Should not normally be invoked; only possible when rewriting an already rewritten tree."
	halt.
	^node
)
noteReadOf: t <TemporaryAST>  = (
	| lastRead <integer> |
"earliest read nested in a closure"
	lastRead:: readMap at: t ifAbsent: [readMap at: t put: currentScope end. ^self].
	"if t has not yet been read, record this read in the map and exit; otherwise, find out what the last recorded value was"
	readMap at: t put: (lastRead min: currentScope end)
	"record the minimum of the last recorded value and the end of the current block. If a read occurs in a nested block, that block will end before the enclosing block or method,  and the block's ending will be recorded"
)
noteWriteOf: t <TemporaryVariableAST>  = (
"Location of last write, and minimal block ending."
	| lastWrite <Integer> prevBlockEnd <Integer> |
	
	prevBlockEnd:: (writeMap at: t ifAbsent:[{0. 0}]) last.
	lastWrite:: Array new: 2.
	lastWrite at:1  put: t start. "record source start index of last write"
	lastWrite at: 2 put: (currentScope end min: prevBlockEnd). "record end of block of any nested write"
	writeMap at: t put: lastWrite.
)
oldProcessExplicitOuterSend: aMsg <MessageAST> atDepth: n = (


| holder <NormalSendAST>  ctxt <VariableAST> start <Integer> end <integer> 
enclosingObj <NormalSendAST>  nonMeta  <NormalSendAST> 
 |
"For n > 0, return
thisContext methodClass enclosingObject`Cn ... C0 
                                         class enclosingObject`Cn ...`C1  ...  
                                            class enclosingObject`Cn`Cn-1 msg

which is the equivalent of

outer X msg

where X is the nth lexically enclosing class. Otherwise, do a self send"

n = 0 ifTrue:[^selfSendFrom: aMsg].
start:: aMsg start.
end:: aMsg end.
ctxt:: VariableAST new name: #thisContext; start: start; end: end.

holder:: NormalSendAST new recv: ctxt;
                                             msg: (MessageAST new sel:#lexicalClass; args: {});
                                              start: start; end: end.

nonMeta:: NormalSendAST new recv: holder;
                                             msg: (MessageAST new sel:#theNonMetaClass; args: {});
                                              start: start; end: end.

enclosingObj::  enclosingObjSendOfDepth: 1 to: nonMeta start: start end: end. 

enclosingObj:: (2 to: n) inject: enclosingObj into:[:r <NormalSendAST> :i <Integer> | 
	| csend <NormalSendAST> |
	  csend::  NormalSendAST new recv: r; 
	                                               msg:(MessageAST new sel: #class; args: {}; start: start; end: end);
	                                               start: start; 
	                                               end: end.
	 enclosingObjSendOfDepth: i to: csend start: start end: end. 
	 ].
^(NormalSendAST new recv: enclosingObj; msg: aMsg; start: start; end: end) apply: self
)
parameterNode: node <ParameterVariableAST> = (
	^node
)
processExplicitOuterReceiver: aMsg <MessageAST> = (
	| selectorBinding <AST> depth <integer> |
	assert:[aMsg args isEmpty]. "this had better be a unary message"
	selectorBinding:: currentScope at: aMsg sel.
	"assert:[selectorBinding data  isClassDeclarationAST]."
	depth: currentDepth -  selectorBinding depth -1.
	addNumericLiteral: depth. "the backend checks that depth in 0 - 256"
	^(ExplicitRecvrAST send: aMsg sel depth: depth)
		start: aMsg start;
		end: aMsg end
)
processExplicitOuterSend: aMsg <MessageAST> = (
"Unused at the moment"
)
processHereSend: aMsg <MessageAST> = (
	| binding <AST> |
	binding:: currentScope at: aMsg sel ifAbsent: [MessageAST new].
	binding isMessagePatternNode ifTrue:
		["this is a message send for a lexically defined method"
		^processImplicitOuterSend: aMsg atDepth: binding depth].
	binding isVarDeclNode
		ifTrue: [^ processVariable: aMsg decl: binding].
	({#true. #false. #nil} includes: aMsg sel) ifTrue:
		[^processVariable: aMsg decl: nil].
	^selfSendFrom: aMsg
)
processImplicitOuterSend: aMsg <MessageAST> atDepth: n <Integer> ^ <SendNode> = (
	"In this case, we don't care about the depth; but when compiling to other platforms, we might, so we maintain the API"
	| selectorBinding <AST> depth <integer> |
	selectorBinding:: currentScope at: aMsg sel.
	"assert:[selectorBinding data  isClassDeclarationAST]."
	depth: currentDepth -  selectorBinding depth.
	addNumericLiteral: depth. "the backend checks that depth in 0 - 256"
	^(ImplicitRecvrSendAST send: (aMsg apply: self) depth: depth) start: aMsg start; end: aMsg end
)
processOuterSend: aMsg <MessageAST> = (
	| holder <NormalSendAST> depth <Integer> binding <AST>  meMsg <MessageAST> |
	assert: [aMsg args isEmpty]. "this had better be a unary message"
	binding:: (currentScope at: #outer) at: aMsg sel.
	"assert binding makes sense "
	assert: [binding isKindOf: Collection].
	"assert: [binding first isKindOf: Class]." "disabled temporarily until we get the class story straight on the JS side"
	assert: [binding last isKindOf: Integer].

	meMsg:: MessageAST new sel: #yourself; args: {}; start: aMsg start; end: aMsg end. "hack!"
	^processOuterSend: meMsg atDepth: binding last
)
processOuterSend: aMsg <MessageAST> atDepth: n = (
"For n > 0, return
thisContext methodClass enclosingObject`Cn ... C0 
                                         class enclosingObject`Cn ...`C1  ...  
                                            class enclosingObject`Cn`Cn-1 msg

which is the equivalent of

outer X msg

where X is the nth lexically enclosing class. Otherwise, do a self send"

	| holder <NormalSendAST> ctxt <VariableAST> start <Integer> end <integer> 
	enclosingObj <NormalSendAST> nonMeta <NormalSendAST>  |

	n = 0 ifTrue: [^selfSendFrom: aMsg].
	start:: aMsg start.
	end:: aMsg end.
	ctxt:: VariableAST new name: #thisContext; start: start; end: end.

	holder:: NormalSendAST new
		recv: ctxt;
	 	msg: (MessageAST new sel: #lexicalClass; args: {});
		start: start; end: end.
	nonMeta:: NormalSendAST new
		recv: holder;
		msg: (MessageAST new sel: #theNonMetaClass; args: {});
		start: start; end: end.
	enclosingObj:: enclosingObjSendOfDepth: 1 to: nonMeta start: start end: end. 

	enclosingObj:: (2 to: n) inject: enclosingObj into:
		[:r <NormalSendAST> :i <Integer> | 
		| csend <NormalSendAST> |
		csend:: NormalSendAST new
			recv: r; 
			msg: (MessageAST new sel: #class; args: {}; start: start; end: end);
			start: start; 
			end: end.
		enclosingObjSendOfDepth: i to: csend start: start end: end].
	^(NormalSendAST new recv: enclosingObj; msg: aMsg; start: start; end: end) apply: self
)
processVariable: aMsg <MessageAST> decl: vd <VarDeclAST>  ^ <AssignmentNode | VariableNode> = (
	^aMsg sel last = $:
		ifTrue: "it is a temporary write"
			[assignmentFrom: aMsg decl: vd]
		ifFalse: "it is a parameter or temporary read"
			[variableFrom: aMsg decl: vd]
)
propertyCallNode: node <PropertyCallAST> ^ <PropertyCallAST> = (
	| args |
	assert: [node isMessageNode].
	args:: OrderedCollection new.
	node args do: [:each | args add: (applyForValueTo: each)].
	addLiteral: node sel.
	^PropertyCallAST new
		send: node sel with: args;
		start: node start;
		end: node end
)
returnsAreNonLocalWhile: block = (
	| originalValue |
	originalValue: areReturnsLocal.
	areReturnsLocal: false.
	^block ensure: [areReturnsLocal: originalValue]
)
rewriteInlinedBlockNode: node <BlockAST> ^ <BlockAST> = (
"An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined."
	| 
	rewrittenNode <BlockAST> 
      params <Collection[ParameterAST]>  
      bodyScope <Scope> 	
	| 
	assert: [node isBlockNode].
	"this shouldn't be handled here, but I'm not sure where the block / codebody 
	comes from."
	node body start isNumber
		ifFalse: [ node body start: node start. node body end: node end ].
	
	params:: node parameters collect:
		[:p <VarDeclAST> |
		(ParameterAST name: p name type: p type)  start: p start; end: p end].
	bodyScope:: scopeMap at: node body.
	params do: [:each | (bodyScope at: each name) data: each].
	addNumericLiteral: node parameters size.
	rewritingMethodBody: false.
	rewrittenNode:: BlockAST new body: (node body apply: self).
	rewrittenNode start: node start; end: node end.
	rewrittenNode body parameters: params.
	node body statements isEmpty ifTrue:
		[rewrittenNode body statements add: (NilAST new start: node body start; end: node body end)].
    ^rewrittenNode
)
selfSendFrom: aMsg <MessageAST>  ^ <MessageNode> = (
	^(NormalSendAST new
		msg: aMsg; 
		recv: (selfNode start: aMsg start; end: aMsg end);
		start: aMsg start; end: aMsg end) apply: self
)
setterBlockArgName = (
	^ ('setter_arg') asSymbol
)
xsetterSendNode: node <SetterSendAST> ^ <AST> = (
"Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send."
	| binding block blockArg send rewrittenSetterSend |
	assert: [node isSetterSendNode ].
	binding:: currentScope at: node msg sel ifAbsent: [MessageAST new].
	binding isVarDeclNode ifTrue:
		"This is an assignment to a temporary; no special handling is needed
		as the value of the expression is the value being assigned."
		[^processVariable: node msg decl: binding].
	valueExpected ifFalse:
		"The parent ignores the expression value; use a plain cheap here message send."
		[^processHereSend: 
			(MessageAST new
				sel: node msg sel;
				args: {applyForValueTo: node msg args first})].
	"The value is used by the parent; rewrite the whole thing as
		setter:: expr  =>  [:a | setter: a. a] value: expr"
	"a -- ok to use a constant name as long as it cannot collide with a user's name"
	blockArg:: ParameterVariableAST name: setterBlockArgName start: nil end: nil.
	"setter: a"
	send:: processHereSend:
		(MessageAST new
			sel: node msg sel;
			args: {blockArg}).
	"send:: applyForEffectTo: send."
	"[:a | setter: a. a]"
	block:: BlockAST new body:
		(CodeBodyAST new
			parameters: {ParameterAST name: setterBlockArgName type: nil}
			temporaries: {}
			statements: {
				send.
				"Need an explicit return because this is not rewritten again."
				BlockLocalReturnAST
					expression: blockArg
					start: node start
					end: node end
			}).
	"[:a | setter: a. a] value: expr"
	rewrittenSetterSend::
		NormalSendAST new
			to: block
			send: (MessageAST new
				sel: #value:;
				args: {applyForValueTo: node msg args first}).
	"TBD: What am I supposed to do with scopeMap here? Original code follows."
	"cb:: (CodeBodyAST new
			parameters: {};
			temporaries: {};
			statements: {sTempAssign. send. sTemp})."
	"scopeMap at: cb put: currentScope."
	^rewrittenSetterSend
)'closures'
currentSegment ^ <Integer> = (
	^0 "default until we implement it properly"
)
lastWriteOf: t <TemporaryAST> ^ <Integer> = (
	^0 "default for now"
)
readsOf: t <TemporaryAST> ^ <Set[Integer]> = (
	^Set new
)
segmentOf: t <TemporaryAST> ^ <Integer> = (
	^0 "default until we get a real implementation"
)
setSegmentOf: t <TemporaryAST> to: i <Integer> = (
	"default until we get a real implementation"
)'node traversal'
assignmentNode: node <AssignmentAST> ^ <AssignmentAST> = (
	assert: [node isAssignmentNode].
	"note write to target variable!"
	^AssignmentAST new
		to: (node var apply: self) assign: (applyForValueTo: node expr);
		start: node start; end: node end
)
blockLocalReturnNode: node = (
	^node
)
blockNode: node <BlockAST> ^ <BlockAST> = (
	" This method should only be called on a block that is not going to be inlined.

	There are two things that require rewriting in blocks.

	1. a.  Non-empty blocks must have their body rewritten recursively
	    b. Empty blocks need a nil expression in them.
	    c. All blocks must have their parameters rewritten from generic VarDecls to ParameterASTs. 
	2. If the last statement in a block is not a return, the block returns
	the expression to its caller. So the last expression needs to be replaced by a 'local return'.

	We accomplish (1) by calling rewriteInlinedBlockNode:, and then do  (2) explicitly.

	The reason for this separation is that step (1) is always needed; step (2) is only needed if the block is not inlined.
	"
	| rewrittenBlock <BlockAST> last <AST> |
	rewritingMethodBody: false.
	returnsAreNonLocalWhile:
		[rewrittenBlock:: rewriteInlinedBlockNode: node.
		last:: rewrittenBlock body statements last.
		(last isReturnStatNode or: [last isBlockLocalReturnAST]) ifFalse:
			["The last expression in a block is returned by it."
			rewrittenBlock body statements removeLast.
			rewrittenBlock body statements add:
				(BlockLocalReturnAST expression: last start: last start end: last end)].
  	  scopeMap at: rewrittenBlock put: (scopeMap at: node)].
    ^rewrittenBlock
)
cascadedSendNode: node <CascadeSendAST> ^ <CascadeSendAST> = ( 
	| prevSend msg |
	assert: [node isCascadedSendNode].
	prevSend:: applyForValueTo: node prevSend.
	msg:: applyForValueTo: node msg.
	^CascadedSendAST new to: prevSend cascade: msg;
							start: node start;
							end: node end;
							yourself
)
charNode: node <CharAST> = (
	addLiteralConstant: node val.
	^node
)
codeBodyNode: node <CodeBodyAST> ^ <CodeBodyAST> = (
	| 
	bodyScope <Scope>
	statements <OrderedCollection[StatementAST]>
	temps <OrderedCollection[TemporaryAST]> 
	result <CodeBodyAST>
	|
	assert: [node isCodeBodyNode].
	pushScopeForNode: node. 
	temps:: node temporaries collect:
		[:each <VarDeclAST> |
		(TemporaryAST name: each name type: each type)
			initializer: (each initializer ifNotNil: [:it | self applyForValueTo: it]);
			start: each start;
			end: each end.
		].
	bodyScope:: scopeMap at: node.
	temps do:
		[: t | (bodyScope at: t name)  data: t].
	statements:: OrderedCollection new.
	node statements keysAndValuesDo:
		[:index :statement | 
		| rewritten |
		rewritten:: (index = node statements size and: [rewritingMethodBody not])
			ifTrue: [applyForValueTo: statement]
			ifFalse: [applyForEffectTo: statement].
		statements add: rewritten].
	result:: CodeBodyAST new
		parameters: node parameters temporaries: temps statements: statements;
		start: node start;
		end: node end.
	popScope.
	scopeMap at: result put: bodyScope.
	^result.
)
genericApplicationExpressionNode: node = (
	assert: [node isGenericApplicationExpressionNode].
	^applyForValueTo: node target
)
guaranteedNode: node = (
	assert: [node isGuaranteedNode].
	^applyForValueTo: node expr
)
ifNode: node <ifAST> ^ <ifAST> = (
	assert: [ node isIfNode ].
	^node
)
implicitSendNode: node = (
    assert: [node apply: ImplicitRecvrVisitor new].
    ^node
)
loopNode: node <LoopAST> ^ <LoopAST> = (
    ^node
)
messageNode: node <MessageAST> ^ <MessageAST> = (
    | args |
    assert: [node isMessageNode].
    args:: OrderedCollection new.
    node args do: [ :arg | args add: (applyForValueTo: arg)].
    addLiteral: node sel.
    ^MessageAST new send: node sel with: args; start: node start; end: node end
)
messagePatternNode: node <MessagePatternAST> ^ <MessagePatternAST> = (
	| params <OrderedCollection[ParameterAST]>  patternScope <Scope> |
	params:: node parameters collect:
		[:p <VarDeclAST> | 
		(ParameterAST name: p name type: p type)
			start: p start;
			end: p end].
	patternScope:: scopeMap at: node.
	params do:
		[:p | (patternScope at: p name) data: p].
	^MessagePatternAST new
		selector: node selector parameters: params;
		start: node start;
		end: node end.
)
methodNode: node <MethodAST> ^<MethodAST | ReturnSelfMethodAST | ReturnInstVarMethodAST>
= (
	| 
	pattern <MessagePatternAST>  
	body <CodeBodyAST>
	result <MethodAST>
	|
	assert: [ node isMethodNode ].
	literalTable:: Dictionary new.
	pattern:: applyForValueTo: node pattern.
	rewritingMethodBody: true.
	body::  applyForValueTo: node body.
	body parameters: pattern parameters.
	body start: node start; end: node end.
	"Append ^self if there is no explicit return terminating the body.
	We are at the method level so that return should have been rewritten as a block local one."
	(body statements isEmpty not and: [body statements last isBlockLocalReturnAST]) ifFalse:
		[assert: [ body start isNumber ]. 		
		body statements addLast:
			(BlockLocalReturnAST
				expression: (ReceiverAST new start: body end; end: body end)
				start: body end
				end: body end)].
	result:: MethodAST new 
		pattern: pattern
		body: body
		visibility: node visibility;
		start: node start; end: node end; yourself.
	scopeMap at: result put: (scopeMap at: node).
	^result
)
mixinClassNode: node = (
	^node
)
normalSendNode: node <NormalSendAST> ^ <AST> = (
	| recv <AST> msg <MessageAST> sel <Symbol> |
	assert: [node isNormalSendNode].

	(isHereNode: node recv) ifTrue:
		[^processHereSend: node msg].
	(isOuterNode: node recv) ifTrue:
		[^processExplicitOuterReceiver: node msg].
	(isSuperNode: node recv) ifTrue:
		[^SuperSendAST send: (applyForValueTo: node msg)].

	(isInlinableAsExpressionConditional: node) ifTrue:
		[^inline: node as: InlinableAsExpressionConditionalAST
			selector: node msg sel
			rewriteArgsAs: [:each | rewriteInlinedBlockNode: each]].
	(isInlinableConditional: node) ifTrue:
		[^inline: node as: InlinableConditionalAST
			selector: node msg sel
			rewriteArgsAs: [:each | rewriteInlinedBlockNode: each]].
	(inlineOperators and: [isInlinableNumericOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableNumericOperators at: node msg sel)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableOperators at: node msg sel)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableBooleanOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (node msg sel = 'and:' ifTrue: ['&&'] ifFalse: ['||']) "BOGUS"
			rewriteArgsAs: [:each <BlockAST> | applyForValueTo: each body statements first]].		

	recv:: applyForValueTo: node recv.
	msg:: applyForValueTo: node msg.
	sel:: msg sel.
	^NormalSendAST new
		to: recv send: msg;
		start: node start;
		end: node end
)
numberNode: node = (
	assert: [node isNumberNode].
	addNumericLiteral: node val.
	^node
)
receiverNode: node <ReceiverAST> = (
	^ node
)
returnInstVarMethodNode: node = (
	^node
)
returnStatNode: node <ReturnStatAST> ^ <ReturnStatAST> = (
	assert: [node isReturnStatNode].
	^areReturnsLocal
		ifTrue:
			[BlockLocalReturnAST
				expression: (applyForValueTo: node expr)
				start: node start
				end: node end]
		ifFalse:
			[ReturnStatAST new
				expr: (applyForValueTo: node expr); 
		 		start: node start;
				end: node end]
)
selfNode ^ <VariableAST> = (
"shouldn't this be a ReceiverAST?"
"generate a an AST representing self; used for implicit self sends"
	^VariableAST new name: #self; start: 0; end: 0
)
setterSendNode: node <SetterSendAST> ^ <AST> = (
"Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send."
	| binding block blockArg blockParam blockScope send rewrittenSetterSend |
	assert: [node isSetterSendNode ].
	binding:: currentScope at: node msg sel ifAbsent: [MessageAST new].
	binding isVarDeclNode ifTrue:
		"This is an assignment to a temporary; no special handling is needed
		as the value of the expression is the value being assigned."
		[^processVariable: node msg decl: binding].
	valueExpected ifFalse:
		"The parent ignores the expression value; use a plain cheap here message send."
		[^processHereSend: 
			(MessageAST new
				sel: node msg sel;
				args: {node msg args first};
				start: node msg start; end: node msg end)].
	"The value is used by the parent; rewrite the whole thing as
		setter:: expr  =>  [:a | setter: a. a] value: expr"
	"a -- ok to use a constant name as long as it cannot collide with a user's name"
	blockArg:: ParameterVariableAST 
					name: setterBlockArgName 
					start: node msg start 
					end: node msg end.
	blockParam:: ParameterAST name: setterBlockArgName type: nil.
	"setter: a"
	send:: NormalSendAST new to: node recv send:
		(MessageAST new sel: node msg sel; args: {blockArg};
		start: node msg start; end: node msg end; yourself);
		start: node  start; end: node  end.
	"[:a | setter: a. a]"
	block:: BlockAST new body:
		(CodeBodyAST new
			parameters: {blockParam}
			temporaries: {}
			statements: {
				send.
				blockArg
			};			
			start: node start; end: node end);
			start: node start; end: node end.
	blockScope:: Scope new.
	blockScope
		superScope: currentScope;
		at: setterBlockArgName put: (SemanticVarDecl decl: {blockParam}).
	scopeMap at: block put: blockScope.
	scopeMap at: block body put: blockScope.
	"[:a | setter: a. a] value: expr"
	rewrittenSetterSend::
		NormalSendAST new
			to: block
			send: (MessageAST new
				sel: #value:;
				args: {node msg args first};
				start: node msg start; end: node msg end);
				start: node  start; end: node  end.
	^applyForValueTo: rewrittenSetterSend
)
stringNode: node = (
	assert: [node isStringNode].
	addLiteralConstant: node val.
	^node
)
superSendNode: node = (
	assert: [node apply: SuperSendVisitor new].
	^node
)
symbolNode: node = (
	assert: [node isSymbolNode].
	addLiteralConstant: node val.
	^node
)
temporaryNode: node <TemporaryVariableAST> = (
	"Possibily " #BOGUS.
	^node
)
tupleNode: aNode <TupleAST> = (
"Rewrite into a tree representing the expression
	(Array new:  n) at: 1 put:: e1 ; ...  at: n put: en; yourself
where n is the size of the tuple."
	|
	arrayNode <NormalSendAST> 
	arrayLengthNode <NumberAST> 
	tupleInitializationNodes <List[NormalSendAST]>
	index <Integer>
	|
	arrayLengthNode:: NumberAST new val: aNode elements size.
	arrayLengthNode start: aNode start; end: aNode end.
	arrayNode:: NormalSendAST new
		to: (NormalSendAST new 
				to: hereNode 
				send:  (MessageAST new
					sel: #Array;
					args: {};
					start: aNode start;
					end: aNode end)) 
		send: (MessageAST new
				sel: #new:;
				args: {arrayLengthNode};
				start: aNode start;
				end: aNode end).
	arrayNode start: aNode start; end: aNode end.
	aNode elements size = 0 ifTrue: [^applyForValueTo: arrayNode].
	index:: 0.
	tupleInitializationNodes:: aNode elements inject: arrayNode into:
		[:r : e |  | msg <MessageAST> |
	      index:: index + 1.
	      msg:: MessageAST new
			sel: #at:put:; 
			args: 
				{NumberAST new val: index; start: aNode start; end: aNode end.
				e}.
		msg start: aNode start; end: aNode end.
	      index = 1 
			ifTrue: 
				[NormalSendAST new to: r send: msg; start: aNode start; end: aNode end] 
				"(Array new: n) at:1 put: e1"
	      	ifFalse: 
				[CascadedSendAST new to: r cascade: msg; start: aNode start; end: aNode end].
				"...; at: k put: ek"
		].
	^applyForValueTo:
		((CascadedSendAST new
			to: tupleInitializationNodes
			cascade:
					(MessageAST new
						sel: #yourself;
						args: {};
						start: aNode start;
						end: aNode end))
				start: aNode start;
				end: aNode end)
)
variableNode: aNode <VariableAST> = (
	assert: [ aNode start isNumber ].
	aNode name = #self ifTrue:
		[^ReceiverAST new start: aNode start; end: aNode end].
	aNode name = #nil ifTrue:
		[^NilAST new start: aNode start; end: aNode end].
	aNode name = #true ifTrue:
		[^BoolAST withValue: true start: aNode start end: aNode end].
	aNode name = #false ifTrue:
		[^BoolAST withValue: false start: aNode start end: aNode end].		
	aNode name = #thisContext ifTrue:
		[^ContextAST new start: aNode start; end: aNode end].
	"recognize inst vars for accessor methods? handle temps etc."
	^aNode
)'private'
addLiteral: literal <Character | Number | String | Symbol> = ( 
	(literalTable includesKey: literal) ifFalse:
		[literalTable at: literal put: literalTable size].
)
at: node error: msg = (
	"Simple solution for now - fix this at some point"
	('error: ', msg) out.
	halt
)
isRemovableBlock: block <BlockAST> withArgs: nofArgs <Integer> ^ <Boolean> = (
"Answers true if block can be removed (inlined) within another block."
	block isBlockNode ifFalse: [^false].
	block parameters size = nofArgs ifFalse: [^false].
	^true
)
parameters: pars matchArguments: args
 = (
 | i |
	#BOGUS yourself. "appears to be unused; delete if so"
 i:: pars size.
 
 "Proceed if no. of parameter matches no. of arguments"
 pars size = args size ifFalse: [ ^ false ].
 
 "check individual arguments, starting with last one"
 i:: pars size.
 [ i > 0 ] whileTrue: [
  (args at: i) isRefNode ifFalse: [ ^ false ].
  (pars at: i) == (args at: i) decl ifFalse: [ ^ false ].
  i:: i - 1
 ].
 
 "parameters & arguments match 1-to-1, in same order"
 ^ true
)
popScope ^ <Scope> = (
	^scopeStack removeLast
)
pushScope: s <Scope> = (
	scopeStack addLast: s
)
pushScopeForNode: n <AST> = (
	scopeStack addLast: (scopeMap at: n)
)
variableFrom: message <MessageAST> decl: declaration <VarDeclAST>  ^ <VariableNode> = (
	assert: [message args isEmpty].
	declaration isNil ifTrue:
		[^(VariableAST new
			name: message sel;
			start: message start;
			end: message end)
				apply: self].
	declaration isTemporaryAST ifTrue: [noteReadOf: declaration].
	^declaration variableClass
		name: message sel
		start: message start
		end: message end                    
)) : ('as yet unclassified'
REFACTORING = (
	"This rewritter and the one used for JavaScript are likely to continue to have very similar requirements and should someday be factored out, rather than duplicated."
))
class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = ASTTool ("The scope builder is a visitor on the AST. It computes a tree of scopes that shadows the AST itself.  More precisely, it computes a mapping from ASTs to their scopes. This allows us to get to the appropriate scope for an abstract syntax node without pollluting the AST with extraneous data like scopes.

We could associate each node in the AST with the scope in which it is found, but this would be overkill. Instead, only nodes that actually introduce new scopes (such as class sides, message patterns, code bodies and blocks) actually get mapped in this manner. The intent is that later phases of compilation will visit the tree and look up the scopes at the points where they are introduced.

The builder starts at a given node, in the context of some mixin, described by a mirror.  This is because, in an incremental environment, we may not have the complete AST for a module, but instead be asked to process a part of that module, such as a nested class, slot definition or method. The surrounding scope can be computed from the mirror representing the immediately enclosing mixin.

Then we traverse the tree, creating and populating new scopes as needed. We maintain a stack of scopes (scopeStack) that initially contains only the surrounding scope.  Scopes get pushed on to the stack when we encounter a node that introduces a scope, and popped when we finish with that node. The scopes are chained to their super scopes (the scope below them on the stack).

A possible optimization is to avoid a traversal of an entire side of a class.
One can process only a side without its subtrees (i.e., methods and nested classes). These can be visited later,  as long as we ensure that the processing of the subtree begins with a proper super scope on top of the scope stack."| 
  scopeStack = OrderedCollection new.
  
  currentDepth ::= initialDepth. "The lexical nesting level of the class declaration currently 
						being visited; top level classes are level 0"
|pushScope: initialScope)
('as yet unclassified'
blockNode: aNode <BlockAST> = (
	| ps <Scope> |
	ps:: Scope new.
	"establish parameter scope"
	aNode parameters do:[:p <VarDeclAST> | ps at: p name put: (SemanticVarDecl decl: {p. currentDepth})].
	nestScope: ps.
	"visit body"
	aNode body apply: self.
	scopeMap at: aNode put: (scopeMap at: aNode body).
	popScope "pop the parameter scope, ps"
)
buildScopeFor: m <MixinMirror> ^ <Scope> = (
	^prvtScopeFor: m.
)
cascadedSendNode: aNode <CascadedSendAST> = (
"generic traversal code"
"visit receiver and messages"
	aNode prevSend apply: self.
	aNode msg apply: self.
)
charNode: aNode <CharAST> = (
"do nothing"
)
classHeaderNode: aNode = (
	aNode constructor apply: self.
	aNode slots do: [:s |  s initializer ifNotNil: [:i | i apply: self]].
	aNode initExprs do: [: e | e apply: self].
)
classNode: aNode <ClassDeclarationAST> = (
	| vs <Scope> |
	currentScope
		at: aNode name 
		put: (SymbolTableEntry for: {MessagePatternAST new selector: aNode name. currentDepth}).
	vs:: Scope new. "establish instance side scope"
	currentDepth:: currentDepth + 1.
	aNode hdr slots do:
		[:v <SlotDeclAST> | 
		vs at: v name put: (SymbolTableEntry for: {MessagePatternAST new selector: v name. currentDepth}).
		v isMutable ifTrue:
			[vs at: (v name asString, ':') asSymbol
				put: (SymbolTableEntry for: {MessagePatternAST new selector: (v name asString, ':') asSymbol. currentDepth}) "setter"]
    	 ].
	self nestScope: vs.
  	aNode instanceSide apply: self.
	popScope.
  	aNode classSide apply: self.
	currentDepth:: currentDepth - 1.
)
codeBodyNode: aNode <CodeBodyAST> = (
	| ts <Scope> |
	"establish local slot scope"
	ts:: Scope new.
	aNode temporaries do:
		[:t <SlotDefAST> | 
		ts at: t name put: (SemanticVarDecl decl:{t slotDecl. currentDepth}); " getter"
		at: (t name asString, ':') asSymbol put: t slotDecl "setter"].
	ts end: aNode end. "we need to know where this scope ends"
	nestScope: ts.
	scopeMap at: aNode put: ts.
	"visit statements"
	aNode statements do:[: s <ReturnStatementAST | SendAST>  | s apply: self].
	popScope.
)
currentScope ^ <Scope> = (
	^scopeStack last
)
enclosingMixinsOf: m <MixinMirror> ^ <Collection[MixinMirror]> = (
	| e enclosers |
	^m enclosingClassStencil enclosingClassStencils collect: [:stencil | stencil mixin]
)
isPseudoVariableNode: aNode <VariableAST> ^ <Boolean> = (
	^aNode name = #self or:
		[aNode name = #super or:
		[aNode name = #outer or:
		[aNode name = #thisContext]]]
)
messageNode: aNode <MessageAST> = (
"generic traversal code"
"visit arguments"
	aNode args do: [:a <SendAST> | a apply: self]
)
messagePatternNode: aNode <MessagePatternAST> = (
	| ps <Scope> |
	ps:: Scope new.
	"establish parameter scope"
	aNode parameters do:
		[:p <VarDeclAST> |
		ps at: p name put: (SemanticVarDecl decl: {p. currentDepth})].
	nestScope: ps.
	scopeMap at: aNode put: ps.
	"the pattern scope, ps, must be popped by the caller"
	"establish type parameter scope - skip for now"
)
methodNode: aNode <MethodAST> = (
	"register method in current scope"
	currentScope
		at: aNode pattern selector
		put: (SymbolTableEntry for: {aNode pattern. currentDepth}).
	"visit pattern"
	aNode pattern apply: self.
	"visit body"
	aNode body apply: self.
	scopeMap
		at: aNode
		put: (scopeMap at: aNode body).
	popScope "Pop pattern scope"
)
mixinApplication: node <MixinApplicationAST> = (
	node mixinExpr apply: self.
	node superclassExpr apply: self
)
mixinClassNode: aNode = (
	"do nothing"
)
nestScope: s <Scope> = (
"Hook up a new lexically nested scope, and push onto the scope stack"
	s superScope: currentScope.
	pushScope: s
)
normalSendNode: aNode <NormalSendAST> = (
"generic traversal code"
"visit recvr and msg"
	aNode recv apply: self.
	aNode msg apply: self.
)
numberNode: aNode <NumberAST> = (
"do nothing"
)
popScope ^ <Scope> = (
	^scopeStack removeLast
)
propertyCallNode: aNode <PropertyCallAST> = (
	messageNode: aNode
)
prvtScopeFor: c <MixinMirror> ^<Scope> = (
"When incrementally compiling a nested class, we need to reconstruct its scope."
	| 
	s <Scope> 
	outerMixins <Collection[MixinMirror]>
	depth <Integer>
	|
	outerMixins:: enclosingMixinsOf: c."should use a cleaner API"
	currentDepth:: outerMixins size - 1.
	depth:: 0.
	outerMixins do: [:o |
		s:: Scope new superScope: s.
		(selectorsFor: o) do:
			[: sel |
			s at: sel 
				put: (SymbolTableEntry for:{MessagePatternAST new selector: sel. depth})].
		depth:: depth + 1].
	^s
)
pushScope: s <Scope> = (
	scopeStack addLast: s
)
returnStatNode: aNode <ReturnStatAST> = (
"generic traversal code"
	"visit expression"
	aNode expr apply: self
)
selectorsFor: m <MixinMirror> ^ <Collection[Symbol]> = (
"Should add a convenience method to mirrors to do this"
	| result <Collection[Symbol]> |
	result:: m methods asOrderedCollection collect:[:s <MethodMirror> | s name].
	result addAll: (m slots asOrderedCollection collect:[: s <SlotMirror> | s name]).
	result addAll: 
		((m slots asOrderedCollection select:[: s | s isMutable]) 
			collect:[: s <SlotMirror> | s name, ':']).
	result addAll: (m classes asOrderedCollection collect:[:s <ClassStencilMirror> | s name]).
	^result
)
setterSendNode: aNode <SetterSendAST> = (
	aNode recv apply: self.
	aNode msg apply: self.
)
sideNode: aNode <SideAST> = (
	scopeMap at: aNode put: currentScope.
	"visit methods"
	aNode categories do:
		[: c <CategoryAST> | c methods do:[:m <MethodAST> | m apply: self]].
	"visit nested classes"
	aNode nestedClasses do: [:nc <ClassDeclarationAST> | nc apply: self].
)
stringNode: aNode <StringAST> = (
"do nothing"
)
symbolNode: aNode <SymbolAST> = (
"do nothing"
)
tupleNode: aNode <TupleAST> = (
"visit elements"
	aNode elements do: [:e <SendAST> | e apply: self]
)
varDeclNode: aNode <VarDeclAST> = (
"Do nothing. It could arguably add aNode's data to current scope - but in practice, the context knows better how to do this"
)
variableNode: aNode <VariableAST> = (
	assert: [aNode name = #'@here' or: [isPseudoVariableNode: aNode]]
		message: 'Unexpected variable name'.
)
visitMethod: aNode <MethodAST> within: m <MixinMirror> ^ <Dictionary[AST, Scope]> = (
	^visitNode: aNode within: m
)
visitNode: aNode <AST> within: m <MixinMirror> ^ <Dictionary[AST, Scope]> = (
	pushScope: (buildScopeFor: m).
	aNode apply: self.
	^scopeMap
)) : ('as yet unclassified'
REFACTORING = (
	"The scope builders for all the Newspeak compilation modules should someday be factored out, rather than duplicated."
)
new ^ <Instance> = (
	^self nestedIn: Scope new atLevel: 0
))
class Translator = ASTTool (
"Visits nodes of an NS AST to produce a Javascript AST. The usual translation unit is a method. Translation is initiated by sending the translateMethodNode: message. The argument is the method to translate, the returned value is the translation."|
	scopeStack
	currentSelector
	protected containsNonLocalReturn <Boolean> "Set to false at the beginning of translating a method. The code that emits a non-local return sets this to true. The top-level code checks the value to see whether to emit a try-catch wrapper for an NLR."

|)
() : ()'as yet unclassified'
language = (
	^#Newspeak3
)
setInput: source <ReadStream> = (
	source position: 1.
	input: source. "save the input"
)
sourceForNode: node <AST> ^ <String> = (
	| savedPos <Integer> pos <Integer> len <Integer> s <String> |
	"^String withAll: (input copyFrom: node start to: node end"
	savedPos:: input position.
	len: (node end - node start) + 1.
	s:: MutableString new: len.
	input position: node start -1.
	1 to: len do:
		[:index |
		s at: index put: input next].	
	input position: savedPos.
	^s
)'entry'
public compileClassSource: source <ReadStream> within: enclosing <MixinMirror> ^<MixinRep> = (
	|
	tree <AST>
	mixinRep <MixinRep>
	|
	tree:: parser classDefinition parse: source.
	setInput: source.
	setScopeFor: tree in: enclosing.
	"sentSelectors:: Set new."
	mixinRep:: classNode: tree.
	scopeMap:: Dictionary new.
	^enclosing isNil ifTrue:[mixinRep] ifFalse:[{enclosing. mixinRep}].
)'factories'
superConstructorMethodFor:  aNode <ClassHeaderAST> ^ <MethodAST> = (
| 
start <Integer> 
end <Integer>
stmts <List[StmtAST]> 
var  <VariableAST> 
initHdr <MessagePatternAST>
superMsg <MessageAST> 
send <NormalSendAST>
body  <CodeBodyAST>
copier <ASTCopier>
params <List[VarDeclAST]>
args <List>
|
#FLAG.

	start:: aNode superConstructorCall start.
	end::  aNode  superConstructorCall end.
	copier:: ASTCopier new.
	params:: aNode constructor parameters collect:[:formal | formal apply: copier].
	initHdr:: MessagePatternAST new selector: (superConstructorNameFor: aNode) parameters: params;
				start: start; end: end. 
	"set up scope with constructor parameters"
	"create call to superclass initializer"
	stmts:: OrderedCollection new. 
	var:: VariableAST new name: #super; start: start; end: end.
	args:: aNode superConstructorCall args collect:[:actual | actual apply: copier].
	superMsg::  PropertyCallAST new send: 'instanceInitializer' with: args; 
				start: start; end: end. 
	"only copy actual args"
	"send these as a tuple? to super instance initializer?"
	send:: NormalSendAST new to: var send: superMsg; start: start; end: end. 
	stmts addFirst: send.
	body:: CodeBodyAST new temporaries: OrderedCollection new
                                       	statements: stmts;
                                      	start: start; end: end.
	^MethodAST new pattern: initHdr
                            body: body
                            visibility: #private;
                            start: start; end: end	
)
superConstructorNameFor: aNode <ClassHeaderAST> ^ <Symbol> = (
	#FLAG.
	^#superInit
)'scopes'
currentScope ^<Scope> = (
	^scopeStack last
)
nestScope: scope <Scope> = (
	"Hook up a new lexically nested scope, and push onto the scope stack"
	scope superScope: currentScope.
	pushScope: scope
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
pushScope: scope <Scope> = (
	scopeStack addLast: scope
)
setScopeFor: node <AST> in: enclosing <MixinMirror | nil> = (
	| scopeBuilder |
	pushScope: Scope new.
	enclosing notNil ifTrue: [nestScope:: ScopeBuilder new buildScopeFor: enclosing].
	currentDepth:: currentScope depth - 1.
	scopeBuilder:: ScopeBuilder nestedIn: currentScope atLevel: currentDepth.
	node apply: scopeBuilder
)'top-processing'
checkForDuplicateNames: node <ClassDeclarationAST> = (

	| namesWithDuplicates names duplicateNames |
	
	namesWithDuplicates:: OrderedCollection new.
	node instanceSide categories do: [:cat |
		cat methods do: [:each | namesWithDuplicates add: each selector]].
	
	node hdr slots do: [:each |
		namesWithDuplicates add: each name.
		each isMutable ifTrue: [namesWithDuplicates add: each name, ':']].
	
	namesWithDuplicates
		addAll: (node instanceSide nestedClasses collect: [:each | each name]).

	names:: Set new.
	duplicateNames:: Set new.
	namesWithDuplicates do: [:each | | present |
		present:: true.
		names include: each ifNew: [present:: false].
		present ifTrue: [duplicateNames add: each]].
	
	duplicateNames isEmpty ifFalse: [ | message |
		message:: String streamContents: [:s |
			s
				nextPutAll: 'Class ';
				nextPutAll: node name;
				nextPutAll: '" has multiple definitions for '.
			duplicateNames
				do: [:each | s nextPutAll: each asString]
				separatedBy: [ s nextPutAll: ','].
			s nextPutAll: '.'.].
		assert: false message: message].
)
classNode: node <ClassDeclarationAST> ^<MixinRep> = (
	|
	mixinMirror <LowLevelMixinMirror>
	nestedClasses <Collection[MixinRep]>
	priorMixinUID <String>
	|
	assert: [node hdr category notNil] message: 'No category for class header'.
	checkForDuplicateNames: node.
	mixinMirror:: computeMixinFrom: node hdr.
	priorMixinUID:: currentMixinUID.
	currentMixinUID::  mixinMirror name.
	currentDepth::currentDepth + 1.
	nestedClasses:: processInstanceSideOf: node ofMixin: mixinMirror lowLevelMirror.
	generateSlotAccessorsFor: mixinMirror lowLevelMirror. 
	"must be called after nested classes are processed, so all synthetic slots have been added"
	processClassSideOf: node ofMixin: mixinMirror lowLevelMirror classMixin.
	currentDepth::currentDepth - 1.
	currentMixinUID:: priorMixinUID.
	^{mixinMirror. nestedClasses}
)
computeMethod: aNode <MethodAST> inScope: s <Scope> = (
	|  scopeBuilder <ScopeBuilder>  |
	scopeBuilder:: ScopeBuilder nestedIn: s atLevel: currentDepth.
	aNode apply: scopeBuilder.
	"need to build scope for method before visiting it"
	^methodNode: aNode.
)
computeMixinFrom: aNode <ClassHeaderAST> ^<CompiledMixinMirror> = (
	| 
	ivNames <Collection[String]>
	mixinMirror <LowLevelMixinMirror>
	hdrString <String>
	|
	ivNames:: aNode slots collect:[:s | s name].
	mixinMirror:: LowLevelMixinMirror named: aNode name isMeta: false.
	ivNames do:
		[:iv | 
		mixinMirror instVars addMirror: (InstanceVariableMirror named: iv mutable: true)].
	hdrString:: input contents copyFrom: aNode start to: aNode end.
	^(CompiledMixinMirror language: language header: hdrString mirror: mixinMirror)
		factoryName: aNode constructor selector;
		category: aNode category;
		comment: (aNode classComment isNil 
			ifTrue: [''] 
			ifFalse: [aNode classComment]);
		slots: (
			aNode slots collect: [:each | | source |
				source:: input contents copyFrom: each start to: each end.
				SlotMirror named: each name source: source isMutable: each isMutable]).
)
methodNode: aNode <MethodAST> ^ <MethodMirror> = (
	| tree <AST> jsTree |
	tree:: aNode apply: rewriter.  "rewrite ast"
	translator beginNewTranslationCycle.
	jsTree:: tree apply: translator.	 "final pass: visit rewritten ast"
	"pop scope?"
	^((MethodMirror named: translator currentSelector)
		method: jsTree)
			src: (sourceForNode: aNode)
)
processInitializerFor: aNode <ClassAST> in: mixinMirror <LowLevelMixinMirror> = (
	processMethod: (superConstructorMethodFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinMirror. 
	makeCreateSlotsFor: aNode hdr within: mixinMirror.
	processMethod: (initializerFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinMirror.
)
processInstanceSideOf: aNode <ClassAST> ofMixin: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	| side <SideAST> |
	processInitializerFor: aNode in: mixinMirror.
	side:: aNode instanceSide.
	processSide: side ofMixin: mixinMirror. "compile instance methods"
	^compileNestedClassesOf: side within: mixinMirror. "gather nested classes"
)
processMethod: aNode <MethodAST> inScope: s <Scope>  in: mixinMirror <LowLevelMixinMirror> = (
	|  method <MethodMirror> |
	method:: computeMethod: aNode inScope: s.
	method isSynthetic: true.
	mixinMirror methods addMirror: method.
	"install method"	
)) : ()
class MixinRep first: cmm last: subreps = (
"The other compilers and mirror systems typically use tuples such that type MixinRep = {CompiledMixinMirror. List[MixinRep]}. For interoperability, this class understands #first and #last."|
	compiledMixinMirror <CompiledMixinMirror> = cmm.
	nestedReps <List[MixinRep]> = subreps.
|)
('as yet unclassified'
first = (
	^compiledMixinMirror
)
last = (
	^nestedReps
)
size = (
	^2
)) : ('as yet unclassified'
REFACTORING = (
	"Use of tuple MixinRep should be rewritten to use this class, as it makes debugging much easier"
))
class PropertyCallAST = MessageAST (
"Sepcialized node to represent applications of JS properties. In some cases (well, at least one) we need to generate ASTs that call javascript methods directly. These calls need to be translated slightly differently (their names must not be mangled). To distinguish these form normal message sends, we use this node.")
('as yet unclassified'
apply: tool <ASTTool> = (
	^tool propertyCallNode: self
)) : ()
class Scope = (
"A generic scope facility.

The text below describes the intended scheme for handling closures using the Cog VM's closure support. It is not yet implemented.

To support efficient compilation of closures, each scope tracks how many temporary variables need to ''remote''. 

A remote temporary is one that is closed over by a nested closure, and cannot reliably be copied down into the closure upon closure creation.  Any temporary that might be written to after closure creation is necessarily remote.

Remote temps are allocated in an array rather than directly in their activation. All the remote temps in a given scope are alllocated in a single array, the remote temp vector. Each remote temp is uniquely identified by an index into th eremote temp vector.

Closures nested within the scope get a reference to the remote temp vector. They can and read and write a temporary by modifying the vector using the index associated with the temporary.

Typically, the first instruction in the code of a closure or method allocates the remote temp vector (if one is needed). This is supported by a special byte code, pushArray.

Reads and writes to a remote temp take the form of at: i and at: i put: v sends where i is the index of the remote temp and v is the value being written to it.

A temporary variable is considered remote iff:

a. It is written to in a closure nested within its defining method or closure.
b. It is read in in a closure c nested within its defining method or closure, and written to after the end of c.

"| 
  superScope 
  bindings =  Dictionary new.
	public end <Integer>
 |)
('access'
at: aKey put: aValue = (


^self bindings at: aKey put: aValue
)
at: aKey put: aValue ifThere: aBlock = (

    "Associates aValue with aKey and answers aValue if aKey
    was absent. Otherwise answers the value of aBlock."
    | wasAbsent |
    self assert: [aKey isSymbol] 
	message:['Attempt to ok up non-symbol ',aKey printString, ' in scope'].
    wasAbsent:: false.
    bindings at: aKey ifAbsent: [bindings at: aKey put: aValue. wasAbsent:: true].
    ^ wasAbsent
        ifTrue: [aValue]
        ifFalse: [aBlock value]
)
at: key = (

	"Answers the value associated with aKey in this or one the super scopes or fails if aKey is absent"
	^self at: key ifAbsent: [self error: 'Key ', key, ' not found!']
)
at: key ifAbsent: blk = (

    "Answers the value associated with aKey in this or one of the superScopes or the value of aBlock if aKey is absent."

	"Optimization note: This is written using [nil] blocks to avoid passing 
		non-clean blocks dynamically down the scope structure."

	| val <T> |
	(val:: self bindings at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	self superScope isNil
		ifTrue: [ ^blk value ].
	(val:: self superScope at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	^blk value
)
clear = (


self bindings keys do:[:k | self bindings removeKey: k].
)
includesIndex: key = (
"should this search the superscope?"
    ^ self bindings includesKey: key
)
includesIndexLocally: key <NameType > ^ <Boolean> = (


^self bindings includesKey: key.
)
removeKey: key = (


self bindings removeKey: key
)
removeKey: key ifAbsent: blk = (


self bindings removeKey: key ifAbsent: blk
)
within: scope = (
    "Creates and initializes a new (sub)scope within scope."
      self superScope: scope.
  )'as yet unclassified'
depth ^ <Integer> = (
	superScope ifNil:[^0].
	^superScope depth + 1.
)) : ('as yet unclassified'
REFACTORING = (
	"This should be factored out along with ScopeBuilder. Perhaps it should also become nested within ScopeBuilder."
))
class SymbolTableEntry for: datum = (| 
  sym  
  data ::= datum first.  
  depth = datum last.  
|)
('as yet unclassified'
isMethodNode = (^self data  isMethodNode)'testing'
isMessagePatternNode = (^self data  isMessagePatternNode)
isVarDeclNode = (^self data isVarDeclNode)) : ()) : ()