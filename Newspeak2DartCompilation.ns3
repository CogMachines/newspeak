Newspeak3
'NS2Dart'
class Newspeak2DartCompilation usingPlatform: platform
	parsing: parsing
	generation: generation
	mirrors: mirrors = (
"Does the interesting work in Newspeak-to-Dart translation.

Throughout this module, the type annotation <Node> means a Dart AST, a subclass of DartGeneration`Syntax`Node.

Mixins: One Dart class is generated for each Newspeak mixin or metamixin. Objects are instances of mixin classes, and classes are instances of metamixin classes. Because Dart does not (yet?) support runtime creation of classes, we only allow class declarations whose superclass clause can be resolved to another class declaration at compile-time: the superclass must be either lexically visible or a well-known class such as Object. Roughly 6% of Newspeak class declarations have superclasses that cannot be resolved at compile time in this way.

Class: Dart objects will not tell you their runtime class, so all Newspeak objects have an additional field to remember their Newspeak class.

Identity hash: Dart objects do not have an identity hash, so all Newspeak objects have an additional field storing one. (The field is wrapped lazily.)

NLR: Dart does not have non-local return; all return statements in nested functions are treated as local returns to the caller of that function rather than to the caller of the enclosing method. We simulate non-local return by wrapping method bodies in try-catch clauses that capture exceptions specific to a method's activation (not the method statically!) and rethrow all other exceptions. Unfortunately, VMs such as V8 or the Dart VM do not optimize methods containing a try, so we only wrap methods that actually contain a NLR to reduce the performance impact. Roughly 2% of Newspeak methods contain an NLR that cannot be inlined away.

Built-in types: Numbers, booleans and closures are represented directly by their Dart couterparts. In cases where the Newspeak and Dart APIs differ, we introduce guards at the relevant send sites and use inline or helper functions to do the Newspeak thing if the receiver is a Dart number, boolean or closure. Strings and arrays are wrapped by objects that map the Newspeak API onto the Dart API.

Implicit receiver sends: At compile-time, we determine whether an implicit receiver send is an outer send or a self send. If it is an outer send, we index into an array of enclosing objects. The index represents the lexical depth, with 0 being the immediately enclosing object. During mixin application, the enclosing objects array of the parent class is copied and prepended with the parent class.

Factories: Class-side methods matching the factory selector perform a raw allocation then call a (synthetic) instance initializer on the new object, as in the Squeak implementation.

Derived from the NS2JS compiler, in turn derived from the NS2Squeak compiler.

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
	Dictionary = platform collections Dictionary.
	OrderedCollection = platform collections OrderedCollection.
	Set = platform collections Set.
	
	Parser = parsing Parser.
	parser = Parser new.
	
	astModule = parsing ASTModule. "Cheat-ish"
	ASTTool = astModule ASTTool.
      ASTCopier = astModule ASTCopier.
      SuperFalseVisitor = astModule FalseVisitor.
      AST = astModule AST.
	AssignmentAST = astModule AssignmentAST.
	BlockAST = astModule BlockAST.
	CascadedSendAST = astModule CascadedSendAST.
	CodeBodyAST = astModule CodeBodyAST.
	MessageAST = astModule MessageAST.
      MessagePatternAST = astModule MessagePatternAST.
	MethodAST = astModule MethodAST.
	NormalSendAST = astModule NormalSendAST.
	NumberAST = astModule NumberAST.
	ReturnStatAST = astModule ReturnStatAST.
      SendAST = astModule SendAST.
	SymbolAST = astModule SymbolAST.
	TupleAST = astModule TupleAST.
      VarDeclAST = astModule VarDeclAST.
	VariableAST = astModule VariableAST.
	
	dart = generation factory.
	DartWriter = generation Writer.
	
	LowLevelMirror = mirrors "LowLevel"Mirror.
	LowLevelMixinMirror = mirrors LowLevelMixinMirror.
	InstanceVariableMirror = mirrors InstanceVariableMirror.
	CompiledMixinMirror = mirrors CompiledMixinMirror.
	SlotMirror = mirrors SlotMirror.
	
	"Caching"
	lastRuntimeSources
	lastRuntimeReps
|)
(
class ClassSymbolTableEntry for: datum = SymbolTableEntry for: datum ()
('as yet unclassified'
isClassDeclaration ^<Boolean> = (
	^true
)) : ()
class Compiler = (
"Translates Newspeak ASTs into Dart ASTs in three phases. First, scopes are computed and associated with ASTs. Second, ASTs are rewritten to capture information such as whether an implicit receiver send is an outer send or a self send, message sends that are reads and writes to locals, messages sends that are inlinable, and implied block-local returns. Third, the rewritten ASTs are translated into Dart ASTs. 

Dart ASTs are always constructed with names already mangled."|
	scopeMap <Map[AST,Scope]> ::= Dictionary new.
	scopeStack <List[Scope]> ::= OrderedCollection new.
	currentDepth <Integer>
	currentMixinClassName <String>
	input <ReadStream>
	
	names = NameMangler new.
	rewriter = Rewriter new.
	translator = Translator new.
	dartWriter = DartWriter new.
	
	enableIntrinsics ::= false.
	
	inlineConditionals ::= true.
	inlineOperators ::= true.
	inlineLoops ::= true.

	useCrawlingHereSends ::= false.
	
	wrapBooleans ::= false.
	wrapNumbers ::= false.
	wrapBlocks ::= false.
	wrapArrays ::= true.
	|)
(
class NameMangler = (
"Maps Newspeak selectors unto Dart identifers and ensures user names and synthetic names don't conflict. Generally, Newspeak selectors are mangled such that they never have an unpaired underscore, so names ending in a single underscore are used for synthetics.

See also Translator's binaryOperatorMappings."|
	private binarySelectorManglings = Dictionary new.
	private reservedWordManglings = Dictionary new.
	private nextTemp ::= 0.
|binarySelectorManglings
		at: '+' put: 'plus_';
		at: '-' put: 'minus_';
		at: '*' put: 'times_';
		at: '/' put: 'over_';
		at: '**' put: 'starstar_';
		at: '//' put: 'overover_';
		at: '\\' put: 'overover_';	
		
		at: '<' put: 'less_';
		at: '>' put: 'greater_';
		at: '<=' put: 'lessequal_';
		at: '>=' put: 'greaterequal_';
		at: '=' put: 'equal_';
		at: '==' put: 'identical_';
		at: '~=' put: 'notequal_';
		at: '~~' put: 'notidentical_';
		
		at: '&' put: 'amp_';
		at: '|' put: 'pipe_';
		at: ',' put: 'comma_';
		at: '@' put: 'at_';
		at: '|>' put: 'mixinapply_';
		
		at: '<<' put: 'leftshfit_';
		at: '>>' put: 'rightshift_';
		at: '=>' put: 'imply_';
		at: '->' put: 'associate_';
		at: '~' put: 'tilde_'.
		
	reservedWordManglings
		at: 'this' put: 'this_';
		at: 'Object' put: 'Object_';
		at: 'new' put: 'new_';
		at: 'else' put: 'else_';
		at: 'print' put: 'print_';
		at: 'class' put: 'class_';
		at: 'in' put: 'in_'.
		
	#FLAG)
('as yet unclassified'
fullyQualifySimpleName: simpleName <Symbol> with: fullyQualifiedPackage <Symbol> = (
	^fullyQualifiedPackage, '`', simpleName
)'compiler temps'
cascadeReceiverTemp ^<String> = (
	^'cascadeReceiver_'
)
definingClassTemp ^<String> = (
	^'definingClass_'
)
guardTemp ^<String> = (
	^'guardTemp_'
)
newCompilerTemp ^<String> = (
	nextTemp: nextTemp + 1.
	^'t' , nextTemp, '_'
)
nlrExceptionTemp ^<String> = (
	^'nlr_exception_'
)
nlrTemp ^<String> = (
	^'nlr_'
)'globals'
Array = (
	^'Array_global'
)
Block = (
	^'Block_global'
)
Class = (
	^'Class_global'
)
Message = (
	^'Message_global'
)
Metaclass = (
	^'Metaclass_global'
)
NLR = (
	^'NLR_'
)
Number = (
	^'Number_global'
)
Object = (
	^'Object_global'
)
String = (
	^'String_global'
)
false = (
	^'false_'
)
nil = (
	^'nil_'
)
true = (
	^'true_'
)'identifiers'
enclosingObjectsArrayFor: fqn <String> meta: meta <Boolean> ^<String> = (
	^(meta 
	ifTrue: [metamixinClassNameFor: fqn] 
	ifFalse: [mixinClassNameFor: fqn]), '_enclosingObjects'
)
mangleSelector: selector <String> ^<String> = (
	"Convert a Newspeak selector into a Dart identifer."
	| res <String> ::= selector. |
	selector first = $_ ifTrue: [halt "Affects access semantics in Dart"].

	selector = 'self' ifTrue: [halt. ^'this'].
	
	(binarySelectorManglings includesKey: selector)
		ifTrue: [^binarySelectorManglings at: selector].
	(reservedWordManglings includesKey: selector)
		ifTrue: [^reservedWordManglings at: selector].
	
	res:: res copyReplaceAll: '_' with: '___'. "Must be first"
	res:: res copyReplaceAll: ':' with: '__'.
	res:: res copyReplaceAll: '`' with: '_'.
	res:: res copyReplaceAll: '.' with: '_'.
	^res
)
mangleSlotName: n <String> ^<String> = (
	^((mangleSelector: n) , '_slot')
)
metamixinClassNameFor: fqn <String> ^<String> = (
	^(mangleSelector: fqn), '_metamixin'
)
mixinClassNameFor: fqn <String> ^<String> = (
	^(mangleSelector: fqn), '_mixin'
)) : ()
class Rewriter = ASTTool (
"A visitor that rewrites the AST into a form more suitable for compilation to Dart. It may be possible to combine the pass that constructs the scopes with the rewriting pass, but this may be messy once we start inlining blocks etc."| 

	scopeStack <OrderedCollection[Scope]> = OrderedCollection new.
	protected valueExpected <Boolean> ::= true. "A flag set by visitor methods to indicate whether the parent AST uses the value of the currently visited node or not."
	protected rewritingBodyForValue <Boolean> ::= false. "Set to false prior to visiting a method body, true prior to visiting a non-inlined block body, and false for some inlined blocks."
	protected areReturnsLocal <Boolean> ::= true. "Set to true while visiting nodes contained within a method and its inlined blocks, false in non-inlined blocks."
	
	protected conditionalSelectors = Set withAll: {#ifTrue:ifFalse:. #ifFalse:ifTrue:. #ifTrue:. #ifFalse:}.
|)
(
class BlockLocalReturnAST expression: x start: s end: e = AST (
"This class represents a 'local return' (LR) -  a return from a block to its caller, as opposed to the caller of its enclosing method (a 'non-local return' or NLR).

An actual return statement in a block means an NLR; an LR is implicit in the source language, and occurs on the last statement of the block, unless that statement is a true return (NLR).  However, the back end of the compiler requires that this information be represented explicitly. This node does that."|
 expr <ExpressionAST> = x.
|start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool>  = (
	^aTool blockLocalReturnNode: self
)
isBlockLocalReturnAST ^<Boolean> = (
	^true
)) : ()
class BoolAST withValue: aBool <Boolean> start: s end: e = VariableAST (
""| val = aBool. |start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool boolNode: self
)
name = (
	^val printString asSymbol
)) : ()
class BoolVisitor = FalseVisitor ()
('as yet unclassified'
boolNode: node = (^true)) : ()
class ContextAST = VariableAST (
"Represents uses of thisContext. I expect these to be restricted in future versions. Currently, we use it for outer sends and super sends")
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool contextNode: self
)
name = (
	^#thisContext
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(thisContext)'
)) : ()
class ContextVisitor = FalseVisitor ()
('as yet unclassified'
contextNode: node = (^true)) : ()
class ExplicitReceiverVisitor = FalseVisitor ()
('as yet unclassified'
explicitOuterReceiverNode: aNode <ExplicitOuterRcvrAST> ^ <Boolean> = (
	^true
)) : ()
class ExplicitRecvrAST send: sym <Symbol> depth: d <Integer> = AST (
"Represents the receiver of an explicit outer send."|
	outerClassName <Symbol> = sym.
	depth <Integer> = d.
	selector <Symbol>
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool explicitOuterReceiverNode: self
)
isExplicitRcvrNode ^ <Boolean> = (
	^true
)
isExpressionNode ^ <Boolean> = (
	^true
)) : ()
class FalseVisitor = SuperFalseVisitor (
"Extends the standard FalseVisitor with methods for dealing with the node types introduced by the rewriter..")
('as yet unclassified'
boolNode: node = (^false)
contextNode: node = (^false)
ifNode: aNode <IfAST> ^ <Boolean> = (
	^false
)
implicitSendNode: aNode <ImplicitRcvrSendAST> ^ <Boolean> = (
	^false
)
loopNode: aNode <LoopAST> ^ <Boolean> = (
	^false
)
nilNode: node = (^false)
parameterNode: aNode <ParameterAST> ^ <Boolean> = (
	^false
)
receiverNode: aNode <ReceiverAST> ^ <Boolean> = (
	^false
)
returnInstVarMethodNode: aNode <ReturnInstVarMethodAST> ^ <Boolean> = (
	^false
)
returnSelfMethodNode: aNode <ReturnSelfMethodAST> ^ <Boolean> = (
	^false
)
superSendNode: aNode <SuperSendAST> ^ <Boolean> = (
	^false
)
superVarNode: aNode <SuperVarAST> ^ <Boolean> = (
	^false
)
temporaryNode: aNode <TemporaryVariableAST> ^ <Boolean> = (
	^false
)
variableNode: aNode = (
	^false
)) : ()
class ImplicitRecvrSendAST send: aMsg <MessageAST> depth: d <integer> = SendAST send: aMsg (
"
Represent a send of a message with an implicit receiver (aka a here send).
"| depth <Integer> ::= d. |)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool implicitSendNode: self
)
isExpressionNode ^ <boolean> = (
	^true
)
recv ^ <VarDeclAST> = (
  ^ assert:[false] message: 'There is no receiver node. It is implicit'
)) : ()
class ImplicitRecvrVisitor = FalseVisitor ()
('as yet unclassified'
implicitSendNode: aNode <ImplicitRcvrSendAST> ^ <Boolean> = (
	^true
)) : ()
class InlinableAsExpressionConditionalAST = NormalSendAST (
"Produced by the rewriter for the conditional messages whose value is required and which can be compiled into a Javascript ternary operator."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinableAsExpressionConditionalNode: self
)) : ()
class InlinableConditionalAST = NormalSendAST (
"Produced by the rewriter for conditional messages (ifTrue: and the like) that can be compiled into Javascript if statements instead of real message sends. To qualify, the message arguments should be literal blocks and the value of the message send should be ignored (for example, '^x ifTrue: [foo]' is not inlinable, while 'x ifTrue: [^foo]' is)."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinableConditionalNode: self
)) : ()
class InlinedOperatorAST = NormalSendAST (
"When the inlineOperators mode is on, message sends with certain selectors are replaced with this node. Javascript code generated for those nodes uses native Javascript operators instead of real message sends. The selector of the message of this AST is not a real Newspeak selector but rather the Javascript operator such as &&."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinedOperatorNode: self
)) : ()
class InstVarVisitor = FalseVisitor ()
('node traversal'
instVarNode: node = (^true)) : ()
class LoopAST = AST (
"This node represents a while loop, and its various routines act as constructors that map from various looping constructs into a while loop. In some cases (like whileTrue:) this is trivial, in others it is a bit more involved.

The general form of the loop is:

prologue;
while (cond = whileTrue) { body}

Ergo, prologue represents some code that sets up the loop (e.g., the initialization of the loop variable when encoding a for loop into a while loop);
whileTrue is true if the loop continues as long as the test condition holds, and false if the loop runs as long as the condition does not hold;
cond is the aforementiond test condition; body is the body of the loop."| 
isWhileTrue <Boolean> 
prologue <CodeBodyAST> ::= 
	CodeBodyAST new 
			parameters: OrderedCollection new;
			temporaries: OrderedCollection new;
			statements: OrderedCollection new.
cond <CodeBodyAST> 
body <CodeBodyAST>  |)
('as yet unclassified'
isExpressionNode ^ <boolean> = (
	^true
)'public access'
apply: aTool <ASTTool>
 = (
    ^aTool loopNode: self
)
do: n <Integer> timesRepeat: block <BlockAST>
 = (
	|
	skope	<Scope>
	loopVarName <Symbol>
	var <ParameterAST>
	|
	skope:: scopeMap at: block body.

	"introduce counter variable"
	loopVarName:: '.i' asSymbol.
	var:: (ParameterAST name: loopVarName type: nil) start: block start; end: block end.	
	skope at: loopVarName put: (SemanticVarDecl decl:{var. 0}) ifThere: [ halt ].
	assert:[block body parameters isEmpty].
	block body parameters add: var.

	"translate n timesRepeat: [blockBody]  into 1 to: n do: [ :.i | blockBody]"
	from: (NumberAST new val: 1; start: block start; end: block end) to: n do: block
)
from: first <AST> to: last <AST> by: step <AST> do: block <BlockAST>
 = (
	|
	blockScope		<Scope>	
	counterVar		<TemporaryAST>
	counter		<TemporaryVariableAST>
	limitNeeded		<Boolean>
	limitName		<Symbol>
	limitVar		<TemporaryAST>
	limit			<LiteralAST | VariableAST>
	condSel			<Symbol>
	condArg		<MutableList[ExpressionAST]>
	condExpr		<ExpressionAST>
	condBody		<CodeBodyAST>
	condStats		<MutableList[StatementAST]>
	incArg			<MutableList[ExpressionAST]>
	incExpr			<ExpressionAST>
	incStat			<StatementAST>
	|
	"preliminaries"
	assert: [ step isNumberNode and:[step val isInteger] ].
	assert: [ block isBlockNode ].
	blockScope:: scopeMap at: block body.

	"loop counter (= block parameter)"
	counterVar:: TemporaryAST name: block parameters removeFirst name type: nil.
	counter:: TemporaryVariableAST name:  counterVar name  start: block start end: block end.
	
	"introduce counter limit variable if needed"
	(limitNeeded:: last isLiteralNode not)
		ifFalse: [
			"no limit variable needed - use last directly since there's no computation involved"
			limit:: last
		]
		ifTrue: [
			limitName:: '.limit' asSymbol.
			limitVar:: TemporaryAST name: limitName type: nil.
			limitVar start: block start; end: block end.
			prologue temporaries add: limitVar.
			blockScope at: limitName put: (SemanticVarDecl decl: {limitVar. 0}) ifThere: [ assert:[false] ].
			limit:: TemporaryVariableAST name: limitName start: block start end: block end.
		].
	
	"setup loop condition => introduce condition block for whileTrue: loop"
	condSel::
		step val < 0
			ifTrue: [ #<= ]
			ifFalse: [ #>= ].
	condArg:: OrderedCollection new add: counter ; yourself.
	condExpr:: NormalSendAST new to: limit send: (MessageAST new send: condSel with: condArg).
	"limit <= counter OR limit >= counter"
	condStats:: OrderedCollection new add: condExpr ; yourself.
	condBody::
		CodeBodyAST new
			parameters: OrderedCollection new;
			temporaries: OrderedCollection new;
			statements: condStats;
			start: block start; end: block end.

	"add counter increment to loop body"
	incArg:: OrderedCollection new add: counter ; yourself.
	incExpr:: NormalSendAST new to: step send: (MessageAST new send: #+ with: incArg).
	incExpr start: block start; end: block end.
	"step + counter"
	incStat:: AssignmentAST new to: counter assign: incExpr. 
	incStat start: block start; end: block end.
	"counter := step + counter"
	block body statements add: incStat.

	"setup prologue"
	prologue temporaries add: counterVar.
	prologue statements add: (AssignmentAST new to: counter assign: first).
	"counter := first"
	limitNeeded ifTrue: [
		"initialize limit variable - note that this must be done *after* setting up the counter because of possible side effects"
		prologue statements add: (AssignmentAST new to: limit assign: last). ".limit := last"
	].
	
	"initialize loop instance variables"
	cond:: condBody.
	isWhileTrue:: true.
	body:: block body
)
from: first <AST> to: last <AST> do: block <BlockAST>
 = (
	from: first to: last by: (NumberAST new val: 1) do: block
)
repeat: block <BlockAST>
 = (
    assert: [block isBlockNode].
    cond:: block body.
    cond statements add: (BoolAST withValue: true start: cond end end: cond end).
    isWhileTrue:: true.
    body:: nil
)
while: b1 <BlockAST>  is: v <Boolean> do: b2 <BlockAST>
 = (
    assert: [b1 isBlockNode].
    assert: [b2 isBlockNode].
    cond:: b1 body.
    isWhileTrue:: v.
    body:: b2 body
)
while: v <Boolean> do: b <BlockAST>
 = (
    assert: [b isBlockNode].
    cond:: b body.
    isWhileTrue:: v.
    body:: nil
)) : ()
class NilAST = VariableAST (
"")
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool nilNode: self
)
name = (
	^#nil
)) : ()
class NilVisitor = FalseVisitor ()
('as yet unclassified'
nilNode: node = (^true)) : ()
class ParameterAST name: n type: t = VarDeclAST name: n type: t (
"")
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool parameterDeclNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(', name, ')'
)'as yet unclassified'
variableClass ^ <ParameterVariableAST class> = (
	^ParameterVariableAST
)) : ()
class ParameterVariableAST name: n start: s end: e = VariableAST (
""name: n. start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool parameterNode: self
)) : ()
class ReceiverAST = VariableAST (
"")
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool receiverNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(self)'
)'as yet unclassified'
name = (
	^#self
)) : ()
class ReceiverVisitor = FalseVisitor ()
('node traversal'
receiverNode: node = (^true)) : ()
class SuperSendAST send: aMsg <MessageAST> = SendAST send: aMsg (
"This code is currently unused.  
Unlike Smalltalk, super calls in Newspeak cannot be statically bound.
Hence, we cannot use the Squeak VM's  super send byte codes. Currently, super sends are rewritten into a complex call structure by the rewriter, to ensure the correct binding of super.

When the Newspeak VM is modified to support dynamic binding of super sends, we will probably use this node and allied code,  which can easily be processed by the byte code compiler and code generator.")
('Unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool superSendNode: self
)
recv ^ <SuperVarAST> = (
  ^SuperVarAST new
)'as yet unclassified'
isExpressionNode ^ <boolean> = (
	^true
)) : ()
class SuperSendVisitor = FalseVisitor ()
('node traversal'
superSendNode: node <SuperSendAST> = (
      ^true
   )) : ()
class SuperVarAST = VarDeclAST name: #super type: nil (
"")
('Unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool superVarNode: self
)) : ()
class TemporaryAST name: n type: t = VarDeclAST name: n type: t (
""| initializer |)
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool temporaryDeclNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(', name, ')'
)'as yet unclassified'
isTemporaryAST ^ <Boolean> = (
	^true
)
variableClass ^ <TemporaryVariableAST class> = (
	^TemporaryVariableAST
)) : ()
class TemporaryVariableAST name: n start: s end: e = VariableAST (
"This node represents reference to a temporary variable."name: n.  start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool temporaryNode: self
)) : ()'as yet unclassified'
applyForEffectTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: false.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
applyForValueTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: true.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
assignmentFrom: aMsg <MessageAST> decl: vd <VarDeclAST> ^ <AssignmentNode> = (
	| var <VariableAST> varName <String> args selector <String> |
	assert: [aMsg args size = 1].
	selector:: aMsg sel asString.
	varName:: selector copyWithSize: (selector size -1).
	assert: [(currentScope at: varName asSymbol) isTemporaryAST].
	"what about setter methods - then we might have an inst var? this cannot happen, because this is only called when processing variables"
	var:: TemporaryVariableAST
		name: varName
		start: aMsg start
	 	end: aMsg end.

	args:: applyForValueTo: aMsg args first. "recurse on RHS"
	   
	"create an assignment"
	^AssignmentAST new 
		to: var assign: args;
		start: aMsg start;
		end: aMsg end                     
)
boolNode: node = (
	"Should not normally be invoked; only possible when rewriting an already rewritten tree."
	halt.
	^node
)
enclosingObjSendOfDepth: n <Integer> to: recv <AST> start: start <Integer> end: end <Integer>  ^ <NormalSendAST> = (
	^NormalSendAST new 
		recv: recv; 
		msg:(MessageAST new sel: (enclosingObjectMsgForDepth: n); args: {}; start: start; end: end);
		start: start; 
		end: end.
)
enclosingObjectMsgForDepth: n <Integer> ^ <String> = (
"Compute the selector necessary for obtaining the nth enclosing object wrt to the current lexical scope."
	| otable  <Dictionary[Symbol, Tuple[Class, Integer]]> ec <Class> |
	"What if n has no corresponding entry in the outer table? This should not happen, as this method is called on the basis of an n value found in the table to begin with."
	otable:: currentScope at: #outer.
	ec:: (otable values detect: [:some | (some at: 2) = (n-1)]) at: 1.
	^(Compiler new enclosingObjectMsgFor: ec) asSymbol
)
explicitOuterReceiverNode: node = (
	assert: [node apply: ExplicitReceiverVisitor new].
	^node
)
hereName = (
	^#'@here'
)
hereNode ^<AST> = (
	^VariableAST new name: hereName
)
inline: node as: sendClass selector: selector rewriteArgsAs: argRewriteBlock = (
	| receiver message |
	receiver:: applyForValueTo: node recv.
	message:: MessageAST new
		send: selector
		with: (node msg args collect: argRewriteBlock).
	^sendClass new
		to: receiver send: message;
		start: node start;
		end: node end
)
isHereNode: aNode <AST> ^ <Boolean> = (
	aNode isVariableNode ifFalse: [^false].
	(isPseudoVariableNode: aNode) ifTrue: [^false].
	assert: [aNode name = hereName].
	^true
)
isInlinableAsExpressionConditional: node <NormalSendAST> ^ <Boolean> = (
	((conditionalSelectors includes: node msg sel) and: [valueExpected]) ifFalse: [^false].
	node msg args do:
		[:each <AST> |
		((isRemovableBlock: each withArgs: 0)
			and: [each body statements size = 1
			and: [each body statements first isReturnStatNode not]])
				ifFalse: [^false]].
	^true
)
isInlinableBooleanOperator: node <NormalSendAST> = (
	| selector |
	selector:: node msg sel.
	^(selector = 'or:' or: [selector = 'and:'])
		and: [node msg args size = 1
		and: [node msg args first isBlockNode
		and: [node msg args first body statements size = 1]]]
)
isInlinableConditional: node <NormalSendAST> ^ <Boolean> = (
	((conditionalSelectors includes: node msg sel) and: [valueExpected not]) ifFalse: [^false].
	node msg args do: [:each <AST> | (isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
	^true
)
isInlineableLoop: node <NormalSendAST> ^ <Boolean>= (
	| selector <Symbol>  args |
	valueExpected ifTrue: [^false]. #FLAG. "Handle this later. Note when we do we will have to adjust the forValue flag in processInlineableLoop."
	selector:: node msg sel.
	args:: node msg args.
	({#whileTrue. #whileFalse. #whileTrue:. #whileFalse:. #repeat} includes: selector) ifTrue:
		[args do:
			[:each |
			(isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
		^isRemovableBlock: node recv withArgs: 0].
	
	(selector = #timesRepeat:) ifTrue:[^isRemovableBlock: args last withArgs: 0].
	({#to:do:. #to:by:do:}  includes:  selector) ifFalse:[^false].
	(isRemovableBlock: args last withArgs: 1) ifFalse:[^false].
	(selector = #to:do:) ifTrue:[^true].
	^args size = 3
)
isOuterNode: aNode <AST> ^ <Boolean> = (
	aNode isVariableNode ifFalse: [^false].
	^aNode name = #outer
)
isPseudoVariableNode: aNode <VariableAST> ^ <Boolean> = (
	^aNode name = #self
		or: [aNode name = #super
		or: [aNode name = #outer
		or: [aNode name = #thisContext]]]
)
isSuperNode: aNode <VariableAST> ^ <Boolean> = (
	aNode isVariableNode ifFalse:[^false].
	^aNode name =  #super 
)
mixinApplication: node <MixinApplicationAST> = (
	| msg |
"For now, just compile it as a regular message send"
	msg:: MessageAST new
			send: #apply:
			with: (OrderedCollection with: node superclassExpr);
			start: node start;
			end: node end.

	^(NormalSendAST new
		to: node mixinExpr send: msg;
		start: node start;
		end: node end) apply: self
)
nilNode: node = (
	"Should not normally be invoked; only possible when rewriting an already rewritten tree."
	halt.
	^node
)
parameterNode: node <ParameterVariableAST> = (
	^node
)
processExplicitOuterReceiver: aMsg <MessageAST> = (
	| selectorBinding <AST> depth <integer> |
	assert:[aMsg args isEmpty]. "this had better be a unary message"
	selectorBinding:: currentScope at: aMsg sel.
	"assert:[selectorBinding data  isClassDeclarationAST]."
	depth: currentDepth -  selectorBinding depth -1.
	^(ExplicitRecvrAST send: aMsg sel depth: depth)
		start: aMsg start;
		end: aMsg end
)
processExplicitOuterSend: aMsg <MessageAST> = (
"Unused at the moment"
)
processHereSend: aMsg <MessageAST> = (
	| binding <AST> |
	binding:: currentScope at: aMsg sel ifAbsent: [MessageAST new].
	binding isMessagePatternNode ifTrue:
		["this is a message send for a lexically defined method"	
		^processImplicitOuterSend: aMsg atDepth: binding depth].
	binding isVarDeclNode
		ifTrue: [^ processVariable: aMsg decl: binding].
	({#true. #false. #nil} includes: aMsg sel) ifTrue:
		[^processVariable: aMsg decl: nil].
	^selfSendFrom: aMsg
)
processImplicitOuterSend: aMsg <MessageAST> atDepth: n <Integer> ^ <SendNode> = (
	| selectorBinding <AST> depth <integer> |
	selectorBinding:: currentScope at: aMsg sel.
	
	depth: currentDepth -  selectorBinding depth.
	"aMsg sel = 'foo' ifTrue: [halt]."
	
	^(ImplicitRecvrSendAST send: (aMsg apply: self) depth: depth) start: aMsg start; end: aMsg end
)
processInlineableLoop: node <NormalSendAST> ^<LoopAST> = (
	|
	rcvr = node recv.
	msg = node msg.
	sel = msg sel.
	numArgs = msg args size.
	arg1 = numArgs >= 1 ifTrue: [msg args at: 1].
	arg2 = numArgs >= 2 ifTrue: [msg args at: 2].
	arg3 = numArgs >= 3 ifTrue: [msg args at: 3].
	|
	
	sel = #whileTrue ifTrue: [^LoopAST new
		while: true
		do: (rewriteInlinedBlockNode: rcvr forValue: true)].
	sel = #whileFalse ifTrue: [^LoopAST new
		while: false
		do: (rewriteInlinedBlockNode: rcvr forValue: true)].
	sel = #whileTrue: ifTrue: [^LoopAST new
		while: (rewriteInlinedBlockNode: rcvr forValue: true) 
		is: true
		do: (rewriteInlinedBlockNode: arg1 forValue: false)].
	sel = #whileFalse: ifTrue: [^LoopAST new
		while: (rewriteInlinedBlockNode: rcvr forValue: true) 
		is: false
		do: (rewriteInlinedBlockNode: arg1 forValue: false)].
	
	sel = #repeat ifTrue: [^LoopAST new
		repeat: (rewriteInlinedBlockNode: rcvr forValue: false)].
	
	sel = #timesRepeat: ifTrue: [^LoopAST new
		do: (rcvr apply: self)
		timesRepeat: (rewriteInlinedBlockNode: arg1 forValue: false)].
	
	sel = #to:do: ifTrue: [^LoopAST new
		from: (rcvr apply: self)
		to: (arg1 apply: self)
		do: (rewriteInlinedBlockNode: arg2 forValue: false)].
	
	sel = #to:by:do: ifTrue: [^LoopAST new
		from: (rcvr apply: self)
		to: (arg1 apply: self)
		by: (arg2 apply: self)
		do: (rewriteInlinedBlockNode: arg3 forValue: false)].
	
	assert: [false] message: 'Unknown loop selector'
)
processOuterSend: aMsg <MessageAST> = (
	| holder <NormalSendAST> depth <Integer> binding <AST>  meMsg <MessageAST> |
	assert: [aMsg args isEmpty]. "this had better be a unary message"
	binding:: (currentScope at: #outer) at: aMsg sel.
	"assert binding makes sense "
	assert: [binding isKindOf: Collection].
	"assert: [binding first isKindOf: Class]." "disabled temporarily until we get the class story straight on the JS side"
	assert: [binding last isKindOf: Integer].

	meMsg:: MessageAST new sel: #yourself; args: {}; start: aMsg start; end: aMsg end. "hack!"
	^processOuterSend: meMsg atDepth: binding last
)
processOuterSend: aMsg <MessageAST> atDepth: n = (
"For n > 0, return
thisContext methodClass enclosingObject`Cn ... C0 
                                         class enclosingObject`Cn ...`C1  ...  
                                            class enclosingObject`Cn`Cn-1 msg

which is the equivalent of

outer X msg

where X is the nth lexically enclosing class. Otherwise, do a self send"

	| holder <NormalSendAST> ctxt <VariableAST> start <Integer> end <integer> 
	enclosingObj <NormalSendAST> nonMeta <NormalSendAST>  |

	n = 0 ifTrue: [^selfSendFrom: aMsg].
	start:: aMsg start.
	end:: aMsg end.
	ctxt:: VariableAST new name: #thisContext; start: start; end: end.

	holder:: NormalSendAST new
		recv: ctxt;
	 	msg: (MessageAST new sel: #lexicalClass; args: {});
		start: start; end: end.
	nonMeta:: NormalSendAST new
		recv: holder;
		msg: (MessageAST new sel: #theNonMetaClass; args: {});
		start: start; end: end.
	enclosingObj:: enclosingObjSendOfDepth: 1 to: nonMeta start: start end: end. 

	enclosingObj:: (2 to: n) inject: enclosingObj into:
		[:r <NormalSendAST> :i <Integer> | 
		| csend <NormalSendAST> |
		csend:: NormalSendAST new
			recv: r; 
			msg: (MessageAST new sel: #class; args: {}; start: start; end: end);
			start: start; 
			end: end.
		enclosingObjSendOfDepth: i to: csend start: start end: end].
	^(NormalSendAST new recv: enclosingObj; msg: aMsg; start: start; end: end) apply: self
)
processVariable: aMsg <MessageAST> decl: vd <VarDeclAST>  ^ <AssignmentNode | VariableNode> = (
	^aMsg sel last = $:
		ifTrue: "it is a temporary write"
			[assignmentFrom: aMsg decl: vd]
		ifFalse: "it is a parameter or temporary read"
			[variableFrom: aMsg decl: vd]
)
returnsAreNonLocalWhile: block = (
	| originalValue |
	originalValue: areReturnsLocal.
	areReturnsLocal: false.
	^block ensure: [areReturnsLocal: originalValue]
)
rewriteBody: node <CodeBodyAST> forValue: forValue <Boolean> ^<CodeBodyAST> = (
	| original result |
	original:: rewritingBodyForValue.
	rewritingBodyForValue:: forValue.
	result:: node apply: self.
	rewritingBodyForValue:: original.
	^result		
)
rewriteInlinedBlockNode: node <BlockAST> forValue: forValue <Boolean> ^ <BlockAST> = (
"An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined."
	| 
	rewrittenNode <BlockAST> 
      params <Collection[ParameterAST]>  
      bodyScope <Scope> 
	| 
	assert: [node isBlockNode].
	"this shouldn't be handled here, but I'm not sure where the block / codebody 
	comes from."
	node body start isNumber
		ifFalse: [ node body start: node start. node body end: node end ].
	
	params:: node parameters collect:
		[:p <VarDeclAST> |
		(ParameterAST name: p name type: p type)  start: p start; end: p end].
	bodyScope:: scopeMap at: node body.
	params do: [:each | (bodyScope at: each name) data: each].
	rewrittenNode:: BlockAST new body: (rewriteBody: node body forValue: forValue).
	rewrittenNode start: node start; end: node end.
	rewrittenNode body parameters: params.
	node body statements isEmpty ifTrue:
		[rewrittenNode body statements add: (NilAST new start: node body start; end: node body end)].
    ^rewrittenNode
)
selfSendFrom: aMsg <MessageAST>  ^ <MessageNode> = (
	^(NormalSendAST new
		msg: aMsg; 
		recv: (selfNode start: aMsg start; end: aMsg end);
		start: aMsg start; end: aMsg end) apply: self
)
setterBlockArgName = (
	^ ('setter_arg') asSymbol
)'node traversal'
assignmentNode: node <AssignmentAST> ^ <AssignmentAST> = (
	assert: [node isAssignmentNode].
	"note write to target variable!"
	^AssignmentAST new
		to: (node var apply: self) assign: (applyForValueTo: node expr);
		start: node start; end: node end
)
blockLocalReturnNode: node = (
	^node
)
blockNode: node <BlockAST> ^ <BlockAST> = (
	" This method should only be called on a block that is not going to be inlined.

	There are two things that require rewriting in blocks.

	1. a.  Non-empty blocks must have their body rewritten recursively
	    b. Empty blocks need a nil expression in them.
	    c. All blocks must have their parameters rewritten from generic VarDecls to ParameterASTs. 
	2. If the last statement in a block is not a return, the block returns
	the expression to its caller. So the last expression needs to be replaced by a 'local return'.

	We accomplish (1) by calling rewriteInlinedBlockNode:, and then do  (2) explicitly.

	The reason for this separation is that step (1) is always needed; step (2) is only needed if the block is not inlined.
	"
	| rewrittenBlock <BlockAST> last <AST> |
	returnsAreNonLocalWhile:
		[rewrittenBlock:: rewriteInlinedBlockNode: node forValue: true.
		last:: rewrittenBlock body statements last.
		(last isReturnStatNode or: [last isBlockLocalReturnAST]) ifFalse:
			["The last expression in a block is returned by it."
			rewrittenBlock body statements removeLast.
			rewrittenBlock body statements add:
				(BlockLocalReturnAST expression: last start: last start end: last end)].
  	  scopeMap at: rewrittenBlock put: (scopeMap at: node)].
    ^rewrittenBlock
)
cascadedSendNode: node <CascadeSendAST> ^ <CascadeSendAST> = ( 
	| prevSend msg |
	assert: [node isCascadedSendNode].
	prevSend:: applyForValueTo: node prevSend.
	msg:: applyForValueTo: node msg.
	^CascadedSendAST new to: prevSend cascade: msg;
							start: node start;
							end: node end;
							yourself
)
charNode: node <CharAST> = (
	^node
)
codeBodyNode: node <CodeBodyAST> ^ <CodeBodyAST> = (
	| 
	bodyScope <Scope>
	statements <OrderedCollection[StatementAST]>
	temps <OrderedCollection[TemporaryAST]> 
	result <CodeBodyAST>
	|
	assert: [node isCodeBodyNode].
	pushScopeForNode: node. 
	temps:: node temporaries collect:
		[:each <VarDeclAST> |
		(TemporaryAST name: each name type: each type)
			start: each start;
			end: each end.
		].
	bodyScope:: scopeMap at: node.
	temps do:
		[:t | (bodyScope at: t name)  data: t].
	node temporaries with: temps do: 
		[:varDecl <VarDeclAST> :temp <TemporaryAST> |
		temp initializer: (varDecl initializer ifNotNil: [:it | self applyForValueTo: it])
		].
	statements:: OrderedCollection new.
	node statements keysAndValuesDo:
		[:index :statement | 
		| rewritten |
		rewritten:: (index = node statements size and: [rewritingBodyForValue])
			ifTrue: [applyForValueTo: statement]
			ifFalse: [applyForEffectTo: statement].
		statements add: rewritten].
	result:: CodeBodyAST new
		parameters: node parameters temporaries: temps statements: statements;
		start: node start;
		end: node end.
	popScope.
	scopeMap at: result put: bodyScope.
	^result.
)
genericApplicationExpressionNode: node = (
	assert: [node isGenericApplicationExpressionNode].
	^applyForValueTo: node target
)
guaranteedNode: node = (
	assert: [node isGuaranteedNode].
	^applyForValueTo: node expr
)
ifNode: node <ifAST> ^ <ifAST> = (
	assert: [ node isIfNode ].
	^node
)
implicitSendNode: node = (
    assert: [node apply: ImplicitRecvrVisitor new].
    ^node
)
loopNode: node <LoopAST> ^ <LoopAST> = (
    ^node
)
messageNode: node <MessageAST> ^ <MessageAST> = (
    | args |
    assert: [node isMessageNode].
    args:: OrderedCollection new.
    node args do: [ :arg | args add: (applyForValueTo: arg)].
    ^MessageAST new send: node sel with: args; start: node start; end: node end
)
messagePatternNode: node <MessagePatternAST> ^ <MessagePatternAST> = (
	| params <OrderedCollection[ParameterAST]>  patternScope <Scope> |
	params:: node parameters collect:
		[:p <VarDeclAST> | 
		(ParameterAST name: p name type: p type)
			start: p start;
			end: p end].
	patternScope:: scopeMap at: node.
	params do:
		[:p | (patternScope at: p name) data: p].
	^MessagePatternAST new
		selector: node selector parameters: params;
		start: node start;
		end: node end.
)
methodNode: node <MethodAST> ^<MethodAST | ReturnSelfMethodAST | ReturnInstVarMethodAST>
= (
	| 
	pattern <MessagePatternAST>  
	body <CodeBodyAST>
	result <MethodAST>
	|
	assert: [ node isMethodNode ].
	pattern:: applyForValueTo: node pattern.
	"rewritingBodyForValue: false.
	body::  applyForValueTo: node body."
	body:: rewriteBody: node body forValue: false.
	body parameters: pattern parameters.
	body start: node start; end: node end.
	"Append ^self if there is no explicit return terminating the body.
	We are at the method level so that return should have been rewritten as a block local one."
	(body statements isEmpty not and: [body statements last isBlockLocalReturnAST]) ifFalse:
		[assert: [ body start isNumber ]. 		
		body statements addLast:
			(BlockLocalReturnAST
				expression: (ReceiverAST new start: body end; end: body end)
				start: body end
				end: body end)].
	result:: MethodAST new 
		pattern: pattern
		body: body
		visibility: node visibility;
		start: node start; end: node end; yourself.
	scopeMap at: result put: (scopeMap at: node).
	^result
)
mixinClassNode: node = (
	^node
)
normalSendNode: node <NormalSendAST> ^ <AST> = (
	| recv <AST> msg <MessageAST> sel <Symbol> |
	assert: [node isNormalSendNode].

	(isHereNode: node recv) ifTrue:
		[^processHereSend: node msg].
	(isOuterNode: node recv) ifTrue:
		[^processExplicitOuterReceiver: node msg].
	(isSuperNode: node recv) ifTrue:
		[^SuperSendAST send: (applyForValueTo: node msg)].

	(inlineConditionals and: [isInlinableAsExpressionConditional: node]) ifTrue:
		[^inline: node as: InlinableAsExpressionConditionalAST
			selector: node msg sel
			rewriteArgsAs: [:each | rewriteInlinedBlockNode: each forValue: true]].
	(inlineConditionals and: [isInlinableConditional: node]) ifTrue:
		[^inline: node as: InlinableConditionalAST
			selector: node msg sel
			rewriteArgsAs: [:each | rewriteInlinedBlockNode: each forValue: false]].
	(inlineOperators and: [isInlinableBooleanOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (node msg sel = 'and:' ifTrue: ['&&'] ifFalse: ['||'])
			rewriteArgsAs: [:each <BlockAST> | applyForValueTo: each body statements first]].
	(inlineLoops and: [isInlineableLoop: node]) ifTrue: [
		^processInlineableLoop: node].

	recv:: applyForValueTo: node recv.
	msg:: applyForValueTo: node msg.
	sel:: msg sel.
	^NormalSendAST new
		to: recv send: msg;
		start: node start;
		end: node end
)
numberNode: node = (
	assert: [node isNumberNode].
	^node
)
receiverNode: node <ReceiverAST> = (
	^ node
)
returnStatNode: node <ReturnStatAST> ^ <ReturnStatAST> = (
	assert: [node isReturnStatNode].
	^areReturnsLocal
		ifTrue:
			[BlockLocalReturnAST
				expression: (applyForValueTo: node expr)
				start: node start
				end: node end]
		ifFalse:
			[ReturnStatAST new
				expr: (applyForValueTo: node expr); 
		 		start: node start;
				end: node end]
)
selfNode ^ <VariableAST> = (
"shouldn't this be a ReceiverAST?"
"generate a an AST representing self; used for implicit self sends"
	^VariableAST new name: #self; start: 0; end: 0
)
setterSendNode: node <SetterSendAST> ^ <AST> = (
"Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send."
	| binding block blockArg blockParam blockScope send rewrittenSetterSend |
	assert: [node isSetterSendNode ].
	binding:: currentScope at: node msg sel ifAbsent: [MessageAST new].
	binding isVarDeclNode ifTrue:
		"This is an assignment to a temporary; no special handling is needed
		as the value of the expression is the value being assigned."
		[^processVariable: node msg decl: binding].
	valueExpected ifFalse:
		"The parent ignores the expression value; use a plain cheap here message send."
		[^processHereSend: 
			(MessageAST new
				sel: node msg sel;
				args: {node msg args first};
				start: node msg start; end: node msg end)].
	"The value is used by the parent; rewrite the whole thing as
		setter:: expr  =>  [:a | setter: a. a] value: expr"
	"a -- ok to use a constant name as long as it cannot collide with a user's name"
	blockArg:: ParameterVariableAST 
					name: setterBlockArgName 
					start: node msg start 
					end: node msg end.
	blockParam:: ParameterAST name: setterBlockArgName type: nil.
	"setter: a"
	send:: NormalSendAST new to: node recv send:
		(MessageAST new sel: node msg sel; args: {blockArg};
		start: node msg start; end: node msg end; yourself);
		start: node  start; end: node  end.
	"[:a | setter: a. a]"
	block:: BlockAST new body:
		(CodeBodyAST new
			parameters: {blockParam}
			temporaries: {}
			statements: {
				send.
				blockArg
			};			
			start: node start; end: node end);
			start: node start; end: node end.
	blockScope:: Scope new.
	blockScope
		superScope: currentScope;
		at: setterBlockArgName put: (SemanticVarDecl decl: {blockParam}).
	scopeMap at: block put: blockScope.
	scopeMap at: block body put: blockScope.
	"[:a | setter: a. a] value: expr"
	rewrittenSetterSend::
		NormalSendAST new
			to: block
			send: (MessageAST new
				sel: #value:;
				args: {node msg args first};
				start: node msg start; end: node msg end);
				start: node  start; end: node  end.
	^applyForValueTo: rewrittenSetterSend
)
stringNode: node = (
	^node
)
superSendNode: node = (
	assert: [node apply: SuperSendVisitor new].
	^node
)
symbolNode: node = (
	^node
)
temporaryNode: node <TemporaryVariableAST> = (
	"Possibily " #BOGUS.
	^node
)
tupleNode: aNode <TupleAST> = (

	^TupleAST new elements: (aNode elements collect: [:e | e apply: self])

"Rewrite into a tree representing the expression
	(Array new:  n) at: 1 put:: e1 ; ...  at: n put: en; yourself
where n is the size of the tuple."
"	|
	arrayNode <NormalSendAST> 
	arrayLengthNode <NumberAST> 
	tupleInitializationNodes <List[NormalSendAST]>
	index <Integer>
	|
	arrayLengthNode:: NumberAST new val: aNode elements size.
	arrayLengthNode start: aNode start; end: aNode end.
	arrayNode:: NormalSendAST new
		to: (NormalSendAST new 
				to: hereNode 
				send:  (MessageAST new
					sel: #Array;
					args: {};
					start: aNode start;
					end: aNode end)) 
		send: (MessageAST new
				sel: #new:;
				args: {arrayLengthNode};
				start: aNode start;
				end: aNode end).
	arrayNode start: aNode start; end: aNode end.
	aNode elements size = 0 ifTrue: [^applyForValueTo: arrayNode].
	index:: 0.
	tupleInitializationNodes:: aNode elements inject: arrayNode into:
		[:r : e |  | msg <MessageAST> |
	      index:: index + 1.
	      msg:: MessageAST new
			sel: #at:put:; 
			args: 
				{NumberAST new val: index; start: aNode start; end: aNode end.
				e}.
		msg start: aNode start; end: aNode end.
	      index = 1 
			ifTrue: 
				[NormalSendAST new to: r send: msg; start: aNode start; end: aNode end] 
				
	      	ifFalse: 
				[CascadedSendAST new to: r cascade: msg; start: aNode start; end: aNode end].
				
		].
	^applyForValueTo:
		((CascadedSendAST new
			to: tupleInitializationNodes
			cascade:
					(MessageAST new
						sel: #yourself;
						args: {};
						start: aNode start;
						end: aNode end))
				start: aNode start;
				end: aNode end)"
)
variableNode: aNode <VariableAST> = (
	assert: [ aNode start isNumber ].
	aNode name = #self ifTrue:
		[^ReceiverAST new start: aNode start; end: aNode end].
	aNode name = #nil ifTrue:
		[^NilAST new start: aNode start; end: aNode end].
	aNode name = #true ifTrue:
		[^BoolAST withValue: true start: aNode start end: aNode end].
	aNode name = #false ifTrue:
		[^BoolAST withValue: false start: aNode start end: aNode end].		
	aNode name = #thisContext ifTrue:
		[^ContextAST new start: aNode start; end: aNode end].
	"recognize inst vars for accessor methods? handle temps etc."
	^aNode
)'private'
currentScope ^ <Scope> = (
	^scopeStack last
)
isRemovableBlock: block <BlockAST> withArgs: nofArgs <Integer> ^ <Boolean> = (
"Answers true if block can be removed (inlined) within another block."
	block isBlockNode ifFalse: [^false].
	block parameters size = nofArgs ifFalse: [^false].
	^true
)
popScope ^ <Scope> = (
	^scopeStack removeLast
)
pushScope: s <Scope> = (
	scopeStack addLast: s
)
pushScopeForNode: n <AST> = (
	scopeStack addLast: (scopeMap at: n)
)
variableFrom: message <MessageAST> decl: declaration <VarDeclAST>  ^ <VariableNode> = (
	assert: [message args isEmpty].
	declaration isNil ifTrue:
		[^(VariableAST new
			name: message sel;
			start: message start;
			end: message end)
				apply: self].
	^declaration variableClass
		name: message sel
		start: message start
		end: message end                    
)) : ('as yet unclassified'
REFACTORING = (
	"This rewritter and the one used for JavaScript are likely to continue to have very similar requirements and should someday be factored out, rather than duplicated."
))
class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = ASTTool ("The scope builder is a visitor on the AST. It computes a tree of scopes that shadows the AST itself.  More precisely, it computes a mapping from ASTs to their scopes. This allows us to get to the appropriate scope for an abstract syntax node without pollluting the AST with extraneous data like scopes.

We could associate each node in the AST with the scope in which it is found, but this would be overkill. Instead, only nodes that actually introduce new scopes (such as class sides, message patterns, code bodies and blocks) actually get mapped in this manner. The intent is that later phases of compilation will visit the tree and look up the scopes at the points where they are introduced.

The builder starts at a given node, in the context of some mixin, described by a mirror.  This is because, in an incremental environment, we may not have the complete AST for a module, but instead be asked to process a part of that module, such as a nested class, slot definition or method. The surrounding scope can be computed from the mirror representing the immediately enclosing mixin.

Then we traverse the tree, creating and populating new scopes as needed. We maintain a stack of scopes (scopeStack) that initially contains only the surrounding scope.  Scopes get pushed on to the stack when we encounter a node that introduces a scope, and popped when we finish with that node. The scopes are chained to their super scopes (the scope below them on the stack).

A possible optimization is to avoid a traversal of an entire side of a class.
One can process only a side without its subtrees (i.e., methods and nested classes). These can be visited later,  as long as we ensure that the processing of the subtree begins with a proper super scope on top of the scope stack."| 
  scopeStack = OrderedCollection new.
  
  currentDepth ::= initialDepth. "The lexical nesting level of the class declaration currently 
						being visited; top level classes are level 0"
|pushScope: initialScope)
('as yet unclassified'
blockNode: aNode <BlockAST> = (
	| ps <Scope> |
	ps:: Scope new.
	"establish parameter scope"
	aNode parameters do:[:p <VarDeclAST> | ps at: p name put: (SemanticVarDecl decl: {p. currentDepth})].
	nestScope: ps.
	"visit body"
	aNode body apply: self.
	scopeMap at: aNode put: (scopeMap at: aNode body).
	popScope "pop the parameter scope, ps"
)
buildScopeFor: m <MixinMirror> ^ <Scope> = (
	^prvtScopeFor: m.
)
cascadedSendNode: aNode <CascadedSendAST> = (
"generic traversal code"
"visit receiver and messages"
	aNode prevSend apply: self.
	aNode msg apply: self.
)
charNode: aNode <CharAST> = (
"do nothing"
)
classHeaderNode: aNode = (
	aNode constructor apply: self.
	aNode slots do: [:s |  s initializer ifNotNil: [:i | i apply: self]].
	aNode initExprs do: [: e | e apply: self].
)
classNode: aNode <ClassDeclarationAST> = (
	| vs <Scope> |
	currentScope
		at: aNode name 
		put: (ClassSymbolTableEntry for: {MessagePatternAST new selector: aNode name. currentDepth}).
	vs:: Scope new. "establish instance side scope"
	currentDepth:: currentDepth + 1.
	aNode hdr slots do:
		[:v <SlotDeclAST> | 
		vs at: v name put: (SymbolTableEntry for: {MessagePatternAST new selector: v name. currentDepth}).
		v isMutable ifTrue:
			[vs at: (v name asString, ':') asSymbol
				put: (SymbolTableEntry for: {MessagePatternAST new selector: (v name asString, ':') asSymbol. currentDepth}) "setter"]
    	 ].
	self nestScope: vs.
  		aNode instanceSide apply: self.
	popScope.
	self nestScope: Scope new. "establish class side scope"
  		aNode classSide apply: self.
	popScope.
	currentDepth:: currentDepth - 1.
)
codeBodyNode: aNode <CodeBodyAST> = (
	| ts <Scope> |
	"establish local slot scope"
	ts:: Scope new.
	aNode temporaries do:
		[:t <SlotDefAST> | 
		ts at: t name put: (SemanticVarDecl decl:{t slotDecl. currentDepth}); " getter"
		at: (t name asString, ':') asSymbol put: t slotDecl "setter"].
	nestScope: ts.
	scopeMap at: aNode put: ts.
	"visit statements"
	aNode temporaries do: [:t | 	t initializer isNil ifFalse: [t initializer apply: self]].
	aNode statements do:[: s <ReturnStatementAST | SendAST>  | s apply: self].
	popScope.
)
currentScope ^ <Scope> = (
	^scopeStack last
)
enclosingMixinsOf: m <MixinMirror> ^ <Collection[MixinMirror]> = (
	| e enclosers |
	^m enclosingClassStencil enclosingClassStencils collect: [:stencil | stencil mixin]
)
isPseudoVariableNode: aNode <VariableAST> ^ <Boolean> = (
	^aNode name = #self or:
		[aNode name = #super or:
		[aNode name = #outer or:
		[aNode name = #thisContext]]]
)
messageNode: aNode <MessageAST> = (
"generic traversal code"
"visit arguments"
	aNode args do: [:a <SendAST> | a apply: self]
)
messagePatternNode: aNode <MessagePatternAST> = (
	| ps <Scope> |
	ps:: Scope new.
	"establish parameter scope"
	aNode parameters do:
		[:p <VarDeclAST> |
		ps at: p name put: (SemanticVarDecl decl: {p. currentDepth})].
	nestScope: ps.
	scopeMap at: aNode put: ps.
	"the pattern scope, ps, must be popped by the caller"
	"establish type parameter scope - skip for now"
)
methodNode: aNode <MethodAST> = (
	"register method in current scope"
	currentScope
		at: aNode pattern selector
		put: (SymbolTableEntry for: {aNode pattern. currentDepth}).
	"visit pattern"
	aNode pattern apply: self.
	"visit body"
	aNode body apply: self.
	scopeMap
		at: aNode
		put: (scopeMap at: aNode body).
	popScope "Pop pattern scope"
)
mixinApplication: node <MixinApplicationAST> = (
	node mixinExpr apply: self.
	node superclassExpr apply: self
)
mixinClassNode: aNode = (
	"do nothing"
)
nestScope: s <Scope> = (
"Hook up a new lexically nested scope, and push onto the scope stack"
	s superScope: currentScope.
	pushScope: s
)
normalSendNode: aNode <NormalSendAST> = (
"generic traversal code"
"visit recvr and msg"
	aNode recv apply: self.
	aNode msg apply: self.
)
numberNode: aNode <NumberAST> = (
"do nothing"
)
popScope ^ <Scope> = (
	^scopeStack removeLast
)
prvtScopeFor: c <MixinMirror> ^<Scope> = (
"When incrementally compiling a nested class, we need to reconstruct its scope."
	| 
	s <Scope> 
	outerMixins <Collection[MixinMirror]>
	depth <Integer>
	|
	outerMixins:: enclosingMixinsOf: c."should use a cleaner API"
	currentDepth:: outerMixins size - 1.
	depth:: 0.
	outerMixins do: [:o |
		s:: Scope new superScope: s.
		(selectorsFor: o) do:
			[: sel |
			s at: sel 
				put: (SymbolTableEntry for:{MessagePatternAST new selector: sel. depth})].
		depth:: depth + 1].
	^s
)
pushScope: s <Scope> = (
	scopeStack addLast: s
)
returnStatNode: aNode <ReturnStatAST> = (
"generic traversal code"
	"visit expression"
	aNode expr apply: self
)
selectorsFor: m <MixinMirror> ^ <Collection[Symbol]> = (
"Should add a convenience method to mirrors to do this"
	| result <Collection[Symbol]> |
	result:: m methods asOrderedCollection collect:[:s <MethodMirror> | s name].
	result addAll: (m slots asOrderedCollection collect:[: s <SlotMirror> | s name]).
	result addAll: 
		((m slots asOrderedCollection select:[: s | s isMutable]) 
			collect:[: s <SlotMirror> | s name, ':']).
	result addAll: (m classes asOrderedCollection collect:[:s <ClassStencilMirror> | s name]).
	^result
)
setterSendNode: aNode <SetterSendAST> = (
	aNode recv apply: self.
	aNode msg apply: self.
)
sideNode: aNode <SideAST> = (
	scopeMap at: aNode put: currentScope.
	"visit methods"
	aNode categories do:
		[: c <CategoryAST> | c methods do:[:m <MethodAST> | m apply: self]].
	"visit nested classes"
	aNode nestedClasses do: [:nc <ClassDeclarationAST> | nc apply: self].
)
stringNode: aNode <StringAST> = (
"do nothing"
)
symbolNode: aNode <SymbolAST> = (
"do nothing"
)
tupleNode: aNode <TupleAST> = (
"visit elements"
	aNode elements do: [:e <SendAST> | e apply: self]
)
varDeclNode: aNode <VarDeclAST> = (
"Do nothing. It could arguably add aNode's data to current scope - but in practice, the context knows better how to do this"
)
variableNode: aNode <VariableAST> = (
	assert: [aNode name = #'@here' or: [isPseudoVariableNode: aNode]]
		message: 'Unexpected variable name'.
)
visitMethod: aNode <MethodAST> within: m <MixinMirror> ^ <Dictionary[AST, Scope]> = (
	^visitNode: aNode within: m
)
visitNode: aNode <AST> within: m <MixinMirror> ^ <Dictionary[AST, Scope]> = (
	pushScope: (buildScopeFor: m).
	aNode apply: self.
	^scopeMap
)) : ('as yet unclassified'
REFACTORING = (
	"The scope builders for all the Newspeak compilation modules should someday be factored out, rather than duplicated."
)
new ^ <Instance> = (
	^self nestedIn: Scope new atLevel: 0
))
class Translator = ASTTool (
"Visits nodes of an NS AST to produce a Dart AST. The usual translation unit is a method. Translation is initiated by sending the translateMethodNode: message. The argument is the method to translate, the returned value is the translation."|
	scopeStack
	currentSelector
	protected containsNonLocalReturn <Boolean> "Set to false at the beginning of translating a method. The code that emits a non-local return sets this to true. The top-level code checks the value to see whether to emit a try-catch wrapper for an NLR."
	protected usesDefiningClass <Boolean>
	protected containsGuardedSend <Boolean>
	
	"We map some Newspeak selectors onto Dart operators to speed arithmetic and comparisons, which become native Dart operations if the operands are unwrapped built-ins."
	binaryOperatorMappings = Dictionary new
		at: '<' put: '<';
		at: '>' put: '>';
		at: '<=' put: '<=';
		at: '>=' put: '>=';
		at: '=' put: '==';
		at: '==' put: '==='; "Not overridable, but the quicksend bytecode in Squeak isn't either."
		at: '~~' put: '!==';		
		at: '+' put: '+';
		at: '-' put: '-';
		at: '*' put: '*';
		at: 'quo:' put: '~/';
		at: '/' put: '/';	"WRONG!"
		at: 'bitOr:' put: '|';
		at: 'bitXor:' put: '^';
		at: 'bitAnd:' put: '&';
		yourself.		

	guards = SendGuards new.
	vmmirror = VMMirrorIntrinsics new.
|#FLAG)
(
class SendGuards = (|
	private guardTemp = dart ident: names guardTemp.
	private guardedSelectors = Dictionary new
		at: #not put: #guardNot:to:;
		at: #& put: #guardAmp:to:;
		at: #ifTrue:ifFalse: put: #guardIfTrueIfFalse:to:;
		at: #ifTrue: put: #guardIfTrue:to:;
		at: #ifFalse: put: #guardIfFalse:to:;
		at: #ifFalse:ifTrue: put: #guardIfFalseIfTrue:to:;
		at: #ln put: #guardLn:to:;
		at: #exp put: #guardExp:to:;
		at: #printString put: #guardPrintString:to:;
		at: #timesRepeat: put: #guardTimesRepeat:to:;
		at: #to: put: #guardTo:to:;
		at: #to:do: put: #guardToDo:to:;
		at: #// put: #guardOverOver:to:;
		at: #\\ put: #guardBackBack:to:;
		at: #rem: put: #guardRem:to:;
		at: #max: put: #guardMax:to:;
		at: #min: put: #guardMin:to:;
		at: #sign put: #guardSign:to:;
		at: #between:and: put: #guardBetweenAnd:to:;
		at: #value put: #guardValue0:to:;
		at: #value: put: #guardValue1:to:;
		at: #value:value: put: #guardValue2:to:;
		at: #isBlock put: #guardIsBlock:to:;
		at: #on:do: put: #guardOnDo:to:;
		yourself.
|)
('as yet unclassified'
guardAmp: msg <MessageAST> to: rcvr <AST> = (
	"a & b =>  (t=a) is bool ? b&&a : a.amp_(b)"

	#FLAG. "Is this produce evaluting conjunction?"

	^if: rcvr
	is: 'bool'
	do: (dart operator: '&&' with: (msg args first apply: translator) and: guardTemp)
	otherwiseSend: msg
)
guardBackBack: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart
		invoke: (dart ident: 'seqexp_backBack')
		with: {guardTemp. msg args first apply: outer Translator})
	otherwiseSend: msg
)
guardBetweenAnd: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart
		invoke: (dart ident: 'seqexp_betweenAnd')
		with: {guardTemp. 
			msg args first apply: outer Translator.
			(msg args at: 2) apply: outer Translator})
	otherwiseSend: msg
)
guardExp: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart on: (dart ident: 'Math') invoke: (dart ident: 'exp') with: {guardTemp})
	otherwiseSend: msg
)
guardIfFalse: msg <MessageAST> to: rcvr <AST> = (
	^self 
		to: rcvr
		ifTrue: (dart ident: names nil)
		ifFalse: (sendValueTo: (msg args at: 1))
		ifNotBoolean: msg
)
guardIfFalseIfTrue: msg <MessageAST> to: rcvr <AST> = (
	^self 
		to: rcvr
		ifTrue: (sendValueTo: (msg args at: 2))
		ifFalse: (sendValueTo: (msg args at: 1)) 
		ifNotBoolean: msg
)
guardIfTrue: msg <MessageAST> to: rcvr <AST> = (
	^self 
		to: rcvr
		ifTrue: (sendValueTo: (msg args at: 1))
		ifFalse: (dart ident: names nil)
		ifNotBoolean: msg
)
guardIfTrueIfFalse: msg <MessageAST> to: rcvr <AST> = (
	^self 
		to: rcvr
		ifTrue: (sendValueTo: (msg args at: 1))
		ifFalse: (sendValueTo: (msg args at: 2)) 
		ifNotBoolean: msg
)
guardIsBlock: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'Function'
	do: (dart ident: 'true')
	otherwiseSend: msg
)
guardLn: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart on: (dart ident: 'Math') invoke: (dart ident: 'log') with: {guardTemp})
	otherwiseSend: msg
)
guardMax: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart
		invoke: (dart ident: 'seqexp_max')
		with: {guardTemp. msg args first apply: outer Translator})
	otherwiseSend: msg
)
guardMin: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart
		invoke: (dart ident: 'seqexp_min')
		with: {guardTemp. msg args first apply: outer Translator})
	otherwiseSend: msg
)
guardNot: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'bool'
	do: (dart prefixOperator: '!' on: guardTemp)
	otherwiseSend: msg	
)
guardOnDo: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'Function'
	do: (dart
		invoke: (dart ident: 'seqexp_ondo')
		with: {guardTemp. 
			msg args first apply: outer Translator.
			(msg args at: 2) apply: outer Translator})
	otherwiseSend: msg
)
guardOverOver: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart
		invoke: (dart ident: 'seqexp_overOver')
		with: {guardTemp. msg args first apply: outer Translator})
	otherwiseSend: msg
)
guardPrintString: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: '! Top_mixin'
	do: (dart
		on: (dart ident: names String)
		invoke: (dart ident: (names mangleSelector: 'wrapping:'))
		with: {dart on: guardTemp invoke: (dart ident: 'toString') with: {}})
	otherwiseSend: msg
)
guardRem: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart
		invoke: (dart ident: 'seqexp_rem')
		with: {guardTemp. msg args first apply: outer Translator})
	otherwiseSend: msg
)
guardSign: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart
		invoke: (dart ident: 'seqexp_sign')
		with: {guardTemp})
	otherwiseSend: msg
)
guardTimesRepeat: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart
		invoke: (dart ident: 'seqexp_timesRepeat')
		with: {guardTemp. msg args first apply: outer Translator})
	otherwiseSend: msg
)
guardTo: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart
		invoke: (dart ident: 'seqexp_to')
		with: {guardTemp. msg args first apply: outer Translator})
	otherwiseSend: msg
)
guardToDo: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'num'
	do: (dart
		invoke: (dart ident: 'seqexp_toDo')
		with: {guardTemp. 
			msg args first apply: outer Translator.
			(msg args at: 2) apply: outer Translator})
	otherwiseSend: msg
)
guardValue0: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'Function'
	do: (dart
		invoke: (guardTemp)
		with: {})
	otherwiseSend: msg
)
guardValue1: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'Function'
	do: (dart
		invoke: (guardTemp)
		with: {msg args first apply: outer Translator})
	otherwiseSend: msg
)
guardValue2: msg <MessageAST> to: rcvr <AST> = (

	^if: rcvr
	is: 'Function'
	do: (dart
		invoke: (guardTemp)
		with: {
			msg args first apply: outer Translator.
			(msg args at: 2) apply: outer Translator})
	otherwiseSend: msg
)
if: rcvr is: type do: fastpath otherwiseSend: msg = (
	^dart
		ternaryIf: (dart operator: 'is' with: (dart assign: guardTemp toBe: rcvr) and: (dart verbatim: type))
		then: fastpath
		else: (processUnguardedSend: msg to: guardTemp).
)
isGuardedSelector: selector <String> ^<Boolean> = (
	^guardedSelectors includesKey: selector
)
processGuardedSend: message <MessageAST> to: receiver <AST> = (
	^self perform: (guardedSelectors at: message sel) with: message with: receiver
)
sendValueTo: ast = (
	wrapBlocks ifFalse: [^dart invoke: (ast apply: translator) with: {}].
	^dart
		on: (ast apply: translator)
		invoke: (dart ident: (names mangleSelector: 'value'))
		with: {}
)
to: boolExp ifTrue: trueExp ifFalse: falseExp ifNotBoolean: originalMessage = (

	^(dart
		ternaryIf: boolExp
		then: trueExp
		else: falseExp)
	"^if: boolExp
	is: 'bool'
	do: (dart
		ternaryIf: guardTemp
		then: trueExp
		else: falseExp)
	otherwiseSend: originalMessage"
)) : ()
class VMMirrorIntrinsics = (
"When compiling the runtime modules, all sends to the receiver 'vmmirror' are evaluated at compile time. They are sent to an instance of this class, which answers Dart ASTs."|
|)
('as yet unclassified'
Array = (
	^dart ident: names Array
)
Block = (
	^dart ident: names Block
)
Error = (
	halt.
)
MessageNotUnderstood = (
	halt.
)
Number = (
	^dart ident: names Number
)
Object = (
	^dart ident: names Object
)
String = (
	^dart ident: names String
)
asNsBoolean: dartBoolean = (
	wrapBooleans ifFalse: [^dartBoolean].
	^dart ternaryIf: dartBoolean then: (dart ident: 'true_') else: (dart ident: 'false_')
)
bitAnd: a with: b = (
	^dart operator: '&' with: a and: b
)
bitOr: a with: b = (
	^dart operator: '|' with: a and: b
)
bitXor: a with: b = (
	^dart operator: '^' with: a and: b
)
classOf: o = (
	^dart memberOf: o at: 'klass_'
)
concatenate: a and: b = (
	^dart on: a invoke: (dart ident: 'concat') with: {b}
)
divide: a by: b = (
	^dart operator: '/' with: a and: b
)
doesNotUnderstand: msg = (
	super Error signal: 'Unknown intrinsic: ', msg selector
)
exp: x= (
	^dart on: (dart ident: 'Math') invoke: (dart ident: 'exp') with: {x}
)
from: a subtract: b = (
	^dart operator: '-' with: a and: b
)
hashOf: o = (
	^dart on: o invoke: (dart ident: 'hashCode') with: {} 
)
identityHashOf: o = (
	^dart
		ternaryIf: (dart
			operator: '===' 
			with: (dart memberOf: o at: 'identityHash_')
			and: (dart ident: 'null'))
		then: (dart
			assign: (dart memberOf: o at: 'identityHash_')
			toBe: (dart verbatim: 'lastHash_ = (92698137 + (353823277 * lastHash_)) & 2147483647'))
		else: (dart memberOf: o at: 'identityHash_')
)
intDivide: a by: b = (
	^dart operator: '~/' with: a and: b
	"^dart
		on: (dart
			on: (dart operator: '/' with: a and: b)
			invoke: (dart ident: 'floor')
			with: {})
		invoke: (dart ident: 'toInt')
		with: {}"
)
invoke: f = (
	^dart invoke: f with: {}
)
invoke: f with: a1 = (
	^dart invoke: f with: {a1}
)
invoke: f with: a1 with: a2 = (
	^dart invoke: f with: {a1. a2}
)
invoke: f with: a1 with: a2 with: a3 = (
	^dart invoke: f with: {a1. a2. a3}
)
invoke: f with: a1 with: a2 with: a3 with: a4 = (
	^dart invoke: f with: {a1. a2. a3. a4}
)
is: a equalTo: b = (
	^asNsBoolean: (dart operator: '==' with: a and: b)
)
is: a greaterOrEqual: b = (
	^asNsBoolean: (dart operator: '>=' with: a and: b)
)
is: a greaterThan: b = (
	^asNsBoolean: (dart operator: '>' with: a and: b)
)
is: a identicalTo: b = (
	^asNsBoolean: (dart operator: '===' with: a and: b)
)
is: a lessOrEqual: b = (
	^asNsBoolean: (dart operator: '<=' with: a and: b)
)
is: a lessThan: b = (
	^asNsBoolean: (dart operator: '<' with: a and: b)
)
lengthOf: n = (
	^dart memberOf: n at: 'length' 
)
list: list at: index = (
	^dart
		subscript: list
		at: index
)
list: list at: index put: value = (
	^dart
		assign: (dart subscript: list at: index)
		toBe: value
)
ln: x= (
	^dart on: (dart ident: 'Math') invoke: (dart ident: 'log') with: {x}
)
millisecondClockValue = (
	^dart verbatim: '(Clock.now()/Clock.frequency()*1000).toInt()'
)
mixinApply: klass to: superclass = (
	^dart invoke: (dart ident: 'mixinapply2') with: {klass. superclass}
)
multiply: a by: b = (
	^dart operator: '*' with: a and: b
)
newList: size = (
	^dart new: (dart ident: 'List') with: {size}
)
on: rcvr invoke: sel with: args = (
	^dart 
		invoke: (dart ident: 'INVOKE')
		with: {rcvr. sel. args}
)
print: obj = (
	^dart invoke: (dart ident: 'print') with: {obj}
)
sqrt: a = (
	^dart on: (dart ident: 'Math') invoke: (dart ident: 'sqrt') with: {a}
)
throw: exception = (
	^dart throw: exception
)
to: a add: b = (
	^dart operator: '+' with: a and: b
)
toString: a = (
	^dart on: a invoke: (dart ident: 'toString') with: {}
)
try: b1 ensure: b2 = (
	^dart 
		try: (dart return: (dart on: b1 invoke: (dart ident: (names mangleSelector: 'value')) with: {})) asBlock
		catch: nil
		with: nil
		finally: (dart on: b2 invoke: (dart ident: (names mangleSelector: 'value')) with: {}) asBlock
)
try: tryblock on: expectedclass do: catchblock = (

	^dart 
		try: (dart return: (dart 
			on: tryblock 
			invoke: (dart ident: (names mangleSelector: 'value')) 
			with: {})) asBlock 
			
		catch: (dart verbatim: (names mixinClassNameFor: 'KernelForDart`Error'),' e_')
		
		with: (dart block: {
			dart
				for: (dart verbatim: 'var c_ = e_.klass_')
				while: (dart verbatim: 'c_ !== nil_')
				step: (dart verbatim: 'c_ = c_.superclass_slot')
				do: (
					dart
					if: (dart
						operator: '==='
						with: (dart ident: 'c_')
						and: expectedclass)
					then: (dart
						return: ((dart 
							on: catchblock 
							invoke: (dart ident: (names mangleSelector: 'value:')) 
							with: {dart ident: 'e_'}))
						) asBlock
				) asBlock.
			
			(dart throw: (dart ident: 'e_'))
		})
)
whileFalse: cond do: block = (
	^dart
		for: (dart verbatim: '')
		while: (dart prefixOperator: '!' on: (nsToDartBool: (self invoke: cond)))
		step: (dart verbatim: '')
		do: (self invoke: block)
)
whileTrue: cond do: block = (
	^dart
		for: (dart verbatim: '')
		while: (nsToDartBool: (self invoke: cond))
		step: (dart verbatim: '')
		do: (self invoke: block)
)) : ()'as yet unclassified'
addCascadedSend: node to: statements = (
	| cascadeReceiver |
	node isCascadedSendNode ifFalse: [
		assert: [node isNormalSendNode] message: 'Cascades must bottom out at a normal send, right?'.
		statements add: (processSend: node msg to: (dart ident: 'cascadeReceiver_')).
		^node recv].
	cascadeReceiver:: addCascadedSend: node prevSend to: statements.
	statements add: (processSend: node msg to: (dart ident: 'cascadeReceiver_')).
	^cascadeReceiver
)
assignmentNode: node <AssignmentAST> = (

	^dart assign: (node var apply: self) toBe: (node expr apply: self)
)
beginNewTranslationCycle = (
	scopeStack:: OrderedCollection new.
	containsNonLocalReturn:: false.
	usesDefiningClass:: false.
	containsGuardedSend:: false.
)
blockLocalReturnNode: node <BlockLocalReturnAST> = (
"	(node expr isNormalSendNode and: [isInlinableConditionalNode: node expr]) ifTrue:
		""Optimize the common special case of returning the value of an ifTrue:ifFalse: message send.
		The clauses already have the necessary local returns of the last expression of each clause
		inserted by the rewriter.""
		[^js if: (node expr recv apply: self)
			then: (node expr msg args first body apply: self)
			else: ((node expr msg args at: 2) body apply: self)]."
	^dart return: (node expr apply: self)
)
blockNode: node <BlockAST> = (
	wrapBlocks ifFalse: [
		^dart 
		functionOf: (node parameters collect: [:each | each apply: self]) asArray
		body: (node body apply: self)].
	
	^dart
		on: vmmirror Block
		invoke: (dart ident: (names mangleSelector: 'wrapping:'))
		with: {dart 
			functionOf: (node parameters collect: [:each | each apply: self]) asArray
			body: (node body apply: self)}
)
boolNode: node <BoolAST> = (
	wrapBooleans ifFalse: [
		^dart ident: (node val ifTrue: ['true'] ifFalse: ['false'])].
	^dart ident: (node val ifTrue: [names true] ifFalse: [names false])
)
cascadedSendNode: node <CascadedSendAST> = (
	| statements cascadeReceiver |
	statements:: OrderedCollection new.
	cascadeReceiver:: addCascadedSend: node to: statements.
	statements at: statements size put: (dart return: statements last).
	^dart 
		invoke: (dart functionOf: {'cascadeReceiver_'} body: (dart block: statements))
		with: {cascadeReceiver apply: self}
)
charNode: node <CharAST> = (
	"Dart has no characters, only strings. Newspeak will probably move in this direction as well."
	^dart
		on: vmmirror String
		invoke: (dart ident: (names mangleSelector: 'wrapping:'))
		with: {dart literal: node val asString}
)
codeBodyNode: node <CodeBodyAST> = (
	| locals statements |
	locals:: node temporaries collect: [:each | each apply: self].
	statements:: node statements collect: [:each | each apply: self].
	^dart block: (locals asArray, statements) asArray
)
definingClassTempOrEmpty = (
	| definingClass = names definingClassTemp. |
	
	^usesDefiningClass 
		ifTrue: [{dart verbatim: 'var ',definingClass,' = this.klass_; while(! ',definingClass,' is ', currentMixinClassName, ') ',definingClass,' = ',definingClass,'.superclass_slot;'}]
		ifFalse: [{}].
)
explicitOuterReceiverNode: node <ExplicitRecvrAST> = (
	^processOuterReceiverAtDepth: node depth
)
guardTempOrEmpty = (
	^containsGuardedSend ifTrue: [{dart var: names guardTemp}] ifFalse: [{}].
)
implicitSendNode: node <ImplicitRcvrSendNode> = (
	^processSend: node msg to: (processOuterReceiverAtDepth: node depth)
)
inlinableAsExpressionConditionalNode: node <InlinableConditionalAST> = (
	| truePath falsePath condition |
	
	condition:: nsToDartBool: (node recv apply: self).
	
	node msg sel = 'ifTrue:' ifTrue:
		[truePath:: (node msg args at: 1) body statements first apply: self.
		falsePath:: dart ident: names nil].
	node msg sel = 'ifFalse:' ifTrue:
		[truePath:: dart ident: names nil.
		falsePath:: (node msg args at: 1) body statements first apply: self].
	node msg sel = 'ifTrue:ifFalse:' ifTrue:
		[truePath:: (node msg args at: 1) body statements first apply: self.
		falsePath:: (node msg args at: 2) body statements first apply: self].
	node msg sel = 'ifFalse:ifTrue:' ifTrue:
		[truePath:: (node msg args at: 2) body statements first apply: self.
		falsePath:: (node msg args at: 1) body statements first apply: self].
	
	^dart ternaryIf: condition then: truePath else: falsePath
)
inlinableConditionalNode: node <InlinableConditionalAST> = (
	| selector inverseCondition hasElseClause condition |
	selector:: node msg sel.
	inverseCondition:: selector = 'ifFalse:ifTrue:' or: [selector = 'ifFalse:'].
	hasElseClause:: node msg args size = 2.
	condition:: nsToDartBool: (node recv apply: self).
	^dart if: (inverseCondition ifTrue: [dart prefixOperator: '!' on: condition] ifFalse: [condition])
		then: (node msg args first body apply: self)
		else: (hasElseClause ifTrue: [(node msg args at: 2) body apply: self] ifFalse: [nil])
)
inlinedOperatorNode: node <InlinedOperatorAST> = (
	^dart operator: node msg sel
		with: (node recv apply: self)
		and: (node msg args first apply: self)
)
loopNode: node <LoopAST> = (

	"prologue; while(cond==whileTrue) {body};"

	|
	prologue = node prologue apply: self.
	cond = node cond apply: self.
	body = node body ifNil: [dart block: {}] ifNotNil: [:it | it apply: self].
	
	"Split the condition is it isn't a single expression"
	condExpression ::= cond statements last.
	condPrologue = cond statements asOrderedCollection removeLast; yourself.
	|
	
	node isWhileTrue ifFalse: [
		condExpression:: dart prefixOperator: '!' on: condExpression].
	
	"Flatten prologue so its declarations are in scope for the loop"
	
	^dart block: 
		prologue statements,
		condPrologue, {
		dart 
			for: (dart verbatim: '')
			while: condExpression
			step: (dart verbatim: '')
			do: (dart block: body statements, condPrologue)}
)
mangleVarName: name <String> ^<String> = (
	#FLAG. "How does this fit with mangling of identifiers?"
	^'l_', name
)
messageNode: node = (
	"useDnuCatcher ifTrue: [sentSelectors add: node sel]."
	^(names mangleSelector: node sel)
)
messagePatternNode: node <MessagePatternAST> ^<List[String]> = (
	currentSelector:: names mangleSelector: node selector.
	^node parameters collect: [:each | each apply: self]
)
methodNode: node <MethodAST> ^<Node> = (
	| translatedBody methodName |
	translatedBody:: node body apply: self.
	
	methodName:: node pattern selector.
	methodName:: 
		in: binaryOperatorMappings
		at: methodName
		ifPresent: [:op | dart verbatim: 'operator ', op]
		ifAbsent: [names mangleSelector: methodName].
		
	^dart
		method: methodName
		params: (node pattern apply: self) asArray
		body: (containsNonLocalReturn
			ifTrue: [wrapBodyForNlrHandling: translatedBody]
			ifFalse: [wrapBodyNoNlrHandling: translatedBody]).
)
nilNode: node <NilAST> = (
	^dart ident: names nil
)
nlrValueName = (
	^'value'
)
normalSendNode: node <NormalSendNode> = (
	^processSend: node msg to: (node recv apply: self)
)
nsToDartBool: nsBool <Node> = (
	wrapBooleans ifFalse: [^nsBool].
	^dart operator: '===' with: nsBool and: (dart ident: 'true_')
)
numberNode: node <NumberAST> = (
	wrapNumbers ifFalse: [^dart literal: node val].
	^dart
		on: vmmirror Number
		invoke: (dart ident: (names mangleSelector: 'wrapping:'))
		with: {dart literal: node val}
)
parameterDeclNode: node <ParameterAST> = (
	^names mangleSelector: node name
)
parameterNode: node <ParameterVariableAST> = (
	^dart ident: (names mangleSelector: node name)
)
processIntrinsic: message = (

	^vmmirror 
		perform: message sel
		withArguments: (message args collect: [:ea | ea apply: self]) asArray
)
processOuterReceiverAtDepth: depth <Integer> = (
	| exp |
	depth = 0 ifTrue: [^dart ident: 'this'].
	
	"Since nesting chains are typically short, it seems like the simplicity of following them directly won't be too expensive. Possibly for depths 1 and 2 this is faster than the enclosing objects array scheme."
	useCrawlingHereSends ifFalse: [
		
		^dart 
			subscript: (dart ident: currentMixinClassName, '_enclosingObjects') 
			at: (dart literal: depth - 1)
	].
	
	
	usesDefiningClass:: true.
	
	exp:: dart ident: names definingClassTemp.  "definingClassNode."
	(1 to: depth) 
		do: [:ignore | exp:: dart memberOf: exp at: (names mangleSlotName: 'enclosingObject')]
		separatedBy: [exp:: dart memberOf: exp at: 'klass_'].
	^exp
)
processSend: message to: receiver = (

	#FLAG. "Yucky pattern matching"
	enableIntrinsics ifTrue: [
		receiver isMethodInvocation ifTrue: [
			receiver target = (dart ident: 'this') ifTrue: [
				receiver method name = 'vmmirror' ifTrue: [
					^processIntrinsic: message]]]].
	
	(guards isGuardedSelector: message sel) ifTrue:
		[containsGuardedSend:: true.
		^guards processGuardedSend: message to: receiver].

	^processUnguardedSend: message to: receiver
)
processUnguardedSend: message to: receiver = (

	^in: binaryOperatorMappings
	at: message sel
	ifPresent: [:op | dart
		operator: op
		with: receiver
		and: (message args first apply: self)]
	ifAbsent: [dart 
		on: receiver
		invoke: (dart ident: (message apply: self))
		with: (message args collect: [:each | each apply: self]) asArray]
)
receiverNode: node <ReceiverAST> = (
	^dart ident: 'this'
)
returnStatNode: node <ReturnAST> = (
	containsNonLocalReturn:: true.
	^dart block: {
		dart assign: (dart memberOf: (dart ident: names nlrTemp) at: nlrValueName) toBe: (node expr apply: self).
		dart throw: (dart ident: names nlrTemp)
	}
)
stringNode: node <StringAST> = (
	#FLAG. "Eventually Newspeak will not have syntax for symbol literals and treat all string literals as symbols (interned strings)"
	^dart
		on: vmmirror String
		invoke: (dart ident: (names mangleSelector: 'wrapping:'))
		with: {dart literal: node val}
)
superSendNode: node <SuperSendAST> = (
	^processSend: node msg to: (dart ident: 'super')
)
symbolNode: node <SymbolAST> = (
	#FLAG. "Are string literals interned in Dart?"
	^self stringNode: node
)
temporaryDeclNode: node <TemporaryAST> = (
	^dart var: (names mangleSelector: node name)
		value: (node initializer = nil
			ifTrue: [dart ident: 'nil_']
			ifFalse: [ node initializer apply: self])
)
temporaryNode: node <TemporaryVariableAST> = (
	^dart ident: (names mangleSelector: node name)
)
tupleNode: node <TupleAST> = (
	^dart
		on: vmmirror Array
		invoke: (dart ident: (names mangleSelector: 'wrapping:'))
		with: {dart list: (node elements collect: [:ea | ea apply: self])}
)
wrapBodyForNlrHandling: body <Block> = (
	| nlrVarNode nlrParamName nlrParamNode |
	nlrVarNode:: dart ident: names nlrTemp.
	nlrParamName:: names nlrExceptionTemp.
	nlrParamNode:: dart ident: nlrParamName.
	^dart block: 
		definingClassTempOrEmpty,
		guardTempOrEmpty, {
		dart var: names nlrTemp value: (dart new: (dart ident: names NLR) with: {}).
		dart try: body catch: (dart verbatim: names NLR,' ',nlrParamName) with:
			(dart block: {
				dart if: (dart operator: '===' with: nlrVarNode and: nlrParamNode)
					then: (dart return: (dart memberOf: nlrParamNode at: nlrValueName))
					else: (dart throw: nlrParamNode)
			})
	}
)
wrapBodyNoNlrHandling: body <Block> = (
	^dart block: 
		definingClassTempOrEmpty,
		guardTempOrEmpty,
		body statements
)) : ()'as yet unclassified'
accessorForNestedClass: classDecl <ClassDeclarationAST> within: mixinMirror = (
	|
	simpleName = classDecl hdr name.
	fullName = names fullyQualifySimpleName: simpleName with: mixinMirror name.
	slotName = names mangleSlotName: fullName.
	superclass = accessorForSuperclass: classDecl hdr superclassName inScope:  (scopeMap at: classDecl instanceSide).
	metamixin = dart ident: (names metamixinClassNameFor: fullName).
	mixin = dart ident: (names metamixinClassNameFor: fullName).
	
	"parentEOA = dart
		memberOf: (dart ident: (names mixinClassNameFor: mixinMirror name))
		at: (names enclosingObjectsArrayFor: mixinMirror name meta: false)."
	parentEOA = dart
		on: (dart memberOf: (dart ident: 'this') at: 'klass_')
		invoke: (dart ident: 'enclosingObjects_') with: {}.
	childEOA = dart
		memberOf: (dart ident: (names mixinClassNameFor: fullName))
		at: (names enclosingObjectsArrayFor: fullName meta: false).
	metachildEOA = dart
		memberOf: (dart ident: (names metamixinClassNameFor: fullName))
		at: (names enclosingObjectsArrayFor: fullName meta: true).
		
	theDynamicWay
	|
	#FLAG.
	
	theDynamicWay:: dart
				assign: (dart ident: slotName)
				toBe: (dart invoke: (dart ident: 'mixinapply') with: {
		dart literal: (names mixinClassNameFor: fullName).
		dart ident: (names mixinClassNameFor: fullName) , '_body'.
		dart literal: (names metamixinClassNameFor: fullName).
		dart ident: (names metamixinClassNameFor: fullName), '_body'.	
		(dart ident: 'superclass').
		(SymbolAST new val: fullName) apply: translator.
		dart invoke: (dart ident: 'seqexp_prepend') with: {dart ident: 'this'. parentEOA}.
		}).
	
	(canResolveSuperclassOf: classDecl) ifFalse: [	
	^dart method: (dart ident: (names mangleSelector: simpleName)) params: {} body: (dart block: {dart
		if: (dart 
			operator: '==='
			with: (dart ident: slotName)
			and: (dart ident: 'null'))
		then: (dart block: 
			translator definingClassTempOrEmpty, {
			dart 
				var: (dart ident: 'superclass') 
				value: superclass.
			
			 theDynamicWay.	
			}).
		dart return: (dart ident: slotName).
		}).
	].
	
	^dart method: (dart ident: (names mangleSelector: simpleName)) params: {} body: (dart block: {dart
		if: (dart 
			operator: '==='
			with: (dart ident: slotName)
			and: (dart ident: 'null'))
		then: (dart block: 
			translator definingClassTempOrEmpty, {
			dart 
				var: (dart ident: 'superclass') 
				value: superclass.
				
dart if: (dart operator: '===' with: childEOA and: (dart ident: 'null'))
	then: (dart block: {				
			dart 
				var: (dart ident: 'metaclass') 
				value: (dart 
					on: (dart ident: 'Metaclass_global') 
					invoke: (dart ident: (names mangleSelector: 'new'))
					with: {}).
			dart 
				var: (dart ident: 'klass')
				value: (dart new: metamixin with: {dart ident: 'metaclass'}).
				
			dart 
				on: (dart ident: 'klass')
				invoke: (dart ident: (names mangleSelector: 'superclass:'))
				with: {dart ident: 'superclass'}.
			dart 
				on: (dart ident: 'klass')
				invoke: (dart ident: (names mangleSelector: 'enclosingObject:'))
				with: {dart ident: 'this'}.
			dart 
				on: (dart ident: 'klass')
				invoke: (dart ident: (names mangleSelector: 'name:'))
				with: {(SymbolAST new val: fullName) apply: translator}.
				
			dart 
				on: (dart ident: 'metaclass')
				invoke: (dart ident: (names mangleSelector: 'superclass:'))
				with: {dart ident: 'Class_global'}.
			dart 
				on: (dart ident: 'metaclass')
				invoke: (dart ident: (names mangleSelector: 'enclosingObject:'))
				with: {dart ident: 'this'}.
			dart 
				on: (dart ident: 'metaclass')
				invoke: (dart ident: (names mangleSelector: 'thisClass:'))
				with: {dart ident: 'klass'}.

			dart 
				assign: childEOA 
				toBe: (dart invoke: (dart ident: 'seqexp_prepend') with: {dart ident: 'this'. parentEOA}).
			dart 
				assign: metachildEOA 
				toBe: (dart invoke: (dart ident: 'seqexp_prepend') with: {dart ident: 'this'. parentEOA}).
							
			dart
				assign: (dart ident: slotName)
				toBe: (dart ident: 'klass').
		})
		else: (dart block: {theDynamicWay})
				
			}).
			
			dart return: (dart ident: slotName).
	})
)
accessorForSuperclass: superclassName <String> inScope: s <Scope> ^<Node> = (
	| send scopeBuilder |
	send:: NormalSendAST new
		to: hereNode
		send: (MessageAST new
			send: superclassName
			with: {}).
	
	rewriter pushScope: s.
	send:: send apply: rewriter.
	rewriter popScope.
	
	translator beginNewTranslationCycle.
	^send apply: translator
	
	"^dart 
		on: (dart ident: 'this')
		invoke: (dart ident: (mangleSelector: superclassName))
		with: {}."
)
canResolveSuperclassOf: node <ClassDeclarationAST> ^<String> = (
	"Try to find the fully qualified name of the mixin of the superclass of the given class declaration. This cannot be done in general statically. Additionally, the scopes do not have enough information to tell us whether the binding is actually a class declaration, or a method or slot. If the latter two, the compiler will hum along but the Dart compiler will complain when the mixin class tries to inherit from a nonexistent class."
	
	| name = node hdr superclassName. scope binding tokens |
	
	tokens:: node hdr name findTokens: $`.
	scope:: scopeMap at: node instanceSide.
	binding:: scope at: node hdr superclassName ifAbsent: [
		
		name = 'Top' ifTrue: [^true].
		name = 'Object' ifTrue: [^true].
		name = 'Error' ifTrue: [^true].
		
		^false
	].
	binding isClassDeclaration ifFalse: [^false].
	^true
)
createNestedClassAccessorFrom: classDecl <ClassDeclarationAST> within: mixinMirror <LowLevelMixinMirror> = (
"Create an accessor method for the nested class represented by the incoming class tree.
This accessor will lazily generate the nested class when its enclosing instance is first asked for it."

	| n <String>  accessorString <String> methodSrc <String>  hdr <ClassHeaderAST> accessor <MethdMirror>  |
	hdr:: classDecl hdr.
	n:: hdr name. 
	methodSrc:: 
		accessorForNestedClass: classDecl within: mixinMirror.
	accessor:: MethodMirror named: (names mangleSelector: classDecl name).
	accessor method: methodSrc.
	accessor isSynthetic: true.
	mixinMirror methods addMirror: accessor.
)
hereNode ^<VariableAST> = (
	"Generates an AST representing the implicit receiver. We use a string so that we can represent a name that is not a legal identier"
	
	^VariableAST new name: #'@here'; start: 0; end: 0.
)
hereSendFrom: arg <VarDeclAST> ^<MessageNode> = (
	^NormalSendAST new
		to: hereNode
		send: (MessageAST new 
			send: arg name
			with: {};
			start: arg start; end: arg end); 
		start: arg start; end: arg end
)
language = (
	^#Newspeak3
)
nestedMixinWrapperFor: nested <ClassDeclarationAST> in: outerClass <MixinMirror>  ^ <ClassDeclarationAST> = (
"Wrap a class declaration to make it look like a nested mixin within outerClass should. This includes making the name be the fully qualified name, and hiding the superclass."

	| wrapper <ClassDeclarationAST> |
	wrapper:: nested clone.
	wrapper hdr: nested hdr clone.
	wrapper hdr name: (names fullyQualifySimpleName: nested name with: outerClass name).
	^wrapper
)
resolveSuperclassOf: node <ClassDeclarationAST> ^<String> = (
	"Try to find the fully qualified name of the mixin of the superclass of the given class declaration. This cannot be done in general statically. Additionally, the scopes do not have enough information to tell us whether the binding is actually a class declaration, or a method or slot. If the latter two, the compiler will hum along but the Dart compiler will complain when the mixin class tries to inherit from a nonexistent class."
	
	| name = node hdr superclassName. scope binding tokens |
	
	tokens:: node hdr name findTokens: $`.
	scope:: scopeMap at: node instanceSide.
	binding:: scope at: node hdr superclassName ifAbsent: [
		
		name = 'Top' ifTrue: [^'Top'].
		name = 'Object' ifTrue: [^'KernelForDart`Object'].
		name = 'Error' ifTrue: [^'KernelForDart`Error'].
		
		^'KernelForDart`Object' "Dynamic mixin"
	].
	binding isClassDeclaration ifFalse: [^'KernelForDart`Object' "Dynamic mixin"].
	
	tokens:: (tokens copyFrom: 1 to: binding depth + 1) , {name}.
	^tokens fold: [:a :b | a , '`', b]
)
selfNode = (
	^VariableAST new name: #self; start: 0; end: 0
)
setInput: source <ReadStream> = (
	source position: 1.
	input: source. "save the input"
)
setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	^((slot isMutableSlot ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), slot name, ':') asSymbol.
)
sourceForNode: node <AST> ^ <String> = (
	| savedPos <Integer> pos <Integer> len <Integer> s <String> |
	"^String withAll: (input copyFrom: node start to: node end"
	savedPos:: input position.
	len: (node end - node start) + 1.
	s:: MutableString new: len.
	input position: node start -1.
	1 to: len do:
		[:index |
		s at: index put: input next].	
	input position: savedPos.
	^s
)
translateMixinRepForBodySources: rep <MixinRep> ^<List[Node]> = (
	| 
	results <Node> = OrderedCollection new.
	cmm <CompiledMixinMirror> = rep first.
	llmm <LowLevelMixinMirror> = cmm lowLevelMirror.
	
	members = OrderedCollection new.
	metamembers = OrderedCollection new.
	|
	#FLAG. #REFACTORING.
	
	members
	addAll: (llmm instVars collect: [:ea | ea field]);
	addAll: {dart verbatim: 'static var ', (names enclosingObjectsArrayFor: cmm name meta: false),';'};
	"addAll: {dart verbatim: (names mixinClassNameFor: cmm name),'(c):super(c);'};"
	addAll: (llmm methods collect: [:ea | ea method]).

	metamembers
	addAll: {dart verbatim: 'static var ', (names enclosingObjectsArrayFor: cmm name meta: true),';'};
	"addAll: {dart verbatim: (names metamixinClassNameFor: cmm name),'(c):super(c);'};"
	addAll: (llmm classMixin methods collect: [:ea | ea method]).
	
	results add: (dart 
		var: (names mixinClassNameFor: cmm name), '_body' 
		value: (dart literal: (
			String streamContents: [:stm | members do: [:member | 
				dartWriter generateSourceFor: member on: stm. stm cr]]))).
		
	results add: (dart 
		var: (names metamixinClassNameFor: cmm name), '_body' 
		value: (dart literal: (
			String streamContents: [:stm | metamembers do: [:member | 
				dartWriter generateSourceFor: member on: stm. stm cr]]))).
	
	rep last do: [:each | results addAll: (translateMixinRepForBodySources: each)].
	
	^results
)'entry'
public compileClassSource: source <ReadStream> within: enclosing <MixinMirror> ^<MixinRep> = (
	|
	tree <AST>
	mixinRep <MixinRep>
	|
	tree:: parser classDefinition parse: source.
	setInput: source.
	setScopeFor: tree in: enclosing.
	mixinRep:: classNode: tree.
	scopeMap:: Dictionary new.
	^enclosing isNil ifTrue:[mixinRep] ifFalse:[{enclosing. mixinRep}].
)'factories'
initializerFor: node <ClassHeaderAST> ^<MethodAST> = (
	|
	stmts  <Collection[StatementAST]>
	start <Integer> = node superConstructorCall start.
	end <Integer> = node superConstructorCall end.
	initHdr <MessagePatternAST>
	body <CodeBodyAST> 
	copier <ASTCopier> = ASTCopier new.
	params <List[VarDeclAST]>
	|
	
	params:: node constructor parameters collect: [:formal | formal apply: copier].
	initHdr:: MessagePatternAST new 
		selector: (initializerSelectorNameFor: node constructor selector)
		parameters: params;
		start: start; end: end. 
	"set up scope with constructor parameters"
	stmts:: node slots collect: [:slot <SlotDefAST> | | aMsg <MessageAST> |
		aMsg:: MessageAST new
			send: (setterSelectorFor: slot) asSymbol
			with: {slot initializer apply: copier};
			start: slot start; end: slot end.
		NormalSendAST new msg: aMsg; 
			recv: (selfNode start: aMsg start; end: aMsg end);
			start: aMsg start; end: aMsg end.			
	].

	stmts addAll: (node initExprs collect:[:ie | ie apply: copier]).
	stmts addFirst: (superConstructorCallFor: node). "add superclass init call as first statement"
	
	body:: CodeBodyAST new
		temporaries: OrderedCollection new
		statements: stmts; 
		start: start; end: end.

	^MethodAST new 
		pattern: initHdr
		body: body
		visibility: #public; 
		start: start; end: end.
)
initializerSelectorNameFor: selector <Symbol> ^<Symbol> = (
	^'initializer`', selector
)
processFactoryFor: node <ClassAST> in: mixinMirror <LowLevelMixinMirror> = (
	| accessor <MethdMirror> argNames ast initializerName basicNew |
	accessor:: MethodMirror named: node hdr constructor selector.
	argNames:: (node hdr constructor parameters collect: [:each | translator mangleVarName: each name]) asArray.
	initializerName:: initializerSelectorNameFor: node hdr constructor selector.
	
	"basicNew:: dart 
					new: (dart ident: (names mixinClassNameFor: node hdr name)) 
					with: {dart ident: 'this'}."
	basicNew:: dart on: (dart ident: 'this') invoke: (dart ident: 'basicNew_') with: {}.
	
	ast:: dart
		method: (names mangleSelector: node hdr constructor selector)
		params: argNames
		body: (dart block: {
			dart return: (dart
				on: basicNew
				invoke: (dart ident: (names mangleSelector: initializerName))
				with: (argNames collect: [:each | dart ident: each]))
		}).
	accessor method: ast.
	mixinMirror methods addMirror: accessor.
)
superConstructorCallFor: node <ClassHeaderAST> ^<NormalSendAST> = (
	"create call to super constructor method"
	| 
	var <VariableAST>
	start <Integer> = node superConstructorCall start.
	end <Integer> = node superConstructorCall end.
	copier <ASTCopier> = ASTCopier new.
	superMsg <MessageAST>
	args <List[VariableAST]> 
	|
	
	var:: VariableAST new name: #self; start: start; end: end.
	args:: node constructor parameters collect:
		[:p <VarDeclAST> | hereSendFrom: p].
	superMsg::  MessageAST new 
		send: (superConstructorNameFor: node) with: args; 
		start: start; end: end.
	^NormalSendAST new to: var send: superMsg; start: start; end: end
)
superConstructorMethodFor: node <ClassHeaderAST> ^<MethodAST> = (
	| 
	start <Integer> = node superConstructorCall start.
	end <Integer> = node superConstructorCall end.
	stmts <List[StmtAST]> 
	var  <VariableAST> 
	initHdr <MessagePatternAST>
	superMsg <MessageAST> 
	send <NormalSendAST>
	body  <CodeBodyAST>
	copier <ASTCopier> = ASTCopier new.
	params <List[VarDeclAST]>
	args <List>
	|

	params:: node constructor parameters collect: [:formal | formal apply: copier].
	initHdr:: MessagePatternAST new
		selector: (superConstructorNameFor: node)
		parameters: params;
		start: start; end: end. 
	"set up scope with constructor parameters"
	
	"create call to superclass initializer"
	stmts:: OrderedCollection new. 
	var:: VariableAST new name: #super; start: start; end: end.
	args:: node superConstructorCall args collect: [:actual | actual apply: copier].
	superMsg:: MessageAST new
		send: (initializerSelectorNameFor: node superConstructorCall sel)
		with: args; 
		start: start; end: end. 

	"only copy actual args"
	"send these as a tuple? to super instance initializer?"
	send:: NormalSendAST new 
		to: var
		send: superMsg; 
		start: start; end: end. 
	stmts addFirst: send.
	body:: CodeBodyAST new
		temporaries: OrderedCollection new
		statements: stmts;
		start: start; end: end.
		
	^MethodAST new
		pattern: initHdr
		body: body
		visibility: #private;
  		start: start; end: end	
)
superConstructorNameFor: node <ClassHeaderAST> ^<Symbol> = (
	#FLAG. "Needs full qualification"
	^'superInit`' , node name, '`', node constructor selector
)'scopes'
currentScope ^<Scope> = (
	^scopeStack last
)
nestScope: scope <Scope> = (
	"Hook up a new lexically nested scope, and push onto the scope stack"
	scope superScope: currentScope.
	pushScope: scope
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
pushScope: scope <Scope> = (
	scopeStack addLast: scope
)
setScopeFor: node <AST> in: enclosing <MixinMirror | nil> = (
	| scopeBuilder |
	pushScope: Scope new.
	enclosing notNil ifTrue: [nestScope:: ScopeBuilder new buildScopeFor: enclosing].
	currentDepth:: currentScope depth - 1.
	scopeBuilder:: ScopeBuilder nestedIn: currentScope atLevel: currentDepth.
	node apply: scopeBuilder
)'top-processing'
checkForDuplicateNames: node <ClassDeclarationAST> = (

	| namesWithDuplicates names duplicateNames |
	
	namesWithDuplicates:: OrderedCollection new.
	node instanceSide categories do: [:cat |
		cat methods do: [:each | namesWithDuplicates add: each selector]].
	
	node hdr slots do: [:each |
		namesWithDuplicates add: each name.
		each isMutable ifTrue: [namesWithDuplicates add: each name, ':']].
	
	namesWithDuplicates
		addAll: (node instanceSide nestedClasses collect: [:each | each name]).

	names:: Set new.
	duplicateNames:: Set new.
	namesWithDuplicates do: [:each | | present |
		present:: true.
		names include: each ifNew: [present:: false].
		present ifTrue: [duplicateNames add: each]].
	
	duplicateNames isEmpty ifFalse: [ | message |
		message:: String streamContents: [:s |
			s
				nextPutAll: 'Class ';
				nextPutAll: node name;
				nextPutAll: '" has multiple definitions for '.
			duplicateNames
				do: [:each | s nextPutAll: each asString]
				separatedBy: [ s nextPutAll: ','].
			s nextPutAll: '.'.].
		assert: false message: message].
)
classNode: node <ClassDeclarationAST> ^<MixinRep> = (
	|
	mixinMirror <LowLevelMixinMirror>
	nestedClasses <Collection[MixinRep]>
	
	|
	assert: [node hdr category notNil] message: 'No category for class header'.
	checkForDuplicateNames: node.
	mixinMirror:: computeMixinFrom: node.

	currentDepth::currentDepth + 1.
	generateSlotAccessorsFor: mixinMirror lowLevelMirror. "Called before handling nested classes because we don't need the accessors for their synthetic slots."
	nestedClasses:: processInstanceSideOf: node ofMixin: mixinMirror lowLevelMirror.
	
	processClassSideOf: node ofMixin: mixinMirror lowLevelMirror classMixin.
	currentDepth::currentDepth - 1.

	^{mixinMirror. nestedClasses}
)
compileNestedClasses: nestedClasses <Collection[ClassDeclarationAST]> within: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	| results <OrderedCollection[MixinRep]> |
      results:: OrderedCollection new.
	nestedClasses do:
		[ :nc <ClassDeclarationAST> |  
			| nClassName <String> nSlot <InstanceVariableMirror> |
		nc hdr category: mixinMirror category, '-nested'.
		
		nClassName:: names fullyQualifySimpleName: nc name 
		                   with: mixinMirror name.
		nSlot:: InstanceVariableMirror named: nClassName mutable: true.
		nSlot field: (dart var: (names mangleSlotName: nClassName)).
		nSlot metadata at: #isSynthetic put: true.
		mixinMirror instVars addMirror: nSlot.
		results add: (classNode: (nestedMixinWrapperFor: nc in: mixinMirror)).
		
		currentMixinClassName:: names mixinClassNameFor: mixinMirror name. "Re-establish context for nested accessors, since they are in the scope of the enclosing class's instance side not the nested class."
		createNestedClassAccessorFrom: nc within: mixinMirror
		].
	^results
)
compileNestedClassesOf: aNode <SideAST> within: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	"where do we check that nested classes do not conflict with each other, or with methods or slots?"
	^compileNestedClasses: aNode nestedClasses within: mixinMirror
)
computeMethod: aNode <MethodAST> inScope: s <Scope> = (
	|  scopeBuilder <ScopeBuilder>  |
	scopeBuilder:: ScopeBuilder nestedIn: s atLevel: currentDepth.
	aNode apply: scopeBuilder.
	"need to build scope for method before visiting it"
	^methodNode: aNode.
)
computeMixinFrom: node <ClassDeclarationAST> ^<CompiledMixinMirror> = (
	| 
	hdr = node hdr.
	mixinMirror = LowLevelMixinMirror named: hdr name isMeta: false.
	|
	
	mixinMirror superclassName: (resolveSuperclassOf: node).
	
	hdr slots do: [:slot |
		mixinMirror instVars addMirror: (slot apply: self)].
	
	^(CompiledMixinMirror 
		language: language
		header: (sourceForNode: hdr)
		mirror: mixinMirror)
		factoryName: hdr constructor selector;
		category: hdr category;
		comment: (hdr classComment isNil 
			ifTrue: [''] 
			ifFalse: [hdr classComment])
)
generateSlotAccessorsFor: m <MixinMirror>  = (
	"We need accessor METHODS so we can call them uniformly. Dart's special getters and setters won't do."
	m instVars do: [:iv <InstanceVariableMirror> | 
		|
		getterName <String>
		setterName <String>
		ivName <String>
		getter <MethodMirror>
		getterDart <Node>
		setter <MethodMirror>
		setterDart <Node>
		|
		getterName:: names mangleSelector: iv name.
		setterName:: names mangleSelector: (setterSelectorFor: iv).
		ivName:: names mangleSlotName: iv name.
		
		getter:: MethodMirror named: getterName.
		getterDart:: dart method: getterName params: {} body: (dart block: {
			dart return: (dart memberOf: (dart ident: 'this') at: ivName)
			}).
		getter method: getterDart.	
		getter isAccessor: true.
		m methods addMirror:  getter.
		
		setter:: MethodMirror named: setterName.
		setterDart:: dart method: setterName params: {'v'} body: (dart block: {
			(dart assign: (dart memberOf: (dart ident: 'this') at: ivName)
				toBe: (dart ident: 'v')).
			dart return: (dart ident: 'this')
			}).
		setter method: setterDart.
		setter isAccessor: true.
		m methods addMirror:  setter.
	]
)
methodNode: aNode <MethodAST> ^ <MethodMirror> = (
	| tree <AST> dartTree |
	tree:: aNode apply: rewriter.  "rewrite ast"
	translator beginNewTranslationCycle.
	dartTree:: tree apply: translator.	 "final pass: visit rewritten ast"
	"pop scope?"
	^(MethodMirror named: translator currentSelector)
		method: dartTree;
		src: (sourceForNode: aNode);
		yourself
)
processClassSideOf: aNode <ClassAST> ofMixin: mixinMirror <LowLevelMixinMirror> = (
	currentMixinClassName:: names metamixinClassNameFor: aNode name.
	processFactoryFor: aNode in: mixinMirror.
	processSide: aNode classSide ofMixin: mixinMirror. "compile class methods"
)
processInitializerFor: aNode <ClassAST> in: mixinMirror <LowLevelMixinMirror> = (
	processMethod: (superConstructorMethodFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinMirror. 
	processMethod: (initializerFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinMirror.
)
processInstanceSideOf: aNode <ClassAST> ofMixin: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	| side <SideAST> |
	currentMixinClassName:: names mixinClassNameFor: aNode name.
	processInitializerFor: aNode in: mixinMirror.
	side:: aNode instanceSide.
	processSide: side ofMixin: mixinMirror. "compile instance methods"
	^compileNestedClassesOf: side within: mixinMirror. "gather nested classes"
)
processMethod: aNode <MethodAST> inScope: s <Scope>  in: mixinMirror <LowLevelMixinMirror> = (
	|  method <MethodMirror> |
	method:: computeMethod: aNode inScope: s.
	method isSynthetic: true.
	mixinMirror methods addMirror: method.
	"install method"	
)
processSide: side <SideAST> ofMixin: mixinMirror <LowLevelMixinMirror> = (
	side categories do:
		[:cat |
		| mirror <MethodMirror> |
		cat methods do: [:m | 
			"who checks that the methods do not conflict with each other or with another slot or class in the same enclosing class? The mirror or the compiler?"
			mirror:: methodNode: m.
			mirror metadata at: #category put: cat.
			mixinMirror methods addMirror: mirror]].
)
slotDefNode: node <SlotDefAST> = (
	
	^(InstanceVariableMirror 
		named: node name
		mutable: node isMutableSlot)
		field: (dart var: (names mangleSlotName: node name));
		src: (sourceForNode: node)
)'top-processing2'
outputMainForReps: reps to: stream = (

	| statements = OrderedCollection new. ast |
	reps do: [:rep <MixinRep> | | cmm = rep first. |
		statements add: (dart 
			assign: (dart ident: (mangleSelector: cmm name),'_global')
			toBe: (dart
				new: (dart ident: (mangleSelector: cmm name), '_class_mixin')
				with: {dart ident: 'null'}))].
			
	#FLAG. #REFACTORING.
	statements add: (dart 
		assign: (dart ident: 'true_')
		toBe: ((dart 
			new: (dart ident: (mangleSelector: 'True'), '_mixin') 
			with: {dart ident: 'True_global'}))).
	statements add: (dart 
		assign: (dart ident: 'false_')
		toBe: ((dart 
			new: (dart ident: (mangleSelector: 'False'), '_mixin') 
			with: {dart ident: 'False_global'}))).
	statements add: (dart 
		assign: (dart ident: 'nil_')
		toBe: ((dart 
			new: (dart ident: (mangleSelector: 'UndefinedObject'), '_mixin') 
			with: {dart ident: 'UndefinedObject_global'}))).
		
	statements add: (dart
		invoke: (dart ident: 'print')
		with: {dart 
			on: (dart ident: 'Test_global')
			invoke: (dart ident: 'main')
			with: {}}).
	
	ast:: dart method: 'main' params: {} body: (dart block: statements).

	dartWriter generateSourceFor: (dart var: 'true_') on: stream.
	dartWriter generateSourceFor: (dart var: 'false_') on: stream.
	dartWriter generateSourceFor: (dart var: 'nil_') on: stream.	

	dartWriter generateSourceFor: ast on: stream
)
outputTopLevelClass: rep <MixinRep> to: stream <WriteStream> = (
	| asts |
	asts:: translateMixinRep: rep. 
	asts do: [:ast | dartWriter generateSourceFor: ast on: stream. stream cr].
	^stream
)
translateMixinRep: rep <MixinRep> ^<List[Node]> = (
	| 
	results <Node> = OrderedCollection new.
	cmm <CompiledMixinMirror> = rep first.
	llmm <LowLevelMixinMirror> = cmm lowLevelMirror.
	basicNew dartName protoDartName protoMetaDartName getEnclosingObjects
	|
	#FLAG. #REFACTORING.
		
	results add: (dart 
		class: (names mixinClassNameFor: cmm name)
		extends: (names mixinClassNameFor: llmm superclassName)
		fields: (llmm instVars collect: [:ea | ea field]) asArray, 
			{dart verbatim: 'static var ', (names enclosingObjectsArrayFor: cmm name meta: false),';'}
		constructors: {dart verbatim: (names mixinClassNameFor: cmm name),'(c):super(c);'}
		methods: (llmm methods collect: [:ea | ea method])).
	
	basicNew:: dart method: 'basicNew_' params: {} body: (
		dart return: (dart
			new: (dart ident: (names mixinClassNameFor: cmm name)) 
			with: {dart ident: 'this'})) asBlock.
			
	dartName:: dart method: 'dartname_' params: {} body: (
		dart return: (dart literal: (names mixinClassNameFor: cmm name))) asBlock.
	protoDartName:: dart method: 'protodartname_' params: {} body: (
		dart return: (dart literal: (names mixinClassNameFor: cmm name))) asBlock.
	protoMetaDartName:: dart method: 'protometadartname_' params: {} body: (
		dart return: (dart literal: (names metamixinClassNameFor: cmm name))) asBlock.
		
	getEnclosingObjects:: dart method: 'enclosingObjects_' params: {} body: (
		dart return: (dart ident: (names metamixinClassNameFor: cmm name),'_enclosingObjects')) asBlock.
			
	results add: (dart
		class: (names metamixinClassNameFor: cmm name)
		extends: (names mixinClassNameFor: ('KernelForDart`Class'))
		fields: {dart verbatim: 'static var ', (names enclosingObjectsArrayFor: cmm name meta: true),';'}
		constructors: {dart verbatim: (names metamixinClassNameFor: cmm name),'(c):super(c);'}
		methods: (llmm classMixin methods collect: [:ea | ea method]) asArray,{basicNew. dartName. protoDartName. protoMetaDartName. getEnclosingObjects}).
	
	rep last do: [:each | results addAll: (translateMixinRep: each)].
	
	^results
)) : ()
class Infrastructure withAppSources: appSources withRuntimeSources: runtimeSources outputTo: stream = (
"Responsible for the top-level wiring of a NS2Dart program. Takes a set of application module sources and runtime module sources. For runtime modules, sends to vmmirror are treated as compiler intrinsics. The first application module is treated as the application definition, and the first runtime module is treated as the runtime definition. A mock namespace object is created with each of the modules as an entry. The namespace assumes all imports are immediate (unlike BlackMarket, where some imports are indirect through a package, and unlike the eventual proper IDE namespace that supports nested namespaces). It also assumes the keys for module definitions are their names. The constructed Dart program starts up with 

runtime:: RuntimeDefinition packageUsing: namespace.
platform:: runtime using: nil.
application:: ApplicationDefinition packageUsing: namespace.
application main: platform args: {}.
"|
	compiler = Compiler new.

	appModuleReps = compileModules: appSources enableIntrinsics: false.
	runtimeModuleReps = compileModules: runtimeSources enableIntrinsics: true.

	names = compiler names.
	writer = DartWriter new.
|topLevelMembers do: [:ast | writer generateSourceFor: ast on: stream. stream cr])
('as yet unclassified'
dynamicMixinHelpers ^<List[Node]> = (
	^{
	dart verbatim: 
'
#import("dart-ext:sample_extension");
INSTALL_NEW_SOURCE(string src) native "LoadSomeSource";
INSTANITATE_CLASS_ONE_ARG(string classname, arg) native "Instantiate1";
SET_STATIC(string classname, string fieldname, fieldvalue) native "SetStatic";
GET_STATIC(string classname, string fieldname) native "GetStatic";
GET_GLOBAL(string fieldname) native "GetGlobal";
INVOKE(receiver, selector, arguments) native "Invoke";

var uniqueSuffix = 1;

mixinapply2( mixinclass, superclass )
{

	return mixinapply(
		mixinclass.protodartname_(),
		GET_GLOBAL("${mixinclass.protodartname_()}_body"),
		mixinclass.protometadartname_(),
		GET_GLOBAL("${mixinclass.protometadartname_()}_body"),
		superclass,
		mixinclass.name().comma_(superclass.name()), //could do better 
		mixinclass.enclosingObjects_()
	);
}

mixinapply( 
  protomixinclassname,
  mixinbody,
  protometamixinclassname,
  metamixinbody,
  superclass,
  applicationName, 
  enclosingObjects )
{
	var supermixinclassname = superclass.dartname_();
	var mixinclassname = "${protomixinclassname}${uniqueSuffix}";
	var metamixinclassname = "${protometamixinclassname}${uniqueSuffix}";
	uniqueSuffix++;

	var constructor = "${mixinclassname}(c):super(c);";
	var metaconstructor = "${metamixinclassname}(c):super(c);";
	var basicnew = "basicNew_() { return new ${mixinclassname}(this); }";
	var dartclassname = "dartname_() { return ''${mixinclassname}''; }";
	var protodartclassname = "protodartname_() { return ''${protomixinclassname}''; }";
	var protometadartclassname = "protometadartname_() { return ''${protometamixinclassname}''; }";
	var getenclosingobjects = "enclosingObjects_() { return ${protometamixinclassname}_enclosingObjects; }";	

	var newsource = 
	"class ${mixinclassname} extends ${supermixinclassname} \n "
	" { ${mixinbody} ${constructor} } \n"
	"class ${metamixinclassname} extends KernelForDart_Class_mixin \n"
	" { ${metamixinbody} ${metaconstructor} ${basicnew} \n"
	" ${dartclassname} ${protodartclassname} ${protometadartclassname} \n"
	" ${getenclosingobjects} } \n";
	
	INSTALL_NEW_SOURCE(newsource);

	var metaclass = Metaclass_global.new_();
	var klass = INSTANITATE_CLASS_ONE_ARG ( metamixinclassname, metaclass );

	klass.superclass__(superclass);
	klass.enclosingObject__( enclosingObjects[0] );
	klass.name__(applicationName);
	metaclass.superclass__(Class_global);
	metaclass.enclosingObject__( enclosingObjects[0] );
	metaclass.thisClass__(klass);

	SET_STATIC( mixinclassname, "${protomixinclassname}_enclosingObjects", enclosingObjects );
	SET_STATIC( metamixinclassname, "${protometamixinclassname}_enclosingObjects", enclosingObjects );

	return klass;
}
'
	}
)
mixinSources = (
	| asts = OrderedCollection new. |
	
	appModuleReps, runtimeModuleReps
		do: [:rep | asts addAll: (compiler translateMixinRepForBodySources: rep)].
	
	^asts
)'private'
accessorsForTopLevelClasses = (

	#REFACTORING. "Commonality with nested class accessors"

	^appModuleReps, runtimeModuleReps collect: [:rep |
		|
		name = rep first name.
		slotName = names mangleSlotName: name.
		metamixin = dart ident: (names metamixinClassNameFor: name).
		mixin = dart ident: (names metamixinClassNameFor: name).
		
		childEOA = dart
			memberOf: (dart ident: (names mixinClassNameFor: name))
			at: (names enclosingObjectsArrayFor: name meta: false).
		metachildEOA = dart
			memberOf: (dart ident: (names metamixinClassNameFor: name))
			at: (names enclosingObjectsArrayFor: name meta: true).
		|
	
dart method: (dart ident: (names mangleSelector: name)) params: {} body: (dart block: {dart
		if: (dart 
			operator: '==='
			with: (dart ident: slotName)
			and: (dart ident: 'null'))
		then: (dart block: {
			dart 
				var: (dart ident: 'superclass') 
				value: (dart ident: names Object).
			dart 
				var: (dart ident: 'metaclass') 
				value: (dart 
					on: (dart ident: 'Metaclass_global') 
					invoke: (dart ident: (names mangleSelector: 'new'))
					with: {}).
			dart 
				var: (dart ident: 'klass')
				value: (dart new: metamixin with: {dart ident: 'metaclass'}).
				
			dart 
				on: (dart ident: 'klass')
				invoke: (dart ident: (names mangleSelector: 'superclass:'))
				with: {dart ident: 'superclass'}.
			dart 
				on: (dart ident: 'klass')
				invoke: (dart ident: (names mangleSelector: 'enclosingObject:'))
				with: {dart ident: names nil}.
			dart 
				on: (dart ident: 'klass')
				invoke: (dart ident: (names mangleSelector: 'name:'))
				with: {(SymbolAST new val: name) apply: compiler translator}.
				
			dart 
				on: (dart ident: 'metaclass')
				invoke: (dart ident: (names mangleSelector: 'superclass:'))
				with: {dart ident: 'Class_global'}.
			dart 
				on: (dart ident: 'metaclass')
				invoke: (dart ident: (names mangleSelector: 'enclosingObject:'))
				with: {dart ident: names nil}.
			dart 
				on: (dart ident: 'metaclass')
				invoke: (dart ident: (names mangleSelector: 'thisClass:'))
				with: {dart ident: 'klass'}.
				
			dart 
				assign: childEOA 
				toBe: (dart list: {}).
			dart 
				assign: metachildEOA 
				toBe: (dart list: {}).
							
			dart
				assign: (dart ident: slotName)
				toBe: (dart ident: 'klass').
			}).
			
			dart return: (dart ident: slotName).
	})
	]
)
compileModules: modules <List[String]> enableIntrinsics: flag <Boolean> ^<List[MixinRep]> = (
	"Strictly speaking, these are module definitions not module (instances)."
	
	| results |
	(flag and: [modules = lastRuntimeSources]) ifTrue: [^lastRuntimeReps].
	
	compiler enableIntrinsics: flag.
	results:: modules collect: [:module <String> |
		compiler compileClassSource: module readStream within: nil].
	
	flag ifTrue: [lastRuntimeReps:: results. lastRuntimeSources:: modules].
	^results
)
fieldsForTopLevelClasses = (
	^appModuleReps, runtimeModuleReps collect: [:rep |
		dart var: (names mangleSlotName: rep first name)
	]
)
globals ^<List[Node]> = (
	^{
	dart var: names true.
	dart var: names false.
	dart var: names nil.
	
	dart var: names Object.
	dart var: names Class.
	dart var: names Metaclass.
	
	dart var: names String.
	dart var: names Number.
	dart var: names Block.
	dart var: names Array.
	
	dart var: names Message.
	
	dart var: 'lastHash_' value: (dart literal: 1984).
	
	dart var: 'platform_global'.
	}
)
mainFunction = (

	|
	appDefnName = appModuleReps first first name.
	runtimeDefnName = runtimeModuleReps first first name.
	|

	#REFACTORING. #FLAG. "This is brittle: it duplicates decisions about naming"

	^dart verbatim: 
'main(){
	var ns = new Namespace_();
	var runtime = ns.',runtimeDefnName,'().packageUsing__(ns);
	platform_global = runtime.using__(nil_);
	var app = ns.',appDefnName,'().packageUsing__(ns);
	app.main__args__(platform_global, Array_global.wrapping__([]));
}'
)
mixinClasses = (
	| asts = OrderedCollection new. |
	
	appModuleReps, runtimeModuleReps
		do: [:rep | asts addAll: (compiler translateMixinRep: rep)].
	
	^asts
)
namespaceClass ^<Node> = (
	^dart
		class: 'Namespace_'
		extends: 'Object'
		fields: fieldsForTopLevelClasses
		constructors: {namespaceConstructor}
		methods: accessorsForTopLevelClasses
)
namespaceConstructor ^<Node> = (

	#REFACTORING. #FLAG. "This is brittle"

	"Create class objects. Create metaclass objects. Link classes and metaclasses. Extract true/false/nil."

^dart verbatim: '

Namespace_(){
	var Kernel = new KernelForDart_metamixin(null);
	var kernel = Kernel.new_();
	
	KernelForDart_slot = Kernel;
	
	//class, superclass, enclosingObject, name/thisClass

	kernel.KernelForDart_Metaclass_slot = new KernelForDart_Metaclass_metamixin(null);
	kernel.KernelForDart_False_slot = new KernelForDart_False_metamixin(null);
	kernel.KernelForDart_Boolean_slot = new KernelForDart_Boolean_metamixin(null);
	//kernel.KernelForDart_Error_slot = new KernelForDart_Error_metamixin(null);
	kernel.KernelForDart_Block_slot = new KernelForDart_Block_metamixin(null);
	kernel.KernelForDart_Number_slot = new KernelForDart_Number_metamixin(null);
	kernel.KernelForDart_Array_slot = new KernelForDart_Array_metamixin(null);
	kernel.KernelForDart_UndefinedObject_slot = new KernelForDart_UndefinedObject_metamixin(null);
	kernel.KernelForDart_Object_slot = new KernelForDart_Object_metamixin(null);
	kernel.KernelForDart_Behavior_slot = new KernelForDart_Behavior_metamixin(null);
	//kernel.KernelForDart_MessageNotUnderstood_slot = new KernelForDart_MessageNotUnderstood_metamixin(null);
	kernel.KernelForDart_String_slot = new KernelForDart_String_metamixin(null);
	kernel.KernelForDart_Class_slot = new KernelForDart_Class_metamixin(null);
	kernel.KernelForDart_True_slot = new KernelForDart_True_metamixin(null);
	kernel.KernelForDart_Message_slot = new KernelForDart_Message_metamixin(null);

	true_ = new KernelForDart_True_mixin(kernel.KernelForDart_True_slot);
	false_ = new KernelForDart_False_mixin(kernel.KernelForDart_False_slot);
	nil_ = new KernelForDart_UndefinedObject_mixin(kernel.KernelForDart_UndefinedObject_slot);

	KernelForDart_mixin.KernelForDart_mixin_enclosingObjects = [];
	KernelForDart_metamixin.KernelForDart_metamixin_enclosingObjects = [];

	kernel.KernelForDart_Object_slot.superclass_slot = nil_;
	kernel.KernelForDart_Object_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Object");
	kernel.KernelForDart_Object_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Object_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Object_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Object_slot.klass_.thisClass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Object_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_Object_mixin.KernelForDart_Object_mixin_enclosingObjects = [kernel];
	KernelForDart_Object_metamixin.KernelForDart_Object_metamixin_enclosingObjects = [kernel];

	kernel.KernelForDart_Metaclass_slot.superclass_slot = kernel.KernelForDart_Behavior_slot;
	kernel.KernelForDart_Metaclass_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Metaclass");
	kernel.KernelForDart_Metaclass_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Metaclass_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Metaclass_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Metaclass_slot.klass_.thisClass_slot = kernel.KernelForDart_Metaclass_slot;
	kernel.KernelForDart_Metaclass_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_Metaclass_mixin.KernelForDart_Metaclass_mixin_enclosingObjects = [kernel];
	KernelForDart_Metaclass_metamixin.KernelForDart_Metaclass_metamixin_enclosingObjects = [kernel];

	kernel.KernelForDart_False_slot.superclass_slot = kernel.KernelForDart_Boolean_slot;
	kernel.KernelForDart_False_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("False");
	kernel.KernelForDart_False_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_False_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_False_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_False_slot.klass_.thisClass_slot = kernel.KernelForDart_False_slot;
	kernel.KernelForDart_False_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_False_mixin.KernelForDart_False_mixin_enclosingObjects = [kernel];
	KernelForDart_False_metamixin.KernelForDart_False_metamixin_enclosingObjects = [kernel];

	kernel.KernelForDart_Boolean_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Boolean_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Boolean");
	kernel.KernelForDart_Boolean_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Boolean_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Boolean_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Boolean_slot.klass_.thisClass_slot = kernel.KernelForDart_Boolean_slot;
	kernel.KernelForDart_Boolean_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_Boolean_mixin.KernelForDart_Boolean_mixin_enclosingObjects = [kernel];
	KernelForDart_Boolean_metamixin.KernelForDart_Boolean_metamixin_enclosingObjects = [kernel];

	kernel.KernelForDart_Block_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Block_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Block");
	kernel.KernelForDart_Block_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Block_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Block_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Block_slot.klass_.thisClass_slot = kernel.KernelForDart_Block_slot;
	kernel.KernelForDart_Block_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_Block_mixin.KernelForDart_Block_mixin_enclosingObjects = [kernel];
	KernelForDart_Block_metamixin.KernelForDart_Block_metamixin_enclosingObjects = [kernel];
	
	kernel.KernelForDart_Number_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Number_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Number");
	kernel.KernelForDart_Number_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Number_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Number_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Number_slot.klass_.thisClass_slot = kernel.KernelForDart_Number_slot;
	kernel.KernelForDart_Number_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_Number_mixin.KernelForDart_Number_mixin_enclosingObjects = [kernel];
	KernelForDart_Number_metamixin.KernelForDart_Number_metamixin_enclosingObjects = [kernel];
	
	kernel.KernelForDart_Array_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Array_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Array");
	kernel.KernelForDart_Array_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Array_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Array_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Array_slot.klass_.thisClass_slot = kernel.KernelForDart_Array_slot;
	kernel.KernelForDart_Array_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_Array_mixin.KernelForDart_Array_mixin_enclosingObjects = [kernel];
	KernelForDart_Array_metamixin.KernelForDart_Array_metamixin_enclosingObjects = [kernel];

	kernel.KernelForDart_UndefinedObject_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_UndefinedObject_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("UndefinedObject");
	kernel.KernelForDart_UndefinedObject_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_UndefinedObject_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_UndefinedObject_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_UndefinedObject_slot.klass_.thisClass_slot = kernel.KernelForDart_UndefinedObject_slot;
	kernel.KernelForDart_UndefinedObject_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_UndefinedObject_mixin.KernelForDart_UndefinedObject_mixin_enclosingObjects = [kernel];
	KernelForDart_UndefinedObject_metamixin.KernelForDart_UndefinedObject_metamixin_enclosingObjects = [kernel];
	
	kernel.KernelForDart_Behavior_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Behavior_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Behavior");
	kernel.KernelForDart_Behavior_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Behavior_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Behavior_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Behavior_slot.klass_.thisClass_slot = kernel.KernelForDart_Behavior_slot;
	kernel.KernelForDart_Behavior_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_Behavior_mixin.KernelForDart_Behavior_mixin_enclosingObjects = [kernel];
	KernelForDart_Behavior_metamixin.KernelForDart_Behavior_metamixin_enclosingObjects = [kernel];
	
	kernel.KernelForDart_String_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_String_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("String");
	kernel.KernelForDart_String_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_String_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_String_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_String_slot.klass_.thisClass_slot = kernel.KernelForDart_String_slot;
	kernel.KernelForDart_String_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_String_mixin.KernelForDart_String_mixin_enclosingObjects = [kernel];
	KernelForDart_String_metamixin.KernelForDart_String_metamixin_enclosingObjects = [kernel];

	kernel.KernelForDart_Class_slot.superclass_slot = kernel.KernelForDart_Behavior_slot;
	kernel.KernelForDart_Class_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Class");
	kernel.KernelForDart_Class_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Class_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Class_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Class_slot.klass_.thisClass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Class_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_Class_mixin.KernelForDart_Class_mixin_enclosingObjects = [kernel];
	KernelForDart_Class_metamixin.KernelForDart_Class_metamixin_enclosingObjects = [kernel];
	
	kernel.KernelForDart_True_slot.superclass_slot = kernel.KernelForDart_Boolean_slot;
	kernel.KernelForDart_True_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("True");
	kernel.KernelForDart_True_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_True_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_True_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_True_slot.klass_.thisClass_slot = kernel.KernelForDart_True_slot;
	kernel.KernelForDart_True_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_True_mixin.KernelForDart_True_mixin_enclosingObjects = [kernel];
	KernelForDart_True_metamixin.KernelForDart_True_metamixin_enclosingObjects = [kernel];
	
	kernel.KernelForDart_Message_slot.superclass_slot = kernel.KernelForDart_Object_slot;
	kernel.KernelForDart_Message_slot.name_slot = kernel.KernelForDart_String_slot.wrapping__("Message");
	kernel.KernelForDart_Message_slot.enclosingObject_slot = kernel;
	kernel.KernelForDart_Message_slot.klass_ = kernel.KernelForDart_Metaclass_slot.new_();
	kernel.KernelForDart_Message_slot.klass_.superclass_slot = kernel.KernelForDart_Class_slot;
	kernel.KernelForDart_Message_slot.klass_.thisClass_slot = kernel.KernelForDart_Message_slot;
	kernel.KernelForDart_Message_slot.klass_.enclosingObject_slot = kernel;
	KernelForDart_Message_mixin.KernelForDart_Message_mixin_enclosingObjects = [kernel];
	KernelForDart_Message_metamixin.KernelForDart_Message_metamixin_enclosingObjects = [kernel];
	
	//Used by mixin application. Replacement with here sends questionable.
	Object_global = kernel.KernelForDart_Object_slot;
	Class_global = kernel.KernelForDart_Class_slot;
	Metaclass_global = kernel.KernelForDart_Metaclass_slot;

	//Used by literal re-writes. In principle replaceable with here sends.
	String_global = kernel.KernelForDart_String_slot;
	Number_global = kernel.KernelForDart_Number_slot;
	Block_global = kernel.KernelForDart_Block_slot;
	Array_global = kernel.KernelForDart_Array_slot;

	//Needed by Top noSuchMethod
	Message_global = kernel.KernelForDart_Message_slot;
}
'
)
nlrClass ^<Node> = (
	"Instances of this class are thrown as the exceptions used to implement non-local returns."
	^dart 
		class: names NLR
		extends: 'Object'
		fields: {dart var: 'value'}
		constructors: {}
		methods: {}
)
seqexpHelpers ^<List[Node]> = (
	^{
	dart verbatim: 
'seqexp_timesRepeat(n, block){
	if(block is Function) for(var i=1; i<=n; i++) block();
	else for(var i=1; i<=n; i++) block.value();
	return n;
}'.

	dart verbatim: 
'seqexp_to(start, stop){
	return platform_global.collections().Interval().from__to__(start,stop);
}'.

	dart verbatim: 
'seqexp_toDo(start, stop, block){
	if(block is Function) for(var i=start; i<=stop; i++) block(i);
	else for(var i=start; i<=stop; i++) block.value__(i);
	return nil_;
}'.

	dart verbatim: 
'seqexp_overOver(rcvr, arg){
	//from VMMaker by way of Primordial Soup
	var posArg, posRcvr, result;
	if(rcvr > 0)
	{
		if(arg > 0) result = rcvr ~/ arg;
		else {
			posArg = 0 - arg;
			result = 0 - ((rcvr + (posArg - 1)) ~/ posArg);
		 }
	}else{
		posRcvr = 0 - rcvr;
		if( arg > 0 ) result = 0 - ((posRcvr + (arg - 1)) ~/ arg);
		else{
			posArg = 0 - arg;
			result = posRcvr ~/ posArg;
		}
	}
	return result;
}'.

	dart verbatim: 
'seqexp_backBack(rcvr, arg){
	return rcvr - (seqexp_overOver(rcvr, arg) * arg);
}'.

	dart verbatim: 
'seqexp_rem(rcvr, arg){
	return rcvr - ((rcvr ~/ arg) * arg);
}'.


	dart verbatim: 
'seqexp_max(rcvr, arg){
	return rcvr > arg ? rcvr : arg;
}'.

	dart verbatim: 
'seqexp_min(rcvr, arg){
	return rcvr < arg ? rcvr : arg;
}'.

	dart verbatim: 
'seqexp_betweenAnd(rcvr, min, max){
	return rcvr >= min && rcvr <= max;
}'.

	dart verbatim: 
'seqexp_sign(rcvr){
	if(rcvr > 0) return 1;
	if(rcvr < 0) return -1;
	return 0;
}'.

	dart verbatim: 
'seqexp_prepend(element, list){
  var newlist = new List(list.length + 1);
  newlist[0] = element;
  for(var i=0; i<list.length; i++) newlist[i+1] = list[i];
  return newlist;
}'.

	dart verbatim:
'seqexp_ondo(tryblock,exceptionclass,catchblock)
{
	try {
		return tryblock(); 
	} catch( KernelForDart_Error_mixin ex ) {
		for(var c = ex.klass_; c !== nil_ && c !== null; c=c.superclass_slot){
			if(c==exceptionclass) return catchblock(ex);
		}
		throw ex;
	}
}'

	}
)
topClass ^<Node> = (
	"Top allows all Newspeak code to reside in mixins. In particular, it means we don't need a special case for Object. Top has two instance variables: one to track the Newspeak class of an object since Dart does not support asking for the runtime class of an object, and one to keep an identity hash. Top has three methods: noSuchMethod() which wraps its arguments appropriately and delegates to #doesNotUnderstand:, toString() which delegates to #printString and unwraps the Newspeak String, and initializer_new() which is the basis case for the instance initializer scheme."
	^dart 
		class: (names mixinClassNameFor: 'Top')
		extends: 'Object' "Dart's Object"
		fields: {
			dart var: 'klass_'.
			dart var: 'identityHash_'}
		constructors: {
			dart verbatim: (names mixinClassNameFor: 'Top'),'(this.klass_);'}
		methods: {
			topNoSuchMethod.
			topToString.
			topInitNew}
)
topInitNew ^<Node> = (
	^dart 
		method: (names mangleSelector: (compiler initializerSelectorNameFor: 'new'))
		params: {}
		body: (dart block: { 
				dart return: (dart ident: 'this')}).
)
topLevelMembers ^<List[Node]> = (

	^dynamicMixinHelpers, {topClass. nlrClass}, 
		mixinClasses, mixinSources, globals, seqexpHelpers,
		{namespaceClass. mainFunction}
)
topNoSuchMethod ^<Node> = (

^dart
	method: 'noSuchMethod'
	params: {'name'. 'args'}
	body: (dart block: {
		dart return: (dart
			on: (dart ident: 'this')
			invoke: (dart ident: (names mangleSelector: 'doesNotUnderstand:'))
			with: {dart 
				on: (dart ident: names Message)
				invoke: (dart ident: (names mangleSelector: 'selector:arguments:'))
				with: {
					dart on: (dart ident: names String) invoke: (dart ident: 'wrapping__') with: {dart ident: 'name'}.
					dart on: (dart ident: names Array) invoke: (dart ident: 'wrapping__') with: {dart ident: 'args'} 
				}
			})
		
	}).
)
topToString ^<Node> = (
^dart
	method: 'toString'
	params: {}
	body: (dart block: {
		dart return: (dart 
			on: (dart 
				on: (dart ident: 'this')
				invoke: (dart ident: (names mangleSelector: 'printString'))
				with: {})
			invoke: (dart ident: (names mangleSelector: 'dartString'))
			with: {})}).
)) : ()
class MethodMirror named: s <Symbol> = LowLevelMirror (
"A descriptor for a Dart method."| 
	selector <Symbol> = s.
	method <Node>  "Dart code"
	src <String> "Newspeak source - optional"
	|)
('as yet unclassified'
isAccessor ^ <Boolean> = (
	^metadata at: #isAccessor ifAbsent:[false]
)
isAccessor: b <Boolean> = (
	isSynthetic: b.
	metadata at: #isAccessor put: b
)
isFactory ^ <Boolean> = (
	^metadata at: #isFactory ifAbsent:[false]
)
isFactory: b <Boolean> = (
	isSynthetic: b.
	metadata at: #isFactory put: b
)
isSynthetic ^ <Boolean> = (
	^metadata at: #isSynthetic ifAbsent:[false]
)
isSynthetic: b <Boolean> = (
	metadata at: #isSynthetic put: b
)
name ^ <Symbol> = (
	^selector
)
simpleName ^ <Symbol> = (
	^selector
)) : ('as yet unclassified'
REFACTORING = (
	"Maybe this should be the class called LowLevelMethodMirror and live in the mirrors module."
))
class Scope = (
"A generic scope facility."|
superScope <Scope>
bindings <Map[Symbol,SymbolTableEntry]> = Dictionary new.
|)
('access'
at: aKey put: aValue = (
	^self bindings at: aKey put: aValue
)
at: aKey put: aValue ifThere: aBlock = (

    "Associates aValue with aKey and answers aValue if aKey
    was absent. Otherwise answers the value of aBlock."
    | wasAbsent |
    self assert: [aKey isSymbol] 
	message:['Attempt to ok up non-symbol ',aKey printString, ' in scope'].
    wasAbsent:: false.
    bindings at: aKey ifAbsent: [bindings at: aKey put: aValue. wasAbsent:: true].
    ^ wasAbsent
        ifTrue: [aValue]
        ifFalse: [aBlock value]
)
at: key = (

	"Answers the value associated with aKey in this or one the super scopes or fails if aKey is absent"
	^self at: key ifAbsent: [self error: 'Key ', key, ' not found!']
)
at: key ifAbsent: blk = (

    "Answers the value associated with aKey in this or one of the superScopes or the value of aBlock if aKey is absent."

	"Optimization note: This is written using [nil] blocks to avoid passing 
		non-clean blocks dynamically down the scope structure."

	| val <T> |
	(val:: self bindings at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	self superScope isNil
		ifTrue: [ ^blk value ].
	(val:: self superScope at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	^blk value
)
clear = (


self bindings keys do:[:k | self bindings removeKey: k].
)
includesIndex: key = (
"should this search the superscope?"
    ^ self bindings includesKey: key
)
includesIndexLocally: key <NameType > ^ <Boolean> = (


^self bindings includesKey: key.
)
removeKey: key = (


self bindings removeKey: key
)
removeKey: key ifAbsent: blk = (


self bindings removeKey: key ifAbsent: blk
)
within: scope = (
    "Creates and initializes a new (sub)scope within scope."
      self superScope: scope.
  )'as yet unclassified'
depth ^ <Integer> = (
	superScope ifNil:[^0].
	^superScope depth + 1.
)) : ('as yet unclassified'
REFACTORING = (
	"This should be factored out along with ScopeBuilder. Perhaps it should also become nested within ScopeBuilder."
))
class SemanticVarDecl decl: d <VarDeclAST> = SymbolTableEntry for: d (
"Semantic info for a variable: slot, local or parameter."|
  offset <Integer>
  remote ::= false.
  remoteVector <SemanticVarDecl>
|)
('as yet unclassified'
isTemporaryAST ^ <Boolean> = (
	^data isTemporaryAST
)
setIndex: i <Integer> InVector: v <VarDeclAST> = (
	assert: remote message: 'Var Decl is not remote'.
	remoteVector:: v.
	offset:: i.
)
variableClass ^ <Class> = (
	^data variableClass
)) : ()
class SymbolTableEntry for: datum = (
"An entry in a scope."| 
  sym  
  data ::= datum first.
  depth = datum last.
|)
('as yet unclassified'
isMethodNode = (^self data  isMethodNode)'testing'
isMessagePatternNode = (^self data  isMessagePatternNode)
isVarDeclNode = (^self data isVarDeclNode)) : ()'as yet unclassified'
MutableString = (
	#FLAG.
	^String
)'private'
REFACTORING = (
	"Rewriter, Translator, Writer are stateful visitors that have a method to reset their state. It would be less error prone if they had no such reset methods and instead a new instance was created for each use.
	MixinRep, CompiledMixinMirror and LowLevelMixinMirror should be unified into one object.
	ScopeBuilder should be factored out and shared by all the compilation modules."
)
assert: block = (
	assert: block message: 'Assertion failed'
)
in: map at: key ifPresent: presentBlock ifAbsent: absentBlock = (
	| value |
	value:: map at: key ifAbsent: [^absentBlock value].
	^presentBlock value: value.
)) : ()