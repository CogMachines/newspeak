Newspeak3
'StructuredVCS'
class VCSNewspeakSourceMirrors usingPlatform: p vcs: vcs = (|
	(* These imports are somewhat cheating. The mature mirrors API probably won't make these avaiable. *)
	CombinatorialParser = p mirrors parserLib CombinatorialParser.
	TypedNS3Grammar = p mirrors grammar TypedNS3Grammar.
	
	(* Is this module the only user? Convert these to Newspeak and nest them here *)
	private Yield = p blackMarket Yield Yield.
	private ParentYield = p blackMarket ParentYield.
	
	private mirrors = p mirrors.
	private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	private Smalltalk = p blackMarket Smalltalk.
	private SystemOrganization = p blackMarket SystemOrganization.
	private Dictionary = p blackMarket Collections Dictionary.
	private OrderedCollection = p blackMarket Collections OrderedCollection.
	private PackageInfo = p blackMarket PackageInfo.
	
	private imageMirrorCache = vcs imageMirrorCache.
	private SourceMirror = vcs sourceMirrors SourceMirror.
	private StringMirror = vcs sourceMirrors StringMirror.
	
	private compilationUnitCache = MirrorCache onSelector: #compilationUnit.
	private methodDeclCache = MirrorCache onSelector: #methodDecl.
|)
(
class ClassSourceMirror = SourceMirror (|
category
accessModifier
name
constructor
superclassClause
classComment
slotsSource
slots
initExpressions
classes
instanceMethods
classMethods
|)
('as yet unclassified'
children = (

	^ Array streamContents: [:stream |
		{#name. #category. #accessModifier. #constructor. #superclassClause. #classComment. #slotsSource. #initExpressions} do: [:each |
			(self perform: each) ifNotNil: [:it | | stringMirror |
				stringMirror:: StringMirror new
					string: it;
					yourself.
				stream nextPut: each -> stringMirror]].
		{#slots. #classes. #instanceMethods. #classMethods} do: [:each |
			(self perform: each) ifNotNil: [:it |
				stream nextPutAll: (it collect: [:el | each -> el])]]]	
)
filename = (
	^name, '.ns3'
)
installAsToplevelClass = (

	installMirrors: {self}
)
isToplevel = (

	flag: #BOGUS. (* Class mirror should know whether it's a top-level class and decide to emit a file header based on that. *)
	^ (category = nil or: [category isEmpty]) not
)
languageIdentifier = (

	^ 'Newspeak3'
)
streamCategory: cat to: stream = (

	| categories sortedAssociations |
	categories:: cat groupBy: [:each | each category] having: [:each | true].
	sortedAssociations:: categories associations sortBy: [:a :b |
		sortBlock value: a key value: b key].
	sortedAssociations do: [:each |
		stream
			nextPut: $';
			nextPutAll: each key;
			nextPut: $'.
		(each value sortBy: sortBlock) do: [:method |
			stream cr.
			method streamTo: stream]].
)
streamClassBodyTo: stream = (

	stream nextPut: $(.
	(classes asOrderedCollection sortBy: sortBlock) do: [:each |
		stream cr.
		each streamTo: stream].
	streamCategory: instanceMethods to: stream.
	stream	nextPutAll: ')'.
	classMethods ifNotNil: [:it |
		stream nextPutAll: ' : ('.
		streamCategory: classMethods to: stream.
		stream nextPut: $).].
)
streamClassCommentTo: stream = (

	(nil = classComment or: [classComment isEmpty]) ifFalse: [
		 | first last firstParen lastParen |
		first:: classComment findFirst: [:x | x = $"].
		last:: classComment findLast: [:x | x = $"].
		
		firstParen:: classComment findFirst: [:x | x = $(].
		lastParen:: classComment findLast: [:x | x = $)].
		
		(firstParen ~= 0) & ((firstParen < first) | (first = 0)) 
			ifTrue: [^stream nextPutAll: classComment].
		
		stream nextPutAll: (classComment copyFrom: 1 to: first).
		
		classComment from: first + 1 to: last - 1 do: [:each |
			stream nextPut: each.
			each = $" ifTrue: [stream nextPut: $"]].
		
		stream nextPutAll: (classComment copyFrom: last to: classComment size)].
		
)
streamClassHeaderTo: stream = (

	stream
		nextPutAll: 'class ';
		nextPutAll: name.
	constructor ifNotNil: [:it | 
		stream
			nextPutAll: ' ';
			nextPutAll: constructor].
	stream nextPutAll: ' ='.
	superclassClause ifNotNil: [:it | 
		stream
			nextPutAll: ' ';
			nextPutAll: superclassClause].
	stream	nextPutAll: ' ('.
	streamClassCommentTo: stream.
	slotsSource ifNotNil: [:it |
		stream nextPutAll: it].
	(* slots ifNotNil: [:it |
		stream cr; nextPut: $|; cr.
		slots
			do: [:each |
					each streamTo: stream.
					stream cr].
		stream
			nextPut: $|;
			cr]. *)
	initExpressions ifNotNil: [:it |
		stream nextPutAll: it].
	stream
		nextPut: $);
		cr.
)
streamFileHeaderTo: stream = (

	isToplevel ifFalse: [
		^ self].
	stream
		nextPutAll: languageIdentifier; cr;
		nextPut: $';
		nextPutAll: category;
		nextPut: $';
		cr.
)
streamTo: stream = (

	streamFileHeaderTo: stream.
	streamClassHeaderTo: stream.
	streamClassBodyTo: stream
)'private'
sortBlock = (

	^ [:a :b | a name <= b name]
)) : ()
class MemoizingParser onParser: p = CombinatorialParser (|
parser = p.
cache = Dictionary new.
keySize = 30.
|)
('as yet unclassified'
cachedResultsStartingWithFirstCharsOf: input = (

	| key length |
	length:: keySize min: input size - input position.
	key:: input next: length.
	^ cache
		at: key
		ifAbsentPut: [OrderedCollection new]		
)
parse: input inContext: context ifError: errorBlock  = (

	| results position result |

	position:: input position.
	results:: cachedResultsStartingWithFirstCharsOf: input.
	input position: position.
	result:: resultFor: input inResults: results.
	result = nil
		ifTrue: [ | parsedInput |
			result:: parser parse: input inContext: context ifError: errorBlock.
			parsedInput:: stringIn: input fromPosition: position.
			results add: parsedInput -> result].
	^ result
)
resultFor: input inResults: results = (

	| result position |
	position:: input position.
	result:: results
		detect: [:each | | inputChunk |
			input position: position.
			inputChunk:: input next: each key size.
			inputChunk = each key]
		ifNone: [
			input position: position.
			^ nil].
	^ result value
)
stringIn: input fromPosition: position = (

	| parsedSize |
	parsedSize:: input position - position.
	input position: position.
	^ input next: parsedSize.
)) : ()
class MethodSourceMirror = SourceMirror (|
protected messagePattern
protected methodSource
protected category
protected accessModifier
private selector
|)
('as yet unclassified'
children = (
	^ {}
)
contentsEquals: other = (

	^ self methodSource = other methodSource and: [
		self category = other category and: [
			self accessModifier = other accessModifier]]
)
copy = (

	(* Should Newspeak have a default shallow copy built in? *)
	^ MethodSourceMirror new
		messagePattern: messagePattern;
		methodSource: methodSource;
		category: category;
		accessModifier: accessModifier;
		selector: selector;
		yourself
)
correspondsHash = (

	^ selector hash
)
correspondsTo: other = (

	^ self selector = other selector
)
isMethodMirror = (

	^ true
)
name = (

	^ selector
)
streamTo: stream = (

	stream nextPutAll: methodSource
)) : ()
class MirrorCache onSelector: selector = ((* Keeps a map of string -> mirror *)|
(* Keep the actual dictionaries in VCS(ImageMirror)Caching, so it can be reused over multiple instances *)
cachedMirrors = imageMirrorCache stringToMirrorCacheForProduction: selector.
parser = SourceMirrorParser new.
production = parser perform: selector.
|)
('as yet unclassified'
mirrorForStream: stream = (

	^ mirrorForStream: stream ifError: [:pos :msg | error]
)
mirrorForStream: stream ifError: errorBlock = (

	| string |
	string:: stream contents.
	^ cachedMirrors at: string ifAbsentPut: [ | newMirror | 
		parser input: string.
		newMirror:: production parse: string readStream ifError: errorBlock.
		(* source -> mirror -> source might rearrange elements in source.
		By caching the same mirror under all keys we might save time when comparing mirrors but we might just as well waste time as long as calculating a mirrors contents is slow *)
		cachedMirrors
			at: newMirror contents
			ifAbsentPut: [newMirror]]
)
void = (
	cachedMirrors keysAndValuesRemove: [:k :v | true].
)) : ()
class SlotSourceMirror = SourceMirror (|
name
accessModifier
type
initializer
immutable
|)
('as yet unclassified'
children = (
	^ {}
)
streamTo: stream = (

	accessModifier ifNotNil: [:it | 
		stream
			nextPutAll: it;
			nextPutAll: ' ' ].
	stream nextPutAll: name.
	type ifNotNil: [:it | 
		stream
			nextPut: $<;
			nextPutAll: it;
			nextPut: $>].
	initializer ifNotNil: [:it | 
		immutable
			ifTrue: [stream nextPutAll: ' = ']
			ifFalse: [stream nextPutAll: ' ::= '].
		stream
			nextPutAll: it;
			nextPutAll: '.'].
)) : ()
class SourceMirrorParser = TypedNS3Grammar (|
protected input
|)
('as yet unclassified'
binaryMsgPattern = (

	^ super binaryMsgPattern wrapper: [:sel :p | 
		(ParentYield wrap: {sel. p} input: input) children: sel token]
)
category = (
	(* category:: string, [methodDecl star] *)

	^super category
		wrapper:
			[ :catname :methods | | cat |
			cat:: catname token.
			(* The MemoizingParser returns the identical mirror for all methods with the same source. If a method with the same source exists in multiple categories (in different classes), we need multiple mirrors.
			
			We could create different mirrors right from the start by including the current category as a key to the memoizing dictionary. But accessing the category before the methods are being parsed would require the Newspeak grammar to be extended so that we have a 'categoryName' rule that we can override. We would want to do that in _the_ Newspeak grammar. We don't want to respecify it here.
			
			For now we create copies of method mirrors if they are set to wrong categories.	*)
			methods collect: [:each |
				(nil = each category or: [each category = cat])
					ifTrue: [
						each category: cat.
						each]
					ifFalse: [
						each copy
							category: cat;
							yourself]]]
)
classDeclaration = (
	(* classDeclaration:: (tokenFromSymbol: #class), [classHeader], [sideDecl], [classSideDecl opt] *)

	^super classDeclaration
		wrapper:
			[ :classKwd :hdr :instanceSide :classSide | | yield classes slots slotsSource instanceMethods classMethods klassName costructor scc cc initExpressions |
			klassName:: hdr first token asSymbol.
			yield:: Yield wrap: {classKwd. hdr. instanceSide. classSide} input: input.
			costructor:: (hdr at: 2) ifNotNil: [:it | (Yield wrap: it input: input) contents].
			scc:: (hdr at: 4) ifNotNil: [:it | (Yield wrap: it input: input) contents].
			cc:: hdr at: 6.
			slots:: (hdr at: 7) ifNotNil: [:it | it children children size = 5 ifTrue: [it children children at: 3] ifFalse: [it children children at: 2]].
			slotsSource:: (hdr at: 7) ifNil: [nil] ifNotNilDo: [:it | it contents].
			initExpressions:: (Yield wrap: (hdr at: 8) input: input) ifNotNilDo: [:it | it contents].
			classes:: instanceSide children first.
			instanceMethods:: instanceSide children at: 2.
			classMethods:: classSide
				ifNotNil: [:it | it children].
			ClassSourceMirror new
				name: klassName;
				constructor: costructor;
				superclassClause: scc;
				slots: slots;
				initExpressions: initExpressions;
				slotsSource: slotsSource;
				classes: classes;
				instanceMethods: instanceMethods;
				classMethods: classMethods;
				classComment: cc;
				yourself]
)
classSideDecl = (
	
	(* classSideDecl:: colon, [lparen], [category star], [rparen] *)
	^super classSideDecl
		wrapper:
			[ :cln :lp :categories :rp | | methods |
			methods:: flatten: categories.
			(ParentYield wrap: {lp. (* categories. *) rp} input: input) children: methods asArray ]
)
compilationUnit = (
	(* compilationUnit::  languageId, [namespaceDecl | [toplevelClass] | [namespaceExpr] ], [eoi] *)
	^super compilationUnit
		wrapper:
			[ :langId :toplevel :eoi |
				toplevel]
)
keywordMsgPattern = (

	^ super keywordMsgPattern wrap: [:kws | | selector |
		selector:: kws inject: '' into: [:acc :each | acc, each first token].
		(ParentYield wrap: kws input: input) children: selector]
)
methodDecl = (
	(* methodDecl:: accessModifier opt, [messagePattern], [equalSign], [lparen], [codeBody], [rparen] *)

	^MemoizingParser onParser: (super methodDecl
		wrapper:
		[ :accessMod :msgPat :eq :lp :cb :rp | | yield accessSym msgPatYield |
			msgPatYield:: Yield wrap: msgPat input: input.
			accessSym:: accessMod = nil
				ifTrue: [ nil ]
				ifFalse: [ accessMod first token ].
			MethodSourceMirror new
				methodSource: (Yield wrap: {accessMod. msgPat. eq. lp. cb. rp} input: input) contents;
				messagePattern: msgPatYield contents;
				selector: msgPat first children;
				accessModifier: accessSym;
				yourself])
)
nestedClassDecl = (
	
	(* nestedClassDecl:: accessModifier opt, [classDeclaration] *)

	^super nestedClassDecl
		wrapper:
			[ :accessMod :klass | | accessSym |
				accessSym:: accessMod = nil
					ifTrue: [ nil ]
					ifFalse: [ accessMod first token ].
				klass accessModifier: accessSym.
				klass]
)
pascalClassComment = (

	^(* super classComment *) (* classComment is broken in super classes. *)
	whitespace opt, pascalComment
		wrapper:
			[ :ws :com | 
			String streamContents: [:stream |
				(* nil = ws ifFalse: [
					stream nextPutAll: ws]. *)
				stream
					nextPutAll: '(*';
					nextPutAll: com token;
					nextPutAll: '*)']]
)
seqSlotDecls = (

	^super seqSlotDecls wrap:
		[ :list |
			(ParentYield wrap: list input: input) children: list]
)
sideDecl = (
	
	(* sideDecl:: lparen, [nestedClassDecl star], [category star], [rparen] *)
	^super sideDecl
		wrapper:
			[ :lp :classes :categories :rp | | methods |
			methods:: flatten: categories.
			(ParentYield wrap: {lp. classes. (* categories. *) rp} input: input) children: {classes asArray. methods asArray} ]
)
simSlotDecls = (

	^super simSlotDecls wrap:
		[ :list |
			(ParentYield wrap: list input: input) children: list]
)
slotDecls = (

	(* slotDecls:: vbar, [slotDef star], [vbar] *)

	^super slotDecls wrap:
		[ :list |
			(ParentYield wrap: list input: input) children: list]
)
slotDef = (
	
	(*
	slotDecls:: vbar, [slotDef star], [vbar].
	slotDef::   accessModifier opt, [slotDecl], [ (((tokenFromSymbol: #=) | [tokenFromSymbol: #'::=']), [expression], [dot]) opt].
	slotDecl::  identifier , [type opt].
	*)

	^super slotDef wrapper:
		[ :accessMod :nameAndType :init | | accessSym immutable expr typeString initializer |
		accessSym:: accessMod = nil
			ifTrue: [ nil ]
			ifFalse: [ accessMod first token ].
		init = nil
			ifTrue: [ immutable:: false. expr:: nil ]
			ifFalse: [immutable:: (init at: 1) token = #=. expr:: (init at: 2) contents ].
		initializer:: expr ifNotNil: [:it | (Yield wrap: expr input: input) contents].
		typeString:: (nameAndType at: 2) = nil
			ifTrue: [ nil ]
			ifFalse: [ | yield |
				yield:: Yield wrap: ((nameAndType at: 2) contents at: 2) contents input: input.
				yield contents].
		SlotSourceMirror new
			name: nameAndType first token;
			accessModifier: accessSym;
			initializer: initializer;
			type: typeString;
			immutable: immutable;
			yourself]
)
smalltalkClassComment = (

	^(* super classComment *) (* classComment is broken in super classes. *)
	whitespace opt, smalltalkComment
		wrapper:
			[ :ws :com | 
			String streamContents: [:stream |
				(* nil = ws ifFalse: [
					stream nextPutAll: ws]. *)
				stream
					nextPut: com first;
					nextPutAll: (com at: 2);
					nextPut: com last]]
)
toplevelClass = (
	(* toplevelClass:: classCategory, [classDeclaration] *)

	^super toplevelClass
		wrapper:
			[ :cat :klass |
				klass category: cat token.
				klass]
)
unaryMsgPattern = (

	^ super unaryMsgPattern wrap: [:sel |
		(ParentYield wrap: sel input: input) children: sel token]
)) : ()'as yet unclassified'
clearCaches = (
	compilationUnitCache void.
	methodDeclCache void.
)
flatten: collection = (

	| result |
	result:: OrderedCollection new.
	collection do: [:each | result addAll: each].
	^ result
)
public installMirrors: newMirrors <Collection[ClassSourceMirrors]> = (
	
	(* Batch Atomic Installation *)
	
	| builders |
	builders:: newMirrors collect: [:ea |
		| builder = ClassDeclarationBuilder fromUnitSource: ea source. |
		#BOGUS yourself. (* The mirror API should provide a non-cheat way to give both the source for a whole module and an existing module to mutate. *)
		Smalltalk
			at: builder simpleName 
			ifPresent: [:it | builder prvtExistingMixin: it mixin].
		builder].
	
	(mirrors installAtomically: builders) do: [:mirror |
		(Smalltalk includesKey: mirror simpleName) ifFalse: [
			| klass = mirror reflectee apply: Object withName: mirror simpleName. |
			Smalltalk at: klass name put: klass.
			klass category: mirror reflectee category.
			SystemOrganization classify: klass name under: klass category.
			PackageInfo named: (klass basicCategory findTokens: '-') first.
		].
	].
)
public mirrorForClass: aClass <Class> ^<ClassSourceMirror> = (

	| stream |
	stream:: (String streamContents: [:s | aClass mixin definingClass printTopClassOn: s]) readStream.
	^ mirrorForStream: stream.
)
public mirrorForStream: stream <ReadStream> ^<ClassSourceMirror> = (

	^ compilationUnitCache mirrorForStream: stream
)) : ()