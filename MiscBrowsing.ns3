Newspeak3
'HopscotchIDE'
class MiscBrowsing usingPlatform: p ide: ide = (
"Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2011 Ryan Macnak and other contributors.
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
	private Smalltalk = p blackMarket Smalltalk.
	private Preferences = p blackMarket System Preferences.
	private Color = p blackMarket Graphics Color.
	private SmalltalkImage = p blackMarket System SmalltalkImage.
	private Undeclared = p blackMarket Undeclared.
	private Utilities = p blackMarket System Utilities.
	private HopscotchImages = p blackMarket Hopscotch HopscotchImages.
	private MCWorkingCopy = p blackMarket Monticello MCWorkingCopy.
	private PackageOrganizer = p blackMarket Smalltalk at: #PackageOrganizer.
	private MCPackage = p blackMarket Monticello MCPackage.
	private PackageInfo = p blackMarket Smalltalk at: #PackageInfo.
	private Language = p blackMarket NsMultilanguage Language.
	private SystemOrganization = p blackMarket SystemOrganization.
	private SystemMetadata = p blackMarket NewsqueakMixins SystemMetadata.
	private ThisOSProcess = p blackMarket OSProcess ThisOSProcess.
	private blackMarket = p blackMarket.
	
	private Time = p time Time.
	private Subject = p hopscotch core Subject.
	private Presenter = p hopscotch core Presenter.
	private TextEditorFragment = p hopscotch fragments TextEditorFragment.
	private TextDisplayFragment = p hopscotch fragments TextDisplayFragment.
	private EditableLinePresenter = p hopscotch fragments EditableLinePresenter.
	private OrderedCollection = p collections OrderedCollection.
	private Dictionary = p collections Dictionary.
	private Set = p collections Set.
	private Gradient = p brazil plumbing Gradient.
	private NewspeakObject = Object.
	private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	
	ide = ide.
	EditableDefinitionPresenter = Delay computation: [ide tools EditableDefinitionPresenter].
	DefinitionListPresenter = Delay computation: [ide tools DefinitionListPresenter].
	ProgrammingPresenter = Delay computation: [ide tools ProgrammingPresenter].
	AssortedMethodsPresenter = Delay computation: [ide browsing AssortedMethodsPresenter].
	MethodSubject = Delay computation: [ide browsing MethodSubject].
	SelectorPresenter = Delay computation: [ide browsing SelectorPresenter].
	SelectorSubject = Delay computation: [ide browsing SelectorSubject].
	ClassCommentPresenter = Delay computation: [ide tools ClassCommentPresenter].
	ClassNamePresenter = Delay computation: [ide tools ClassNamePresenter].
	DefinitionTemplate = Delay computation: [ide tools DefinitionTemplate].
	OneLineDefinitionTemplate = Delay computation: [ide tools OneLineDefinitionTemplate].
|)
(
class AuthorInitialsPresenter onSubject: s = EditableDefinitionPresenter onSubject: s (
"Displays and edits the author initials that saved methods are labeled with. The subject is a  PersonalInformationSubject."|  |)
('as yet unclassified'
defaultDefinition = (
^ThisOSProcess thisOSProcess environment at: #USERNAME ifAbsent: ['']
)
definitionText = (
| initials |
initials:: subject authorInitials.
^(initials isNil or: [initials isEmpty])
	ifTrue: [defaultDefinition]
	ifFalse: [initials]
)
presentationDefinition = (

	^label: definitionText asText allBold
)
respondToAccept = (

	subject 
		authorInitials: editor textBeingAccepted asString
		ifFail: [:message <String> | ^editor showMessage: message].
	leaveEditState
)) : ()
class AuthorNamePresenter onSubject: s = EditableDefinitionPresenter onSubject: s (
"Displays and edits the author name and email. The subject is a PersonalInformationSubject."|  |)
('as yet unclassified'
defaultDefinition = (
^'Full Name <email@company.com>'
)
definitionText = (
| name |
name:: subject authorName.
^(name isNil or: [name isEmpty])
	ifTrue: [defaultDefinition]
	ifFalse: [name]
)
presentationDefinition = (

	^label: definitionText asText allBold
)
respondToAccept = (

	subject 
		authorName: editor textBeingAccepted asString
		ifFail: [:message <String> | ^editor showMessage: message].
	leaveEditState
)) : ()
class BitOfWisdom new = Object (
""| text image actionLabel actionBlock |)
() : ('as yet unclassified'
text: aString = (

	^self new text: aString
)
text: aString actionLabel: labelString actionBlock: aBlock = (

	^self new 
		text: aString;
		actionLabel: labelString;
		actionBlock: aBlock
)
text: aString image: aForm = (

	^self new
		text: aString;
		image: aForm
))
class ClassCategoryDocsPresenter onSubject: s = ProgrammingPresenter onSubject: s (
""|  |)
('as yet unclassified'
classViewOf: classSubject = (
^
	column: {
		minorHeadingBlock:
			(row: {
				image: (iconForClassNamed: classSubject className).
				mediumBlank.
				(link: classSubject className asText allBold
					action: [browseClassNamed: classSubject className])
				}
			).
		indentedBlock:
			(ClassCommentPresenter onSubject: classSubject)
		}
)
definition = (
^
	column: {
		majorHeadingBlock: (
			row: {
				link: subject title asText allBold
					action: [browseClassCategory: subject subject].
				label: ' documentation view' asText allBold.
				}
			).
		mediumBlank.
		column: 
			((subject classSubjects) collect:
				[:each | classViewOf: each]).
		mediumBlank.
		}
)) : ()
class ClassCategoryPresenter onSubject: s = DefinitionListPresenter onSubject: s (
"Displays a class category as a collection of lines identifying the classes in the category, expandable into full class presenters."| categoryNamePresenter |)
('actions'
respondToRunTestsUsing: testCases = (

	testClasses:: testCases
)'as yet unclassified'
addClassTemplate = (

	prefixes add:
		(DefinitionTemplate new
			caption: 'Defining a new class:';
			initialText: subject classTemplateText;
			colorizerBlock: [ :text | subject colorizeClassSource: text];
			acceptResponse: 
				[:template | | success |
				(subject 
						acceptNewClassDefinition: template text 
						)
					ifTrue: [prefixes remove: template].
				refresh];
			cancelResponse:
				[:template | 
				prefixes remove: template])
)
captionForClassSubject: aSubject = (

	^row: {
		ClassNamePresenter onSubject: aSubject.
		maybeShowRunTestLinkFor: (Array with: aSubject).
		filler.
		(deferred: [subclassCountLabelFor: aSubject]) width: 25.
		blank: 5.
		(deferred: [methodCountLabelFor: aSubject]) width: 30.
		}
)
contentPresenters = (

	^(subject classSubjects) collect:
		[:each |
		expandableLineForClassSubject: each]
)
expandableLineForClassSubject: aSubject = (

	| toggle |
	toggle::
		collapsed: [captionForClassSubject: aSubject]
		expanded: [aSubject presenter].
	toggle onUserToggled: [toggle requestVisibility].
	^toggle
)
maybeShowRunTestLink = (
	^nothing
	
	"| subjects |
	subjects:: subject classSubjectsUsingReflection: reflection.
	^maybeShowRunTestLinkFor: subjects"
)
respondToConvert = (
enterSubject::
	missionary
		ConvertToNS2Subject onModel: subject model
)
respondToRename = (
categoryNamePresenter enterEditState
)'definition'
definition = (
^
	column: {
		minorHeadingBlock: (
			row: {
				[categoryNamePresenter:: EditableClassCategoryPresenter onSubject: subject.
				categoryNamePresenter] value.
				mediumBlank.
				linkImage: HopscotchImages default editImage
					action: [respondToRename].
				largeBlank.
				packageLink.
				largeBlank.
				(link: 'docs' 
					action: [browseClassCategoryDocs: subject model]) tinyFont.
				largeBlank.
				(link: 'convert' 
					action: [respondToConvert]) tinyFont.
				largeBlank.		
				addButtonWithAction: [addClassTemplate].
				deferred: [maybeShowRunTestLink].
				filler.
				expandButtonWithAction: [expandAll].
				blank: 3.
				collapseButtonWithAction: [collapseAll].
				}
			).
		mediumBlank.
		super definition.
		mediumBlank.
		}
)
maybeShowRunTestLinkFor: collectionOfSubjects = (

	^nothing
	"| testCases |
	testCases:: (collectionOfSubjects select: [:aSubject | aSubject isTestCase]).	
	testCases:: (testCases collect: [:aSubject | aSubject model]) asSet.

	^testCases notEmpty 
		ifTrue:
			[row: {
				smallBlank.
				(link: 'tests' action: [respondToRunTestsUsing: (testCases)]) tinyFont
			}]
		ifFalse: [nothing]"
)
packageLink = (
^
	(subject packageName
		ifNil: [label: '(no package)']
		ifNotNil: 
			[:packageName |
			link: packageName action: [browsePackage: packageName]])
				tinyFont
)'private-color patches'
brightnessForN: n midpoint: gamma = (
	"Return the value of brightness to use for the number of elements n, with the constraints that the brightness for 0 is 1, the brightness for gamma is 0.5 and the brighness asymptotically approaches 0 as n increases."

	^(gamma / (gamma + n)) asFloat
)
methodCountLabelFor: aSubject = (

	| count brightness caption holder |
	count:: aSubject methodCount.
	brightness:: brightnessForN: count midpoint: 40.
	caption:: (label: count printString) tinyFont.
	caption color: ((brightness < 0.7)
		ifTrue: [Color white]
		ifFalse: [Color black]).
	^(row: {filler. caption. blank: 5}) 
		color: (patchColorWithHue: 170 value: brightness)
)
patchColorWithHue: hue value: brightness = (

	^Color h: hue s: 1 - brightness v: brightness
)
subclassCountLabelFor: aSubject = (

	| count brightness caption holder |
	count:: aSubject totalSubclassCount.
	brightness:: brightnessForN: count midpoint: 20.
	caption:: (label: count printString) tinyFont.
	caption color: ((brightness < 0.8)
		ifTrue: [Color white]
		ifFalse: [Color black]).
	^(row: {filler. caption. blank: 5}) 
		color: (patchColorWithHue: 210 value: brightness)
)) : ()
class ClassCategorySubject onModel: m = Subject onModel: m (
"Represents a viewpoint of a class category as a collection of classes. The model is the category name."|  |)
('accessing'
classSubjects = (

	^retrieveClasses collect: 
		[:each | 
		flag: #BOGUS. "calling onto the presenter may not be right"
		presenter subjectForClass: each]
)
classTemplateText = (
^
'class ClassNameHere = (
"Describe the class in this comment."
|
	slot1
	slot2
|
) ()'
)
title = (

	^model, ' category'
)'as yet unclassified'
= anotherSubject = (

	^anotherSubject class == self class
		and: [anotherSubject model = model]
)
acceptNewClassDefinition: definitionString = (
	| builder mixin klass |
	builder:: ClassDeclarationBuilder fromSource: definitionString.
	(Smalltalk includesKey: builder simpleName) ifTrue: [
		Error signal: 'Class with that name already exists'].
	mixin:: builder install reflectee.
	klass:: mixin apply: Object withName: builder simpleName.
	Smalltalk at: klass name put: klass.
	klass mixin category: model.
	SystemOrganization classify: klass name under: model.
	^true
)
colorizeClassSource: sourceText <String | Text> ^<Text> = (
^ide browsingNS3 NS3Colorizer new
	parseText: sourceText asString
	fromClass: NewspeakObject
	usingSelector: #classDeclaration
)
hash = (

	^model hash
)
name = (

	^model
)
packageName ^<String | nil> = (

	^(PackageInfo allPackages 
		detect: [:some | some includesSystemCategory: model]
		ifNone: [^nil])
			packageName
)
rename: newName ifSuccessful: successAction ifFailed: failAction = (

	(SystemOrganization categories includes: newName)
		ifTrue: [^failAction value: newName asString, ' already exist'].
	(newName select: [:each | Character lf = each or: [Character cr = each]]) isEmpty not
		ifTrue: [^failAction value: 'Cannot contain newlines.'].
	SystemOrganization renameCategory: model toBe: newName.
	model:: newName.
	^successAction value
)'private'
createPresenter = (

	^ClassCategoryPresenter onSubject: self
)
retrieveClasses = (

	^((Smalltalk organization listAtCategoryNamed: model)
		collect: [:each | Smalltalk at: each ifAbsent: [ SystemMetadata classNamed: each inNamespace: Smalltalk ]])
		reject: [:each | each isNil]
)) : ()
class ConfigurationPresenter onSubject: s = ProgrammingPresenter onSubject: s (
"Displays user-configurable system settings (this is the target of the ''Configuration'' link on the Home page). The subject is a ConfigurationSubject."| namePresenter initialsPresenter |)
('as yet unclassified'
definition = (
	namePresenter:: AuthorNamePresenter onSubject: subject.
	initialsPresenter:: AuthorInitialsPresenter onSubject: subject.
	subject authorNameProvided ifFalse:
		[namePresenter enterEditState].
	subject authorInitialsProvided ifFalse:
		[initialsPresenter enterEditState].

	^column: {
		majorHeadingBlock: (
			label: 'User information' asText allBold
			).
		indentedBlock: (column: {
			"entryLabeled: 'Name and email:' with: namePresenter."	
			entryLabeled: 'Initials:' with: initialsPresenter.
			})
	}
)
entryLabeled: caption <String> with: presenter <Presenter> = (
^row: {
	(label: caption) width: 150.
	mediumBlank.
	presenter.
	}
)) : ()
class ConfigurationSubject onModel: m = Subject onModel: m (
"This subject represents the system configuration, including the user personal information such as author initials and the email address."|  |)
('as yet unclassified'
= another <Presenter> = (
^another class = self class
)
authorInitials = (
^Utilities authorInitialsPerSe
)
authorInitials: newInitials ifFail: failAction <[String]> = (
newInitials isEmptyOrNil ifTrue: [^failAction value: 'Empty'].
(newInitials select: [:each | each isSeparator]) isEmpty not ifTrue: [^failAction value: 'Must not contain whitespace'].
Utilities setAuthorInitials: newInitials
)
authorInitialsProvided ^<Boolean> = (
^authorInitials isEmptyOrNil not
)
authorName = (
^Utilities authorNamePerSe
)
authorName: newName ifFail: failAction <[String]> = (
newName isEmptyOrNil ifTrue: [^failAction value: 'Must be non-empty'].
Utilities authorName: newName
)
authorNameProvided ^<Boolean> = (
^authorName isEmptyOrNil not
)
createPresenter = (

	^ConfigurationPresenter onSubject: self
)
hash = (
^class hash
)
isRequiredInformationProvided = (
^authorInitialsProvided "and: [authorNameProvided]"
)
title = (
^'Configuration'
)) : ('as yet unclassified'
new = (
	^onModel: nil
))
class DeletedClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
""|  |)
('as yet unclassified'
definition = (
^
	majorHeadingBlock:
		(label: 'Class ', subject className, ' has been deleted.    * sniff *')
)) : ()
class DeletedClassSubject onModel: m = Subject onModel: m (
"Represents a class that has been deleted from the system. The model is the name of the class."|  |)
('as yet unclassified'
className = (

	^model
)
createPresenter = (

	^DeletedClassPresenter onSubject: self
)
title = (

	^className, ' (deleted class)'
)) : ()
class DeploymentInstructionsPresenter = Presenter onSubject: nil (
""|
|)
('as yet unclassified'
definition = (
	^textDisplay: 
'Your system does not appear set up for EXE deployment.

You must be running on Windows, and your virtual machine directory must contain the following files:
1) A virtual machine, nsvm.exe, that has been compiled with IMAGE_IN_EXE
2) deployment.image
3) deployment.changes
4) ResHacker.exe
5) upx.exe

1, 2 and 3 should have been provided by the Newspeak installer. If they are not present, you need to get a current Newspeak release and reinstall.
Unfortunately, the IDE cannot automatically install 4 and 5 for you, as these are separately licensed applications.
4 can be downloaded from http://angusj.com/resourcehacker/reshack.zip
5 can be downloaded from http://upx.sourceforge.net/download/upx307w.zip

Of course running 4 & 5 is subject to their licenses.
Once you have downloaded these you can move the executables to the Newspeak Virtual Machine directory (should be under Program Files). 
'
)
title = (
	^'Deployment instructions'
)) : ()
class EditableClassCategoryPresenter onSubject: s = EditableLinePresenter onSubject: s (
"Presents an editory for renaming a class category."|  |)
('actions'
browseClassCategory: categoryName <Symbol> = (

	defaultPopularityRecord
		rememberCategoryVisit: categoryName.
	enterSubject: (ClassCategorySubject onModel: categoryName)
)'as yet unclassified'
definitionText = (

	^subject model asString
)
respondToAccept = (
"A subclass must redefine this to do whatever is needed to be done with <editor text> to save its as the new state of the subject, and send #leaveEditState if the save was successful."
| newName |
newName:: editor text asString asSymbol.
subject rename: newName ifSuccessful: [leaveEditState] ifFailed: [:reason |]
)
viewerDefinition = (

	^link: [subject title asText allBold]
		action: [browseClassCategory: subject model]
)) : ()
class HomePresenter onSubject: s = ProgrammingPresenter onSubject: s (
""| helpHolder configurationSubject |)
('as yet unclassified'
aboutSystemDefinition = (

	^(link: 'About this system' action: [respondToAboutSystem]) smallFont.
)
column1: definitions1 column2: definitions2 column3: definitions3 = (
^row: {
	(column: definitions1) width: 0 elasticity: 1.
	(column: definitions2) width: 0 elasticity: 1.
	(column: definitions3) width: 0 elasticity: 1.
	}
)
definition = (
configurationSubject:: ConfigurationSubject new.
^homePageDefinition
)
didYouKnow = (

	| wisdom |
	wisdom:: subject randomBitOfWisdom.
	wisdom actionLabel notNil ifTrue:
		[^textAndActionWisdom: wisdom].
	wisdom image notNil ifTrue:
		[^textAndImageWisdom: wisdom].
	^TextDisplayFragment new text: wisdom text
)
helpButton = (
^helpText isNil
	ifTrue: [nothing]
	ifFalse: [(link: '[?]' action: [respondToHelp]) tinyFont]
)
helpText ^<String | nil> = (
"If this method answers a string, a help button will appear on the Home page. Clicking on that button will display the string."
^'This is the home page. You can always return to the home page of a Newspeak browser by clicking on the home icon at the top of the browser. 
The home page includes links to a variety of useful places, like recently visited classes and packages, the source control page and more. 
If you look at the list of classes, you will see each class has a round icon next to it. The icon tells you which language the class is written in; the current system mixes Smalltalk and Newspeak code. So, for example, a gray icon represents Smalltalk. Golden icons represent Newspeak3, which is the currently operational dialect of Newspeak.'
)
homePageDefinition = (
	helpHolder:: list.
^
	column: {
		helpHolder.
		majorHeadingBlock: (
			row: {
				label: 'Navigation' asText allBold.
				filler.
				helpButton.
			}
		).
		mediumBlank.
		
		indentedBlock:
			(column1: {
				link: 'System Source' asText allBold
					action: [browseSystem].
				"link: 'Source Control' asText allBold
					action: [respondToBrowseSourceControl]."
				link: 'MemoryHole' asText allBold
					action: [enterSubject: ide vcs ui mainSubject]
				}
			column2: {
				link: 'Workspaces'
					action: [navigateToWorkspaces].
				link: 'Pasteboard'
					action: [navigateToPasteboard].
Preferences experimental ifTrue: [					
				link: 'Jumpstation' 
					action: [enterSubject:: JumpStationSubject onModel: nil].
] ifFalse: [blank: 0].					
				undeclaredDefinition.
				}
			column3: {
				row: {
					link: 'Configuration'
						action: [enterSubject: configurationSubject].
					configurationSubject isRequiredInformationProvided
						ifTrue: [nothing]
						ifFalse: [missingInfoMarker]
					}
				}
			).
		mediumBlank.

		majorHeadingBlock: (label: 'Recently Visited' asText allBold).
		mediumBlank.
		indentedBlock::
			holder: [recentStuffDefinition].
		largeBlank.
		
		majorHeadingBlock: (label: 'Did you know?' asText allBold).
		smallBlank.
		indentedBlock::
			holder: [didYouKnow].
		mediumBlank.
		indentedBlock: aboutSystemDefinition.
		}
)
missingInfoMarker = (
^row: {
	blank: 3.
	(row: {(label: ' << fix it! ') color: Color yellow}) color: Color red
	}
)
navigateToPasteboard = (
enterSubject: PasteboardSubject new
)
navigateToWorkspaces = (
	enterSubject: ide theWorkspaceManager AllWorkspacesSubject new
)
noticeExposure = (
	"Whenever the page is revisited we want the recent stuff and the 'did you know' sections updated. They are created in holders, so a simple refresh will do that."

	refresh
)
recentStuffDefinition = (
^
	column1: {
		label: 'Packages' asText allBold.
		mediumBlank.
		column: (subject recentPackages collect: 
			[:each | link: each action: [browsePackage: each] fixTemps])
		}
	column2: {
		label: 'Categories' asText allBold.
		mediumBlank.
		column: (subject recentCategories collect: 
			[:each | linkToBrowseCategory: each]).
		}
	column3: {
		label: 'Classes' asText allBold.
		mediumBlank.
		list:
			((subject recentClassesForPresenter: self) collect: 
				[:each | 
				(ClassNamePresenter onSubject: each)
					highlightIfRecent: false]).
		}
)
respondToAboutSystem = (
	enterSubject: (SystemInformationSubject onModel: SmalltalkImage current)
)
respondToBrowseSourceControl = (
sendUp
	navigatorDo: [:navigator | navigator enterSubject: subject newSourceControlSubject]
)
respondToHelp = (
helpHolder setPresenters: {
	row: {
		filler.
		(link: 'close help' action: [helpHolder setPresenters: {}]) tinyFont.
	}.
	textDisplay: helpText.
}
)
respondToUndeclared = (
enterSubject:: UndeclaredReferencesSubject
				on: blackMarket Platform theSystemScope allUsersOfUndeclared
				)
textAndActionWisdom: wisdom = (
^
	column: {
		TextDisplayFragment new text: wisdom text.
		(link: wisdom actionLabel action: wisdom actionBlock) tinyFont
		}
)
textAndImageWisdom: wisdom = (
^
	row: {
		image: wisdom image.
		mediumBlank.
		elastic: 
			(TextDisplayFragment new text: wisdom text).
		}
)
undeclaredDefinition = (
Undeclared isEmpty ifTrue: [^nothing].
^link: 'Unresolved references (', Undeclared size asString, ')' action: [respondToUndeclared]
)) : ()
class HomeSubject onModel: m = Subject onModel: m (|  |)
('as yet unclassified'
= anotherSubject = (
"As there is just one possible logical home of the system, all subjects representing it are considered equal."

^self class = anotherSubject class
)
createPresenter = (

	^HomePresenter onSubject: self
)
newSourceControlSubject = (

	^ide theSourceManager mainSubject
)
recentCategories = (

	^ide defaultPopularityRecord categoryVisits asSortedList
)
recentClassesForPresenter: presenter <Presenter> = (

	| namesStillAround |
	namesStillAround:: ide defaultPopularityRecord classVisits
		reject: [:each | ([SystemMetadata classNamed: each inNamespace: Smalltalk] ifError: []) isNil].
	^namesStillAround collect:  
		[:each | 
		presenter subjectForClass: (SystemMetadata classNamed: each inNamespace: Smalltalk)]
)
recentPackages = (

	^ide defaultPopularityRecord packageVisits asSortedList
)
title = (
^'Home'
)'quips'
bitsOfWisdom = (
	"This defines the bits of wisdom displayed at the bottom of the Hopscotch home page. Each time a page opens a new element is selected at random. An element may evaluate to nil, which will select another element at random."
	
^
	{
	[BitOfWisdom text: 'Holding down the Shift key and clicking a link opens the link target in a new window. This also works for menu items and navigation buttons.'].
	
	[BitOfWisdom 
		text: 'Hold down the Shift key while clicking the "new window" toolbar button to open a copy of the current page instead of the default home page.'
		image: HopscotchImages default hsNewImage].

	[BitOfWisdom 
		text: 'The Refresh toolbar button rebuilds the current page from scratch. Use it if you suspect the current page got out of sync with the data it displays.'
		image: HopscotchImages default hsRefreshImage].

	[Undeclared size > 0 
		ifTrue:
			[BitOfWisdom 
				text: 'There are ', Undeclared size printString, ' entries in the Undeclared dictionary right now.'
				actionLabel: 'show them'
				actionBlock: [Undeclared inspect]]
		ifFalse: [nil]].

	[BitOfWisdom
		text: 'The following packages have unsaved modifications: ',
			(String streamContents: 
				[:s |
				(MCWorkingCopy registry select: [:each | each modified]) do:
					[:each | s cr; nextPutAll: each package name]])].

	[BitOfWisdom 
		text: 'This icon identifies a class whose language does not yet have a dedicated icon.'
		image: HopscotchImages default classUnknownImage].	

	[BitOfWisdom 
		text: 'This is the "expand all" button which appears in headers of expandable item groups.'
		image: HopscotchImages default hsExpandImage].
	
	[BitOfWisdom 
		text: 'This is the "collapse all" button which appears in headers of expandable item groups.'
		image: HopscotchImages default hsCollapseImage].

	[BitOfWisdom 
		text: 'This is the "add" button which appears in headers of groups of items you can add to, such as methods of a class or classes of a package.'
		image: HopscotchImages default hsAddImage].
	
	[BitOfWisdom 
		text: 'This is the "reorder" button. It appears in lists of methods and switches the method sort order. The default is to group methods by category, the alternative is to sort them alphabetically by selector ignoring the category.'
		image: HopscotchImages default hsReorderImage].
	
	[BitOfWisdom
		text: 'Recently visited classes are highlighted in yellow in category and package views to make them easier to notice.'].

	[BitOfWisdom 
		text: 'This icon indicates that the method is overridden in one of the subclasses.'
		image: HopscotchImages default itemSubOverride].
	
	[BitOfWisdom 
		text: 'This icon indicates that the method overrides one defined in a superclass.'
		image: HopscotchImages default itemSuperOverride].
	
	[BitOfWisdom 
		text: 'This icon indicates that the method both overrides one defined in a superclass and is overridden in one of the subclasses.'
		image: HopscotchImages default itemBothOverride].

	[BitOfWisdom
		text: 'You can search for multiple patterns simultaneously by separating the patterns with a semicolon. For example: "includes;contains".'].
	
	[BitOfWisdom
		text: 'By default, the search function finds anything that contains the search term. For example, a search for "foo" will find all of the following: "foo", "foos", "afoo" and "afoos". For a different match policy, include explicit wildcards. A * will match any number of any characters; a # will match any single character.'].

	[BitOfWisdom
		text: 'The colored bars on the right of class names in the category and package views are "heat maps" of the number of subclasses (blue) and the number of methods (green) of the classes. They make "important" and "big" classes easy to spot.'].
	

	}, 
	ide languageUiDescriptionRegistry bitsOfWisdom

)
lateNightWisdom = (

	^BitOfWisdom 
		text: 'It''s ', Time now printString, '. Go get some rest!'
)
randomBitOfWisdom = (

	| bits |
	Time now hour < 5 ifTrue: [^lateNightWisdom].
	bits:: bitsOfWisdom.
	^bits atRandom value ifNil: [randomBitOfWisdom]
)) : ('as yet unclassified'
new = (
	^onModel:nil
))
class JumpStationItemDragSource new = HopscotchSubjectDragSource (
"Experimental"| presenter |)
('as yet unclassified'
identifyPayloadTo: identificationReceiver = (
^identificationReceiver
	try: [identificationReceiver draggingJumpStationItem: presenter]
	or: [super identifyPayloadTo: identificationReceiver]
)) : ()
class JumpStationItemPresenter onSubject: s = Presenter onSubject: s (
"Experimental"|  |)
('as yet unclassified'
beWhite: definition = (
^(column: {definition}) color: Color white
)
createDragSource = (
^JumpStationItemDragSource new
	subject: subject originalSubject;
	presenter: self;
	wastelandTarget: HopscotchWastelandDropTarget new
)
definition = (
^
	beWhite: (
		padded: (
			column: {
				row: {
					elastic:: grabArea: nothing.
					linkImage: HopscotchImages default itemDeleteImage 
						action: [respondToDelete].
					}.
				link: subject originalSubject title
					action: [enterSubject: subject originalSubject].
			}
		)
		with: {5. 5. 5. 5}
	)
)
respondToDelete = (
sendUp deliveryOptional removeJumpStationItem: self
)) : ()
class JumpStationPresenter onSubject: s = Presenter onSubject: s (
"Experimental."| theCanvas itemBeingMoved pickUpOrigin pickUpOffset previousItem |)
('as yet unclassified'
createDropTargetFor: session <DragDropSession> ^<DropTarget | nil> = (
ifDraggingHopscotchSubject: session source 
	do: [:ignored <Subject> | ^createDropTargetForHopscotchSubject].
^nil
)
createDropTargetForHopscotchSubject = (
^DropTarget new
	entryAction: 
		[:s <DragSource> | introduceSubject: s subject];
	stepAction: 
		[:s <DragSource> | moveSubject: s subject];
	dropAction: 
		[:s <DragSource> | dropSubject: s subject];
	exitAction: 
		[:s <DragSource> | removeSubject: s subject]
)
createItemForSubject: droppedSubject <Subject> ^<JumpStationItemPresenter> = (
^JumpStationItemPresenter onSubject: 
	(PasteboardItemSubject onModel: droppedSubject refreshmentSubject)
)
definition = (
^canvas: {
	at: 5 @ 5 display: (label: 'Drag and drop things here').
}
dropTargetCreationBlock: [:session | createDropTargetFor: session]
)
ifDraggingHopscotchSubject: source <DropSource> do: action <[Subject]> = (
source identifyPayloadTo:
	(AdHocMessageReceiver new
		receive: #draggingHopscotchSubject:
		using: action)
)
onWhite: presenter = (
"Wrap up the presenter so that it has a white background."
^(column: {presenter}) color: Color white
)
randomColor = (
^{Color black. Color red. Color green. Color blue. Color yellow} atRandom
)
removeJumpStationItem: presenter <Presenter> = (
substance remove: presenter
)
viewport = (
"The default implementation builds a viewport that *contains* the visual of the presenter. Here the visual is already a viewport, and we don't want an extra one around it."
^visual
)'drag/drop-incoming'
dropSubject: subject <Subject> = (
previousItem notNil ifTrue:
	[substance addItem: 
		((CanvasLineBetweenItems from: previousItem to: itemBeingMoved)
			showArrow: true;
			arrowColor: randomColor)].
previousItem:: itemBeingMoved.
itemBeingMoved:: nil
)
introduceSubject: subject <Subject> = (
| newItem |
newItem:: createItemForSubject: subject.
itemBeingMoved:: substance add: newItem at: substance visual mousePoint.
)
moveSubject: subject <Subject> = (
substance moveItem: itemBeingMoved to: visual mousePoint
)
removeSubject: subject <Subject> = (
substance removeItem: itemBeingMoved.
itemBeingMoved:: nil
)) : ()
class JumpStationSubject onModel:m = Subject onModel: m (
"Experimental."|  |)
('as yet unclassified'
= another = (
^self class = another class
)
createPresenter = (
^JumpStationPresenter onSubject: self
)
hash = (
^self class hash
)
title = (
^'Jumpstation'
)) : ()
class PackagePresenter onSubject: s = ProgrammingPresenter onSubject: s (
"Presents a PackageSubject as a block with the package name on the left and a list of package category names on the right. This presenter is used as an element of the ''systemscape'' view of packages and categories."| categoriesManagerX prefixesManagerX |)
('accessing'
categoriesManager = (

	^categoriesManagerX
)
categoriesManager: list = (

	categoriesManagerX:: list.
	^list
)
prefixesManager = (

	^prefixesManagerX
)
prefixesManager: list = (

	prefixesManagerX:: list.
	^list
)'actions'
createCategoryFromTemplate: template = (

	| newName |
	newName:: categoryNameFromTemplateText: template text.
	(Smalltalk organization categories includes: newName) ifTrue:
		[^self].
	Smalltalk organization addCategory: newName.
	prefixesManager remove: template.
	categoriesManager refresh
)'as yet unclassified'
addCategory = (

	prefixesManager add:
		(OneLineDefinitionTemplate new
			caption: definitionTemplateCaption;
			acceptResponse:
				[:template |
				createCategoryFromTemplate: template];
			cancelResponse:
				[:template | prefixesManager remove: template])
)'definition'
definition = (
^
	row: {
		packagePart
			width: 0 elasticity: 4.
		smallBlank.
		(column: {
			prefixesManager:: list.
			categoriesManager:: list: 
				[subject retrieveCategories collect:
					[:each | linkToBrowseCategory: each]].
			})
			width: 0 elasticity: 6.
		}
)
packagePart = (

	| part |
	part:: row: {
		link: subject packageName asText allBold
			action: [browsePackage: subject packageName].
		filler.
		(link: 'add' action: [addCategory]) tinyFont.
		"addButtonWithAction: [addCategory]."
		}.
	^subject packageIsRecent
		ifTrue: [part color: recentlyVisitedColor]
		ifFalse: [part]
)'private'
categoryNameFromTemplateText: text = (

	^subject packageName, '-',  text asString
)
definitionTemplateCaption = (

	^subject packageName, '-'
)
linkToBrowseCategory: categoryName = (

	| link |
	link:: super linkToBrowseCategory: categoryName.
	^(ide defaultPopularityRecord categoryVisits
		includes: categoryName)
			ifTrue: [(row: {link}) color: recentlyVisitedColor]
			ifFalse: [link]
)) : ()
class PackageSubject onModel: m = Subject onModel: m (
"Represents a perspective on a package as a collection of categories. The classes contained by the categories are not included. The model is the package name."|  |)
('accessing'
title = (

	^packageName, ' package'
)'as yet unclassified'
= anotherSubject = (

	^anotherSubject class == self class
		and: [anotherSubject model = model]
)
hash = (

	^model hash
)
packageIsRecent = (

	^ide defaultPopularityRecord packageVisits
		includes: packageName
)
packageName = (

	^model
)
withPackageDo: action ifAbsent: absentAction = (
| organizer package |
organizer:: PackageOrganizer default.
package:: organizer packageNamed: model ifAbsent: [^absentAction value].
^action value: package
)'copying'
postCopy = (

	super postCopy.
	categories:: nil
)'private'
createPresenter = (

	^PackagePresenter onSubject: self
)
retrieveCategories ^<Collection[Symbol]> = (
"Answer a collection of category names contained by the package."
^withPackageDo: [ :package | package systemCategories]
	ifAbsent: [Array new]
)
retrieveExtensions ^<Collection[MethodReference]> = (
"Answer a collection of category names contained by the package."
^withPackageDo: [ :package | package extensionMethods]
	ifAbsent: [Array new]
)) : ()
class PackageWithClassesPresenter onSubject: s = ProgrammingPresenter onSubject: s (
"Presents a package (as a PackageWithClassesSubject) as essentially a list of ClassCategoryPresenters."| contentManager |)
('actions'
collapseAll = (

	majorUpdate: [contentManager presenters do: [:each | each collapse]]
)
expandAll = (

	majorUpdate: [contentManager presenters do: [:each | each expand]]
)'as yet unclassified'
extensionMethodsDefinition = (
| toggle subjects |
subjects:: subject extensionMethodSubjects.
toggle::
	heading: (link: 'Extension Methods' action: [toggle toggle])
	details: (AssortedMethodsPresenter onSubject: subjects).
^subjects isEmpty ifTrue: [{}] ifFalse: [{toggle}]
)
respondToAcceptCategory: template <DefinitionTemplate> = (
| catname |
catname:: subject packageName, '-'.
catname:: catname, template text asString withBlanksTrimmed.
catname:: catname asSymbol.
Smalltalk organization addCategory: catname.
contentManager remove: template.
contentManager add: (expandableViewOf: (ClassCategorySubject onModel: catname))
)
respondToAddCategory = (
	| template |

	template:: OneLineDefinitionTemplate new
		caption: subject packageName, '-';
		acceptResponse: [ :t | respondToAcceptCategory: t];
		cancelResponse: [contentManager remove: template].
	contentManager add: template
)
respondToScm = (
	| pkg |
	pkg:: theSourceManager mainSubject subjectFor: subject packageName.
	nil = pkg
		ifTrue: [confirm: subject packageName, ' is not under source control.']
		ifFalse: [sendUp navigatorDo: [:navigator | navigator enterSubject: pkg]]
)'definition'
definition = (

	contentManager:: list:
		[extensionMethodsDefinition,
		(subject categorySubjects collect: 
			[:each | expandableViewOf: each])].
^
	column: {
		minorHeadingBlock: (
			row: {
				label: subject packageName asText allBold.
				largeBlank.
				(link: subject revisions action: [respondToScm]) tinyFont.
				largeBlank.
				addButtonWithAction: [respondToAddCategory].
				filler.
				expandButtonWithAction: [expandAll].
				blank: 3.
				collapseButtonWithAction: [collapseAll].
				}).
		smallBlank.
		contentManager
		}
)
expandableViewOf: categorySubject = (

	| toggle |
	toggle::
		collapsed: 
			(link: categorySubject name 
			action: [browseClassCategory: categorySubject name])
		expanded: 
			(ClassCategoryPresenter onSubject: categorySubject).
	^toggle
)) : ()
class PackageWithClassesSubject onModel:m = PackageSubject onModel:m (
"Extends the perspective of a package to be a collection of category subjects (and therefore classes of those categories) rather than just category names. Reports the categories it contains as #categorySubjects, where each category subject is a ClassCategorySubject."|  |)
('as yet unclassified'
categorySubjects = (

	^retrieveCategories collect:
		[:each | ClassCategorySubject onModel: each]
)
createPresenter = (

	^PackageWithClassesPresenter onSubject: self
)
extensionMethodSubjects = (

	^retrieveExtensions collect:
		[ :each <MethodReference> | MethodSubject on: each]
)
revisions ^<String> = (
| pkg |
pkg:: MCPackage named: model asString.
^String streamContents: [ :s |
	pkg hasWorkingCopy ifTrue: [
		pkg workingCopy ancestry ancestors
			do: [ :ancestor | s nextPutAll: (ancestor name findTokens: '-') last]
			separatedBy: [s nextPutAll: ', ']	]]
)) : ()
class PasteboardItemPresenter onSubject:s = Presenter onSubject:s (
""|  |)
('as yet unclassified'
backgroundColor = (
^Gradient 
	from: (Color h: 40 s: 0 v: 0.95)
	to: (Color h: 40 s: 0 v: 0.88)
)
bodyBlock: definition = (
^(
padded: 
	(row: {
		elastic: definition.
		blank: 5.
		closeButton.
	})
with: {3. 8. 5. 8}
) 
	color: backgroundColor
)
closeButton = (
^imageButton: 
	{HopscotchImages default itemDeleteImage}
action: 
	[respondToClose]
)
definition = (
^column: {
	blank: 3.
	bodyBlock: 
		(collapsed: (label: subject originalSubject title)
		expanded: originalContent).
	blank: 3
	}
)
originalContent = (
^(padded: subject originalPresenter with: {1. 1. 1. 1}) 
	color: Color white
)
respondToClose = (
sendUp deliveryOptional removePasteboardItem: self
)
xbodyBlock: definition = (
^padded: 
	(row: {
		elastic: definition.
		blank: 5.
		closeButton.
	})
with: {3. 8. 5. 8}
roundedCornersColor: backgroundColor
)) : ()
class PasteboardItemSubject onModel:m = Subject onModel:m (
""|  |)
('as yet unclassified'
createPresenter = (

	^PasteboardItemPresenter onSubject: self
)
originalPresenter = (
^model presenter
)
originalSubject = (
"Rename for clarity."
^model
)
refreshmentSubject = (
^super refreshmentSubject model: model refreshmentSubject
)) : ()
class PasteboardPresenter onSubject: s = Presenter onSubject: s (
""| things |)
('as yet unclassified'
areaColor = (
^Color gray: 0.9
)
clearPasteboard = (
subject removeAll.
things presenters: {}
)
collapsibleEntryFor: droppedSubject = (
| toggle |
toggle:: expanded: droppedSubject presenter
	collapsed: (link: droppedSubject title action: [toggle toggle]).
^toggle
)
definition = (

	things:: 
		list: [subject presenters]
		dropExpecting: #draggingHopscotchSubject: 
		action: [:index :args | insertSubject: args first afterIndex: index].
	^column: {
		blank: 3.
		dropAreaLabelled: 'drag and drop here to add content'.
		blank: 3.
		things.
		}
)
dropAreaLabelled: labelString = (
^row: {
	elastic: (centered: ((label: labelString) color: labelColor)).
	button: 'Clear' action: [clearPasteboard].
}
)
entryFor: droppedSubject = (
^droppedSubject presenter
)
expandableEntryFor: droppedSubject = (
| toggle |
toggle:: collapsed: (link: droppedSubject title action: [toggle toggle])
	expanded: droppedSubject presenter.
^toggle
)
ifInterestedInDragAt: windowRelativePoint <Point> 
forSession: session <DragDropSession>
doWithTarget: targetBlock = (
	(visual windowRelativeBounds containsPoint: windowRelativePoint) ifTrue:
		[targetBlock value: things target]
)
insertSubject: droppedSubject <Subject> afterIndex: index <Integer> = (
| itemSubject |
itemSubject:: PasteboardItemSubject onModel: droppedSubject refreshmentSubject.
subject add: itemSubject afterIndex: index.
things add: itemSubject presenter afterIndex: index
)
labelColor = (
^Color white
)
receiveRequestFrom: dispatcher ^<Boolean> = (
	"Receive and process a notice coming from one of the children (usually as the result of using #sendUp or #sendDown)."

	(self respondsTo: dispatcher selector) ifTrue: 
		[dispatcher message sendTo: self.
		^true].
	^false
)
removePasteboardItem: item = (
subject remove: item subject.
things remove: item
)
viewportColor = (
^Color gray: 0.5
)) : ()
class PasteboardSubject onModel:m = Subject onModel:m (
""|  |model:: OrderedCollection new)
('as yet unclassified'
= anotherSubject = (
^self class = anotherSubject class
)
add: itemSubject <PasteboardItemSubject> afterIndex: index <Integer> = (
model add: itemSubject afterIndex: index
)
createPresenter = (

	^PasteboardPresenter onSubject: self
)
hash = (
^1
)
presenters = (
^model collect: [:each | each presenter]
)
refreshmentSubject = (
^super refreshmentSubject
	model: (model collect: [:each | each refreshmentSubject])
)
remove: itemSubject <PasteboardItemSubject> = (
model remove: itemSubject
)
removeAll = (
model:: OrderedCollection new.
)
title = (
^'Pasteboard'
)) : ('as yet unclassified'
new = (
	^self onModel:nil
))
class SearchResultsPresenter onSubject:s = ProgrammingPresenter onSubject:s (
""|  |)
('as yet unclassified'
classSearchResults = (
^
	incrementalList:
		[:s |
		subject classesMatches do:
			[:each | | classSubject |
			classSubject:: subjectForClass: each.
			s nextPut:
				(collapsed: (ClassNamePresenter onSubject: classSubject)
					expanded: [classSubject presenter] fixTemps)]]
)
classesSection = (
 subject classesMatches isEmpty ifTrue: [
     ^ nothing.
  ] ifFalse: [
     ^ sectionWithHeader: 'Classes' andContents: classSearchResults.
  ].	
)
packageSearchResults = (
^
	incrementalList:
		[:s |
		subject packageMatches do:
			[:packageInfo |
			s nextPut:
				(link: packageInfo packageName action: [browsePackage: packageInfo packageName] fixTemps).
			] fixTemps]
)
packagesSection = (
  subject packageMatches isEmpty ifTrue: [
     ^ nothing.
  ] ifFalse: [
     ^ sectionWithHeader: 'Packages' andContents: packageSearchResults.
  ].	
)
searchFeedback = (
 subject searchSuggestions isEmpty 
      ifTrue: [^ nothing] 
      ifFalse: [
	  ^ sectionWithHeader: 'Did you mean?' andContents: searchSuggestions.
	].	
)
searchSuggestions = (
^ incrementalList: [:s |
	subject searchSuggestions do: [:suggestion | s nextPut: (link: suggestion action: [ enterSubject: (SearchResultsSubject onModel: suggestion)] fixTemps). ] fixTemps
   ].	
)
sectionWithHeader: theHeader andContents: theContents = (
^ column: {minorHeadingBlock: (label: (theHeader asText allBold)). indentedBlock: theContents. }	
)
selectorSearchResults = (
^
	incrementalList:
		[:s |
		subject selectorsMatches do:
			[:each |
			s nextPut:
				(collapsed: (linkToBrowseSelector: each)
				expanded: [SelectorPresenter onSubject: (SelectorSubject onModel: each)] fixTemps).
			] fixTemps]
)
selectorsSection = (
 subject selectorsMatches isEmpty ifTrue: [
     ^ nothing.
  ] ifFalse: [
     ^ sectionWithHeader: 'Selectors' andContents: selectorSearchResults.
  ].	
)'definition'
definition = (
^
	column: {		
		( deferred: [searchFeedback]).
		( initially: (label: 'Searching packages') deferred: [packagesSection] ).
		( initially: (label: 'Searching Classes') deferred: [classesSection] ).
		( initially: (label: 'Search Selectors') deferred: [selectorsSection] ).
		}
)) : ()
class SearchResultsSubject onModel: searchTerm <String> = Subject onModel: searchTerm ( 
""| classesMatches selectorsMatches packageMatches searchSuggestions |findClassMatches.
	findSelectorMatches.
	findPackageMatches.
	createSuggestions)
('accessing'
title = (

	^'Search for "', model, '"'
)'as yet unclassified'
createSuggestions = (
	| foundNoResults <Boolean> names <Set[String]> |
	
	foundNoResults:: true.
	classesMatches isEmpty ifFalse:[foundNoResults:: false].
	selectorsMatches isEmpty ifFalse:[foundNoResults:: false].
	packageMatches isEmpty ifFalse:[foundNoResults:: false].
	foundNoResults ifFalse:[searchSuggestions:: Set new. ^self].

	names:: blackMarket Set new: 200.
	blackMarket Platform theSystemScope allClassesDo:[:each | names add: (each simpleName)].
	PackageOrganizer default packages do:[:each | names add: (each packageName)].
	Symbol allSymbols do:[:each | names add: each].
	
	searchSuggestions:: (model correctAgainst: names).
)
searchPatterns ^<Array[String]> = (
"Produce a collection of the specific search pattern to use. The model is the raw input provided by the user and may include multiple patterns."

| parts |
parts:: model findTokens: ';'.
parts:: parts collect: [:each | each withBlanksTrimmed].
parts:: parts select: [:each | each notEmpty].
parts:: parts collect:
	[:each |
	(each includesAnyOf: '*#')
		ifTrue: [each]
		ifFalse: [('"*"' match: each)
				ifTrue: [each copyFrom: 2 to: each size - 1]
				ifFalse: ['*', each, '*']]].
^parts
)'private'
createPresenter = (

	^SearchResultsPresenter onSubject: self
)
findClassMatches = (

	| collected patterns |
	collected:: Set new: 20.
	patterns:: searchPatterns. "compute once"
	blackMarket Platform theSystemScope allClassesDo:
		[ :cls |
		patterns do:
			[ :pattern | (pattern match: cls simpleName) ifTrue: [ collected add: cls ]]].
	classesMatches:: (collected asSortedList:
		[:a :b | a name < b name]) asArray
)
findPackageMatches = (

	| collected packages |
	collected:: Set new: 20.
	packages:: PackageOrganizer default packages.
	searchPatterns do: 
		[:pattern |
		collected addAll: (packages select: 
			[:packageInfo | pattern match: packageInfo packageName])].
	packageMatches:: collected asSortedList: [:a :b | a packageName < b packageName].
)
findSelectorMatches = (

	| collected |
	collected:: Set new: 20.
	searchPatterns do: 
		[:each |
		collected addAll: (Symbol selectorsMatching: each)].
	selectorsMatches:: properlySorted: collected.
)
properlySorted: selectors = (

	| lower upper |
	lower:: OrderedCollection new: selectors size.
	upper:: OrderedCollection new: selectors size // 2.
	selectors do:
		[:each |
		each first isUppercase
			ifTrue: [upper add: each ]
			ifFalse: [lower add: each]].
	^lower asSortedList asArray, upper asSortedList
)) : ()
class SystemInformationPresenter onSubject: s = Presenter onSubject: s (
"Implements the 'About this system' page usually accessible from the start page.

   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"|  |)
('as yet unclassified'
definition = (

	^holder: "Everything is in a holder so that noticeExposure refreshes it"
		[column: {
			title: 'System version:' text: subject systemName.
			title: 'Image path: ' text: subject imageFullPathName.
			title: 'OS version: ' text: subject osVersion.
			title: 'VM version: ' text: subject vmVersion.
			subject squeakVersion ifNotNil: 
				[:sqv |
				title: 'Squeak version: ' text: sqv].
			title: 'VM path: ' text: subject vmFullPathName.
		}
	]
)
noticeExposure = (
	"Whenever the page is revisited we want the information updated. The send below ensures that anything created inside a holder is refreshed."

	refresh
)
title: title text: text = (
	^column: {
		label: title asText allBold.
		blank: 10.
		row: {
			blank: 15.
			textDisplay: text}.
		blank: 15.
		}
)) : ()
class SystemInformationSubject onModel: m = Subject onModel: m (
"My model is a SmalltalkImage.

   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"|  |)
('as yet unclassified'
= somethingElse = (
	^somethingElse class = self class
)
createPresenter = (

	^SystemInformationPresenter onSubject: self
)
hash = (
	^self class hash
)
imageFullPathName = (
	^model imageName asString
)
osVersion = (
	^model osVersion asString
)
squeakVersion = (
	#BOGUS yourself.
	^'?'
)
systemName = (
	^SmalltalkImage current datedVersion asString
)
title = (
	^'About ', vmName
)
vmFullPathName = (

	^model getSystemAttribute: 0
)
vmName = (
	^blackMarket Platform theSystemScope systemName
)
vmVersion = (
	^model vmVersion asString
)) : ()
class SystemscapePresenter onSubject: s = ProgrammingPresenter onSubject: s (
""|  |)
('definition'
definition = (
^
	column: 
		headerElements,
		unpackagedElements,
		packageElements
)
headerElements = (
^
	{majorHeadingBlock:
		(label: 'Packages and Categories' asText allBold).
	mediumBlank}
)
packageElements = (

	| elements |
	elements:: OrderedCollection new.
	subject retrieveSortedPackageNames 
		do: [:each | elements add: (PackageSubject onModel: each) presenter]
		separatedBy: [elements add: mediumBlank].
	^elements
)
unpackagedElements = (
^
	{UnpackagedCategoriesSubject new presenter.
	mediumBlank
	}
)) : ()
class SystemscapeSubject new = Subject onModel:nil (
""|  |)
('accessing'
title = (

	^'System Source'
)'as yet unclassified'
retrieveSortedPackageNames = (

	| names |
	names:: PackageInfo allPackages collect: [:each | each packageName].
	^names asSortedCollection
)'private'
createPresenter = (

	^SystemscapePresenter onSubject: self
)) : ()
class UndeclaredReferencesPresenter onSubject:s = AssortedMethodsPresenter onSubject:s (
"This presenter is simply a reimplementation of its superclass to ask its subject the subjects to create presenters for."|  |)
('accessing'
methodsGroupedByPackage = (

	| packages |
	packages:: Dictionary new.
	subject references do: 
		[:aSubject |
		(packageOfMethod: aSubject) ifNotNil:
			[:aPackage |
			(packages 
				at: aPackage packageName
				ifPresent: [:e|e] 
				ifAbsentPut: [OrderedCollection new]) add: aSubject]].
	^packages
)) : ()
class UndeclaredReferencesSubject onModel:m = Subject onModel:m (
"This subject provides the prespective on the references of Undeclared throughout the system.   Those methods in the system that are using Undeclared can be found by:

	SystemScope theModule allUsersOfUndeclared 

This will return a collection of MethodReferences.   This subject's model holds onto this collection (it is the client of UndeclaredUsersSubject's responsibility to ask SystemScope)."| |)
('as yet unclassified'
= other = (
^class = other class
)
createPresenter = (

	^UndeclaredReferencesPresenter onSubject: self
)
hash = (
^class hash
)
references = (

	^model collect: [ :ea | MethodSubject on: ea]
)
refreshmentSubject = (

	^self class on: blackMarket Platform theSystemScope allUsersOfUndeclared
)
title = (

	^'Undeclared References (', Undeclared size asString, ')'
)) : ('as yet unclassified'
on: references <SequenceableCollection[MethodSubject]> = (

	^(onModel: references) 
))
class UnpackagedCategoriesPresenter onSubject: s = PackagePresenter onSubject: s (
""|  |)
('as yet unclassified'
categoryNameFromTemplateText: text = (

	^text asString
)
packagePart = (

	^row: {
		label: '(unpackaged)'.
		filler.
		(link: 'add' action: [addCategory]) tinyFont.
		"addButtonWithAction: [addCategory]."
		}
)'private'
definitionTemplateCaption = (

	^'New category: '
)) : ()
class UnpackagedCategoriesSubject onModel:m = Subject onModel:m (
"Represents a perspective similar to PackageSubject, but for those categories that do not belong to a package."|  |)
('as yet unclassified'
createPresenter = (

	^UnpackagedCategoriesPresenter onSubject: self
)
retrieveCategories = (

	| allCategories packageOrganizer |
	allCategories:: Smalltalk organization categories asSet.
	packageOrganizer:: PackageOrganizer default.
	packageOrganizer packages do:
		[:each |
		each systemCategories do:
			[:eachCategory |
			allCategories remove: eachCategory ifAbsent: []]].
	^allCategories asSortedCollection
)) : ('as yet unclassified'
new = (
	^onModel: nil
))
class UnsavedChangesPresenter onSubject:s = ProgrammingPresenter onSubject:s (
""|  |)
('accessing'
title = (

	^'Unsaved Changes'
)'actions'
forceCloseBrowser = (

	sendUp navigatorDo: [:shell | shell forceCloseWindow]
)
showHistory = (

	sendUp navigatorDo: [:shell | shell showHistory]
)'definition'
definition = (
^
	column: {
		(column: {
			blank: 50.
			centered: (label: 'This browser contains unsaved edits.').
			largeBlank.
			centered: 
				(row: {
					button: 'Show Them' action: [showHistory].
					mediumBlank.
					button: 'Close Anyway' action: [forceCloseBrowser]
					}).
			blank: 50.
			})
			color: (Gradient from:(Color h:0 s: 0.5 v: 0.8) to: (Color h:0 s: 0.5 v: 0.6)).
		centered: (label: '(this page is under construction)').
		mediumBlank.
		}
)'testing'
isTransient = (

	^true
)) : ('as yet unclassified'
new = (
	^self onSubject: nil
))'as yet unclassified'
flag: x = (
	
)) : ()