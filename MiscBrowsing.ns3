Newspeak3
'HopscotchIDE'
class MiscBrowsing usingPlatform: p ide: ide = (
(* Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2011 Ryan Macnak and other contributors.
Copyright 2012 Cadence Design Systems, Inc.
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)||
	private Smalltalk = p blackMarket Smalltalk.
	private Preferences = p blackMarket System Preferences.
	private SmalltalkImage = p blackMarket System SmalltalkImage.
	private Undeclared = p blackMarket Undeclared.
	private Utilities = p blackMarket System Utilities.
	private HopscotchImages = p blackMarket Hopscotch HopscotchImages.
	private PackageOrganizer = p blackMarket Smalltalk at: #PackageOrganizer.
	private MCPackage = p blackMarket Monticello MCPackage.
	private MCWorkingCopy = p blackMarket Monticello MCWorkingCopy.
	private MCWorkingCopyBrowser = p squeak MCWorkingCopyBrowser.
	private PackageInfo = p blackMarket Smalltalk at: #PackageInfo.
	private Language = p blackMarket NsMultilanguage Language.
	private SystemOrganization = p blackMarket SystemOrganization.
	private SystemMetadata = p blackMarket NewsqueakMixins SystemMetadata.
	private blackMarket = p blackMarket.
	
      private Color = p graphics Color.
	private ObjectMirror = p mirrors ObjectMirror.
	private Time = p time Time.
	private Subject = p hopscotch core Subject.
	private Presenter = p hopscotch core Presenter.
	private TextEditorFragment = p hopscotch fragments TextEditorFragment.
	private TextDisplayFragment = p hopscotch fragments TextDisplayFragment.
	private EditableLinePresenter = p hopscotch fragments EditableLinePresenter.
	private OrderedCollection = p collections OrderedCollection.
	private Dictionary = p collections Dictionary.
	private Set = p collections Set.
	private Gradient = p brazil plumbing Gradient.
	private NewspeakObject = Object.
	private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	private platform = p.
	
	ide = ide.
	systemScope = ide systemScope.
	EditableDefinitionPresenter = ide tools EditableDefinitionPresenter.
	DefinitionListPresenter = ide tools DefinitionListPresenter.
	ProgrammingPresenter = ide tools ProgrammingPresenter.
	AssortedMethodsPresenter = ide browsing AssortedMethodsPresenter.
	AssortedMethodsSubject = ide browsing AssortedMethodsSubject.
	MethodSubject = ide browsing MethodSubject.
	SelectorPresenter = ide browsing SelectorPresenter.
	SelectorSubject = ide browsing SelectorSubject.
	ClassCommentPresenter = ide tools ClassCommentPresenter.
	ClassNamePresenter = ide tools ClassNamePresenter.
	DefinitionTemplate = ide tools DefinitionTemplate.
	OneLineDefinitionTemplate = ide tools OneLineDefinitionTemplate.
	Workspace = ide theWorkspaceManager Workspace.
	ClassActionsPresenter = ide browsingNS3 ClassActionsPresenter.
||)
(
class BitOfWisdom new = Object (
(*  *)| text image actionLabel actionBlock |)
() : ('as yet unclassified'
text: aString = (

	^self new text: aString
)
text: aString actionLabel: labelString actionBlock: aBlock = (

	^self new 
		text: aString;
		actionLabel: labelString;
		actionBlock: aBlock
)
text: aString image: aForm = (

	^self new
		text: aString;
		image: aForm
))
class ClassCategoryPresenter onSubject: s = DefinitionListPresenter onSubject: s (
(* Displays a class category as a collection of lines identifying the classes in the category, expandable into full class presenters. *)| categoryNamePresenter |)
('as yet unclassified'
acceptNewClassDefinitionFrom: aTemplate = (

	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
addClassTemplate = (

	prefixes add:
		(DefinitionTemplate new
			caption: 'Defining a new class:';
			initialText: subject classTemplateText;
			colorizerBlock: [:text | subject colorizeClassSource: text];
			acceptResponse: 
				[:template | acceptNewClassDefinitionFrom: template];
			cancelResponse:
				[:template | prefixes remove: template])
)
captionForClassSubject: aSubject = (

	^row: {
		ClassNamePresenter onSubject: aSubject.
		maybeShowRunTestLinkFor: (Array with: aSubject).
		filler.
		(deferred: [subclassCountLabelFor: aSubject]) width: 25.
		blank: 5.
		(deferred: [methodCountLabelFor: aSubject]) width: 30.
		}
)
contentPresenters = (

	^(subject classSubjects) collect:
		[:each |
		expandableLineForClassSubject: each]
)
expandableLineForClassSubject: aSubject = (

	| toggle |
	toggle::
		collapsed: [captionForClassSubject: aSubject]
		expanded: [aSubject presenter].
	toggle onUserToggled: [toggle requestVisibility].
	^toggle
)
maybeShowRunTestLink = (
	^nothing
	
	(* | subjects |
	subjects:: subject classSubjectsUsingReflection: reflection.
	^maybeShowRunTestLinkFor: subjects *)
)
respondToRename = (
categoryNamePresenter enterEditState
)'definition'
definition = (
^
	column: {
		minorHeadingBlock: (
			row: {
				[categoryNamePresenter:: EditableClassCategoryPresenter onSubject: subject.
				categoryNamePresenter] value.
				mediumBlank.
				linkImage: HopscotchImages default editImage
					action: [respondToRename].
				largeBlank.
				packageLink.
				largeBlank.
				(* (link: 'docs' 
					action: [browseClassCategoryDocs: subject model]) tinyFont.
				largeBlank.
				(link: 'convert' 
					action: [respondToConvert]) tinyFont.
				largeBlank.		*)
				addButtonWithAction: [addClassTemplate].
				deferred: [maybeShowRunTestLink].
				filler.
				expandButtonWithAction: [expandAll].
				blank: 3.
				collapseButtonWithAction: [collapseAll].
				}
			).
		mediumBlank.
		super definition.
		mediumBlank.
		}
)
maybeShowRunTestLinkFor: collectionOfSubjects = (

	^nothing
	(* | testCases |
	testCases:: (collectionOfSubjects select: [:aSubject | aSubject isTestCase]).	
	testCases:: (testCases collect: [:aSubject | aSubject model]) asSet.

	^testCases notEmpty 
		ifTrue:
			[row: {
				smallBlank.
				(link: 'tests' action: [respondToRunTestsUsing: (testCases)]) tinyFont
			}]
		ifFalse: [nothing] *)
)
packageLink = (
^
	(subject packageName
		ifNil: [label: '(no package)']
		ifNotNil: 
			[:packageName |
			link: packageName action: [browsePackage: packageName]])
				tinyFont
)'private-color patches'
brightnessForN: n midpoint: gamma = (
	(* Return the value of brightness to use for the number of elements n, with the constraints that the brightness for 0 is 1, the brightness for gamma is 0.5 and the brighness asymptotically approaches 0 as n increases. *)

	^(gamma / (gamma + n)) asFloat
)
methodCountLabelFor: aSubject = (

	| count brightness caption holder |
	count:: aSubject methodCount.
	brightness:: brightnessForN: count midpoint: 40.
	caption:: (label: count printString) tinyFont.
	caption color: ((brightness < 0.7)
		ifTrue: [Color white]
		ifFalse: [Color black]).
	^(row: {filler. caption. blank: 5}) 
		color: (patchColorWithHue: 170 value: brightness)
)
patchColorWithHue: hue value: brightness = (

	^Color h: hue s: 1 - brightness v: brightness
)
subclassCountLabelFor: aSubject = (

	| count brightness caption holder |
	count:: aSubject totalSubclassCount.
	brightness:: brightnessForN: count midpoint: 20.
	caption:: (label: count printString) tinyFont.
	caption color: ((brightness < 0.8)
		ifTrue: [Color white]
		ifFalse: [Color black]).
	^(row: {filler. caption. blank: 5}) 
		color: (patchColorWithHue: 210 value: brightness)
)) : ()
class ClassCategorySubject onModel: m = Subject onModel: m (
(* Represents a viewpoint of a class category as a collection of classes. The model is the category name. *)|  |)
('accessing'
classSubjects = (

	^retrieveClasses collect: 
		[:each | 
		flag: #BOGUS. (* calling onto the presenter may not be right *)
		presenter subjectForClass: each]
)
classTemplateText = (
^
'class ClassNameHere = (
(*Describe the class in this comment.*)
|
	slot1
	slot2
|
) ()'
)
title = (

	^model, ' category'
)'as yet unclassified'
= anotherSubject = (

	^anotherSubject class == self class
		and: [anotherSubject model = model]
)
addClassFromDefinition: definitionString ifSuccess: successBlock ifFailure: failureBlock = (
		
	| builder mixin klass |
	[builder:: ClassDeclarationBuilder fromSource: definitionString]
		on: Error
		do: [:ex | ^failureBlock value: ex description].
	(Smalltalk includesKey: builder simpleName) ifTrue:
		[^failureBlock value: 'A top-level class named ', builder simpleName, ' already exists'].
	mixin:: builder install reflectee.
	klass:: mixin apply: Object withName: builder simpleName.
	Smalltalk at: klass name put: klass.
	klass mixin category: model.
	SystemOrganization classify: klass name under: model.
	successBlock value
)
colorizeClassSource: sourceText <String | Text> ^<Text> = (
^ide browsingNS3 NS3Colorizer new
	parseText: sourceText asString
	fromClass: Object
	usingSelector: #classDeclaration
)
hash = (

	^model hash
)
name = (

	^model
)
packageName ^<String | nil> = (

	^(PackageInfo allPackages 
		detect: [:some | some includesSystemCategory: model]
		ifNone: [^nil])
			packageName
)
rename: newName ifSuccessful: successAction ifFailed: failAction = (

	(SystemOrganization categories includes: newName)
		ifTrue: [^failAction value: newName asString, ' already exist'].
	(newName select: [:each | Character lf = each or: [Character cr = each]]) isEmpty not
		ifTrue: [^failAction value: 'Cannot contain newlines.'].
	SystemOrganization renameCategory: model toBe: newName.
	model:: newName.
	^successAction value
)'private'
createPresenter = (

	^ClassCategoryPresenter onSubject: self
)
retrieveClasses = (

	^((Smalltalk organization listAtCategoryNamed: model)
		collect: [:each | Smalltalk at: each])
		reject: [:each | each isNil]
)) : ()
class DeletedClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(*  *)|  |)
('as yet unclassified'
definition = (
^
	majorHeadingBlock:
		(label: 'Class ', subject className, ' has been deleted.    * sniff *')
)) : ()
class DeletedClassSubject onModel: m = Subject onModel: m (
(* Represents a class that has been deleted from the system. The model is the name of the class. *)|  |)
('as yet unclassified'
className = (

	^model
)
createPresenter = (

	^DeletedClassPresenter onSubject: self
)
title = (

	^className, ' (deleted class)'
)) : ()
class EditableClassCategoryPresenter onSubject: s = EditableLinePresenter onSubject: s (
(* Presents an editory for renaming a class category. *)|  |)
('actions'
browseClassCategory: categoryName <Symbol> = (

	ide defaultPopularityRecord
		rememberCategoryVisit: categoryName.
	enterSubject: (ClassCategorySubject onModel: categoryName)
)'as yet unclassified'
definitionText = (

	^subject model asString
)
respondToAccept = (
(* A subclass must redefine this to do whatever is needed to be done with <editor text> to save its as the new state of the subject, and send #leaveEditState if the save was successful. *)
| newName |
newName:: editor text asString asSymbol.
subject rename: newName ifSuccessful: [leaveEditState] ifFailed: [:reason |]
)
viewerDefinition = (

	^link: [subject title asText allBold]
		action: [browseClassCategory: subject model]
)) : ()
class HomePresenter onSubject: s = ProgrammingPresenter onSubject: s (
(*  *)| helpHolder  |)
('as yet unclassified'
aboutSystemDefinition = (

	^(link: 'About this system' action: [respondToAboutSystem]) smallFont.
)
column1: definitions1 column2: definitions2 column3: definitions3 = (
^row: {
	(column: definitions1) width: 0 elasticity: 1.
	(column: definitions2) width: 0 elasticity: 1.
	(column: definitions3) width: 0 elasticity: 1.
	}
)
definition = (
  ^homePageDefinition
)
didYouKnow = (

	| wisdom |
	wisdom:: subject randomBitOfWisdom.
	wisdom actionLabel notNil ifTrue:
		[^textAndActionWisdom: wisdom].
	wisdom image notNil ifTrue:
		[^textAndImageWisdom: wisdom].
	^TextDisplayFragment new text: wisdom text
)
helpButton = (
^helpText isNil
	ifTrue: [nothing]
	ifFalse: [(link: '[?]' action: [respondToHelp]) tinyFont]
)
helpText ^<String | nil> = (
(* If this method answers a string, a help button will appear on the Home page. Clicking on that button will display the string. *)
^'This is the home page. You can always return to the home page of a Newspeak browser by clicking on the home icon at the top of the browser. 
The home page includes links to a variety of useful places, like recently visited classes and packages, the source control page and more. 
If you look at the list of classes, you will see each class has a round icon next to it. The icon tells you which language the class is written in; the current system mixes Smalltalk and Newspeak code. So, for example, a gray icon represents Smalltalk. Golden icons represent Newspeak3, which is the currently operational dialect of Newspeak.'
)
homePageDefinition = (
	helpHolder:: list.
^
	column: {
		helpHolder.
		majorHeadingBlock: (
			row: {
				label: 'Navigation' asText allBold.
				filler.
				helpButton.
			}
		).
		mediumBlank.
		
		indentedBlock:
			(column1: {
				link: 'System Source' asText allBold
					action: [browseSystem].
				link: 'Namespace' asText allBold
					action: [enterSubject:: NamespaceSubject new].
				link: 'MemoryHole' asText allBold
					action: [enterSubject: ide vcs ui mainSubject]
				}
			column2: {
				link: 'Pasteboard'
					action: [navigateToPasteboard].
				undeclaredDefinition.
				}
			column3: {
					link: 'Workspaces'
						action: [navigateToWorkspaces].
					link: 'Under the Hood'
						action: [navigateToQueries]
				}
			).
		mediumBlank.

		majorHeadingBlock: (label: 'Recently Visited' asText allBold).
		mediumBlank.
		indentedBlock:
			(holder: [recentStuffDefinition]).
		largeBlank.
		
		majorHeadingBlock: (label: 'Did you know?' asText allBold).
		smallBlank.
		indentedBlock:
			(holder: [didYouKnow]).
		mediumBlank.
		indentedBlock: aboutSystemDefinition.
		}
)
navigateToPasteboard = (
enterSubject: PasteboardSubject new
)
navigateToQueries = (
enterSubject: QueriesSubject new
)
navigateToWorkspaces = (
	enterSubject: ide theWorkspaceManager AllWorkspacesSubject new
)
noticeExposure = (
	(* Whenever the page is revisited we want the recent stuff and the 'did you know' sections updated. They are created in holders, so a simple refresh will do that. *)

	refresh
)
recentStuffDefinition = (
^
	column1: {
		label: 'Packages' asText allBold.
		mediumBlank.
		column: (subject recentPackages collect: 
			[:each | link: each action: [browsePackage: each]])
		}
	column2: {
		label: 'Categories' asText allBold.
		mediumBlank.
		column: (subject recentCategories collect: 
			[:each | linkToBrowseCategory: each]).
		}
	column3: {
		label: 'Classes' asText allBold.
		mediumBlank.
		list:
			((subject recentClassesForPresenter: self) collect: 
				[:each | 
				(ClassNamePresenter onSubject: each)
					highlightIfRecent: false]).
		}
)
respondToAboutSystem = (
	enterSubject: (SystemInformationSubject onModel: SmalltalkImage current)
)
respondToHelp = (
helpHolder setPresenters: {
	row: {
		filler.
		(link: 'close help' action: [helpHolder setPresenters: {}]) tinyFont.
	}.
	textDisplay: helpText.
}
)
respondToUndeclared = (
	enterSubject:: 
		UndeclaredReferencesSubject on: systemScope allUsersOfUndeclared
)
textAndActionWisdom: wisdom = (
^
	column: {
		TextDisplayFragment new text: wisdom text.
		(link: wisdom actionLabel action: wisdom actionBlock) tinyFont
		}
)
textAndImageWisdom: wisdom = (
^
	row: {
		image: wisdom image.
		mediumBlank.
		elastic: 
			(TextDisplayFragment new text: wisdom text).
		}
)
undeclaredDefinition = (
Undeclared isEmpty ifTrue: [^nothing].
^link: 'Unresolved references (', Undeclared size asString, ')' action: [respondToUndeclared]
)) : ()
class HomeSubject onModel: m = Subject onModel: m (|  |)
('as yet unclassified'
= anotherSubject = (
(* As there is just one possible logical home of the system, all subjects representing it are considered equal. *)

^self class = anotherSubject class
)
createPresenter = (

	^HomePresenter onSubject: self
)
recentCategories = (

	^ide defaultPopularityRecord categoryVisits asSortedList
)
recentClassesForPresenter: presenter <Presenter> = (

	| namesStillAround |
	namesStillAround:: ide defaultPopularityRecord classVisits
		reject: [:each | ([SystemMetadata classNamed: each inNamespace: Smalltalk] ifError: []) isNil].
	^namesStillAround collect:  
		[:each | 
		presenter subjectForClass: (SystemMetadata classNamed: each inNamespace: Smalltalk)]
)
recentPackages = (

	^ide defaultPopularityRecord packageVisits asSortedList
)
title = (
^'Home'
)'quips'
bitsOfWisdom = (
	(* This defines the bits of wisdom displayed at the bottom of the Hopscotch home page. Each time a page opens a new element is selected at random. An element may evaluate to nil, which will select another element at random. *)
	
^
	{
	[BitOfWisdom text: 'Holding down the Shift key and clicking a link opens the link target in a new window. This also works for menu items and navigation buttons.'].
	
	[BitOfWisdom 
		text: 'Hold down the Shift key while clicking the "new window" toolbar button to open a copy of the current page instead of the default home page.'
		image: HopscotchImages default hsNewImage].

	[BitOfWisdom 
		text: 'The Refresh toolbar button rebuilds the current page from scratch. Use it if you suspect the current page got out of sync with the data it displays.'
		image: HopscotchImages default hsRefreshImage].

	[Undeclared size > 0 
		ifTrue:
			[BitOfWisdom 
				text: 'There are ', Undeclared size printString, ' entries in the Undeclared dictionary right now.'
				actionLabel: 'show them'
				actionBlock: [Undeclared inspect]]
		ifFalse: [nil]].

	[BitOfWisdom
		text: 'The following packages have unsaved modifications: ',
			(String streamContents: 
				[:s |
				(MCWorkingCopy registry select: [:each | each modified]) do:
					[:each | s cr; nextPutAll: each package name]])].

	[BitOfWisdom 
		text: 'This icon identifies a class whose language does not yet have a dedicated icon.'
		image: HopscotchImages default classUnknownImage].	

	[BitOfWisdom 
		text: 'This is the "expand all" button which appears in headers of expandable item groups.'
		image: HopscotchImages default hsExpandImage].
	
	[BitOfWisdom 
		text: 'This is the "collapse all" button which appears in headers of expandable item groups.'
		image: HopscotchImages default hsCollapseImage].

	[BitOfWisdom 
		text: 'This is the "add" button which appears in headers of groups of items you can add to, such as methods of a class or classes of a package.'
		image: HopscotchImages default hsAddImage].
	
	[BitOfWisdom 
		text: 'This is the "reorder" button. It appears in lists of methods and switches the method sort order. The default is to group methods by category, the alternative is to sort them alphabetically by selector ignoring the category.'
		image: HopscotchImages default hsReorderImage].
	
	[BitOfWisdom
		text: 'Recently visited classes are highlighted in yellow in category and package views to make them easier to notice.'].

	[BitOfWisdom 
		text: 'This icon indicates that the method is overridden in one of the subclasses.'
		image: HopscotchImages default itemSubOverride].
	
	[BitOfWisdom 
		text: 'This icon indicates that the method overrides one defined in a superclass.'
		image: HopscotchImages default itemSuperOverride].
	
	[BitOfWisdom 
		text: 'This icon indicates that the method both overrides one defined in a superclass and is overridden in one of the subclasses.'
		image: HopscotchImages default itemBothOverride].

	[BitOfWisdom
		text: 'You can search for multiple patterns simultaneously by separating the patterns with a semicolon. For example: "includes;contains".'].
	
	[BitOfWisdom
		text: 'By default, the search function finds anything that contains the search term. For example, a search for "foo" will find all of the following: "foo", "foos", "afoo" and "afoos". For a different match policy, include explicit wildcards. A * will match any number of any characters; a # will match any single character.'].

	[BitOfWisdom
		text: 'The colored bars on the right of class names in the category and package views are "heat maps" of the number of subclasses (blue) and the number of methods (green) of the classes. They make "important" and "big" classes easy to spot.'].
	
	[BitOfWisdom
		text: 'War is peace. Freedom is slavery. Ignorance is strength.'].
	}, 
	ide languageUiDescriptionRegistry bitsOfWisdom

)
lateNightWisdom = (

	^BitOfWisdom 
		text: 'It''s ', Time now printString, '. Go get some rest!'
)
randomBitOfWisdom = (

	| bits |
	Time now hour < 5 ifTrue: [^lateNightWisdom].
	bits:: bitsOfWisdom.
	^bits atRandom value ifNil: [randomBitOfWisdom]
)) : ('as yet unclassified'
new = (
	^onModel:nil
))
class NamespacePresenter onSubject: s = DefinitionListPresenter onSubject: s (|
|)
('as yet unclassified'
acceptNewClassDefinitionFrom: aTemplate = (
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
acceptNewNamespaceDefinitionFrom: aTemplate = (
	subject
		addNamespaceFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
addClassTemplate = (
	prefixes add:
		(DefinitionTemplate new
			caption: 'Defining a new class:';
			initialText: subject classTemplateText;
			colorizerBlock: [:text | subject colorizeClassSource: text];
			acceptResponse: 
				[:template | acceptNewClassDefinitionFrom: template];
			cancelResponse:
				[:template | prefixes remove: template])
)
addNamespaceTemplate = (
	prefixes add:
		(DefinitionTemplate new
			caption: 'Defining a new namespace:';
			initialText: 'NewNamespace';
			colorizerBlock: [:text | ];
			acceptResponse: 
				[:template | acceptNewNamespaceDefinitionFrom: template];
			cancelResponse:
				[:template | prefixes remove: template])
)
captionForClassSubject: cSubject = (

	(* BOGUS: we are displaying the class's name. we should display its key *)
	| part |
	part:: row1: {
		image: cSubject classUiDescription classIcon.
		smallBlank.
		link: [cSubject className (*asText allBold*)]
			action: [browseClassMirror: cSubject classMirror].
	} row2: {
		(row: {deferred: [(label: cSubject classCommentText withBlanksTrimmed)
			smallFont; 
			color: secondaryTextColor]})
				compressibility: 1.
		filler 
			compressibility: 0.
			
		(* In the face of namespace nesting, should application and test configuration be invoked with the root namespace or the local namespace? If the local namespace, these links only make sense in the context of the namespace view and should not be part of the class presenter itself. *)
		ClassActionsPresenter onSubject: cSubject.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: cSubject className].
	}.
	cSubject isRecentlyVisited ifTrue: [part color: recentlyVisitedColor].
	^part
)
classEntryAt: key for: klass = (
	| s = subjectForClass: klass. |
	^collapsed: [captionForClassSubject: s]
	expanded: [s presenter]
)
contentList = (
	^zebra: super contentList
)
contentPresenters = (
	^subject namespace keys asSortedList collect: 
		[:key | entryDefinitionAt: key for: (subject namespace at: key)]
)
definition = (
	^column: {
		minorHeadingBlock: (row: {
			label: subject key asText allBold.
			largeBlank.
			addButtonWithAction: [openMenuWithLabelsAndActions: {
				'Add Class' -> [addClassTemplate].
				'Add Namespace' -> [Error signal: 'Unimplemented'].
				'Add Image' -> [respondToAddImage].
				'Add Text' -> [respondToAddText].
				'Add Value' -> [Error signal: 'Unimplemented'].
				}].
			filler.
			expandButtonWithAction: [expandAll].
			blank: 3.
			collapseButtonWithAction: [collapseAll].
		}).
		smallBlank.
		super definition.
	}
)
entriesStringFor: ns = (
	^String streamContents: [:stm |
		ns keys
			do: [:key | stm nextPutAll: key] 
			separatedBy: [stm nextPutAll: ', ']]
)
entryActionsMenuFor: key = (
	^menuWithLabelsAndActions: {
		'Rename ',key -> [respondToRename].
		'Copy ',key -> [respondToCopy].
		'Remove ',key -> [subject namespace removeKey: key. refresh].
	}
)
entryDefinitionAt: key for: value = (
	([value isNamespace] ifError: [false])
		ifTrue: [^namespaceEntryAt: key for: value].
	([value isBehavior] ifError: [false])
		ifTrue: [^classEntryAt: key for: value].
	^valueEntryAt: key for: value
)
namespaceEntryAt: key for: namespace = (
	| nSubject = NamespaceSubject onModel: namespace key: key. |
	^collapsed:
		[ | part |
		part:: row1: 
			{image: HopscotchImages default classPresenterImage.
			smallBlank.
			link: key action: [
				ide defaultPopularityRecord
		rememberCategoryVisit: key. (* Should be the namespace itself, but non-strings break the home page. *)
				enterSubject:: nSubject].
		} row2: {
			(label: (entriesStringFor: namespace))
				smallFont; 
				compressibility: 1;
				color: secondaryTextColor.
			filler 
				compressibility: 0.
			mediumBlank.
			dropDownMenu: [entryActionsMenuFor: key]}.
		nSubject isRecentlyVisited
			ifTrue: [part color: recentlyVisitedColor]
			ifFalse: [part].
		]
	expanded:
		[nSubject presenter]
)
respondToAddImage = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Image files (*.png)' ->'*.png'}.
	fileRequester initialDirectory: (blackMarket FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key form |
		key:: (blackMarket FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		form:: blackMarket PNGReadWriter formFromFileNamed: fn.
		Smalltalk at: key asSymbol put: form.
	].
)
respondToAddText = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Text files (*.txt)' ->'*.txt'}.
	fileRequester initialDirectory: (blackMarket FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key text |
		key:: (blackMarket FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		text:: ((blackMarket MultiByteFileStream oldFileNamed: fn)
			converter: (blackMarket TextConverter newForEncoding: 'utf8')) contents.
		Smalltalk at: key asSymbol put: text.
	].
)
row1: row1 row2: row2 = (
	^row: {
		(row: row1) width: 0 elasticity: 1.
		(row: {mediumBlank}, row2) width: 0 elasticity: 2.5.
	}
)
valueEntryAt: key for: object = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^collapsed:
		[row1: {
			image: HopscotchImages default classUnknownImage.
			smallBlank.
			link: key action: [enterPresenter:: (objectSubjectFor: object) presenter selfCaption: key].
		} row2: {
			(label: object printString)
				smallFont; 
				compressibility: 1;
				color: secondaryTextColor.
			filler 
				compressibility: 0.
			mediumBlank.
			dropDownMenu: [entryActionsMenuFor: key]}]
	expanded:
		[(objectSubjectFor: object) presenter selfCaption: key]
)) : ()
class NamespaceSubject onModel: m key: k = Subject onModel: m (|
key = k.
|)
('as yet unclassified'
= other ^<Boolean> = (
	^class = other class 
		and: [model = other model]
		and: [key = other key].
)
addClassFromDefinition: definitionString ifSuccess: successBlock ifFailure: failureBlock = (
	| builder mixin klass |
	[builder:: ClassDeclarationBuilder fromSource: definitionString]
		on: Error
		do: [:ex | ^failureBlock value: ex description].
	(namespace includesKey: builder simpleName) ifTrue:
		[^failureBlock value: 'A class named ', builder simpleName, ' already exists in this namespace'].
	mixin:: builder install reflectee.
	klass:: mixin apply: Object withName: builder simpleName.
	namespace at: klass name put: klass.
	#BOGUS. (* Don't bother setting categories once Newspeak classes are out of the Smalltalk system dictionary. *)
	klass mixin category: 'Unclassified'.
	SystemOrganization classify: klass name under: 'Unclassified'.
	successBlock value
)
addNamespaceFromDefinition: definitionString ifSuccess: successBlock ifFailure: failureBlock = (
	| selector = definitionString asSymbol. |
	selector isUnary ifFalse:
		[^failureBlock value: 'Must be a unary selector'].
	(namespace includesKey: selector) ifTrue:
		[^failureBlock value: 'A class named ', definitionString, ' already exists in this namespace'].
	namespace at: selector put: (ide namespacing Namespace new).
	successBlock value
)
classTemplateText = (
^
'class ClassNameHere = (
(*Describe the class in this comment.*)
|
	slot1
	slot2
|
) ()'
)
colorizeClassSource: sourceText <String | Text> ^<Text> = (
^ide browsingNS3 NS3Colorizer new
	parseText: sourceText asString
	fromClass: Object
	usingSelector: #classDeclaration
)
createPresenter = (
	^NamespacePresenter onSubject: self
)
hash ^<Integer> = (
	^model hash bitXor: key hash
)
isRecentlyVisited = (
	(ide defaultPopularityRecord categoryVisits includes: key) 
		ifTrue: [^true].
		
	(* Should this be recursive? *)
	namespace keys do: [:key | 
		(ide defaultPopularityRecord classVisits includes: key) ifTrue: [^true]].
	^false
)
namespace = (
	^self model
)
refreshmentSubject = (
	^self class onModel: model key: key
)
title ^<String> = (
	^key
)) : ('as yet unclassified'
new = (
	^self onModel: ide namespacing Newspeak key: 'Newspeak'
))
class PackagePresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* Presents a PackageSubject as a block with the package name on the left and a list of package category names on the right. This presenter is used as an element of the ''systemscape'' view of packages and categories. *)| categoriesManagerX prefixesManagerX |)
('accessing'
categoriesManager = (

	^categoriesManagerX
)
categoriesManager: list = (

	categoriesManagerX:: list.
	^list
)
prefixesManager = (

	^prefixesManagerX
)
prefixesManager: list = (

	prefixesManagerX:: list.
	^list
)'actions'
createCategoryFromTemplate: template = (

	| newName |
	newName:: categoryNameFromTemplateText: template text.
	(Smalltalk organization categories includes: newName) ifTrue:
		[^self].
	Smalltalk organization addCategory: newName.
	prefixesManager remove: template.
	categoriesManager refresh
)'as yet unclassified'
addCategory = (

	prefixesManager add:
		(OneLineDefinitionTemplate new
			caption: definitionTemplateCaption;
			acceptResponse:
				[:template |
				createCategoryFromTemplate: template];
			cancelResponse:
				[:template | prefixesManager remove: template])
)'definition'
definition = (
^
	row: {
		packagePart
			width: 0 elasticity: 4.
		smallBlank.
		(column: {
			prefixesManager:: list.
			categoriesManager:: list: 
				[subject retrieveCategories collect:
					[:each | linkToBrowseCategory: each]].
			})
			width: 0 elasticity: 6.
		}
)
packagePart = (

	| part |
	part:: row: {
		link: subject packageName asText allBold
			action: [browsePackage: subject packageName].
		filler.
		(link: 'add' action: [addCategory]) tinyFont.
		(* addButtonWithAction: [addCategory]. *)
		}.
	^subject packageIsRecent
		ifTrue: [part color: recentlyVisitedColor]
		ifFalse: [part]
)'private'
categoryNameFromTemplateText: text = (

	^subject packageName, '-',  text asString
)
definitionTemplateCaption = (

	^subject packageName, '-'
)
linkToBrowseCategory: categoryName = (

	| link |
	link:: super linkToBrowseCategory: categoryName.
	^(ide defaultPopularityRecord categoryVisits
		includes: categoryName)
			ifTrue: [(row: {link}) color: recentlyVisitedColor]
			ifFalse: [link]
)) : ()
class PackageSubject onModel: m = Subject onModel: m (
(* Represents a perspective on a package as a collection of categories. The classes contained by the categories are not included. The model is the package name. *)|  |)
('accessing'
title = (

	^packageName, ' package'
)'as yet unclassified'
= anotherSubject = (

	^anotherSubject class == self class
		and: [anotherSubject model = model]
)
hash = (

	^model hash
)
packageIsRecent = (

	^ide defaultPopularityRecord packageVisits
		includes: packageName
)
packageName = (

	^model
)
withPackageDo: action ifAbsent: absentAction = (
| organizer package |
organizer:: PackageOrganizer default.
package:: organizer packageNamed: model ifAbsent: [^absentAction value].
^action value: package
)'copying'
postCopy = (

	super postCopy.
	categories:: nil
)'private'
createPresenter = (

	^PackagePresenter onSubject: self
)
retrieveCategories ^<Collection[Symbol]> = (
(* Answer a collection of category names contained by the package. *)
^withPackageDo: [ :package | package systemCategories]
	ifAbsent: [Array new]
)
retrieveExtensions ^<Collection[MethodReference]> = (
(* Answer a collection of category names contained by the package. *)
^withPackageDo: [ :package | package extensionMethods]
	ifAbsent: [Array new]
)) : ()
class PackageWithClassesPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* Presents a package (as a PackageWithClassesSubject) as essentially a list of ClassCategoryPresenters. *)| contentManager |)
('actions'
collapseAll = (

	majorUpdate: [contentManager presenters do: [:each | each collapse]]
)
expandAll = (

	majorUpdate: [contentManager presenters do: [:each | each expand]]
)'as yet unclassified'
extensionMethodsDefinition = (
| toggle subjects |
subjects:: subject extensionMethodSubjects.
toggle::
	heading: (link: 'Extension Methods' action: [toggle toggle])
	details: (AssortedMethodsSubject onModel: subjects) presenter.
^subjects isEmpty ifTrue: [{}] ifFalse: [{toggle}]
)
respondToAcceptCategory: template <DefinitionTemplate> = (
| catname |
catname:: subject packageName, '-'.
catname:: catname, template text asString withBlanksTrimmed.
catname:: catname asSymbol.
Smalltalk organization addCategory: catname.
contentManager remove: template.
contentManager add: (expandableViewOf: (ClassCategorySubject onModel: catname))
)
respondToAddCategory = (
	| template |

	template:: OneLineDefinitionTemplate new
		caption: subject packageName, '-';
		acceptResponse: [ :t | respondToAcceptCategory: t];
		cancelResponse: [contentManager remove: template].
	contentManager add: template
)
respondToScm = (
	MCWorkingCopyBrowser open
)'definition'
definition = (

	contentManager:: list:
		[extensionMethodsDefinition,
		(subject categorySubjects collect: 
			[:each | expandableViewOf: each])].
^
	column: {
		minorHeadingBlock: (
			row: {
				label: subject packageName asText allBold.
				largeBlank.
				(link: subject revisions action: [respondToScm]) tinyFont.
				largeBlank.
				addButtonWithAction: [respondToAddCategory].
				filler.
				expandButtonWithAction: [expandAll].
				blank: 3.
				collapseButtonWithAction: [collapseAll].
				}).
		smallBlank.
		contentManager
		}
)
expandableViewOf: categorySubject = (

	| toggle |
	toggle::
		collapsed: 
			(link: categorySubject name 
			action: [browseClassCategory: categorySubject name])
		expanded: 
			(ClassCategoryPresenter onSubject: categorySubject).
	^toggle
)) : ()
class PackageWithClassesSubject onModel:m = PackageSubject onModel:m (
(* Extends the perspective of a package to be a collection of category subjects (and therefore classes of those categories) rather than just category names. Reports the categories it contains as #categorySubjects, where each category subject is a ClassCategorySubject. *)|  |)
('as yet unclassified'
categorySubjects = (

	^retrieveCategories collect:
		[:each | ClassCategorySubject onModel: each]
)
createPresenter = (

	^PackageWithClassesPresenter onSubject: self
)
extensionMethodSubjects ^ <Collection[MethodSubject]> = (

	^retrieveExtensions collect:
		[ :each <MethodReference> | MethodSubject onMethod: each]
)
revisions ^<String> = (
| pkg |
pkg:: MCPackage named: model asString.
^String streamContents: [ :s |
	pkg hasWorkingCopy ifTrue: [
		pkg workingCopy ancestry ancestors
			do: [ :ancestor | s nextPutAll: (ancestor name findTokens: '-') last]
			separatedBy: [s nextPutAll: ', ']	]]
)) : ()
class PasteboardItemPresenter onSubject:s = Presenter onSubject:s (
(*  *)|  |)
('as yet unclassified'
backgroundColor = (
^Gradient 
	from: (Color h: 40 s: 0 v: 0.95)
	to: (Color h: 40 s: 0 v: 0.88)
)
bodyBlock: definition = (
^(
padded: 
	(row: {
		elastic: definition.
		blank: 5.
		closeButton.
	})
with: {3. 8. 5. 8}
) 
	color: backgroundColor
)
closeButton = (
^imageButton: 
	{HopscotchImages default itemDeleteImage}
action: 
	[respondToClose]
)
definition = (
^column: {
	blank: 3.
	bodyBlock: 
		(collapsed: (label: subject originalSubject title)
		expanded: originalContent).
	blank: 3
	}
)
originalContent = (
^(padded: subject originalPresenter with: {1. 1. 1. 1}) 
	color: Color white
)
respondToClose = (
sendUp deliveryOptional removePasteboardItem: self
)) : ()
class PasteboardItemSubject onModel:m = Subject onModel:m (
(*  *)|  |)
('as yet unclassified'
createPresenter = (

	^PasteboardItemPresenter onSubject: self
)
originalPresenter = (
^model presenter
)
originalSubject = (
(* Rename for clarity. *)
^model
)
refreshmentSubject = (
^super refreshmentSubject model: model refreshmentSubject
)) : ()
class PasteboardPresenter onSubject: s = Presenter onSubject: s (
(*  *)| things |)
('as yet unclassified'
areaColor = (
^Color gray: 0.9
)
clearPasteboard = (
subject removeAll.
things presenters: {}
)
collapsibleEntryFor: droppedSubject = (
| toggle |
toggle:: expanded: droppedSubject presenter
	collapsed: (link: droppedSubject title action: [toggle toggle]).
^toggle
)
definition = (

	things:: 
		list: [subject presenters]
		dropExpecting: #draggingHopscotchSubject: 
		action: [:index :args | insertSubject: args first afterIndex: index].
	^column: {
		blank: 3.
		dropAreaLabelled: 'drag and drop here to add content'.
		blank: 3.
		things.
		}
)
dropAreaLabelled: labelString = (
^row: {
	elastic: (centered: ((label: labelString) color: labelColor)).
	button: 'Clear' action: [clearPasteboard].
}
)
entryFor: droppedSubject = (
^droppedSubject presenter
)
expandableEntryFor: droppedSubject = (
| toggle |
toggle:: collapsed: (link: droppedSubject title action: [toggle toggle])
	expanded: droppedSubject presenter.
^toggle
)
ifInterestedInDragAt: windowRelativePoint <Point> 
forSession: session <DragDropSession>
doWithTarget: targetBlock = (
	(visual windowRelativeBounds containsPoint: windowRelativePoint) ifTrue:
		[targetBlock value: things target]
)
insertSubject: droppedSubject <Subject> afterIndex: index <Integer> = (
| itemSubject |
itemSubject:: PasteboardItemSubject onModel: droppedSubject refreshmentSubject.
subject add: itemSubject afterIndex: index.
things add: itemSubject presenter afterIndex: index
)
labelColor = (
^Color white
)
receiveRequestFrom: dispatcher ^<Boolean> = (
	(* Receive and process a notice coming from one of the children (usually as the result of using #sendUp or #sendDown). *)

	(self respondsTo: dispatcher selector) ifTrue: 
		[dispatcher message sendTo: self.
		^true].
	^false
)
removePasteboardItem: item = (
subject remove: item subject.
things remove: item
)
viewportColor = (
^Color gray: 0.5
)) : ()
class PasteboardSubject onModel:m = Subject onModel:m (
(*  *)|  |model:: OrderedCollection new)
('as yet unclassified'
= anotherSubject = (
^self class = anotherSubject class
)
add: itemSubject <PasteboardItemSubject> afterIndex: index <Integer> = (
model add: itemSubject afterIndex: index
)
createPresenter = (

	^PasteboardPresenter onSubject: self
)
hash = (
^1
)
presenters = (
^model collect: [:each | each presenter]
)
refreshmentSubject = (
^super refreshmentSubject
	model: (model collect: [:each | each refreshmentSubject])
)
remove: itemSubject <PasteboardItemSubject> = (
model remove: itemSubject
)
removeAll = (
model:: OrderedCollection new.
)
title = (
^'Pasteboard'
)) : ('as yet unclassified'
new = (
	^self onModel:nil
))
class QueriesPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* A presenter for queries such as browseAllSelect: *)| queries |)
('as yet unclassified'
definition = (
	^column: {
		majorHeadingBlock:
			(label: 'Under the Hood' asText allBold).
		mediumBlank.
		link: 'platform' action: [respondToInspectPlatform].
		link: 'ide' action: [respondToInspectIde].
		link: 'memoryHole' action: [respondToInspectMemoryHole].
		mediumBlank.
		holder: [installationStatus].
		mediumBlank.
		holder: [experimentalStatus].
		largeBlank.
		queries:: list: {QuerySubject new presenter}.
		button: 'Add Query' action: [respondToAddQuery] }
)
experimentalStatus = (
	^ide experimental
		ifTrue: [link: 'Disable experimental features'
				action: [ide experimental: false. refresh]]
		ifFalse: [link: 'Enable experimental features'
				action: [ide experimental: true. refresh]]
)
installationStatus = (
	shell isDebugger & shell isInNamespace ifTrue:
		[^column: {
			textDisplay: 'This is an ordinary IDE instance. It is affected by changes to the IDE and platform code in the namespace and is the debugger of unhandled exceptions.'.
			link: 'Open a supervisor IDE.' action: [respondToOpenSupervisorIDE]}].

	shell isDebugger & shell isInNamespace not ifTrue:
		[^column: {
			textDisplay: 'This is the supervisor IDE instance. It IS NOT affected by changes to the IDE and platform code in the namespace and IS the debugger of unhandled exceptions.'.
			link: 'Open a supervisee window.' action: [respondToOpenSuperviseeWindow]}].

	shell isDebugger not & shell isInNamespace ifTrue:
		[^column: {
			textDisplay: 'This is a supervisee IDE instance. It IS affected by changes to the IDE and platform code in the namespace and IS NOT the debugger of unhandled exceptions.'.
			link: 'Open a supervisor window.' action: [respondToOpenSupervisorWindow].
			link: 'Takeover debugging (become ordinary IDE instance).' action: [respondToBecomeDebugger]}].
	
	^column: {
		textDisplay: 'This is an orphaned IDE instance. It IS NOT affected by changes to the IDE and platform code in the namespace and IS NOT the debugger of unhandled exceptions.'.
		link: 'Open a supervisor/ordinary window.' action: [respondToOpenSupervisorWindow].
		link: 'Takeover debugging (become ordinary IDE instance).' action: [respondToBecomeDebugger]
	}
)
respondToAddQuery = (
	queries add: QuerySubject new presenter
)
respondToBecomeDebugger = (
	blackMarket BlackMarket ide: ide.
	refresh.
	shell updateToolbar.
)
respondToInspectIde = (
	inspect: ide yourself
)
respondToInspectMemoryHole = (
	inspect: ide vcs yourself
)
respondToInspectPlatform = (
	inspect: platform yourself
)
respondToOpenSuperviseeWindow = (
	((blackMarket HopscotchIDEApp packageUsing: ide namespacing manifestForSqueak)
		main: platform args: {})
			IDEWindow open.
	refresh.
	shell updateToolbar.
)
respondToOpenSupervisorIDE = (
	|
	HopscotchIDEApp = blackMarket HopscotchIDEApp.
	RuntimeForSqueak = blackMarket RuntimeForSqueak.
	Deployment = blackMarket Deployment.
	runtime = Deployment nofDeepCopy: (RuntimeForSqueak packageUsing: ide namespacing manifestForSqueak).
	ideapp = Deployment nofDeepCopy: (HopscotchIDEApp packageUsing: ide namespacing manifestForSqueak).
	safePlatform = runtime using: blackMarket VMMirror new.
	|
	blackMarket BlackMarket ide: (ideapp main: safePlatform args: {}).
	blackMarket BlackMarket ide IDEWindow open.
	refresh.
	shell updateToolbar.
)
respondToOpenSupervisorWindow = (
	blackMarket ide IDEWindow open.
	refresh.
	shell updateToolbar.
)) : ()
class QueriesSubject onModel: m = Subject onModel: m (
(* A subject for queries such as browseAllSelect: *))
('as yet unclassified'
= other = (
	^self class = other class
		and: [self model = other model]
)
createPresenter = (^QueriesPresenter onSubject: self)
hash = (
	^self class hash bitXor: self model hash
)
title = (
	^'Under the Hood'
)) : ('as yet unclassified'
new = (
	^self onModel: nil
))
class QueryPresenter onSubject: s = ProgrammingPresenter onSubject: s ( (* A presenter for queries such as browseAllSelect: *)||)
('as yet unclassified'
definition = (
	| mfwText |
	mfwText:: TextEditorFragment new text: '[:m | booleanExpression]'.
	mfwText changeResponse: [].
	^row: {
			button: 'methods for which'	
				action: [respondToMethodsForWhichWith: mfwText].
			blank: 10.
			elastic: mfwText
		}
)
respondToMethodsForWhichWith: mfwText <TextEditorFragment> = (	
	| text block results MethodReference |
	text:: mfwText textBeingAccepted.	
	mfwText removeMessages.
	block:: ((ObjectMirror reflecting: mfwText editor)
		evaluate: text asString
		withBlackMarket: Workspace new
		ifCompilerError: [:e | ^mfwText addMessage: e description]
		ifError: [:e | halt]) reflectee.
	block isBlock ifFalse: [^self].
	results:: systemScope allSelect: block.
	MethodReference:: blackMarket System MethodReference.
	enterSubject: ((outer MiscBrowsing AssortedMethodsSubject onModel: (results
		collect: [:pair| 
			MethodSubject onMethod: (MethodReference class: pair first selector: pair last)]))
				title: 'Selected Methods';
				yourself)
)) : ()
class QuerySubject onModel: m = Subject onModel: m ( (* A subject for queries such as browseAllSelect: *)||)
('as yet unclassified'
createPresenter = (^QueryPresenter onSubject: self)) : ('as yet unclassified'
new = (
	^self onModel: nil
))
class SearchResultsPresenter onSubject:s = ProgrammingPresenter onSubject:s (
(*  *)|  |)
('as yet unclassified'
classSearchResults = (
^
	incrementalList:
		[:s |
		subject classesMatches do:
			[:each | | classSubject |
			classSubject:: subjectForClass: each.
			s nextPut:
				(collapsed: (ClassNamePresenter onSubject: classSubject)
					expanded: [classSubject presenter])]]
)
classesSection = (
 subject classesMatches isEmpty ifTrue: [
     ^ nothing.
  ] ifFalse: [
     ^ sectionWithHeader: 'Classes' andContents: classSearchResults.
  ].	
)
packageSearchResults = (
	^incrementalList: [:s |
		subject packageMatches do: [:packageInfo |
			s nextPut:
				(link: packageInfo packageName
				action: [browsePackage: packageInfo packageName])]]
)
packagesSection = (
  subject packageMatches isEmpty ifTrue: [
     ^ nothing.
  ] ifFalse: [
     ^ sectionWithHeader: 'Packages' andContents: packageSearchResults.
  ].	
)
searchFeedback = (
 subject searchSuggestions isEmpty 
      ifTrue: [^ nothing] 
      ifFalse: [
	  ^ sectionWithHeader: 'Did you mean?' andContents: searchSuggestions.
	].	
)
searchSuggestions = (
	^incrementalList: [:s |
		subject searchSuggestions do: [:suggestion |
			s nextPut: 
				(link: suggestion
				action: [ enterSubject:(SearchResultsSubject onModel: suggestion)])]].	
)
sectionWithHeader: theHeader andContents: theContents = (
^ column: {minorHeadingBlock: (label: (theHeader asText allBold)). indentedBlock: theContents. }	
)
selectorSearchResults = (
	^incrementalList: [:s |
		subject selectorsMatches do: [:each |
			s nextPut:
				(collapsed: (linkToBrowseSelector: each)
				expanded: [SelectorPresenter onSubject: (SelectorSubject onModel: each)])]]
)
selectorsSection = (
 subject selectorsMatches isEmpty ifTrue: [
     ^ nothing.
  ] ifFalse: [
     ^ sectionWithHeader: 'Selectors' andContents: selectorSearchResults.
  ].	
)'definition'
definition = (
^
	column: {		
		( deferred: [searchFeedback]).
		( initially: (label: 'Searching packages') deferred: [packagesSection] ).
		( initially: (label: 'Searching Classes') deferred: [classesSection] ).
		( initially: (label: 'Search Selectors') deferred: [selectorsSection] ).
		}
)) : ()
class SearchResultsSubject onModel: searchTerm <String> = Subject onModel: searchTerm (|
includeSynthetics <Boolean> ::= searchTerm includes: $`.
classesMatches <List[Class | Mixin]>
selectorsMatches <List[Symbol]>
packageMatches <List[PackageInfo]>
searchSuggestions <List[Symbol]>
|findClassMatches.
	findSelectorMatches.
	findPackageMatches.
	createSuggestions)
('accessing'
title = (

	^'Search for "', model, '"'
)'as yet unclassified'
createSuggestions = (
	| foundNoResults <Boolean> names <Set[String]> |
	
	foundNoResults:: true.
	classesMatches isEmpty ifFalse:[foundNoResults:: false].
	selectorsMatches isEmpty ifFalse:[foundNoResults:: false].
	packageMatches isEmpty ifFalse:[foundNoResults:: false].
	foundNoResults ifFalse:[searchSuggestions:: Set new. ^self].

	names:: blackMarket Set new: 200.
	systemScope allClassesDo: [:each | names add: (each simpleName)].
	PackageOrganizer default packages do:[:each | names add: (each packageName)].
	Symbol allSymbols do:[:each | names add: each].
	
	searchSuggestions:: (model correctAgainst: names).
)
searchPatterns ^<Array[String]> = (
(* Produce a collection of the specific search pattern to use. The model is the raw input provided by the user and may include multiple patterns. *)

| parts |
parts:: model findTokens: ';'.
parts:: parts collect: [:each | each withBlanksTrimmed].
parts:: parts select: [:each | each notEmpty].
parts:: parts collect:
	[:each |
	(each includesAnyOf: '*#')
		ifTrue: [each]
		ifFalse: [('"*"' match: each)
				ifTrue: [each copyFrom: 2 to: each size - 1]
				ifFalse: ['*', each, '*']]].
^parts
)'private'
createPresenter = (

	^SearchResultsPresenter onSubject: self
)
findClassMatches = (

	| collected patterns |
	collected:: Set new: 20.
	patterns:: searchPatterns. (* compute once *)
	systemScope allClassesDo:
		[ :cls |
		patterns do:
			[ :pattern | (pattern match: cls simpleName) ifTrue: [ collected add: cls ]]].
	classesMatches:: (collected asSortedList:
		[:a :b | a simpleName < b simpleName]) asArray
)
findPackageMatches = (

	| collected packages |
	collected:: Set new: 20.
	packages:: PackageOrganizer default packages.
	searchPatterns do: 
		[:pattern |
		collected addAll: (packages select: 
			[:packageInfo | pattern match: packageInfo packageName])].
	packageMatches:: collected asSortedList: [:a :b | a packageName < b packageName].
)
findSelectorMatches = (

	| collected |
	collected:: Set new: 20.
	searchPatterns do: 
		[:each |
		collected addAll: (Symbol selectorsMatching: each)].
	includeSynthetics ifFalse:
		[collected removeAllSuchThat: [:each | each includes: $`].
		collected removeAllSuchThat: [:each | each includes: $ ]].
	selectorsMatches:: properlySorted: collected.
)
properlySorted: selectors = (

	| lower upper |
	lower:: OrderedCollection new: selectors size.
	upper:: OrderedCollection new: selectors size // 2.
	selectors do:
		[:each |
		each first isUppercase
			ifTrue: [upper add: each ]
			ifFalse: [lower add: each]].
	^lower asSortedList asArray, upper asSortedList
)) : ()
class SystemInformationPresenter onSubject: s = Presenter onSubject: s (
(* Implements the 'About this system' page usually accessible from the start page.

   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)|  |)
('as yet unclassified'
definition = (

	^holder: (* Everything is in a holder so that noticeExposure refreshes it *)
		[column: {
			title: 'System version:' text: subject systemName.
			title: 'Image path: ' text: subject imageFullPathName.
			title: 'OS version: ' text: subject osVersion.
			title: 'VM version: ' text: subject vmVersion.
			subject squeakVersion ifNotNil: 
				[:sqv |
				title: 'Squeak version: ' text: sqv].
			title: 'VM path: ' text: subject vmFullPathName.
		}
	]
)
noticeExposure = (
	(* Whenever the page is revisited we want the information updated. The send below ensures that anything created inside a holder is refreshed. *)

	refresh
)
title: title text: text = (
	^column: {
		label: title asText allBold.
		blank: 10.
		row: {
			blank: 15.
			textDisplay: text}.
		blank: 15.
		}
)) : ()
class SystemInformationSubject onModel: m = Subject onModel: m (
(* My model is a SmalltalkImage.

   Copyright 2008 Cadence Design Systems, Inc.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)|  |)
('as yet unclassified'
= somethingElse = (
	^somethingElse class = self class
)
createPresenter = (

	^SystemInformationPresenter onSubject: self
)
hash = (
	^self class hash
)
imageFullPathName = (
	^model imageName asString
)
osVersion = (
	^model osVersion asString
)
squeakVersion = (
	#BOGUS yourself.
	^'?'
)
systemName = (
	^SmalltalkImage current datedVersion asString
)
title = (
	^'About ', vmName
)
vmFullPathName = (

	^model getSystemAttribute: 0
)
vmName = (
	^systemScope systemName
)
vmVersion = (
	^model vmVersion asString
)) : ()
class SystemscapePresenter onSubject: s = ProgrammingPresenter onSubject: s (
(*  *)|  |)
('definition'
definition = (
^
	column: 
		headerElements,
		unpackagedElements,
		packageElements
)
headerElements = (
^
	{majorHeadingBlock:
		(label: 'Packages and Categories' asText allBold).
	mediumBlank}
)
packageElements = (

	| elements |
	elements:: OrderedCollection new.
	subject retrieveSortedPackageNames 
		do: [:each | elements add: (PackageSubject onModel: each) presenter]
		separatedBy: [elements add: mediumBlank].
	^elements
)
unpackagedElements = (
^
	{UnpackagedCategoriesSubject new presenter.
	mediumBlank
	}
)) : ()
class SystemscapeSubject new = Subject onModel:nil (
(*  *)|  |)
('accessing'
title = (

	^'System Source'
)'as yet unclassified'
retrieveSortedPackageNames = (

	| names |
	names:: PackageInfo allPackages collect: [:each | each packageName].
	^names asSortedCollection
)'private'
createPresenter = (

	^SystemscapePresenter onSubject: self
)) : ('as yet unclassified'
onModel: m = (
(* This method gets called when refreshing the system view *)
	^new
))
class UndeclaredReferencesPresenter onSubject:s = AssortedMethodsPresenter onSubject:s (
(* This presenter is simply a reimplementation of its superclass to ask its subject the subjects to create presenters for. *)|  |)
('accessing'
methodsGroupedByPackage = (

	| packages |
	packages:: Dictionary new.
	subject references do: 
		[:aSubject |
		(packageOfMethod: aSubject) ifNotNil:
			[:aPackage |
			(packages 
				at: aPackage packageName
				ifPresent: [:e|e] 
				ifAbsentPut: [OrderedCollection new]) add: aSubject]].
	^packages
)) : ()
class UndeclaredReferencesSubject onModel:m = Subject onModel:m (
(* This subject provides the prespective on the references of Undeclared throughout the system.   Those methods in the system that are using Undeclared can be found by:

	SystemScope theModule allUsersOfUndeclared 

This will return a collection of MethodReferences.   This subject's model holds onto this collection (it is the client of UndeclaredUsersSubject's responsibility to ask SystemScope). *)| |)
('as yet unclassified'
= other = (
^class = other class
)
createPresenter = (

	^UndeclaredReferencesPresenter onSubject: self
)
hash = (
^class hash
)
references ^ <Collection[MethodSubject]> = (

	^model collect: [ :ea | MethodSubject onMethod: ea]
)
refreshmentSubject = (

	^self class on: systemScope allUsersOfUndeclared
)
title = (

	^'Undeclared References (', Undeclared size asString, ')'
)) : ('as yet unclassified'
on: references <SequenceableCollection[MethodSubject]> = (

	^(onModel: references) 
))
class UnpackagedCategoriesPresenter onSubject: s = PackagePresenter onSubject: s (
(*  *)|  |)
('as yet unclassified'
categoryNameFromTemplateText: text = (

	^text asString
)
packagePart = (

	^row: {
		label: '(unpackaged)'.
		filler.
		(link: 'add' action: [addCategory]) tinyFont.
		(* addButtonWithAction: [addCategory]. *)
		}
)'private'
definitionTemplateCaption = (

	^'New category: '
)) : ()
class UnpackagedCategoriesSubject onModel:m = Subject onModel:m (
(* Represents a perspective similar to PackageSubject, but for those categories that do not belong to a package. *)|  |)
('as yet unclassified'
createPresenter = (

	^UnpackagedCategoriesPresenter onSubject: self
)
retrieveCategories = (

	| allCategories packageOrganizer |
	allCategories:: Smalltalk organization categories asSet.
	packageOrganizer:: PackageOrganizer default.
	packageOrganizer packages do:
		[:each |
		each systemCategories do:
			[:eachCategory |
			allCategories remove: eachCategory ifAbsent: []]].
	^allCategories asSortedCollection
)) : ('as yet unclassified'
new = (
	^onModel: nil
))
class UnsavedChangesPresenter onSubject:s = ProgrammingPresenter onSubject:s (
(*  *)|  |)
('accessing'
title = (

	^'Unsaved Changes'
)'actions'
forceCloseBrowser = (

	sendUp navigatorDo: [:shell | shell forceCloseWindow]
)
showHistory = (

	sendUp navigatorDo: [:shell | shell showHistory]
)'definition'
definition = (
^
	column: {
		(column: {
			blank: 50.
			centered: (label: 'This browser contains unsaved edits.').
			largeBlank.
			centered: 
				(row: {
					button: 'Show Them' action: [showHistory].
					mediumBlank.
					button: 'Close Anyway' action: [forceCloseBrowser]
					}).
			blank: 50.
			})
			color: (Gradient from:(Color h:0 s: 0.5 v: 0.8) to: (Color h:0 s: 0.5 v: 0.6)).
		centered: (label: '(this page is under construction)').
		mediumBlank.
		}
)'testing'
isTransient = (

	^true
)) : ('as yet unclassified'
new = (
	^self onSubject: nil
))'as yet unclassified'
flag: x = (
	
)) : ()