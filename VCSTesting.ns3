Newspeak3
'StructuredVCS'
class VCSTesting usingPlatform: platform module: svcs backendProvider: bp testFramework: minitest = (|
(* Copyright (c) 2010-2011 Matthias Kleine

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ''Software''), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. *)
	private vcs = svcs.
	private backendProvider = bp usingPlatform: platform vcs: vcs.
	private M = vcs.
	
	private backend = backendProvider Backend new.
	private TestContext = minitest TestContext.

	private Set = platform Collections Set.
	private OrderedCollection = platform Collections OrderedCollection.
	private FileDirectory = platform Files FileDirectory.
	private SmalltalkImage = platform System SmalltalkImage.
	
	private sourceMirrorParser = svcs sourceMirrors SourceMirrorParser new.

|)
(
class BackendTests = TestContext (|
	private repository
	private repositoryDirectories = Set new.
|initialize)
('as yet unclassified'
cleanUp = (

	repositoryDirectories do: [:each |
		each exists ifTrue: [
			each recursiveDelete]]
)
fail = (

	assert: false
)
historian = (

	assert: repository historians size = 1.
	^ repository historians anyOne
)
initialize = (

	| otherRepository |
	otherRepository:: newUninitializedRepository.
	otherRepository create.
	repository:: newUninitializedRepository.
	repository clone: otherRepository repositoryId
)
newUninitializedRepository = (

	| repositoryDirectory | 
	repositoryDirectory:: (FileDirectory on: SmalltalkImage current imagePath) / ('test_repository', 9999999 atRandom asString).
	repositoryDirectories add: repositoryDirectory.
	^ backend LocalRepository onRepositoryId: repositoryDirectory pathName
)
remoteRepository = (

	^ repository remoteRepositories anyOne
)
test01Assert = (

	assert: true
)
test02CorrectlySetupRepository = (

	assert: repository historians size = 1.
	assert: repository historians anyOne name = 'master'.
	assert: repository historians anyOne version message = 'Initial Commit'.
	repository historians anyOne
		trackedHistorianifPresent: [:it | assert: it = remoteRepository historians anyOne]
		ifAbsent: [fail]
		ifError: [fail].
)
test03CreateNewVersion = (

	| newVersion |
	newVersion:: repository createNewVersion.
	newVersion
		parents: {historian version};
		mirrors: {emptyClassMirror};
		message: 'New Version'.
	historian commit: newVersion.
	assert: newVersion = historian version.
)
test04CreateNewHistorian = (

	| version newHistorian historianName |
	historianName:: 'testing_historian'.
	version:: repository historians anyOne version.
	newHistorian:: repository
		newHistorianNamed: historianName
		setTo: version
		ifFail: [^ fail].
	assert: newHistorian name = historianName.
	assert: newHistorian version = version.
	assert: newHistorian = (repository
		historianNamed: historianName
		ifFail: [^ fail])
)
test05ShareNewHistorian = (

	| version newHistorian historianName |
	historianName:: 'testing_historian'.
	version:: repository historians anyOne version.
	newHistorian:: repository
		newHistorianNamed: historianName
		setTo: version
		ifFail: [^ fail].
	newHistorian shareTo: remoteRepository.
	
	newHistorian
		trackedHistorianifPresent: [:it |
			assert: it name = newHistorian name.
			assert: it version = newHistorian version.]
		ifAbsent: [fail]
		ifError: [fail].
	
	assert: (remoteRepository historianNamed: historianName ifFail: [^ fail]) version = newHistorian version.
)) : ('as yet unclassified'
TEST_CONTEXT = ())
class SmalltalkMirrorTests = TestContext (|

|)
('as yet unclassified'
exampleClassSource = (

	^ '''From Squeak4.1 of 17 April 2010 [latest update: #9957] on 12 January 2011 at 4:32:51 pm''!
Object subclass: #ExampleClass
	instanceVariableNames: ''iv1 iv2''
	classVariableNames: ''Cv1 Cv2''
	poolDictionaries: ''Pd1''
	category: ''Kernel-Models''!

!ExampleClass methodsFor: ''as yet unclassified'' stamp: ''mkl 1/12/2011 16:32''!
bar

	^ self foo! !


!ExampleClass methodsFor: ''testing'' stamp: ''mkl 1/12/2011 16:32''!
foo

	^ 42! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

ExampleClass class
	instanceVariableNames: ''Ci1 Ci2''!'

)
test01ReadExampleClassSource = (

	(* ChangeSet scanFile:  stream from: 1 to: stream size *)
)) : ('as yet unclassified'
TEST_CONTEXT = ())
class SmalltalkParsing = (|

	private CombinatorialParsing = (platform moduleOf: 'NS2 Combinatorial Parsing') CombinatorialParsing.
	BlocklessCombinatorialParsing = platform BlocklessCombinatorialParsing mixin apply: CombinatorialParsing.
	private blocklessCombinatorialParsing = BlocklessCombinatorialParsing usingLib: platform.
	private smalltalkSourceMirrors = platform StructuredVCS SmalltalkSourceMirrors
		usingPlatform: platform
		parserLib: blocklessCombinatorialParsing.
|)
(
class SmalltalkParsingTests = TestCase (|

|)
('as yet unclassified'
classDefinition = (

	^ 'Superclass subclass: #Classname
instanceVariableNames: ''instVar1 instVar2''
classVariableNames: ''classVar1 classVar2''
poolDictionaries: ''poolDict1 poolDict 2''
category: ''Category''!'
)
test01True = (

	assert: true
)
test02ParseChunks = (

	assert: (smalltalkSourceMirrors parseChunks: 'a!') size = 1.
	assert: (smalltalkSourceMirrors parseChunks: 'abcd!efghi!!jklmno! pqrstuvw!') asArray ={'abcd'. 'efghi!jklmno'. ' pqrstuvw'}	
)) : ()) : ()
class VCSTests = TestContext (|
|)
(
class SimpleTree = (|
public children = OrderedCollection new.
protected contents
id
|)
('as yet unclassified'
= other = (

	^ nil ~= other and: [id = other id]
)
contentsEquals: other = (

	^ contents = other contents
)) : ()'as yet unclassified'
ClassMirrorMergeSubject = (

 	^ sourceControlSubject mergingUI ClassMirrorMergeSubject
)
assert: left and: right comparesTo: compare = (

	| result |
	result:: M Differencer compare: left to: right.
	assert: result = compare
)
assert: left equals: right= (

	| result |
	result:: M Differencer compare: left to: right.
	assert: result changeInfo isEquals
)
assertMerge: left with: right withAncestor: ancestor to: result = (

	assert: result = (M WordMerger merge: left with: right withAncestor: ancestor) string.
)
classSourceWithMethodsAndFields1 = (

	^ 'class A = (
	|
	protected field1 = 42.
	field2
	|
	)
	(
	''categoryA''
	foo = (^ 23)
	bar = (^ 42)
	''categoryB''
	foobar = (^ 2342)
	)'
)
classSourceWithMethodsAndFields2 = (

	^ 'class A = (
	|
	protected otherField1 = 42.
	otherField2
	|
	)
	(
	''otherCategoryA''
	otherFoo = (^ 23)
	otherBar = (^ 42)
	''otherCategoryB''
	otherFoobar = (^ 2342)
	)'
)
compare: left to: right= (

	^ M Differencer compare: left to: right.
)
compare: left to: right withAncestor: ancestor= (

	^ M Differencer compare: left to: right withAncestor: ancestor.
)
slotSourcesOf: mirror = (

	^ mirror slotsSource
)
sourceControlSubject = (

	^ M SourceControlSubject onModel: {}
)
test01SimpleTree = (

	| a b c |
	
	a:: SimpleTree new
		contents:1;
		yourself.
	b:: SimpleTree new
		contents: 1;
		yourself.
	c:: SimpleTree new
		contents: 2;
		yourself.
	assert: a equals: b.
	assert: (compare: a to: c) changeInfo isEquals not.
)
test02aNewspeakEqualClasses = (

	| a b |
	
	a:: sourceMirrorForNewspeakClass: emptyClassSource.
	b:: sourceMirrorForNewspeakClass: emptyClassSource.
	assert: a equals: b.

	a:: sourceMirrorForNewspeakClass: classSourceWithMethodsAndFields1.
	b:: sourceMirrorForNewspeakClass: classSourceWithMethodsAndFields1.
	assert: a equals: b.
)
test02bNewspeakAddedMethodsAndFields = (

	| a b changeTree |
	
	a:: sourceMirrorForNewspeakClass: emptyClassSource.
	b:: sourceMirrorForNewspeakClass: classSourceWithMethodsAndFields1.
	changeTree:: compare: a to: b.
	assert: changeTree changeInfo changeTypes = {#equals. #addition} asSet
)
test02cNewspeakAddedMethodsAndFields = (

	| ancestor a b changeTree |
	
	ancestor:: sourceMirrorForNewspeakClass: emptyClassSource.
	a:: sourceMirrorForNewspeakClass: classSourceWithMethodsAndFields1.
	b:: sourceMirrorForNewspeakClass: classSourceWithMethodsAndFields2.
	changeTree:: compare: a to: b withAncestor: ancestor.
	(* Structured merging of fields will report conflicts even if only different fields were
	changed as long as fields are treated as one block of text. *)
	(* assert: changeTree changeInfo conflict = false *)
)
test03aDiff3 = (

	assertMerge: 'a b c' with: 'a b c' withAncestor: 'a b c' to: 'a b c'.
	
	assertMerge: 'a b c' with: 'a b c d' withAncestor: 'a b c' to: 'a b c d'.
	assertMerge: 'a b c d' with: 'a b c' withAncestor: 'a b c' to: 'a b c d'.

	assertMerge: 'a b c' with: 'a c' withAncestor: 'a b c' to: 'a c'.
	assertMerge: 'a c' with: 'a b c' withAncestor: 'a b c' to: 'a c'.
	
	assertMerge: 'a b c' with: 'a c d' withAncestor: 'a c' to: 'a b c d'.
	assertMerge: 'a c d' with: 'a b c' withAncestor: 'a c' to: 'a b c d'.
	
	assertMerge: 'a b c' with: 'a b c' withAncestor: 'a c' to: 'a b c'.
	assertMerge: 'x b c' with: 'y b c' withAncestor: 'a b c' to: '<<<<<x=====y>>>>> b c'.
	assertMerge: 'x b c d' with: 'y b z c' withAncestor: 'a b c' to: '<<<<<x=====y>>>>> b z c d'.
)
test03bDiff3 = (

	assertMerge: 'foo' with: '' withAncestor: 'foobar' to: '<<<<<foo=====>>>>>'.
	assertMerge: '''foo' with: '''' withAncestor: '''foobar' to: '''<<<<<foo=====>>>>>'.
)
test04aChangeClassCategory = (

	| sourceA sourceB mirrorA mirrorB changeTree |
	
	sourceA:: 'Newspeak2
	''A''
	class Foo = ()(class Bar = ()())'.

	sourceB:: 'Newspeak2
	''B''
	class Foo = ()(class Bar = ()())'.

	mirrorA:: sourceMirrorForNewspeakCompilationUnit: sourceA.
	mirrorB:: sourceMirrorForNewspeakCompilationUnit: sourceB.

	changeTree:: compare: mirrorA to: mirrorB withAncestor: mirrorA.
	assert: changeTree changeInfo isRight
)
test05KeepSlotComments = (

	| source mirror changeTree mergeSubject  mergedMirror |
	
	source:: 'class Foo = (|slot1 "comment" slot2|)()'.
	mirror:: sourceMirrorForNewspeakClass: source.
	changeTree:: compare: mirror to: mirror withAncestor: mirror.
	mergeSubject:: ClassMirrorMergeSubject mergeSubjectOn: changeTree.
	
	mergedMirror:: mergeSubject
		mirrorIfPresent: [:it |
			assert: ((slotSourcesOf: it) includesSubString: 'comment')]
		ifRemoved: [
			assert: false.
			^ self]
		ifFail: [
			assert: false.
			^ self].	
)
test06ClassCommentsWithoutLeadingWhitespace = (

	| source mirror |
	
	source:: 'class Outer = ( "Outer Comment")(class Inner = ( "Inner Comment")())'.
	mirror:: sourceMirrorForNewspeakClass: source.
	
	assert: (mirror classComment includesSubString: 'Outer Comment').
	assert: (mirror classes anyOne classComment includesSubString: 'Inner Comment').
)
test07RecognizeCategoryChange = (

	| sourceA sourceB mirrorA mirrorB |
	
	sourceA:: 'class Class = ()(''A''foo = ())'.
	sourceB:: 'class Class = ()(''B''foo = ())'.
	mirrorA:: sourceMirrorForNewspeakClass: sourceA.
	mirrorB:: sourceMirrorForNewspeakClass: sourceB.
	
	assert: (compare: mirrorA to: mirrorB) changeInfo isEquals not.
)
test08IdenticalMirrorsDifferentCategories = (

	| prefix sourceA sourceB mirrorA mirrorB methodSource |
	
	prefix:: 'Newsqueak2
	''Foo''
	'.
	(* use a long method, so both methods start with the same N characters and are thus cached into the same bucket *)
	methodSource:: 'foo = ("123123123123123123123123123123112312312323123123123")'.
	sourceA:: prefix, 'class Class = ()(''A''', methodSource, ')'.
	sourceB:: prefix, 'class Class = ()(''B''', methodSource, ')'.
	(* Use cached mirror loading *)
	mirrorA:: M sourceMirrors mirrorForStream: sourceA readStream.
	mirrorB:: M sourceMirrors mirrorForStream: sourceB readStream.
	
	assert: mirrorA instanceMethods anyOne category = 'A'.
	assert: mirrorB instanceMethods anyOne category = 'B'.
)
test09RecognizeClassInitializerChange = (

	| sourceA sourceB mirrorA mirrorB |
	
	sourceA:: 'class Class = (||foo)()'.
	sourceB:: 'class Class = (||bar)()'.
	mirrorA:: sourceMirrorForNewspeakClass: sourceA.
	mirrorB:: sourceMirrorForNewspeakClass: sourceB.
	
	assert: (compare: mirrorA to: mirrorB) changeInfo isEquals not.
)) : ('as yet unclassified'
TEST_CONTEXT = ())'as yet unclassified'
emptyClassCompilationUnitSource = (

	^ 'Newsqueak2
''Newspeak3''
class A = ()()'
)
emptyClassMirror = (

	^ sourceMirrorForNewspeakCompilationUnit: emptyClassCompilationUnitSource
)
emptyClassSource = (

	^ 'class A = ()()'
)
sourceMirrorForNewspeakClass: input = (

	sourceMirrorParser input: input.
	^ sourceMirrorParser classDeclaration parse:  input readStream
)
sourceMirrorForNewspeakCompilationUnit: input = (

	sourceMirrorParser input: input.
	^ sourceMirrorParser compilationUnit parse:  input readStream
)) : ()