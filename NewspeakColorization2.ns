Newspeak3
'HopscotchIDE'
class NewspeakColorization2 usingPlatform: p = (|
private Color = p graphics Color.
private Map = p collections Map.
private List = p collections List.
private TokenizingParser = p mirrors parserLib TokenizingParser.	
private TypedNS3Grammar = p mirrors grammar TypedNS3Grammar.

private TextProperties = p text TextProperties.
private TextString = p text TextString.
private TextBlock = p text TextBlock.
|) (
public class NS3BrowserColorizer = NS3Colorizer (|
	propertiesMap <Map[Symbol, TextProperties]> = computePropertiesMap.
	textSegments <List[TextString]> = List new.
|) (
'as yet unclassified'
coloredText = (	
  ^TextBlock units: textSegments
)
computePropertiesMap ^ <Map[Symbol, TextProperties]>= (
(* compute a mapping from 'kinds', which are symbols denoting logical categories of code, to textual properties used to colorize them*)
  | 
  redUnderlined <TextProperties> = TextProperties new; color: Color red; underlined: true; yourself.
  orangeBoldUnderlined <TextProperties> = TextProperties new; color: Color orange; bold: true; underlined: true; yourself.
  underlined <TextProperties> = TextProperties new;  underlined: true; yourself.
  gray <TextProperties> = TextProperties new; color: Color gray; yourself.
  blue <TextProperties> = TextProperties new; color: Color blue twiceDarker; yourself.
  grayBold <TextProperties> = TextProperties new; color: Color gray; bold: true; yourself.
  blackBold <TextProperties> = TextProperties new; color: Color black; bold: true; yourself.
  blueBold <TextProperties> = TextProperties new; color: Color blue twiceDarker; bold: true; yourself.
  magentaBold <TextProperties> = TextProperties new; color: Color magenta twiceDarker; bold: true; yourself.
  bold <TextProperties> = TextProperties new; bold: true; yourself.
 |

      Map new
		 at: #error put: redUnderlined;
             at: #undefinedUnary put: redUnderlined;
             at: #undefinedBinary put: redUnderlined;
             at: #undefinedKeyword put: redUnderlined;
             at: #shadowingTempVar put: orangeBoldUnderlined;
             at: #obsoleteMessage put: orangeBoldUnderlined;
             at: #whitespaceWarning put: orangeBoldUnderlined;
             at: #incompleteUnary put: underlined;
             at: #incompleteBinary put: underlined;
             at: #incompleteKeyword put: underlined;
             at: #self put: gray;
             at: #super put: gray;
             at: #outer put: gray;
             at: #true put: gray;
             at: #false put: gray;
             at: #nil put: gray;
             at: #string put: gray;
             at: #symbol put: gray;
             at: #number put: gray;
             at: #character put: gray;
             at: #public put: gray;
             at: #protected put: gray;
             at: #private put: gray;
             at: #tempVar put: grayBold;
             at: #blockTempVar put: grayBold;
             at: #blockPatternArg put: grayBold;
             at: #patternArg put: grayBold;
             at: #slotDecl put: grayBold;
             at: #patternTempVar put: grayBold;
             at: #methodTempBar put: blackBold;
             at: #leftParenthesis put: blackBold;
             at: #rightParenthesis put: blackBold;
             at: #leftParenthesis3 put: blackBold;
             at: #rightParenthesis3 put: blackBold;
             at: #leftParenthesis6 put: blackBold;
             at: #rightParenthesis6 put: blackBold;	
             at: #blockStart put: blackBold;	
             at: #blockEnd put: blackBold;	
             at: #blockStart3 put: blackBold;	
             at: #blockEnd3 put: blackBold;	
             at: #blockStart6 put: blackBold;	
             at: #blockEnd6 put: blackBold;	
             at: #leftBrace put: blackBold;	
             at: #rightBrace put: blackBold;	
             at: #leftBrace3 put: blackBold;
             at: #rightBrace3 put: blackBold;	
             at: #leftBrace6 put: blackBold;	
             at: #rightBrace6 put: blackBold;		
             at: #messagePatternDecl put: bold;
             at: #className put: bold;
             at: #comment put: blue;
             at: #type put: blueBold;		
             at: #return put: blueBold;
             at: #leftParenthesis1 put: blueBold;
             at: #rightParenthesis1 put: blueBold;
             at: #leftParenthesis4 put: blueBold;
             at: #rightParenthesis4 put: blueBold;
             at: #leftParenthesis7 put: blueBold;
             at: #rightParenthesis7 put: blueBold;
             at: #blockStart1 put: blueBold;
             at: #blockEnd1 put: blueBold;
             at: #blockStart4 put: blueBold;
             at: #blockEnd4 put: blueBold;
             at: #blockStart7 put: blueBold;
             at: #blockEnd7 put: blueBold;
             at: #leftBrace1 put: blueBold;
             at: #rightBrace1 put: blueBold;
             at: #leftBrace4 put: blueBold;
             at: #rightBrace4 put: blueBold;
             at: #leftBrace7 put: blueBold;
             at: #rightBrace7 put: blueBold;		
             at: #leftParenthesis2 put: magentaBold;
             at: #rightParenthesis2 put: magentaBold;
             at: #leftParenthesis5 put: magentaBold;
             at: #rightParenthesis5 put: magentaBold;
             at: #blockStart2 put: magentaBold;
             at: #blockEnd2 put: magentaBold;
             at: #blockStart5 put: magentaBold;
             at: #blockEnd5 put: magentaBold;
             at: #leftBrace2 put: magentaBold;
             at: #rightBrace2 put: magentaBold;
             at: #leftBrace5 put: magentaBold;
             at: #rightBrace5 put: magentaBold;
             yourself
)
noteRange: kind from: start to: end = (
(* We assume that the code to be colorized is processed in order, with no overlaps *)
      | textString <TextString> |
	(* The range 0..size is degenerate and leads to errors in Squeak 5.0 Morphic layout of paragraphs. *)
	textString:: TextString forString: (coloredText copyFrom: (start max: 1) to: end) properties: (propertiesMap at: kind)
	textSegments add: textString.
)
public parseText: s <String> fromClass: c <Class> usingSelector: selector <Symbol> ^<Text> = (
	| parser |

	assert: [s isString].

	inputSize:: s size.
	klass:: c.
	bracketDepth:: 0.
	braceDepth:: 0.
	parenDepth:: 0.
	rangeMap:: List new.
	cachedScopeStack: nil.

	coloredText:: TextBlock forString: s.

	parser:: (perform: selector), eoi.
	parser parseString: s ifError: [:msg :pos |
		noteRange: #error from: pos to: inputSize.
		^coloredText ].
	^coloredText
)
) : (
)
class NS3Colorizer = TypedNS3Grammar (|
	cachedScopeStack
	klass
	rangeMap
	inputSize
	startComment
	braceDepth
	bracketDepth
	parenDepth
	isFirst ::= true.
|) (
'as yet unclassified'
accessModifier = (
	^super accessModifier wrapper: [ :mod :ws |
		noteRange: mod token asSymbol from: mod start to: mod end.
		mod]
)
beginComment = (
	^(TokenizingParser withSubparser: super beginComment) wrap:
		[:t | self noteRange: #unfinishedComment from: t start to: self inputSize. t].
)
binaryMsgPattern = (
	^super binaryMsgPattern wrapper:
		[:sel <Token> :p <Tuple[Token, Token]> |
		self pushScope.
		self currentScope at: p first token put: #parameter.
		self noteRange: #messagePatternDecl from: sel start to: sel end.
		self noteRange: #patternArg from: p first start to: p first end].
)
binarySelector = (
	^super binarySelector wrap:
		[:t | | kind |
		kind:: selector: t token 
			ifDefined: [#binary] 
			ifIncomplete: [#incompleteBinary]
			ifUndefined: [#undefinedBinary] 
			ifObsolete: [#obsoleteMessage].
		self noteRange: kind from: t start to: t end.
		t].
)
block = (
	^super block wrapper:
		[:lb :params :cb :rb |
		params isNil ifFalse: [params isEmpty ifFalse: [self popScope]].
		{lb. params. cb. rb}]
)
blockParameter = (
	^super blockParameter wrapper:
		[:cn :sd | (* blockParameter ::= colon, slotDecl *)
		| kind |
		checkBlockParameter: sd first.
		kind:: (symbolInScope: sd first token) ifTrue: [#shadowingTempVar] ifFalse: [#blockPatternArg].
		noteRange: kind from: sd first start to: sd first end.
		sd]
)
blockParameters = (
	^super blockParameters wrapper:
		[:ps :vb  | self pushScope. 
		ps do: [:p | self currentScope at: p first token put: #parameter].
		{ps. vb}]
)
braceLevelString = (
	^self braceDepth = 1 ifTrue: [''] ifFalse: [self braceDepth printString]
)
bracketLevelString = (
	^self bracketDepth = 1 ifTrue: [''] ifFalse: [self bracketDepth printString]
)
characterConstant = (
	^super characterConstant wrap:
		[:t | self noteRange: #'$' from: t start to: t end. t].
)
checkBlockParameter: sd <Token> = (
	(coloredText string runeAt: sd start - 1) = 58 ifTrue: [^self].
	self noteRange: #whitespaceWarning from: sd start - 1 to: sd start -1
)
checkKeyword: kwd <Token> = (
	kwd end >= inputSize ifTrue: [^self].
	(coloredText string runeAt: kwd end + 1) <= 32 ifTrue: [^self].
	self noteRange: #whitespaceWarning from: kwd start to: kwd end
)
public classHeader = (
	^super classHeader
		wrap:
			[ :tokens |
			(tokens at: 9) = nil ifFalse:
				[ | decs |
					decs:: (tokens at: 9) size = 3 ifTrue: [
						((tokens at: 9) at: 2) ] ifFalse: [(tokens at: 9) at: 3].			
					
					decs
					do: [ :each | noteRange: #slotDecl from: (each at: 2) first start to: (each at: 2) first end ] ].
			tokens ]
)
public codeBody = (
	^super codeBody wrapper:
		[:litMsg :tmps :stmts |
		tmps isNil ifFalse: [tmps isEmpty ifFalse: [self popScope]].
		{tmps. stmts}]
)
comment = (
	^super comment
		wrapper: [:token | self noteRange: #comment from: token start to: token end].
)
currentScope = (
	self assert: [self scopeStack isEmpty not].
	^self scopeStack last
)
decreaseBraceLevel = (
	self braceDepth: (self braceDepth - 1) \\ 7.
)
decreaseBracketLevel = (
	self bracketDepth: (self bracketDepth - 1) \\ 7.
)
decreaseParenLevel = (
	self parenDepth: (self parenDepth - 1) \\ 7.
)
endComment = (
	^(TokenizingParser withSubparser: super endComment) wrap:
		[:t | self rangeMap removeLast. t].
)
extendedCanUnderstand: sel = (
	| k |
	k: klass.
	[k isNil] whileFalse: 
		[(k canUnderstand: sel) ifTrue: [^true].
		 k: k enclosingClass].

	klass mixin applications do: [:any | ^any canUnderstand: sel].
	^Object canUnderstand: sel
)
increaseBraceLevel = (
	self braceDepth: (self braceDepth + 1) \\ 7.
)
increaseBracketLevel = (
	self bracketDepth: (self bracketDepth + 1) \\ 7.
)
increaseParenLevel = (
	self parenDepth: (self parenDepth + 1) \\ 7.
)
keywordHereSend = (
	^super keywordHereSend wrap: 
		[:kws | | sel kind |
		sel:: String streamContents: 
			[:s |
			kws do: [:kwd |
				self rangeMap removeLast.
				s nextPutAll: kwd first token]].
		kind:: symbol: sel
			ifInScope: [#instVar] 
			ifNotInScope: [#undefinedKeyword] 
			ifObsolete: [#obsoleteMessage].
		kws do: 
			[:kwp | self noteRange: kind from: kwp first start to: kwp first end]]
)
keywordMsg = (
	^super keywordMsg wrapper:
		[:esend :kws |
		| sel kind |
		kws do: [:kwp | checkKeyword: (kwp at: 1)].
		
		sel:: (kws inject: '' into: [:s :kwp | s, (kwp at: 1) token]) asString.
		kind:: selector: sel 
			ifDefined: [#keyword] 
			ifIncomplete: [#incompleteKeyword]
			ifUndefined: [#undefinedKeyword] 
			ifObsolete: [#obsoleteMessage].
		kws do: [:kwp | self noteRange: kind from: kwp first start to: kwp first end]].
)
keywordMsgPattern = (
	^super keywordMsgPattern wrap: [ :kws |
		assert: [kws isEmpty not].
		pushScope.
		kws do: [:kwp | | kind |
			kind:: (symbolInScope: kwp last first token) ifTrue: [#shadowingTempVar] ifFalse: [#patternArg].
			currentScope at: kwp last first token put: #parameter.
			noteRange: #messagePatternDecl from: kwp first start to: kwp first end.
			noteRange: kind from: kwp last first start to: kwp last first end]]
)
lbracket = (
	^super lbracket wrap:
		[:t |
		| range |
		self increaseBracketLevel.
		range:: ('blockStart', self bracketLevelString) asSymbol.
		self noteRange: range from: t start to: t end. 
		t]
)
lcurly = (
	^super lcurly wrap: 
		[:t | | range |
		self increaseBraceLevel.
		range:: ('leftBrace', self braceLevelString) asSymbol.
		self noteRange: range from: t start to: t end. 
		t]
)
lparen = (
	^super lparen wrap: 
		[:t | | range |
		self increaseParenLevel.
		range:: ('leftParenthesis', self parenLevelString) asSymbol.
		self noteRange: range from: t start to: t end. 
		t]
)
method = (
	| res |
	self pushScope.
	res:: super method.
	self popScope.
	^res
)
nestedClassDecl = (
	^super nestedClassDecl wrap:
		[:tokens | (* accessModifier opt, classDeclaration*)
		noteRange: #className from: ((tokens last) at: 2) start to: ((tokens last) at: 2) end.
		tokens]
)
number = (
	^super number wrap:
		[:t | self noteRange: #number from: t start to: t end. t].
)
parenLevelString = (
	^self parenDepth = 1 ifTrue: [''] ifFalse: [self parenDepth printString]
)
pattern = (
	^super pattern wrap:
		[:tpl | 
		self noteRange: #string from: (tpl at: 1) start to: (tpl at: 3) end.
		tpl at: 2]
)
popScope = (
	self scopeStack removeLast
)
pushScope = (
	self scopeStack addLast: Dictionary new
)
rbracket = (
	^super rbracket wrap:
		[:t | 
		| range |
		range:: ('blockEnd', self bracketLevelString) asSymbol.
		self decreaseBracketLevel.
		self noteRange: range from: t start to: t end. 
		t]
)
rcurly = (
	^super rcurly wrap:
		[:t | | range |
		range:: ('rightBrace', self braceLevelString) asSymbol.
		self decreaseBraceLevel.
		self noteRange: range from: t start to: t end. 
		t]
)
returnStatement = (
	^super returnStatement wrapper:
		[:h <Token> :expr :od <Token> |
		self noteRange: #return from: h start to: h end.
		expr].
)
returnType = (
	^super returnType wrapper: 
		[:h <Token> :t | self noteRange: #type from: h start to: h end. t]
)
rparen = (
	^super rparen wrap:
		[:t |  | range |
		range:: ('rightParenthesis', self parenLevelString) asSymbol.
		self decreaseParenLevel.
		self noteRange: range from: t start to: t end. 
		t]
)
scopeStack = (
	(* deal with forwarding reference *)
	cachedScopeStack isCollection 
		ifFalse: [cachedScopeStack:: OrderedCollection new].
	^cachedScopeStack
)
selector: sel ifDefined: definedAction ifIncomplete: incompleteAction ifUndefined: undefinedAction ifObsolete: obsoleteAction = (
	({#isKindOf:. #out. #halt. #inspect. #flag:. #instVarAt:. #isMemberOf:. #~. #!=} includes: sel) ifTrue: [^obsoleteAction value].
	Symbol hasInterned: sel ifTrue: [:s | ^definedAction value].
	(Symbol thatStartsCaseSensitive: sel skipping: nil) isNil
		ifTrue: [^incompleteAction value]
		ifFalse: [^undefinedAction value]
)
semicolon = (
	^super semicolon wrap:
		[:t | self noteRange: #cascadeSeparator from: t start to: t end. t].
)
setterKeyword = (
	^super setterKeyword wrap: [:skw <Token> | | kind |
		checkKeyword: skw.
		kind:: (self symbolInScope: (skw token copyUpToLast: ":"))
			ifTrue: [#instVar]
			ifFalse: [#undefinedKeyword].
		self noteRange: kind from: skw  start to: skw end.
		skw]
)
slotDef = (
	^super slotDef wrap:
		[:tokens | | sd kind |
		sd:: (tokens at: 2) first.
		noteRange: #slotDecl from: sd start to: sd end.		
		(* isFirst ifTrue: [pushScope. isFirst: false]. *)
		tokens]
)
slotName = (
	^super slotName wrap: 
		[:n <Token> | | kind |
		kind:: ({'self'. 'super'. 'outer'. 'true'. 'false'. 'nil'} includes: n token)
			ifTrue: [n token asSymbol]
                  ifFalse: [symbol: n token
				ifInScope: [#instVar] 
				ifNotInScope: [#undefinedUnary] 
				ifObsolete: [#obsoleteMessage]].
		noteRange: kind from: n start to: n end.
		n]
)
string = (
	^super string wrap:
		[:t | self noteRange: #string from: t start to: t end. t]
)
symbol: aString <String> ifInScope: inScopeAction ifNotInScope: notInScopeAction ifObsolete: obsoleteAction = (
	scopeStack do: [:s | (s includesKey: aString) ifTrue: [^inScopeAction value]].
	Symbol hasInterned: aString ifTrue: [ :sel <Symbol> |
		scopeStack do: [:s | (s includesKey: sel) ifTrue: [^inScopeAction value]].
		(extendedCanUnderstand: sel) ifTrue: [
			(ImplementationBase canUnderstand: sel)
				ifTrue: [^obsoleteAction value]
				ifFalse: [^inScopeAction value]]].
	^notInScopeAction value
)
symbolConstant = (
	^super symbolConstant wrapper:
		[:p <Token> :s | 
		self noteRange: #symbol from: p start to: s end.
		s].
)
symbolInScope: aString <String> ^ <Boolean> = (
	scopeStack do: [:s | (s includesKey: aString) ifTrue: [^true]].
	^Symbol hasInterned: aString ifTrue: [ :sel <Symbol> |
		scopeStack do: [:s | (s includesKey: sel) ifTrue: [^true]].
		(extendedCanUnderstand: sel) ifTrue: [^true].
		^false]
)
tempSlotDef = (
	^super slotDef wrap: [ :tokens | | sd kind |
		sd:: (tokens at: 2) first.
		noteRange: #slotDecl from: sd start to: sd end.
		
		isFirst ifTrue: [pushScope. isFirst: false].
		
		kind:: (symbolInScope: sd token) ifTrue: [#shadowingTempVar] ifFalse: [#tempVar].
		currentScope at: sd token put: #temporary.
		currentScope at: sd token, ':' put: #temporary.
		noteRange: kind from: sd start to: sd end.
		
		tokens]
)
temporaries = (
	|
	tempSlotDefs = tempSlotDef star.
 	tempSeqSlotDecls = vbar, tempSlotDefs, vbar.
 	tempSimSlotDecls = vbar, vbar, tempSlotDefs, vbar, vbar.
 	tempSlotDecls = tempSimSlotDecls | tempSeqSlotDecls.
	|

	^tempSlotDecls wrap: 
		[:parts | | vb1 vb2 vds vb3 vb4 |
		parts size = 3
			ifTrue:
				[vb1:: parts at: 1.
				vb2:: vb1. 
				vds:: parts at: 2. 
				vb3:: parts at: 3.
				vb4:: vb3] 
			ifFalse:
				[vb1:: parts at: 1. 
			vb2:: parts at: 2.
			vds:: parts at: 3.
			vb3:: parts at: 4.
			vb4:: parts at: 5].
	
		isFirst: true.
		noteRange: #methodTempBar from: vb1 start to: vb2 end.
		noteRange: #methodTempBar from: vb3 start to: vb4 end.
		vds]
)
type = (
	^super type wrapper:
		[:lb :te :rb | self noteRange: #type from: lb start to: rb end. te]
)
unaryMsgPattern = (
	^super unaryMsgPattern wrap:
		[:sel <Symbol> |
		self noteRange: #messagePatternDecl from: sel start to: sel end.
		sel].
)
unarySelector = (
	^super unarySelector wrap:
		[:t | | kind |
		kind:: selector: t token 
			ifDefined: [#unary] 
			ifIncomplete: [#incompleteUnary]
			ifUndefined: [#undefinedUnary] 
			ifObsolete: [#obsoleteMessage].
		self noteRange: kind from: t start to: t end.
		t].
)
variableName = (
	^super variableName wrap:
		[:n <Token> |
		n token = 'self' ifTrue: [self noteRange: #self from: n start to: n end]
		ifFalse: [n token = 'super' ifTrue: [self noteRange: #super from: n start to: n end]
		ifFalse: [n token = 'true' ifTrue: [self noteRange: #true from: n start to: n end]
		ifFalse: [n token = 'false' ifTrue: [self noteRange: #false from: n start to: n end]
		ifFalse: [n token = 'nil' ifTrue: [self noteRange: #nil from: n start to: n end]
		ifFalse: []]]]].
		n]
)
) : (
)
) : (
)
