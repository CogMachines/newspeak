Newspeak3
'NewspeakMirrorsForJavascript'
class NewspeakMirrorsForJavascript usingPlatform: platform = (
(* Provides high- and low-level mirrors for Newspeak running on Javascript

Only one kind of low-level mirror exists. A LowLevelObjectMirror exposes Javascript's abstractions. It allows accessing properties and calling an object's methods.

High-level mirrors reify abstractions found in the Newspeak programming language. Mirrors are provided for objects, classes, methods, slots, mixins, and class declarations. Mirrors can be created from a reflectee using the appropriate mirror classes' #reflecting: factory method. 

Developers generally interact directly with objects and classes and can as of such create mirrors for these. Class and Object mirrors in turn provide access to the other kinds of mirrors. This allows developers to obtain mirrors for reflectees that have no immediate reification in Newspeak, such as mixins or methods.

High-level mirrors are currently introspective, only. They do not allow modifying reflectees. Interface and implementation are based on NewspeakMirrors.

High-level mirrors make use of low-level mirrors to interact with the Javascript representation of Newspeak. As such, high-level mirrors rely on a specific representation of Newspeak in Javascript. It is desirable to keep the reliance on this representation. For example, if the names of both a class and a mixin are stored in a single place it is desirable to have only one method that knows how to access this place.

Creating a redundancy-free implementation requires special care with deciding where to put the knowledge about representation details. The current implementation has not yet reached a stable state with regard to this.

Mirrors can reflect on Javascript code that was produced by compiling Newspeak as well as other languages that are compiled to the same Javascript representation. In order to support other languages, reflectees must specify the name of the the parser that is to be used to reconstruct ASTs. This module maitains a dictionary of parsers, for which the reflectee's language names serve as keys.

TODO:

 - We could simplify most uses of llm by using aliens

   Copyright 2012 SAP AG.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)|

	private Dictionary = platform collections Dictionary.
	
	private Alien = Delay computation: [platform aliens Alien].
	private JavascriptEvaluator = Delay computation: [platform aliens JavascriptEvaluator].
	private CharacterReadStream = platform streams CharacterReadStream.

	private infrastructure = Infrastructure new.
	private ImmutableMirrorGroup = infrastructure ImmutableMirrorGroup.
	private MutableMirrorGroup = infrastructure MutableMirrorGroup.
	
	(* We can include alternate parsers, in case other languages are translated to Javascript. *)
	private parsers = Dictionary new.
	
	private Association = platform collections Association.
	
	private highLevelMirrors = HighLevelMirrors new.
	public ClassMirror = highLevelMirrors ClassMirror.
	public ObjectMirror = highLevelMirrors ObjectMirror.
	public ClosureMirror = highLevelMirrors ClosureMirror.
		
	private lowLevelMirrors = LowLevelMirrors new.
	public LowLevelMirror = lowLevelMirrors Mirror.
	public LowLevelMixinMirror = lowLevelMirrors LowLevelMixinMirror.
	public InstanceVariableMirror = lowLevelMirrors InstanceVariableMirror.
	
	public Message = platform kernel Message.
|LowLevelObjectMirror addLowLevelObjectMirrorPrimitiveMethods)
(
class HighLevelMirrors = ((* Mirrors reflecting Newspeak's abstractions

The abstractions provided by the high level mirrors correspond to constructs found in Newspeak. The following types of mirrors exist:

An *ObjectMirror* reflects arbitrary Newspeak objects. It knows the object's class, can read/write slots, perform methods, (and should be able to access nested classes).

A *ClassMirror* reflects a Newspeak class. It can be obtained by asking an ObjectMirror for the object's class or by directly reflecting on a class. A ClassMirror can reveal the classes' name, superclass, mixin, methods, slots, nested class declarations. Methods, slots, and nested class declarations include mirrors defined in superclasses.

A *MixinMirror* reflects a MixinHandle. It can be obtained by asking a ClassMirror for the classes' mixin, or by directly reflecting on a MixinHandle. It supports a subset of the ClassMirror protocol. It does not have a superclass and as such has only local slots, methods, and nested classes.

A *ClassDeclarationMirror* reflects the declaration of a Newspeak class.. As such it can be thought of as an AST that implements the mirror API. Class declarations are currently reified as MixinHandles. ClassDeclarationMirrors can be obtained by asking a ClassMirror or a MixinMirror for its declaration, or for its nested class declarations. A ClassDeclarationMirror allows introspecting the classes header, as well as its instance and class sides. Sides are currently not implemented as separate classes but simply return mirrors for either instance- or class-side mixins.

A *ClassHeaderMirror* is a part of a ClassDeclarationMirror.

A *SlotMirror*  reflects a slot. A *MethodMirror* reflects a method. Both kinds of mirrors lack a reification of reflectees that is available to application developers. The lack of such a reflectee stands in conflict with the requirement of the Mirror API to actually expose the object that is being reflected through the 'reflecteeIfFail:' method.

There are several ways to address the problem:

- Asking Slot/MethodMirrors for their reflectee always fails
- Slot/Method mirrors report some user-intelligible information (e.g. name)

Reporting the name of the reflected object as the reflectee has the following undesirable consequences. The name alone is not sufficient to identify the actual reflected object. As a result of this insufficiency the information that identifies the actual object must be kept somewhere else. If this information is not specific to the MirrorClass it becomes impossible to create a Mirror from what is reported as its reflectee.

A MethodMirror reflects the source of its method. It creates an AST to answer any requests.

A SlotMirror reflects the AST directly. This mismatch to the MethodMirror comes from the fact that the SlotDefAST is already available at slot mirror creation time.



Here are a few general observations: 

These mirrors are based on NewspeakMirrors. Design guidelines explained there apply here as well.

Mirrors can have a simpleName and a fullyQualifiedName. The simpleName is the name by which the mirror's reflectee is known in its enclosing scope. The fullyQualifiedName includes the names of all enclosing scopes.

Operations on mirrors that can return multiple mirrors (e.g. a classes' methods) return MirrorGroups. MirrorGroups are dictionaries indexed by mirror's simpleNames.

The API is not stable, yet. *)ObjectMirror addObjectMirrorPrimitiveMethods)
(
class ClassDeclarationMirror reflecting: mixin = MixinBasedMirror reflecting: mixin (
(* See comment of enclosing class *)|
|)
('accessing'
classSide = (

	(* SideMirror classes not yet implemented. *)
	^ (MixinMirror reflecting: reflectee) dualMixin
)
enclosingClassDeclaration = (

	| enclosingMixin |
	
	enclosingMixin:: llmReflectee
		propertyAt: #enclosingMixin
		ifAbsent: [^ nil].
	^ ClassDeclarationMirror reflecting: enclosingMixin
)
fullyQualifiedName = (

	^ instanceSide fullyQualifiedName
)
header = (

	^ ClassHeaderMirror reflecting: reflectee
)
instanceSide = (

	(* SideMirror classes not yet implemented. *)
	^ MixinMirror reflecting: reflectee
)
metadata = (

	^ Dictionary new
)
simpleName = (

	(* Instance and class side have distinct names. Is that what we want? *)
	^ instanceSide simpleName
)
slots = (

	^ header slots
)) : ()
class ClassHeaderMirror reflecting: mixin = MixinBasedMirror reflecting: mixin ((* See comment of enclosing class *)|
|)
('accessing'
classComment = (

	^ ast classComment
)
declaration = (

	^ ClassDeclarationMirror reflecting: reflectee
)
initExprs = (

	^ ast initExprs
)
primaryFactory = (

	^ ast constructor
)
slots = (

	| mirrors llmMetadataAtProperty |

	llmMetadataAtProperty:: metadataAt: #slots.
	mirrors:: llmMetadataAtProperty collect: [:each |
		SlotMirror reflecting: each].
	^ ImmutableMirrorGroup group: mirrors
	
(* Don't rely on the AST being available. Slot mirrors must be functional before we can use any parser.

	| mirrors |
	mirrors:: ast slots collect: [:each | SlotMirror reflecting: each].
	^ ImmutableMirrorGroup group: mirrors
*)
)
source = (

	^ metadataAt: #header
)
superclassClause = (

	^ ast superConstructorCall
)'private'
ast ^ <ClassHeaderAST> = (

	^ metadataAt: 'cachedAST' ifAbsentPut: [
		| parser |
		parser:: parsers at: (metadataAt: #language).
		parser classHeader parse: (readStreamFor: source)].
)
metadataAt: key ifAbsentPut: block= (

	| llmMetadata |
	llmMetadata:: llmReflectee asLLMPropertyAt: #metadata.
	^ llmMetadata propertyAt: key ifAbsentPut: block
)) : ()
class ClassMirror reflecting: factory = Mirror reflecting: factory ((* See comment of enclosing class *)|
	public slots = Delay computation: [withSuperclassesCollectMirrorGroup: [:each |
		each slots]].

	public methods = Delay computation: [withSuperclassesCollectMirrorGroup: [:each |
		each methods]].
|)
('accessing'
allSuperclasses = (

	| superclasses klass|
	superclasses:: Array new.
	klass: superclass.
	[nil = klass] whileFalse: [
		superclasses add: klass.
		klass:: klass superclass].
	^ superclasses
)
declaration = (

	^ mixin declaration
)
enclosingObject = (

	| enclosingObjects |
	enclosingObjects:: llmRuntimeClass propertyAt: 'enclosingObjects`', fullyQualifiedName.
	^ ObjectMirror reflecting: (enclosingObjects at: 1)
)
fullyQualifiedName = (

	^ mixin fullyQualifiedName
)
mixin = (

	^ MixinMirror reflecting: (llmRuntimeClass propertyAt: 'mixin')
)
nestedClassDeclarations = (

	^ withSuperclassesCollectMirrorGroup: [:each |
		each nestedClassDeclarations]
)
simpleName = (

	^ mixin simpleName
)
superclass = (

	(* Currently returns nil if no superclass is present. Is that the expected result? How about an explicit failure block *)
	| llmSuperRTC superFactory |
	llmSuperRTC:: llmRuntimeClass asLLMPropertyAt: #superclass.
	nil = llmSuperRTC reflectee ifTrue: [^nil].
	superFactory:: llmSuperRTC propertyAt: #factory.
	^ClassMirror reflecting: superFactory
)'actions'
basicNew ^ <ObjectMirror >= (

	| instance |
	instance:: (LowLevelObjectMirror reflecting: reflectee) call: #basicNew with: {}.
	
	(* We're not going through Aliens right now, as #onJavascriptObject: currently silently returns its arguments if that already is a Newspeak object. This behavior might be considered a design flaw, but we should not rely on it working here. 

	instance:: (Alien onJavascriptObject: reflectee) basicNew *)
	^ ObjectMirror reflecting: instance
)'private'
llmRuntimeClass = (

	^ llmReflectee asLLMPropertyAt: #runtimeClass.
)
withSuperclassesCollectMirrorGroup: block = (

	(* The result must include mirrors provided by superclasses. We could implement this by accessing the runtime class directly. We nevertheless manually go through the class declarations of our superclasses in order to avoid another dependence on the Javascript implementation *)
	
	| mirrorGroup currentClassMirror withAllSuperclasses |
	mirrorGroup:: MutableMirrorGroup group: {}.
	withAllSuperclasses:: allSuperclasses reverse.
	withAllSuperclasses add: self.
	withAllSuperclasses do: [:classMirror |
		mirrorGroup addAllMirrors: (block value: classMirror mixin)].
	^ ImmutableMirrorGroup group: mirrorGroup
)) : ()
class ClosureMirror reflecting: closure <Block> = Mirror reflecting: closure (
(* It is often necessary to reflect on the structure of a closure - to see what its (dynamic) lexical scope is etc.  On the other hand, unlike Smalltalk, in Newspeak we want to ensure that unauthorized parties may not tamper with closure objects handed to them.  Thus, at base level closures provide only the ability to evaluate themselves, and to determine their arity.  

Certainly native Javascript closures do not provide any abilities beyond these.
Ideally, one should provide a way to assemble closures as well (say, to implement deserialization) but the JS platform will not for the foreseeable future, as Javascript exposes no mechanism to implement it.

At the meta-level, full access should be made available via mirrors, and this class implements that functionality. At this stage, this is only a first approximation. *))
('as yet unclassified'
ast ^ <AST> = (

^llmReflectee propertyAt: 'cachedAST' ifAbsentPut: [
	(* invoke the ast property as a function *)
	(llmReflectee asLLMPropertyAt: 'ast') on: llmReflectee apply:{}
(*		| parser |
		parser:: parsers at: (llmReflectee propertyAt: 'language').
		parser block parse: (readStreamFor: source) *)]
)
evaluateFreeMessage: selector <Symbol> with: args  = (
	(* Evaluate the message named selector in the dynamic scope of the closure, with the given arguments. A special case of this would evaluate a free variable. Actual message sends involve standard method lookup via the enclosing object chain *)
)
freeVariableNamed: s <String> ^ <ObjectMirror> = (
(* ^ObjectMirror reflecting: (JavascriptEvaluator evalFunction: 'freeVariable' with:{reflectee. s}) *)
(* alas, the code below is not equivalent, because it neglects to evaluate the function. Consequently we mirror the function rather than its result. The resulting object has a reflectee that is a plain JS function. Very unhealthy *)

	^ObjectMirror reflecting: ((llmReflectee asLLMPropertyAt: #freeVariables)  propertyAt: s)
)
function ^  <Function> = (^ObjectMirror reflecting: reflectee)
source = (
	^llmReflectee propertyAt: 'source'
)) : ()
class MethodMirror reflecting: methodMetadata = Mirror reflecting: methodMetadata (|
|)
('accessing'
accessLevel = (

	^ ast visibility
)
ast ^ <MethodDeclAST> = (
	
	^ llmReflectee propertyAt: 'cachedAST' ifAbsentPut: [
		| parser |
		parser:: parsers at: (llmReflectee propertyAt: 'language').
		parser methodDecl parse: (readStreamFor: source)].
)
metadata = (

	(* Metadata isn't stored, yet *)
	^ Dictionary new
)
name = (

	^ simpleName
)
reflecteeIfFail: failBlock <[:Exception]> = (

	^ failBlock value: (Error description: 'Method mirrors do not expose their reflectees')
)
simpleName = (

	^ llmReflectee propertyAt: 'name'
)
source = (

	^ llmReflectee propertyAt: 'source'
)) : ()
class Mirror reflecting: r = ((* A high level mirror reflecting on a Newspeak object represented in Javascript *)|
	protected reflectee = r.
	protected llmReflectee = LowLevelObjectMirror reflecting: reflectee.
|)
('accessing'
reflecteeIfFail:  fblk <[:Exception]> ^ <Object>  = (
	^reflectee (* default; we can always access the reflectee of a local object; subclasses may override if there are issues *)
)) : ()
class MixinBasedMirror reflecting: mixin = Mirror reflecting: mixin (|

|llmReflectee
	propertyAt: #metadata
	ifAbsent: [
		assert: false
		description: 'reflecting: expects a mixin for ', self class])
('protected'
metadataAt: key = (

	| llmMetadata |
	llmMetadata:: llmReflectee asLLMPropertyAt: #metadata.
	^ llmMetadata propertyAt: key
)) : ()
class MixinMirror reflecting: mixin = MixinBasedMirror reflecting: mixin (
(* See comment of enclosing class. *)|
|)
('accessing'
classMixin ^ <MixinMirror> = (

	^ isMeta 
		ifFalse:[MixinMirror reflecting: (llmReflectee propertyAt: #classMixin)]
		ifTrue:[MixinMirror reflecting: Metaclass mixin].
)
declaration ^ <ClassDeclarationMirror> = (

	^ ClassDeclarationMirror 
		reflecting: (isMeta ifFalse:[reflectee] ifTrue:[dualMixin reflectee])
)
dualMixin ^ <MixinMirror> = (

	^ isMeta 
		ifTrue:[MixinMirror reflecting: (llmReflectee propertyAt: #instanceMixin)]
		ifFalse:[classMixin].
)
fullyQualifiedName = (

	(* See comment in simpleName *)
	^ metadataAt: #name
)
isMeta = (

	^ metadataAt: #isMeta
)
methods = (

	| mirrors llmMetadataAtProperty |

	llmMetadataAtProperty:: metadataAt: #methods.
	mirrors:: llmMetadataAtProperty collect: [:each |
		MethodMirror reflecting: each].
	^ ImmutableMirrorGroup group: mirrors
)
nestedClassDeclarations = (

	| llmNestedMixins nestedMirrors |
	llmNestedMixins:: llmReflectee asLLMPropertyAt: 'nestedMixins'.
	nestedMirrors:: Array new.
	llmNestedMixins ownPropertiesDo: [:propertyName | | nested |
		nested:: llmNestedMixins propertyAt: propertyName.
		nestedMirrors add: (ClassDeclarationMirror reflecting: nested)].
	^ ImmutableMirrorGroup group: nestedMirrors
)
simpleName = (

	(* Do we want to have distinct names for classes and their meta-classes? If yes, we must ourselves look up the name. If not, better forward to the class declaration. Same is true for fullyQualifiedName *)

	^ metadataAt: #simpleName
)
slots = (

	^ isMeta
		ifTrue: [ImmutableMirrorGroup group: {}]
		ifFalse: [declaration slots]
)) : ()
class ObjectMirror reflecting: object = Mirror reflecting: object ((* See comment of enclosing class *)|
	cachedClassMirror
|)
('accessing'
getClassIfFail:  failBlock <[:Exception]> ^ <ClassMirror>  = (

	nil = cachedClassMirror ifTrue: [
		cachedClassMirror:: ClassMirror reflecting: reflectee class].
	^ cachedClassMirror
)
getSlot: slotName <Symbol> ifFail: failBlock ^ <ObjectMirror | R> = (

	ensureHasSlot: slotName ifNot: [^ failBlock value].
	^ self class reflecting: (llmReflectee propertyAt: slotName)
)
perform: selector <Symbol> with:  args <Array[Object]> ifFail:  failBlock <[:Exception]>  ^ <ObjectMirror> = (
	| result <Object> |

	^ [self perform: selector with: args] on: Error do: [:ex | ^ failBlock value: ex]
)
perform: selector with: args = (

	(* Implemented on the infrastructure side so that the complete name mangling + DNU-handling can be kept there *)
	implementedByInfrastructure
)
setSlot: slotName <Symbol> to:  object <Object> ifFail:  failBlock <[:Exception]>  = (

	ensureHasSlot: slotName ifNot: [^ failBlock value].
	llmReflectee propertyAt: slotName put: object
)'private'
ensureHasSlot: slotName ifNot: failBlock = (

	| classMirror |
	classMirror:: getClassIfFail: [^ failBlock value: 'Could not access object''s class'].
	(classMirror slots includesMirrorNamed: slotName) ifFalse: [
		^ failBlock value: 'Trying to access nonexistent slot ', slotName].
)) : ('public'
canReflectOn: object = (

	^ LowLevelObjectMirror hasObject: object property: 'respondsToNewspeakMessages'
))
class SlotMirror reflecting: slotMetadata = Mirror reflecting: slotMetadata (
(* SlotMirrors introspect the source of slot definitions. Doing so requires being able to parse the source. It happens that the parser itself makes use of slot mirrors. This use is limited to listing the slots of a class and asking for their names. We break this cycle by explicitly storing the name of the reflected slot in here, so that we can report it without a parser being available. *)|
|)
('accessing'
accessLevel ^ <Symbol> = (

	^ ast accessModifier
)
isMutable ^ <Boolean> = (

	^ llmReflectee propertyAt: 'isMutable'
)
metadata = (

	(* Metadata isn't stored, yet *)
	^ Dictionary new
)
name ^ <Symbol> = (

	^ simpleName
)
reflecteeIfFail: failBlock <[:Exception]> = (

	^ failBlock value: (Error description: 'Slot mirrors do not expose their reflectees')
)
simpleName = (

	(* Don't refer to the AST. We want to avoid parsing. See class comment. *)

	^ llmReflectee propertyAt: 'name'
)
source = (

	^ llmReflectee propertyAt: 'source'
)'private'
ast ^ <SlotDefAST> = (

	^ llmReflectee propertyAt: 'cachedAST' ifAbsentPut: [
		| parser |
		parser:: parsers at: (llmReflectee propertyAt: 'language').
		parser slotDef parse: (readStreamFor: source)].
)) : ()) : ()
class Infrastructure = ((* Provides infrastructure classes that are not yet provided by the JS environment *))
(
class Dictionary = ( 	(* Just a quick hack until we have proper dictionaries *)|
	llm = LowLevelObjectMirror reflecting: Array new. (* Could be any object *)
|)
('as yet unclassified'
associations = (

	| result counter |
	result:: Array new: size.
	counter:: 1.
	llm ownPropertiesDo: [:each |
		result
			at: counter
			put: (Association key: each value: (llm propertyAt: each)).
		counter:: counter + 1].
	^ result
)
at: key ifPresent: presentBlock ifAbsentPut: absentBlock = (

	^ (includesKey: key)
		ifTrue: [presentBlock value: (self at: key)]
		ifFalse: [at: key put: absentBlock value]
)
reject: aBlock = (
	| result |
	result:: Array new. (* Assuming JS array-backed Arrays which are actually ordered collections. *)
	self do:
		[:each |
		(aBlock value: each) ifFalse: [result add: each]].
	^result
)
select: aBlock = (
	| result |
	result:: Array new. (* Assuming JS array-backed Arrays which are actually ordered collections. *)
	self do:
		[:each |
		(aBlock value: each) ifTrue: [result add: each]].
	^result
)
values = (

	| result counter |
	result:: Array new: size.
	counter:: 1.
	llm ownPropertiesDo: [:each |
		result
			at: counter
			put: (llm propertyAt: each).
		counter:: counter + 1].
	^ result
)'public'
at: key = (

	^ llm propertyAt: key
)
at: key ifAbsent: absentBlock = (

	^ (includesKey: key)
		ifTrue: [self at: key]
		ifFalse: absentBlock
)
at: key put: value = (

	llm propertyAt: key put: value.
	^ value
)
do: block = (

	llm ownPropertiesDo: [:name | | value |
		value:: llm propertyAt: name.
		block value: value].
)
includesKey: key = (

	^ keys includes: key
)
keys = (

	^ llm ownProperties
)
size = (

	^ llm ownProperties size
)) : ('as yet unclassified'
newFrom: collection = (

	| result |
	result:: self new.
	collection do: [:each |
		result at: (each at: 1) put: (each at: 2)].
	^ result
))
class ImmutableMirrorGroup group: group = (|
	mirrors = Dictionary new.
|group do: [:each | mirrors at: each simpleName put: each])
('accessing'
collect: aBlock = (
	| result |
	result:: Array new.
	self do: [:each | result add: (aBlock value: each)].
	^result
)
do: block = (

	mirrors do: block
)
findMirrorNamed: mirrorName = (

	(* The Newspeak version silently fails if the mirror is not present and returns nil. It that actually what we want? *)
	^ mirrors at: mirrorName
)
includesMirrorNamed: simpleName = (

	^ mirrors includesKey: simpleName
)
includesMirrorSatisfying: block = (

	mirrors do: [:each |
		(block value: each) ifTrue: [^ true]].
	^ false
)) : ()
class MutableMirrorGroup group: group = ImmutableMirrorGroup group: group (|
|)
('public'
addAllMirrors: mirrorGroup = (

	(* self should not be required. some compiler problem *)
	mirrorGroup do: [:each | addMirror: each]
)
addMirror: mirror = (

	(* self should not be required. some compiler problem *)
	self mirrors at: mirror simpleName put: mirror
)) : ()) : ()
class LowLevelMirrors = (|
|)
(
class CompiledMixinMirror language: l header: h mirror: llm = (|
	language = l.
	header = h.
	lowLevelMirror = llm.
	commentString
|)
('as yet unclassified'
category = (
	^ lowLevelMirror category
)
category: c = (
	lowLevelMirror category: c.
)
comment = (
	commentString ifNil: [^''].
	^ commentString.
)
comment: c = (
	commentString: c.
)
name = (
	^ lowLevelMirror name
)) : ()
class InstanceVariableMirror named: n = Mirror (
(* A mirror on an instance variable *)|
	name <String> = n.
|)
() : ()
class LowLevelMethodMirror = Mirror (|
	debugInfo
	selector <Symbol>
	klass <Class>
	src <String>
|)
('as yet unclassified'
isConstructor = (
	^metadata at: #isConstructor ifAbsent: [false]
)
isNestedClassAccessor = (
	^metadata at: #isNestedClassAccessor ifAbsent: [false]
)
isSlotAccessor = (
	^metadata at: #isSlotAccessor ifAbsent: [false]
)
isSubInitializer = (
	^metadata at: #isSubInitializer ifAbsent: [false]
)
isSuperConstructor = (
	^metadata at: #isSuperConstructor ifAbsent: [false]
)
isSynthetic = (
	^metadata at: #isSynthetic ifAbsent: [false]
)
name ^<Symbol> = (
	^selector
)) : ()
class LowLevelMixinMirror named:  n <Symbol> isMeta: b <Boolean> = Mirror (
(* Represents a Squeak Class. *)|
	name <Symbol> = n.
	instVars <MirrorGroup> = MutableMirrorGroup group:{}.
	methods  <MirrorGroup> = MutableMirrorGroup group:{}.
	category <Symbol>
	cachedClassMixin
	isMeta = b.
|)
('as yet unclassified'
classMixin = (
	(* assert: [isMeta not]. *)
	cachedClassMixin isNil ifTrue:
		[cachedClassMixin:: self class named: (name, ' class') asSymbol isMeta: true].
	^cachedClassMixin	 
)) : ()
class Mirror = (
(* Common base class for low level mirrors. *)|
	metadata <MutableMap[Symbol, Object]> = Dictionary new.
|)
('as yet unclassified'
simpleName = (
	^name
)) : ()) : ()
class LowLevelObjectMirror reflecting: reflectee = (
(* Reflects on Javascript objects

Unlike other mirrors, methods don't return mirrors but reflectees. See top-level class comment otherwise. *)|
	reflectee = reflectee.
|)
('public'
asLLMPropertyAt: identifier = (

	^ self class reflecting: (propertyAt: identifier)
)
call: property with: arguments = (

	implementedByInfrastructure
)
hasOwnProperty: identifier = (

	implementedByInfrastructure
)
hasProperty: identifier = (

	^ implementedByInfrastructure
)
on: this apply: arguments = (

	(* Assumes we're reflecting on a function *)
	implementedByInfrastructure
)
ownProperties = (

	^ properties select: [:each | hasOwnProperty: each] 
)
ownPropertiesDo: block = (

	(* We could skip the intermediate construction of a list of properties. This code is cleaner, though *)
	ownProperties do: block
)
properties = (

	| result |
	result:: Array new.
	propertiesDo: [:identifier | result add: identifier].
	^ result
)
propertiesDo: block = (

	implementedByInfrastructure
)
propertyAt: identifier = (

	(* I'm not sure whether we want to expose 'propertyAt:' at all. By exposing only 'propertyAt:ifFail:' we would clearly expose that error treatment is client responsibility *)
	implementedByInfrastructure
)
propertyAt: identifier ifAbsent: absentBlock = (

	^ (hasProperty: identifier)
		ifTrue: [propertyAt: identifier]
		ifFalse: [absentBlock value]
)
propertyAt: identifier ifAbsentPut: absentBlock = (

	^ (hasProperty: identifier)
		ifTrue: [propertyAt: identifier]
		ifFalse: [
			| newValue |
			newValue:: absentBlock value.
			propertyAt: identifier put: newValue.
			newValue]
)
propertyAt: identifier put: value = (

	implementedByInfrastructure
)) : ('as yet unclassified'
hasObject: object property: property = (

	implementedByInfrastructure
)'public'
emptyObject = (

	implementedByInfrastructure
))'accessing'
at: key putParser: parser = (

	parsers at: key put: parser
)'as yet unclassified'
readStreamFor: string = (

	^ CharacterReadStream on: string
)) : ()