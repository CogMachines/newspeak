Newspeak3
'Mirrors'
class NewspeakMirrorsForSqueak usingLib: platform = NewspeakObject (
"The new Newspeak  mirrors API. It is a work in progress that attempts to address weaknesses of the current API and of past mirror APIs. The mirrors here are high level mirrors: they represent language constructs in NS2 and above.

The API follows several general guidelines:

1) Operations return mirrors (an exception is getting the reflectee).
2) Operations take non-mirrors as arguments.
3) Operations take a failure block.

The motivation for (3) is that mirrors should be useful in both local and distributed settings. Forcing the user to confront the possibility of failure helps make code more robust in the distributed case.  This also contributes to (1); returned results may refer to remote values, and going through the mirror API to deal with them will help ensure failure scenarios are dealt with.

On the other hand, arguments can always be converted to mirrors by the API.  Much of the awkwardness in mirror APIs stems from the need to package arguments as mirrors - with the API often immediately extracting the reflectee afterwards.  The API should endeavor to deal with either mirrors or non-mirrors when this makes sense (e.g., when applying a mixin to a superclass, the superclass argument could be either a class or a class mirror) or to provide a separate call for mirrors (say, when adding a method - one call might accept source as a string, another a MethodMirror).

The implementation will likely change. As we reform the reflective interface, we are likely to reduce our reliance on existing code like SqueakVMMirror and NS2Reflection; either their code will migrate here or vice versa.

The API is divided into immutable and mutable parts. Mirrors are basically immutable.  As such they support introspection directly. In order to mutate code, one uses MirrorBuilders. These are created based on a mirror, and allow modifications to be accumulated without having any effect on the system.  The builder can be asked to provide a mirror reflecting its current state at any time. This allows the results of multiple builders to be batched and submitted to the atomic installer as well.

All this brings up the question of how mirrors differ from ASTs. Mirrors and ASTs should ideally be viewed as different implementations of the same interface.  Mirrors differ in how they are constructed and how they compute their subtrees. Mirrors may be connected to a live representation, or to a source base or whatever. 

MirrorBuilders also differ in supporting mutability and in what inputs can drive them (e.g, addFromSource:) so they extend the base API of mirrors and ASTs. 

It may be a while before this module realizes the ideal description given above. Also, the implementation still relies heavily on earlier reflective APIs - be they the built-in Squeak reflection classes or other efforts. Ultimately, the actual logic for this should reside here.

   Copyright 2008 Cadence Design Systems, Inc.
   Copyright (c) 2009-2010 Gilad Bracha

   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|  
MutableHashedMap = platform collections Dictionary.
MutableList = platform collections OrderedCollection.

Duct = platform blackMarket Duct. "Note: not the one in brazil because brazil is not available during bootstrap"
BrazilWeakStorage = platform blackMarket BrazilWeakStorage.

Error = platform Exceptions Error.
Metaclass = platform Metaclass.
SystemMetadata = platform NewsqueakMixins SystemMetadata.
Language = platform NsMultilanguage Language.

atomicInstaller = platform namespace AtomicInstaller usingPlatform: platform.

lowLevelMirrors = platform namespace LowLevelMirrors usingLib: platform.
LowLevelMirror = lowLevelMirrors Mirror.
CompiledMixinMirror = lowLevelMirrors CompiledMixinMirror.
LowLevelMixinMirror = lowLevelMirrors LowLevelMixinMirror.
LowLevelMethodMirror = lowLevelMirrors LowLevelMethodMirror.
InstanceVariableMirror = lowLevelMirrors InstanceVariableMirror.
ImmutableMirrorGroup = (platform namespace MirrorGroups usingLib: platform) ImmutableMirrorGroup.


private vmmirror = platform blackMarket VMMirror new.

parserLib = Delay computation: [platform namespace BlocklessCombinatorialParsing usingLib: platform].
grammar = Delay computation: [platform namespace Newspeak3Grammar parserLib: parserLib].
asts = Delay computation: [platform namespace Newspeak3AST usingLib: platform].
parsing = Delay computation: [platform namespace Newspeak3Parsing
	usingLib: platform
	ast: asts
	grammar: grammar].
compilation = Delay computation: [platform namespace Newspeak3Compilation
	usingPlatform: platform 
	newspeakParser: parsing
	mirrorLib: platform mirrors].

protected storedCompiler "cached compiler and module"


private mixinBasedMirrors <WeakIdentitySet[MixinMirror]> = BrazilWeakStorage new.
|)
(
class ClassDeclarationBuilder fromMixinRep: rep <MixinRep> forExistingMixin: mixin <Mixin> = (
"
Builders do not give an ordinary mirror representing their current state: ask the builder itself. (Although this could be done: submit to atomic install without a namespace, don't install into Smalltalk, don't update the existingMixin, and reflect on the result.)

Builders internally keep a CompiledMixinMirror that reflects the current state, including edits made but not yet installed. Queries reflect the state of this CMM.

Builders are connected up and down.  If you get a builder on a declaration, if you ask *the builder* for an enclosing or nested declaration and edit, installing any of them means installing all of them.  Builders created de novo (via reflecting: or fromSource:) remain independent.
"|
	"Used to create the namespace for AtomicInstall so existing instances are updated"
	prvtExistingMixin <Mixin | nil> = mixin.

	"Lazy.  It should not be neccessary to always unpack an entire module definition.
	Perhaps this should be eager to complete creating-a-builder-is-like-forking semantics."
	prvtEnclosingDeclaration <ClassDeclarationBuilder>
	
	"Eager. Simplifies CDB on installed CD versus new CD.  This must be computed anyway to install."
	public instanceSide <MixinBuilder> = MixinBuilder 
		forClassDeclaration: self
		lowLevelMixin: rep first lowLevelMirror
		withNestedReps: rep last.
		
	public classSide <MixinBuilder> = MixinBuilder 
		forClassDeclaration: self
		lowLevelMixin: rep first lowLevelMirror classMixin
		withNestedReps: {}.
	
	prvtCompiledMixinMirror <CompiledMixinMirror> = rep first.
	
	public header <ClassHeaderBuilder> = ClassHeaderBuilder forClassDeclaration: self.
|)
('API'
enclosingClass ^<ClassDeclarationBuilder> = (
	prvtEnclosingDeclaration ifNil: [
		| enclosing <Class> |
		
		prvtExistingMixin isNil ifTrue: [^nil].
		
		enclosing:: SystemMetadata mixinOf: prvtExistingMixin definingClass. "the mixin slot is used to store the enclosing mixin of a defining class"
		enclosing ifNil:[^nil].
		
		prvtEnclosingDeclaration:: ClassDeclarationBuilder reflecting: enclosing mixin.
		
		prvtEnclosingDeclaration instanceSide nestedClasses addMirror: self
	].
	^prvtEnclosingDeclaration
)
fullyQualifiedName ^<Symbol> = (
	^prvtCompiledMixinMirror name
)
headerFromSource: newHeader <String> = (
	|
	compiledResults <MixinRep>
	|
	
	#BOGUS yourself.
	"API:
		<ClassDeclarationBuilder> headerFromSource:
		vs
		<ClassDeclarationBuilder> header source:
	
	Semantics: Do we allow the name to be changed? If so:	
		Have to check for conflicts with methods/slots of enclosing.
		If it conflicts with another class, override it?
		If it is new, does this make a copy, or replace the old one?
		
		Currently, this takes 'Foo = ()' instead of 'class Foo = ()'.  Perhaps we should do the latter since an access modifier might be specified?
	"
	compiledResults:: compiler compileClassHeader: ('Newspeak3 ''', header category, ''' class ', newHeader) readStream of: self.

	lazyIsTopLevel ifTrue: [
		"Result directly corrosponds to me"
		checkForSlotConflicts: compiledResults first.
		prvtCompiledMixinMirror: compiledResults first.
	] ifFalse: [
		"Result corresponds to my enclosing class, since my slot/accessor may have been adjusted"
		| nestedReps |
		nestedReps:: compiledResults last.
		assert: [nestedReps size = 1] message: 'Does it only answer with me and not my siblings?'.
		checkForSlotConflicts: nestedReps first first.
		enclosingClass prvtCompiledMixinMirror: compiledResults first.	
		prvtCompiledMixinMirror: nestedReps first first.
	].
)
install ^<ClassDeclarationMirror> = (
	|
	reps <List[MixinRep]>
	lowReps <List[LowLevelMixinRep]>
	mixinLists <List[MixinList]>
	|
	prvtEnclosingDeclaration ifNotNil: [
		"Modifications were made to my enclosing class, must go up to really install."
		prvtEnclosingDeclaration install.
		assert: [reflectee notNil] 
			message: 'Reflectee should have been filled in after install'.
		^ClassDeclarationMirror reflecting: reflectee
	].
 
	reps:: {computeMixinRep}.
	lowReps:: reps collect: [:ea | asLowLevelRep: ea].

	mixinLists:: atomicInstaller
		atomicallyInstallMixinReps: lowReps
		namespace: computeNamespace.

	mixinLists with: reps do: [:r <MixinList> :rep <MixinRep> | 
		"install metadata"
		install: r intoIDEBasedOn: rep.
	].
	
	assert: [mixinLists size = 1] message: 'Should be one MixinList result'.
	extractNewExistingMixinFrom: mixinLists first.
	notifyExistingMirrors.
	
	assert: [reflectee notNil] message: 'Reflectee should have been filled in after install'.
	^ClassDeclarationMirror reflecting: reflectee
)
name ^<Symbol> = (
	^fullyQualifiedName
)
reflectee ^<Mixin | nil> = (
	#BOGUS yourself.
	"If this builder corresponds to a class declaration that was already installed, we're okay. But this builder might represent a new class declaration that doesn't have a corresponding Mixin yet (#install will ensure it is filled, though). So, do we return a potentially nil reflectee or not support accessing a reflectee at all?"
	
	^prvtExistingMixin
)
simpleName ^<Symbol> = (
	^SystemMetadata fullyQualifiedNameToSimple: fullyQualifiedName
)'as yet unclassifed'
printOn: stm = (
	stm nextPutAll: 'ClassDeclarationBuilder('; nextPutAll: fullyQualifiedName; nextPutAll: ')'.
)'private'
asLowLevelRep: mixinrep = (
	^{	mixinrep first lowLevelMirror.
		mixinrep last collect: [:ea | asLowLevelRep: ea] }
)
checkForSlotConflicts: newCompiledMixinMirror = (
	
	newCompiledMixinMirror name = self name ifFalse: [Error signal: 'Cannot change name this way'].

	newCompiledMixinMirror lowLevelMirror instVars do: [:each <InstanceVariableMirror> | checkNameConflictsForSlot: each name].
)
checkNameConflictsForSlot: slotName <Symbol> = (
	(instanceSide nestedClasses includesMirrorNamed: slotName) 
		ifTrue:[^Error signal: 'Class already has nested class named ', slotName].		
	(instanceSide methods includesMirrorNamed: slotName)
		ifTrue:[^Error signal: 'Class already has method named ', slotName]
)
compiledMixinMirror = (
	"Asked for by compiler"
	^prvtCompiledMixinMirror
)
computeMixinRep = (
	^{	prvtCompiledMixinMirror.  
		instanceSide nestedClasses collect: [:ea | ea computeMixinRep] }
)
computeNamespace = (
	prvtExistingMixin isNil ifTrue: [^MutableHashedMap new].
	^MutableHashedMap new
		at: fullyQualifiedName put: prvtExistingMixin definingClass;
		yourself
)
extractNewExistingMixinFrom: mixinList = (
	prvtExistingMixin:: mixinList head mixin.	
	mixinList tail do: [:nestedMixinList |
		| n |
		n:: SystemMetadata fullyQualifiedNameToSimple: nestedMixinList head name.
		(instanceSide nestedClasses findMirrorNamed: n)
			extractNewExistingMixinFrom: nestedMixinList
	].
)
lazyIsTopLevel = (

	prvtEnclosingDeclaration isNil ifFalse: [^false].
	
	"enclosingDeclaration not yet created"
	prvtExistingMixin isNil ifTrue: [^true "can't be created: must be new decl"].
	^(SystemMetadata mixinOf: prvtExistingMixin definingClass) isNil
)
notifyExistingMirrors = (
	instanceSide notifyExistingMirrors.
	classSide notifyExistingMirrors.
)'testing'
isClassDeclarationMirror ^<Boolean> = (
	^true
)) : ('accessing'
fromSource: src <String> ^<ClassDeclarationBuilder> = (
	^self fromUnitSource: 'Newspeak3 ''Uncategorized'' ', src
)
reflecting: mixin <Mixin> ^<ClassDeclarationBuilder> = (
	assert: [mixin isMixin & mixin isMeta not] message: 'Provide an instance-side mixin'.
	^self 
		fromMixinRep: (mixinRepFor: mixin definingClass)
		forExistingMixin: mixin
)'as yet unclassified'
fromUnitSource: src <String> ^<ClassDeclarationBuilder> = (
	| rep <MixinRep> |
	rep:: compiler
		compileClassSource: src readStream
		within: nil.
	^self fromMixinRep: rep forExistingMixin: nil
))
class ClassDeclarationMirror reflecting: mixin <Mixin> = Mirror reflecting: mixin (
"A class declaration defines the instance and class sides, and a header. Each side comprises methods and nested classes. The header provides a superclass clauses, a primary factory a class comment and an instance initializer.  

This mirror provides a view of a class declaration based on its runtime representation in the Newspeak image running on Squeak. To create an instance, provide the instance-side mixin. The mirror can obtain all necessary information from that."|
	instanceSideLazy
	classSideLazy
|assert: [mixin isMixin & mixin isMeta not] message: 'Provide an instance-side mixin')
('API'
classSide ^ <MixinMirror> = (
	classSideLazy ifNil: [
		classSideLazy:: MixinMirror reflecting: reflectee classMixin].
	^classSideLazy
)
enclosingClass ^ <ClassDeclarationMirror> = (
	| enclosing <Class> |
	enclosing:: 	SystemMetadata mixinOf: reflectee definingClass. "the mixin slot is used to store the enclosing mixin of a defining class"
	enclosing ifNil:[^nil].
	^ClassDeclarationMirror reflecting: enclosing mixin
)
fullyQualifiedName ^ <Symbol> = (
	^reflectee definingClass name
)
header ^ <ClassHeaderMirror> = (
	^ClassHeaderMirror reflecting: reflectee
)
instanceSide ^ <MixinMirror> = (
	instanceSideLazy ifNil: [
		instanceSideLazy:: MixinMirror reflecting: reflectee].
	^instanceSideLazy
)
name ^ <Symbol> = (
	^self fullyQualifiedName
)
simpleName ^ <Symbol> = (
	^SystemMetadata fullyQualifiedNameToSimple: fullyQualifiedName
)
source ^ <String> = (
	^String streamContents: [ :s | reflectee definingClass printClassOn: s ]	
)'restricted'
compiledMixinMirror = (
	"Used by the compiler.  Polymorphic with ClassDeclarationBuilder, which must answer the one that represents edits in progress."
	^makeCompiledMixinMirrorForClass: reflectee definingClass
)'testing'
isClassDeclarationMirror ^<Boolean> = (
	^true
))
class ClassHeaderBuilder forClassDeclaration: decl = (
"Describe the class in this comment."|
	prvtDeclaration <ClassDeclarationBuilder> = decl.
|)
('as yet unclassified'
category ^<Symbol> = (
	^prvtDeclaration prvtCompiledMixinMirror category ifNil: ['Uncategorized']
)
category: c <Symbol | String> = (
	prvtDeclaration prvtCompiledMixinMirror category: c asSymbol
)
name ^<Symbol> = (
	"Is this full or simple?"
	^prvtDeclaration name
)
name: newName <Symbol> = (
	"This would be a nice convenience method"
	notYetImplemented
)
primaryFactory ^ <MethodBuiler> = (

	| lowLevelMethodMirror |

	lowLevelMethodMirror:: prvtDeclaration prvtCompiledMixinMirror lowLevelMirror classMixin methods mirrors
		detect: [:mirror | mirror isConstructor].

	^MethodBuilder reflecting: lowLevelMethodMirror in: prvtDeclaration classSide
)
source ^<String> = (
	^prvtDeclaration prvtCompiledMixinMirror header
)
source: newHeaderSource <String> = (
	prvtDeclaration headerFromSource: newHeaderSource
))
class ClassHeaderMirror reflecting: mixin <Mixin> = Mirror reflecting: mixin ("A class header defines the class' name, primary factory, superclass clause, class comment and instance initializer (slots and init expressions).

This mirror provides access to a class header based on the runtime representation.")
('API'
category ^ <Symbol> = (
	^reflectee definingClass basicCategory asSymbol
)
classComment ^ <String> = (
	^(SystemMetadata definingClassMetadataOf: reflectee definingClass) classComment
)
declaration ^<ClassDeclarationMirror> = (
	^ClassDeclarationMirror reflecting: self reflectee
)
primaryFactory ^ <MethodMirror> = (

	^MethodMirror reflecting: (reflectee classMixin definingClass 
		methodDict at: primaryFactoryName)
)
source ^ <String> = (
	^(SystemMetadata definingClassMetadataOf: reflectee definingClass)  languageData
)'as yet unclassified'
name ^ <Symbol> = (
	^reflectee definingClass name
)
preamble ^<Symbol> = (
	"Foo factory = SuperFoo superFactory"
	| headerAst |
	headerAst:: Language newspeak3 parserInstance classHeader parse: self source readStream.
	^source copyFrom: headerAst start to: headerAst superConstructorCall end
)
primaryFactoryName ^ <Symbol> = (
"return the selector of the primary factory"	
	"| headerAst |
	
	headerAst:: Language newspeak3 parserInstance classHeader parse: self source readStream.
	^headerAst constructor selector.

	"^(SystemMetadata definingClassMetadataOf: reflectee definingClass) constructorName
)
slotDecls ^ <MirrorGroup[SlotDefMirror]> = (
	
	^self slots
)
slots ^ <MirrorGroup[SlotDefMirror]> = (
	
	"Need also visibility, mutablity of each"
	^ImmutableMirrorGroup group: 
		((reflectee definingClass instVarNames
			reject: [:ea | ea includes: $`]) 
				collect: [:ea | SlotMirror named: ea])
)
superclassClause ^ <SendAST> = (
	^(SystemMetadata definingClassMetadataOf: reflectee definingClass) superclassClause
))
class ClassMirror reflecting: c <Class> = Mirror reflecting: c (
"WIP. New mirror for classes.  Does just what we need for porting the parser library.

Copyright (c) 2009-2010 Gilad Bracha

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ''Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"|

|)
('as yet unclassified'
allSuperclasses ^ <List[ClassMirror]> = (
	| klass <Class> superclasses <List[Class]> |
	superclasses:: MutableList new.
	klass:: superclass.
	[klass isNil] whileFalse:[
		superclasses add: klass.
		klass:: klass superclass.
	].
	^superclasses
)
canUnderstand: selector <Symbol> ^<Boolean> = (
	
	(mixin canUnderstand: selector) ifTrue: [^true].
	superclass = nil
		ifTrue: [^false]
		ifFalse: [^superclass canUnderstand: selector].
)
computeMirrorGroup: mgAccessor <[Mirror, ^MirrorGroup]> ^ <MirrorGroup> = (
"Return a mirror group based on the mixins group and those of all superclasses. The argument mgAccessor extracts a mirror group from any mirror provided to it."
	| mg <MirrorGroup>  |
	
	mg:: MutableMirrorGroup group:{} within: self.
	(allSuperclasses reverse add: self; yourself) do:[:klass <ClassMirror> |
		mg addAllMirrors: (mgAccessor value: klass mixin)
	].
	^ ImmutableMirrorGroup group: mg	
)
enclosingObject ^ <ObjectMirror> = (
	^SystemMetadata enclosingObjectOf: reflectee
)
methods ^ <MirrorGroup[MethodMirror]> = (
	^computeMirrorGroup: [:r | r methods]
)
mixin ^ <MixinMirror> = (

	^MixinMirror reflecting: reflectee mixin
)
name ^ <Symbol> = (
	^reflectee name
)
nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (
	^computeMirrorGroup: [:r | r nestedClasses]
)
simpleName ^ <Symbol> = (

	^ mixin simpleName
)
slots ^ <MirrorGroup[SlotMirror]> = (
	^computeMirrorGroup: [:r | r slots].
)
superclass ^ <ClassMirror> = (
	reflectee superclass isNil ifTrue:[^nil].
	^ClassMirror reflecting: reflectee superclass
))
class ImmutableMirrorGroupInMixin group: mirrorz in: mixinMirror = ImmutableMirrorGroup group: mirrorz (|
	public enclosingMixin <MixinMirror> = mixinMirror.
	public channelForChanges <Duct> = Duct new.
|channelForChanges beWeak owner: self)
('private'
private notifyAddedMirror: newMirror = (
	channelForChanges send: (MirrorAddedEvent forNewMirror: newMirror)
)
private notifyRemovedMirror: oldMirror = (
	channelForChanges send: (MirrorRemovedEvent forOldMirror: oldMirror)
)
private notifyReplacedMirror: oldMirror with: newMirror = (
	channelForChanges send: (MirrorReplacedEvent from: oldMirror to: newMirror)
)'restricted'
updateToContain: actualMirrors <Collection[Mirror]> = (
	

	|
	mirrorNames
	|
	"'update' out.
	mirrors out.
	'->' out.
	actualMirrors out."

	mirrorNames:: actualMirrors collect: [:newMirror |
		| oldMirror |
		oldMirror:: findMirrorNamed: newMirror simpleName.
		oldMirror == nil ifTrue: [
			mirrors addLast: newMirror.
			notifyAddedMirror: newMirror.
		] ifFalse: [
			oldMirror = newMirror ifTrue: [
				"Unchanged"
			] ifFalse: [
				mirrors at: (mirrors indexOf: oldMirror) put: newMirror.
				notifyReplacedMirror: oldMirror with: newMirror.
			]
		].
		newMirror simpleName.
	].

	mirrors copy do: [:oldMirror |
		(mirrorNames includes: oldMirror simpleName) ifFalse: [
			mirrors remove: oldMirror.
			notifyRemovedMirror: oldMirror.
		].
	].
))
class MessageMirror selector: s <Symbol> args: as <List[Object]> = (
"Reifies the notion of a message, per the Newspeak specification. This is what should actually be sent to doesNotUnderstand:"|
	selector <Symbol>= s.
	arguments <List[Object]> = as.
|)
('as yet unclassified'
sendTo: r <Object> ^ <Object> = (
	^r perform: selector with: arguments
))
class MethodBuilder reflecting: llm in: mb = (
"Describe the class in this comment."|
	prvtLowLevelMethodMirror = llm.
	prvtMixinBuilder = mb.
|)
('as yet unclassified'
category ^<Symbol> = (
	^prvtLowLevelMethodMirror metadata at: #category
)
category: cat <String | Symbol> = (
	^prvtLowLevelMethodMirror metadata at: #category put: cat asSymbol
)
definingMixin ^<MixinBuilder> = (
	^prvtMixinBuilder
)
name ^<Symbol> = (
	^prvtLowLevelMethodMirror selector
)
reflectee ^<CompiledMethod> = (
	#BOGUS yourself.
	"Poorly defined: If this a new method, the compiled method retrieved from the low level method would not be able to answer with its source.  This is because in Squeak, the compiled method has to ask for it from its class, which will fail if the method is not yet installed. Perhaps it would be better to not give access to this."
	"^lowLevelMethodMirror compiledMethod"
	FAIL.
)
selector ^<Symbol> = (
	^name
)
simpleName ^<Symbol> = (
	^name
)
source ^<String> = (
	^prvtLowLevelMethodMirror method 
		ifNil: [prvtLowLevelMethodMirror src]
		ifNotNil: [:it | it getSource]
))
class MethodMirror reflecting: m <CompiledMethod> = Mirror reflecting: m (
"A basic mirror for a language level method.")
('as yet unclassified'
category ^<Symbol> = (
	^reflectee methodClass organization categoryOfElement: name
)
definingMixin ^<MixinMirror> = (
	^MixinMirror reflecting: reflectee methodClass mixin
)
name ^<Symbol> = (
	^reflectee selector
)
simpleName = (
	^ name
)
source ^<String> = (
	^reflectee getSource asString
)
visibility ^<Symbol> = (
	#BOGUS yourself.  "Is the NS3 compiler setting this info?  Not that the VM respects it yet anyway..."
	reflectee isProtected ifTrue: [^#protected].
	reflectee isPrivate ifTrue: [^#private].
	^#public
))
class Mirror reflecting: r <Object> = (
"Top of the Mirror hierarchy. An abstract class.  

Copyright (c) 2009-2010 Gilad Bracha

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ''Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

"|
	reflectee <Object> = r.
|)
('as yet unclassified'
= other = (
	^self class = other class and: [self reflectee == other reflectee]
)
hash = (
	^ reflectee identityHash
)
isMirror ^<Boolean> = (
	^true
)
printOn: stm = (
	stm	nextPutAll: class simpleName.
	stm	nextPutAll: ' reflecting: '.
	reflectee printOn: stm.
)
reflecteeIfFail:  fblk <[Exception]> ^ <Object>  = (
	^reflectee "default; we can always access the reflectee of a local object; subclasses may override if there are issues"
))
class MirrorAddedEvent forNewMirror: m = MirrorEvent (
"Sent by a mirror group on its channelForUpdates when a new mirror has been added."|
	public newMirror = m.
|)
('as yet unclassified'
isMirrorAddedEvent ^<Boolean> = (
	^true
))
class MirrorEvent = (
""|
|)
('testing'
isMirrorEvent ^<Boolean> = (
	^true
))
class MirrorRemovedEvent forOldMirror: m = MirrorEvent (
"Sent by a mirror group on its channelForUpdates when an existing mirror has been removed."|
	public oldMirror = m.
|)
('as yet unclassified'
isMirrorRemovedEvent ^<Boolean> = (
	^true
))
class MirrorReplacedEvent from: oldM to: newM = MirrorEvent (
"Sent by a mirror group on its channelForUpdates when an existing mirror has been replaced by a new mirror."|
	public oldMirror = oldM.
	public newMirror = newM.
|)
('as yet unclassified'
isMirrorReplacedEvent ^<Boolean> = (
	^true
))
class MixinBuilder forClassDeclaration: cbd lowLevelMixin: llm withNestedReps: reps = (
"The mirror builder for mixins.  See MixinMirror."|
	public declaration <ClassDeclarationBuilder> = cbd.
	public isMeta <Boolean> = llm isMeta.
	public methods <MutableMethodGroup> = MutableMethodGroup group: (methodsFrom: llm) within: self.
	public nestedClasses <MutableNestedClassGroup> = MutableNestedClassGroup group: (nestedClassesFrom: reps) within: self.
|)
('accessing'
canUnderstand: selector <Symbol> ^<Boolean> = (
	
	"Slot, method, nested class, or factory method"
	
	(methods includesMirrorNamed: selector) ifTrue: [^true].
	(nestedClasses includesMirrorNamed: selector) ifTrue: [^true].
	(slots includesMirrorNamed: selector) ifTrue: [^true].
	(selector last = $:) ifTrue: [
		#BOGUS. "Someday immutable slots will be enforced and this won't be quite right"
		(slots includesMirrorNamed: (selector allButLast: 1)) ifTrue: [^true].
	].
	isMeta ifTrue: [
		declaration header primaryFactory simpleName = selector ifTrue: [^true].
	].
	^false
)
slots ^ <ImmutableMirrorGroup[SlotMirror]> = (
	| slotMirrors <Collection[SlotMirror]> | 
	isMeta ifTrue: [ slotMirrors:: {} ] ifFalse: [
		slotMirrors:: (declaration prvtCompiledMixinMirror lowLevelMirror instVars 
			collect: [:each <InstanceVariableMirror> | SlotMirror named: each name])
				reject: [:each <SlotMirror> | each name includes: $`].
	].
	^ImmutableMirrorGroup group: slotMirrors
)'private'
checkNameConflictsForMethod: selector <Symbol> = (
	(nestedClasses includesMirrorNamed: selector)
		ifTrue:[^Error signal: 'Class already has nested class named ', selector].
	(slots includesMirrorNamed: selector)
		ifTrue:[^Error signal: 'Class already has slot named ', selector].
	isMeta ifTrue: [declaration header primaryFactory simpleName = selector 
		ifTrue:[^Error signal: 'Class already has primary factory named ', selector]].
)
checkNameConflictsForNestedClass: klassName <Symbol> = (
	(methods includesMirrorNamed: klassName)
		ifTrue:[^Error signal: 'Class already has method named ', klassName].
	(slots includesMirrorNamed: klassName)
		ifTrue:[^Error signal: 'Class already has slot named ', klassName]	
)
methodsFrom: llm <LowLevelMixinMirror> ^<List[MethodBuilder]> = (
	^(llm methods 
		select: [:m <LowLevelMethodMirror> | m isSynthetic not])
			collect: [:m <LowLevelMethodMirror> | MethodBuilder reflecting: m in: self]
)
nestedClassesFrom: reps <List[MixinRep]> ^<List[ClassDeclarationBuilder]> = (
	^reps collect: [:rep <MixinRep> | | nc |
		
		nc:: (ClassDeclarationBuilder fromMixinRep: rep forExistingMixin: nil).
		nc prvtEnclosingDeclaration: declaration.
		
		"The existingMixin will be nil if this is a new (uninstalled) class declaration."
		declaration reflectee ifNotNil: [:mixin |
			| nestedDefiningClass |
			nestedDefiningClass:: (SystemMetadata systemMetadataOf: mixin definingClass) 
				nestedMixins detect: [:ea | ea name = nc name] ifNone: [nil].
			nc prvtExistingMixin: (nestedDefiningClass ifNotNil: [:it | it mixin]).
		].
		
		nc
	]
)
notifyExistingMirrors = (
	isMeta
		ifTrue: [mixinChanged: declaration reflectee classMixin]
		ifFalse: [mixinChanged: declaration reflectee].

	nestedClasses do: [:ea | ea notifyExistingMirrors].
)) : ('as yet unclassified'
reflecting: mixin <Mixin | ClassMixin> ^<MixinBuilder> = (
	^mixin isMeta
		ifTrue: [(ClassDeclarationBuilder reflecting: mixin definingClass theNonMetaClass mixin) classSide]
		ifFalse: [(ClassDeclarationBuilder reflecting: mixin) instanceSide]
))
class MixinMirror reflecting: m <Mixin> = Mirror reflecting: m (
"A mixin is the difference between a class and its superclass: a set of additional methods, slots and nested class declarations.  Newspeak class declarations define an instance-side mixin and a class-side mixin, and Newspeak classes (other than Top) are all the result of mixin application.

What about mirroring the initializer?
Need to decide who does these things - the class declaration mirror or the mixin mirror. One should delegate to the other."|
	slotsLazy
	methodsLazy 
	nestedClassesLazy 
|mixinBasedMirrors add: self)
('accessing'
applications ^<Set[ClassMirror]> = (

	| apps |
	apps:: IdentitySet new.
	apps addAll: reflectee applications.
	isMeta ifFalse: [
		apps addAll: (SystemMetadata systemMetadataOf: reflectee definingClass) applications.
	].
	^apps collect: [:ea | ClassMirror reflecting: ea]
)
canUnderstand: selector <Symbol> ^<Boolean> = (
	
	"Slot, method, nested class, or factory method"
	
	(methods includesMirrorNamed: selector) ifTrue: [^true].
	(nestedClasses includesMirrorNamed: selector) ifTrue: [^true].
	(slots includesMirrorNamed: selector) ifTrue: [^true].
	(selector last = $:) ifTrue: [
		#BOGUS. "Someday immutable slots will be enforced and this won't be quite right"
		(slots includesMirrorNamed: (selector allButLast: 1)) ifTrue: [^true].
	].
	isMeta ifTrue: [
		declaration header primaryFactory simpleName = selector ifTrue: [^true].
	].
	^false
)
declaration ^ <ClassDeclarationMirror> = (
	^ClassDeclarationMirror 
		reflecting: (isMeta ifFalse:[reflectee] ifTrue:[dualMixin reflectee]) 
)
isMeta ^ <Boolean> = (
	^self reflectee isMeta
)
isMixinMirror ^<Boolean> = (
	^true
)
methods ^ <MirrorGroup[MethodMirror]> = (
	methodsLazy ifNil: [
		methodsLazy:: ImmutableMirrorGroupInMixin group: computeMethods in: self].
	^methodsLazy
)
name ^ <Symbol> = (
	^reflectee name
)
nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (
	nestedClassesLazy ifNil: [
		nestedClassesLazy:: ImmutableMirrorGroupInMixin group: computeNestedClasses in: self].
	^nestedClassesLazy
)
simpleName ^ <Symbol> = (

	^ SystemMetadata fullyQualifiedNameToSimple: reflectee definingClass name
)
slots ^ <MirrorGroup[SlotMirror]> = (
	slotsLazy ifNil: [
		slotsLazy:: ImmutableMirrorGroupInMixin group: computeSlots in: self].
	^slotsLazy
)'as yet unclassified'
classMixin ^ <MixinMirror> = (
	#BOGUS yourself.
	isMeta 
		ifFalse:[^MixinMirror reflecting: reflectee classMixin]
		ifTrue:[^MixinMirror reflecting: Metaclass mixin].
		"This would be true in a pure Newspeak system, but not on our implementation"
)
dualMixin ^ <MixinMirror> = (
	isMeta 
		ifTrue:[^MixinMirror reflecting: reflectee definingClass theNonMetaClass mixin]
		ifFalse:[^classMixin].
)'private'
computeMethods ^ <Collection[MethodMirror]> = (
	^(reflectee definingClass methodDict
		collect: [:each <CompiledMethod> | MethodMirror reflecting: each])
			reject: [:each <MethodMirror> | each reflectee isSynthetic].
)
computeNestedClasses ^<Collection[ClassDeclarationMirror]> = (
	| metadata |
	isMeta ifTrue: [^{}].
	metadata:: SystemMetadata systemMetadataOf: reflectee definingClass.
	^metadata nestedClasses
		ifNotNil: [:nc | nc collect: [:each | ClassDeclarationMirror reflecting: each mixin ]]
		ifNil: [{}].
)
computeSlots ^ <Collection[SlotMirror]> = (
	^(reflectee definingClass instVarNames 
		reject: [:iv <String> | iv includes: $`])
			collect: [:iv <String> | SlotMirror named: iv].
)'restricted'
mixinChanged = (
	slotsLazy ifNotNil: [:it | it updateToContain: computeSlots].
	methodsLazy ifNotNil: [:it | it updateToContain: computeMethods].
	nestedClassesLazy ifNotNil: [:it | it updateToContain: computeNestedClasses].
))
class MutableMethodGroup group: mirrors within: mb = MutableMirrorGroup group: mirrors within: mb (
""|
|)
('accessing'
addFromSource: s <String> = (
	| 
	result <LowLevelMethodMirror>
	newM
	|
	result:: compiler
		compileMethodSource: s readStream 
		within: enclosingMixin declaration.
	result metadata at: #category put: #'as yet unclassified'. "Or it will think it's synthetic and lose the source"
	
	newM:: MethodBuilder reflecting: result in: enclosingMixin.
	addMirror: newM.
	^newM
)
addMirror: m <MethodBuilder>= (
	
	"What would it mean if a user of builders called this?  A MethodMirror would need to be converted to a MethodBuilder.  A MethodBuilder that already is a member of another method group may need to be copied."
	
	enclosingMixin checkNameConflictsForMethod: m name.
	
	super addMirror: m.
	lowLevelMixin methods addMirror: m prvtLowLevelMethodMirror.
	^m
)
removeMirror: m = (

	super removeMirror: m.
	lowLevelMixin methods removeMirror: m prvtLowLevelMethodMirror.
)'private'
lowLevelMixin = (
	"Cannot cache from instantiation: might be replaced by editing class header or add/remove nested class."	
	^enclosingMixin isMeta
		ifTrue: [enclosingMixin declaration compiledMixinMirror lowLevelMirror classMixin]
		ifFalse: [enclosingMixin declaration compiledMixinMirror lowLevelMirror].
))
class MutableMirrorGroup group: ms within: mb = ImmutableMirrorGroup group: ms (
"A mirror group for high level mirrors. Takes base level elements as arguments to be added, and supports a notion of ordering, so that source declaration ordering can be preserved.

A MutableMirrorGroup knows about its enclosing mirror, because it supports adding members in source form via the #addFromSource: abstract method, which is specialized by subclasses. The source must be compiled, and that requires the enclosing mirror to provide the necessary surrounding scope.
"| 
	public enclosingMixin <MixinBuilder> = mb.	"definingMixin?"
|)
('as yet unclassified'
addAllMirrors: mirrorGroup <MirrorGroup | Collection[Mirror]> = (
	mirrorGroup do: [:each | addMirror: each]
)
addFromSource: s <String> = (
	self subclassResponsibility
)
addMirror: m <Mirror>  = (
	mirrors keysAndValuesDo: [:index :mirror | 
		mirror simpleName = m simpleName ifTrue: [^mirrors at: index put: m]].
	^mirrors addLast: m
)
mirrors ^ <MutableHashedMap[Mirror]> = (
" mirrors is also an outer scope slot; we define this method to ensure we get the inherited one."
	^super mirrors
)
removeAll = (
	mirrors: MutableList new.
)
removeAllSuchThat: blk = (
	mirrors select: blk thenDo: [ :m <Mirror> | removeMirrorNamed: m name].
)
removeMirror: m <Mirror> = (
	^mirrors remove: m
)
removeMirrorNamed: n <Symbol | String> = (
	| m |
	m:: findMirrorNamed: n.
	^m ifNotNil: [removeMirror: m].
))
class MutableNestedClassGroup group: mirrors within: mb = MutableMirrorGroup group: mirrors within: mb (
""|
|)
('accessing'
addFromSource: source <String> ^<ClassDeclarationBuilder> = (
	|
	enclosingDeclaration
	compiledResults <MixinRep>
	nestedReps
	newCDB
	|
	enclosingDeclaration:: enclosingMixin declaration.
	
	compiledResults:: compiler 
		compileClassSource: ('Newspeak3 ''', enclosingDeclaration header category, ''' ', source) readStream
		within: enclosingDeclaration.
		
	enclosingDeclaration prvtCompiledMixinMirror: compiledResults first.
	nestedReps:: compiledResults last.
	
	assert: [nestedReps size = 1] message: 'Does it only answer with me and not my siblings?'.
	
	newCDB:: ClassDeclarationBuilder fromMixinRep: nestedReps first forExistingMixin: nil.
	newCDB prvtEnclosingDeclaration: enclosingDeclaration.
		
	addMirror: newCDB.
	^newCDB
)
addMirror: m <ClassDeclarationBuilder> = (

	#BOGUS yourself.
	"What would it mean if a user of builders called this?  A ClassDeclarationMirror would need to be converted to a ClassDeclarationBuilder.  A ClassDeclarationBuilder that already has an enclosing class different than this group's would need to be deep copied."

	enclosingMixin checkNameConflictsForNestedClass: m simpleName.
	super addMirror: m.
	^m
)
removeMirror: victim <ClassDeclarationBuilder> = (
	|
	victimName
	sep
	|
	"Must patch the compiled mixin mirror: remove my slot and accessor"
	victimName: victim fullyQualifiedName.
	sep:: Language newspeak3 syntheticNameSeparator.
	lowLevelMixin methods removeMirrorNamed: victimName,sep,'slot'.
	lowLevelMixin methods removeMirrorNamed: victimName,sep,'slot:'.
	lowLevelMixin methods removeMirrorNamed: victim simpleName.
	lowLevelMixin instVars removeMirrorNamed: victimName,sep,'slot'.
	
	"Indices can change"
	compiler generateSlotAccessorsFor: lowLevelMixin.
	
	super removeMirror: victim.
)'private'
lowLevelMixin = (
	"Cannot cache from instaniation: might be replaced by editing class header or add/remove nested class."
	^enclosingMixin isMeta
		ifTrue: [enclosingMixin declaration compiledMixinMirror lowLevelMirror classMixin]
		ifFalse: [enclosingMixin declaration compiledMixinMirror lowLevelMirror].
))
class ObjectMirror reflecting: r <Object> = Mirror reflecting: r (
"A high level mirror on local objects. The API for a Newspeak object mirror is exceedingly simple. One can view or change its reflectee's class; one can send the reflectee a message; one can set the reflectee's slots; and one can request access to the reflectee.  We may later extend this with printing/safe printing, the ability to execute an arbitrary method on the reflectee, or generalized super-object access.

All of this is realized in methods of this class, except reflectee access which is inherited.

Note that there is no need to get slots - we can send a message to do that.  However, for the time being we support that as well, as there is no way to access overridden features.

The differences between #perform: on an object and a mirror are:

1. The mirror can perform private messages.
2. The mirror forces the user to deal with possible failure.
3. The result is also a mirror.

We may choose to refactor the implementation so that all the work is done by a NewspeakObjectMirorUtility. The idea is that in cases where many objects are involved, it is wasteful to allocate a dedicated mirror per object. Instead,  the utility can be shared across all the objects. This works as long as we are prepared to give out a global authority to mirror all objects; if we want fine grain security, we need a capability per object.

Copyright (c) 2009-2010 Gilad Bracha

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ''Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

")
('as yet unclassified'
evaluate: expression <String> ^<ObjectMirror> = (
	
	| cls mxn mtdMirror result |
	cls:: vmmirror classOf: reflectee.
	mxn:: MixinMirror reflecting: cls mixin.
	mtdMirror:: compiler
		compileExpressionSource: expression readStream
		inContext: nil
		inMixin: mxn declaration. 
		
	mtdMirror metadata at: #category put: 'DoIts'.
	mtdMirror klass: cls.
	
	result:: vmmirror 
		object: reflectee 
		executeMethod: mtdMirror compiledMethod
		with: {}
		ifFail: [primitiveFailed].

	^ObjectMirror reflecting: result
)
getClassIfFail:  fblk <[Exception]> ^ <ClassMirror>  = (
	^ClassMirror reflecting: (vmmirror classOf: reflectee)  "never fails on local objects"
)
getSlot: slotName <Symbol> ifFail:  fblk <[Exception, ^R def]> ^ <ObjectMirror | R> = (
	^self class reflecting: ( vmmirror
		namedSlotOf: reflectee
		at: (reflectee class instVarIndexFor: slotName)
		ifFail: fblk
	)
)
perform: selector <Symbol> with:  args <Array[Object]> ifFail:  fblk <[Exception]>  ^ <ObjectMirror> = (
	| result <Object> |
	result:: [reflectee perform: selector withArguments: args] on: Error do: [:ex <Error> | ^fblk value: ex].
	^self class reflecting: result
)
setClass: klass <Class | ClassMirror> ifFail:  fblk <[Exception]> ^ <ClassMirror>  = (
	vmmirror changeClassOf: reflectee to: klass ifFail: fblk
)
setSlot: slotName <Symbol> to:  obj <Object> ifFail:  fblk <[Exception]> = (
	vmmirror
		namedSlotOf: reflectee
		at: (reflectee class instVarIndexFor: slotName)
		put: obj
		ifFail: fblk
))
class SlotMirror named: n <String> = Mirror reflecting: n (
"WIP. Just enough to get us going.

Copyright (c) 2009-2010 Gilad Bracha

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ''Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.")
('as yet unclassified'
isMutable = (
	"Used by compiler in scope building"
	^true
)
name ^ <String> = (
	#BOGUS yourself.
	^reflectee
)
simpleName = (

	^ name
)
source = (
	^name
))'as yet unclassified'
compiler ^ <Newspeak3Compilation Compiler> = (
	storedCompiler ifNil:[
			storedCompiler:: compilation Compiler new.
			storedCompiler language: Language newspeak3.	].
	^storedCompiler
)
mixinChanged: mixin = (
	#BOGUS. "It really should be 'mirror reflectee == mixin', but it appears there are still issues with atomic install"
	mixinBasedMirrors do: [:mirror | 
		mirror reflectee definingClass = mixin definingClass ifTrue: [mirror mixinChanged]].
)'construct-mixinrep'
isConstructorSelector: sel forMixin: mxn = (
	^mxn declaration header primaryFactoryName = sel
	"^ (sel = 'new') 
		ifTrue: [ true ]
		ifFalse: [ | src <Yield> impl | 
			impl:: mxn isMeta
			ifFalse: [ mxn implementationMirror ]
			ifTrue: [ | klass <Class> |
				klass:: mxn implementationMirror implementationClass.
				(reflectionClass new mixinFor: klass theNonMetaClass) implementationMirror
			].
		src:: impl classHeader constructor.
		src isNil 
			ifTrue: [ false ]
			ifFalse: [ | mp <MessagePatternAST> |
				mp:: parserInstance messagePattern parse: src contents readStream.
				sel = mp selector]]."
)
isNestedClassAccessorSelector: sel forMixin: mxn = (
	| ts <OrderedCollection[String]> |
	ts:: sel findTokens: syntheticNameSeparator.
	^ (ts size = 1 and: [mxn nestedClasses includesMirrorNamed: ts anyOne])
		or: [ ts size > 2 
			and: [(ts last = 'slot' or: [ts last = 'slot:']) 
				and: [mxn nestedClasses includesMirrorNamed: (ts at: ts size - 1)]]]
)
isSlotAccessorSelector: sel forMixin: mxn = (
	^ (mxn slots includesMirrorNamed: sel)
		or: [(sel endsWith: ':') 
			and: [mxn slots includesMirrorNamed: (sel copyFrom: 1 to: sel size - 1)]].	
)
isSubInitializerSelector: sel = (
	| ts  <OrderedCollection[String]> | 
	ts:: sel findTokens: syntheticNameSeparator.
	^ ts size > 1 
		and: [(ts at: ts size - 1) isPositiveInteger 
		and: [ (ts last) startsWith: 'init' ]].	
)
isSuperConstructorSelector: sel = (
	| ts  <OrderedCollection[String]> | 
	ts:: sel findTokens: syntheticNameSeparator.
	^ ts size > 1 and: [(ts at: ts size - 1) = 'superInit'].
)
makeCompiledMixinMirrorFor: lowLevelMixinMirror <LowLevelMixinMirror> from: aClass <Class> = (
	| klassMeta |
	klassMeta:: SystemMetadata definingClassMetadataOf: aClass.
	
	^ (lowLevelMirrors CompiledMixinMirror 
					language: klassMeta language
					header:  klassMeta languageData
					mirror: lowLevelMixinMirror)
			category: aClass category; "use system metadata?"
			comment: aClass comment."use system metadata?"	
)
makeCompiledMixinMirrorForClass: aClass <Class> = (
	^ makeCompiledMixinMirrorFor: (makeLowLevelMixinMirrorFor: aClass) from: aClass.
)
makeLowLevelMethodMirrorNamed: selector fromCompiledMethod: cm <CompiledMethod> inClass: klass <Class> ^ <LowLevelMethodMirror> = (

	| mirror |
	mirror:: lowLevelMirrors LowLevelMethodMirror new.
	mirror
		method: cm; 
		klass: klass; 
		selector: selector.	
	^mirror
)
makeLowLevelMixinMirrorFor: klass <Class> = (
	| llm <LowLevelMixinMirror> llcm | 
	assert:[klass isMeta not] message: ''.
	
	llm:: lowLevelMirrors LowLevelMixinMirror named: klass name isMeta: false.

	"instance variables -- n.b. slot accessors need to be generated"
	klass instVarNames do: [: iv | 
		llm instVars addMirror: (lowLevelMirrors InstanceVariableMirror named: iv)
	].

	"methods"
	klass methodDictionary keysAndValuesDo: [ :selector :method |
		| methodMirror |
		methodMirror:: makeLowLevelMethodMirrorNamed: selector 
						fromCompiledMethod: method 
						inClass: klass.
		methodMirror selector: selector. "temporary fix for t0 / t0: issue"
		llm methods addMirror: methodMirror.
	].
	setMetadataForMixinMirror: llm inClass: klass.

	"category"
	llm category: (klass category ifNil:['uncategorized'] ifNotNil:[:c <String> | c]).
	
	"meta class / class side"
	llcm:: lowLevelMirrors LowLevelMixinMirror named: klass class name isMeta: true.
	klass class methodDictionary keysAndValuesDo: [ :sel :mtd | | methodMirror |
		methodMirror:: makeLowLevelMethodMirrorNamed:  sel 
						fromCompiledMethod: mtd 
						inClass: klass class.
		llcm methods addMirror: methodMirror.
	].
	setMetadataForMixinMirror: llcm inClass: klass class.
	llm cachedClassMixin: llcm.
	
	^llm
)
mixinRepFor: definingClass <Class> ^ <MixinRep> = (
	| 
		compiledMixinMirror <CompiledMixinMirror>
		nestedClassesMixinReps <Collection[MixinRep]>
		lowMirror <LowLevelMixinMirror>
		classMetadata <DefiningClassMetadata>
	|
	lowMirror:: makeLowLevelMixinMirrorFor: definingClass .
	setMetadataForMixinMirror: lowMirror inClass: definingClass .
	compiledMixinMirror:: makeCompiledMixinMirrorFor: lowMirror from: definingClass .

	classMetadata:: SystemMetadata definingClassMetadataOf: definingClass .	
	nestedClassesMixinReps:: classMetadata nestedClasses asOrderedCollection
		collect: [ :nc <Class> | mixinRepFor: nc ].

	^ { compiledMixinMirror . nestedClassesMixinReps }
)
setMetadataForMethodMirror: mirror <LowLevelMethodMirror> inClass: klass <Class> ^ <LowLevelMethodMirror> = (
	| category <String> |

	category:: (klass organization categoryOfElement: mirror selector).
	mirror metadata at: #isSynthetic put: category isNil.
	mirror metadata at: #category put: category.
	category ifNil: [ setMetadataForSyntheticMethod: mirror inClass: klass ].
	^ mirror
)
setMetadataForMixinMirror: mirror <LowLevelMixinMirror> inClass: klass <Class> ^ <LowLevelMixinMirror> = (

	mirror methods do: [ :mm <LowLevelMethodMirror> |
		setMetadataForMethodMirror: mm inClass: klass.
	].

	^ mirror
)
setMetadataForSyntheticMethod: mtd <LowLevelMethodMirror> inClass: klass <Class> ^ <LowLevelMethodMirror> = (
	| lang selector meta mxn |
	lang:: klass language.
	assert: [ lang isNewspeakLanguage3 ] message: 'procedure expects NS3'.
	mxn:: MixinMirror reflecting: klass mixin.
	selector:: mtd selector.

	meta:: mtd metadata.
	meta at: #isSuperConstructor put: false.
	meta at: #isSubInitializer put: false.
	meta at: #isConstructor put: false.
	meta at: #isSlotAccessor put: false.
	meta at: #isNestedClassAccessor put: false.

	"mutually exclusive, therefore shortcut semantics"
	(isSuperConstructorSelector: selector)
		ifTrue: [ meta at: #isSuperConstructor put: true. ^ mtd].
	(isSubInitializerSelector: selector) 
		ifTrue: [meta at: #isSubInitializer put: true. ^ mtd].
	(isSlotAccessorSelector: selector forMixin: mxn)
		ifTrue: [meta at: #isSlotAccessor put: true. ^ mtd].
	(isNestedClassAccessorSelector: selector forMixin: mxn)
		ifTrue: [meta at: #isNestedClassAccessor put: true. ^ mtd].
	(isConstructorSelector: selector forMixin: mxn)
		ifTrue: [meta at: #isConstructor put: true. ^ mtd].
)
syntheticNameSeparator = (
	^ Language syntheticNameSeparator.
)'install-metadata'
hideSyntheticMethodsOf: c <Class> basedOn: m <LowLevelMixinMirror> = (

	hideSyntheticMethodsOf: c usingMirror: m.
	hideSyntheticMethodsOf: c class usingMirror: m classMixin.
)
hideSyntheticMethodsOf: c <Class> usingMirror: m <LowLevelMixinMirror> = (

	m methods do: [: mtd <LowLevelMethodMirror> |
				(mtd metadata at: #isSynthetic ifAbsent:[false])
					ifTrue:[c organization basicRemoveElement: mtd name]
			]
)
install: mlist <MixinList> intoIDEBasedOn: mr <MixinRep> = (
	self installClass: mlist head intoIDEBasedOn: mr first.
	mlist tail with: mr last do:[:r <MixinList> : rep <MixinRep> | 
		install: r intoIDEBasedOn: rep.
	].
)
installClass: c <Class> intoIDEBasedOn: m <CompiledMixinMirror> = (
	"c environment: Smalltalk."
	"set environment"
	hideSyntheticMethodsOf: c basedOn: m lowLevelMirror.
	"fix organization to hide synthetic methods"

	(SystemMetadata systemMetadataOf: c) 
		language: (m language ifNil: [halt]);
		languageData: m header. 
		"set header in metadata based on source code in m"
	
	m lowLevelMirror methods do: [ :mtdMirror | 
		mtdMirror metadata at: #category ifPresent: [ :cat | 
			cat isNil ifFalse: [c organization quietlyClassify: mtdMirror selector under: cat]
		].
	].
	
	"category?"
	"ad hoc solution. add information to metadata?"
	c category: (m category isNil ifTrue: [ #'' ] ifFalse: [ m category ]).
))