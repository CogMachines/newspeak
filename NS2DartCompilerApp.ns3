Newspeak3
'NS2Dart'
class NS2DartCompilerApp packageUsing: ns = (
"An app for the Newspeak-to-Dart compiler.

Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
	CP = ns NS2CombinatorialParsing CombinatorialParsing.
	BCP = ns NS2CombinatorialParsing BlocklessCombinatorialParsing.
	BlocklessCombinatorialParsing = BCP mixin |> CP.
	Grammar = ns Newspeak3Grammar.
	ASTs = ns Newspeak3AST.
	Parsing = ns Newspeak3Parsing.
	Generation = ns DartGeneration.
	Mirrors = ns MirrorsForDart.
	Compilation = ns Newspeak2DartCompilation.
	
	runtime = ns RuntimeForDart packageUsing: ns.
|)
(
class CompilerApp usingPlatform: p = (|
	private parserLib = BlocklessCombinatorialParsing usingLib: p.
	private grammar = Grammar parserLib: parserLib.
	private asts = ASTs usingLib: p.
	private parsing = Parsing usingLib: p ast: asts grammar: grammar.
	private generation = Generation usingPlatform: p.
	private mirrors = Mirrors usingPlatform: p.
	private compilation = Compilation usingPlatform: p parsing: parsing generation: generation mirrors: mirrors. 
	
	private OrderedCollection = p collections OrderedCollection.
	private ObjectMirror = p mirrors ObjectMirror.
	|)
('entry'
public compileApp: app to: output = (
	compileApp: app withRuntime: runtime to: output
)
public compileApp: app withRuntime: runtimeArg to: output = (
	compileAppSources: (extractSourcesFromApp: app)
	withRuntimeSource: (extractSourcesFromApp: runtimeArg)
	to: output
)
public compileAppSources: appSources withRuntimeSource: runtimeSource to: output = (
	compilation Infrastructure 
		withAppSources: (appSources)
		withRuntimeSources: (runtimeSource)
		outputTo: output
)
public compileSource: appDefnSource to: output = (
	compileAppSources: {appDefnSource}
	withRuntimeSource: (extractSourcesFromApp: runtime)
	to: output
)'private'
private extractSourcesFromApp: app = (
	"Ordered is important: the app definition must come first"
	|
	modules = OrderedCollection new. 
	mirror = ObjectMirror reflecting: app.
	|
	modules add: (sourceOf: app class).
	(mirror getClassIfFail: []) slots do: [:slot |
		| klass = (mirror getSlot: slot name ifFail: [halt]) reflectee. |
		modules add: (sourceOf: klass)].
	^modules asArray
)
private sourceOf: klass = (
	| stream |
	stream:: (String new: 1000) writeStream.
	klass mixin printTopClassOn: stream.
	^stream contents.
)) : ()'as yet unclassified'
main: platform args: args = (
	^CompilerApp usingPlatform: platform
)) : ()