Newspeak3
'Samples'
 class SimpleBrowsing usingPlatform: p  ide: webIde =  (
(* An IDE for Newspeak on the web. 
Copyright 2016-2017 Google Inc.
*)|     (* imports *)      StringBuilder = p kernel StringBuilder.	Subject = p hopscotch core Subject.	Presenter = p hopscotch core Presenter.	TextEditorFragment = p hopscotch fragments TextEditorFragment.	Color = p graphics Color.	Gradient = p hopscotch Gradient.	List = p collections List.	Map = p collections Map.	ClassMirror = p mirrors ClassMirror.	ObjectMirror = p mirrors ObjectMirror.	ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.	(* module variables *)	ide = webIde.	detailAreaRatio = 1.6.	captionColor = Color h: 240 s: 0.05 v: 0.9.      |) (
class ClassFactoryPresenter onSubject: s <ClassFactorySubject> = MethodPresenter onSubject: s (
(* WIP. Present the factory method, colorized *)) (
acceptResponse ^ <[:TextEditorFragment :Event]> = (
	^[:ed <TextEditorFragment> :event <Event> | 
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		b addFactoryFromSource: ed textBeingAccepted.
		b declaration install.
		ed text: (colorizeMethodSource: (crToLf: ed textBeingAccepted)).
		ed setCursor.
		ed leaveEditState.
		]	
)
colorizeMethodSource: s <String> ^ <TextFragment> = (
	^ text: (ide colorizer parseClassHeader: s fromClass: subject classDeclaration) 
)
) : (
)
class ClassFactorySubject onModel: m <ClassDeclarationMirror> = MethodSubject onModel: m (
(* WIP. *)) (
public accessModifier ^ <Symbol> = (
	^#public
)
public createPresenter ^ <ClassFactoryPresenter> = (
	^ClassFactoryPresenter onSubject: self
)
) : (
)
class ClassPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
** p  <[Number]> = (
	^p
)
collapsedHeadingDefinition = (
	^row: {
		blank: 5.
		image: ide images classIcon.
		blank: 5.
		link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror (* Why do we need a copy? *)]
		}.
)
public definition ^ <Fragment> = (
	^column: {
		headingDefinition.
		minorClassHeadingBlock: (label: 'Classes').
		column: (subject classMirror instanceSide nestedClasses collect: [:ea | nestedClass: ea]).
		minorClassHeadingBlock: (label: 'Methods').
		column: (subject classMirror instanceSide methods collect: [:ea | (MethodSubject onModel: ea) presenter]).
		minorClassHeadingBlock: (label: 'Class Methods').
		column: (subject classMirror classSide methods collect: [:ea | (MethodSubject onModel: ea) presenter]).
	}
)
expandedHeadingDefinition ^ <Fragment> = (
	| parts |
	parts:: List new.
	subject enclosingClassSubjects
		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]
		separatedBy: [parts add: ( label: ' in ')].
	^column: {
		blank: 5.
		row: {blank: 5. image: ide images classIcon. blank: 5. row: parts}.
		inspectSelf.
		label: 'Slots'.
		row: {
			mediumBlank.
			column: (subject classMirror instanceSide slots collect: [:ea | label: ea name]).
		}.
	}
)
headingDefinition ^ <Fragment> = (
	^(column: {
		expanded: [expandedHeadingDefinition]
		collapsed: [collapsedHeadingDefinition].
	}) color: (Color h: 240 s: 0.05 v: 0.9).
)
headingDefinition:  minorClassHeadingColor <Object> = (
  | definition <Type> |
	^(column: {
		expanded: [ :inspectSelf | expandedHeadingDefinition]
		collapsed: [ | inspectSelf | collapsedHeadingDefinition].
	}) color: (Color h: 240 s: 0.05 v: 0.9).
)
inspectSelf ^ <Fragment> = (
	^row: {filler. link:  'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]}
)
minorClassHeadingBlock: body = (
	^(padded: body with: {10. 5. 5. 5.})
		color: minorClassHeadingColor
)
minorClassHeadingColor = (
	^Gradient 
		from: (Color h: 240 s: 0.02 v: 0.94) 
		to: (Color h: 240 s: 0.02 v: 0.9)
)
nestedClass: cdm = (
	^collapsed: [row: {			
					image: (iconForAccessModifier: cdm accessModifier).
					blank: 3.
					link: cdm simpleName action: [enterSubject:: ClassSubject onModel: cdm]
					}
				]
	expanded: [(ClassSubject onModel: cdm) presenter]
)
) : (
)
public class ClassSubject onModel: m <ClassDeclarationMirror> = Subject onModel: m (|
|) (
public classCommentText ^<String> = (
	^model header classComment ifNil: ['']
)
public classMirror ^ <ClassDeclarationMirror> = (
	^model
)
public createPresenter = (
	^ClassPresenter onSubject: self
)
public enclosingClassSubjects = (
	| them = List new. c |
	c:: model.
	[c isNil] whileFalse: [them add: (ClassSubject onModel: c). c:: c enclosingClass].
	^them
)
public name = (
	^model simpleName
)
public title = (
	^name
)
) : (
)
public class DefinitionListPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* DefinitionListPresenter is an abstract superclass of presenters that displays helper ''transient'' presenters that visually appear to belong to the main list of subject presenters. One common example is a method list presenter which can at times include presenters for methods being added or residue presenters of removed methods. *)| prefixes <PresenterList> content <PresenterList> suffixes <PresenterList> |) (
public collapseAll = (
	(* Collapse all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	(*majorUpdate: [*)
		content presenters do: [:each | each collapse]
		(*]*)
)
contentList ^ <PresenterList> = (

	^list: [contentPresenters]
)
contentPresenters ^ <List[Presenter]> = (

	^List new
)
definition ^ <Fragment> = (

	prefixes:: list.
	content:: contentList.
	suffixes:: list.
	^column: {
		prefixes.
		content.
		suffixes.
		}
)
public expandAll = (
	(* Expand all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	(*majorUpdate: [*)
		content presenters do: [:each | each expand]
		(*]*)
)
) : (
)
class MethodPresenter onSubject: s <MethodSubject> = ProgrammingPresenter onSubject: s (
(* A presenter for a single method. *)) (
acceptResponse ^ <[:TextEditorFragment :Event]> = (
	^[:ed <TextEditorFragment> :event <Event> | 
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		b methods addFromSource: ed textBeingAccepted.
		b declaration install.
		ed text: (colorizeMethodSource: (crToLf: ed textBeingAccepted)).
		ed setCursor.
		ed leaveEditState.
		]	
)
changeResponse ^ <[:TextEditorFragment :Event]> = (
	^[:ed <TextEditorFragment> :event <Event>  |  | cp <Integer> |
		ed textBeingAccepted out.
		cp:: ed cursorPosition.
		ed text: (colorizeMethodSource: (crToLf: ed textBeingAccepted)).
		ed setCursor: cp.
		ed enterEditState.
	  ]
)
colorizeMethodSource: s <String> ^ <TextFragment> = (
	^ text: (ide colorizer parseMethod: s fromClass: subject classDeclaration) 
)
public definition ^ <Fragment> = (
	| toggle |
	toggle:: 
		collapsed: [row: {
			image: (iconForAccessModifier: subject accessModifier).
			blank: 3.
			(link: subject name action: [toggle expand]) color: Color black
			}
		]
		expanded: [column: {
			row:{
			  image: (iconForAccessModifier: subject accessModifier).
			  blank: 3.
			  (link: subject name action: [toggle collapse]) color: Color black
			}.
			TextEditorFragment new
				text: (colorizeMethodSource: (crToLf: subject source));
				changeResponse: changeResponse; 
				acceptResponse: acceptResponse
		}].
	^toggle	
)
) : (
)
public class MethodSubject onModel: mm <MethodMirror> = Subject onModel: mm (
(* Manages the UI for a method. *)) (
public accessModifier ^ <Symbol> = (
	^methodMirror accessModifier
)
public classDeclaration ^ <ClassDeclarationMirror> = (
	^methodMirror definingMixin declaration
)
public createPresenter ^ <Presenter> = (
	^MethodPresenter onSubject: self
)
public methodMirror ^ <MethodMirror> = (
	^model
)
public name ^ <Symbol> = (
	^methodMirror name
)
public source ^ <String> = (
	^methodMirror source
)
) : (
)
class NamespacePresenter onSubject: s = DefinitionListPresenter onSubject: s (|
|) (
class ClassEntryPresenter onSubject: s <ClassSubject> = EntryPresenter onSubject: s () (
classCommentSummary ^ <String> = (
    | fullComment <String> = subject classCommentText. |
	^ fullComment(* need to trim blanks *)
)
collapsedDefinition = (
	(* BOGUS: we are displaying the class's name. we should display its key *)
	| part |
	part:: row1: {
		image: ide images classIcon.
		smallBlank.
		row: {link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror]}.
	} row2: {
		(row: {deferred: [(label: classCommentSummary)
			smallFont; 
			color: secondaryTextColor]})
				compressibility: 1.
		filler 
			compressibility: 0.
			
		(* In the face of namespace nesting, should application and test configuration be invoked with the root namespace or the local namespace? If the local namespace, these links only make sense in the context of the namespace view and should not be part of the class presenter itself. *)
		(*ClassActionsPresenter onSubject: subject.*)
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: subject name].
	}.
	(* subject isRecentlyVisited ifTrue: [part color: recentlyVisitedColor]. *)
	^part
)
expandedDefinition = (
	^subject presenter
)
) : (
)
class EntryPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
public collapse = (
	substance collapse
)
definition = (
	^collapsed: [collapsedDefinition] expanded: [expandedDefinition]
)
public expand = (
	substance expand
)
) : (
)
class NamespaceEntryPresenter onSubject: s = EntryPresenter onSubject: s () (
collapsedDefinition = (
	^row1: {
		image: ide images classPresenterIcon.
		smallBlank.
		row: {link: subject key action: [
			(*ide defaultPopularityRecord
			rememberNamespaceVisit: subject key. (* Should be the namespace itself, but non-strings break the home page. *)*)
			enterSubject:: subject refreshmentSubject]}.
	} row2: {
		(label: subject summaryText)
				smallFont; 
				compressibility: 1;
				color: secondaryTextColor.
		filler 
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: subject key]
	}.
)
expandedDefinition = (
	^subject presenter
)
) : (
)
class ValueEntryPresenter onSubject: s = EntryPresenter onSubject: s (|
	public key
|) (
collapsedDefinition = (
	^row1: {
		image: ide images classUnknownIcon.
		smallBlank.
		link: key action: [enterSubject:: subject].
	} row2: {
		(label: subject title)
			smallFont; 
			compressibility: 1;
			color: secondaryTextColor.
		filler 
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: key]
	}
)
definition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^collapsed: [collapsedDefinition]
	expanded: [subject presenter selfCaption: key]
)
expandedDefinition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^subject presenter selfCaption: key
)
) : (
)
acceptNewClassDefinitionFrom: aTemplate = (
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
acceptNewNamespaceDefinitionFrom: aTemplate = (
	subject
		addNamespaceFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
addClassTemplate = (
	prefixes add:
		(DefinitionTemplate new
			caption: 'Defining a new class:';
			initialText: subject classTemplateText;
			colorizerBlock: [:text | subject colorizeClassSource: text];
			acceptResponse: 
				[:template | acceptNewClassDefinitionFrom: template];
			cancelResponse:
				[:template | prefixes remove: template])
)
addNamespaceTemplate = (
	prefixes add:
		(DefinitionTemplate new
			caption: 'Defining a new namespace:';
			initialText: 'NewNamespace';
			colorizerBlock: [:text | ];
			acceptResponse: 
				[:template | acceptNewNamespaceDefinitionFrom: template];
			cancelResponse:
				[:template | prefixes remove: template])
)
contentList ^ <PresenterList> = (
	^zebra: super contentList
)
contentPresenters ^ <List[Presenter]> = (
      | lexicalOrder <[:Symbol :Symbol | Boolean]> |
     lexicalOrder:: [:a <Symbol> :b <Symbol> |
		lexicallyLessOrEqual: a than: b
	].
	^(subject namespace keys asArray sort: lexicalOrder) collect: [:key | presenterForEntryAt: key]
)
definition ^ <Fragment> = (
	^column: {
		minorHeadingBlock: (row: {
			label: subject key (*asText allBold*).
			largeBlank.
			subject namespace isKindOfCategoryNamespace
				ifTrue: [addButtonWithAction: [respondToAddForCategory]]
				ifFalse: [addButtonWithAction: [respondToAddForRoot]].
			filler.
			expandButtonWithAction: [expandAll].
			blank: 3.
			collapseButtonWithAction: [collapseAll].
			blank: 3.
			dropDownMenu: [namespaceMenu].
		}).
		smallBlank.
		super definition.
	}
)
entryActionsMenuFor: key = (
	^menuWithLabelsAndActions: {
		{'Remove ', key. [ide namespacing removeKey: key.  refresh]}.
	}
)
lexicallyLessOrEqual: a <String> than: b <String> ^ <Boolean> = (
(* BOGUS: This should be a utility somewhere *)
	| length = a size min: b size. |
	1 to: length do: [: i | 
		(a runeAt: i) < (b runeAt: i) ifTrue: [^true].
		(a runeAt: i) > (b runeAt: i) ifTrue: [^false].		
		].
	^true
)
namespaceMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
presenterForEntryAt: key <Symbol> ^ <EntryPresenter> = (
	| entry = subject namespace at: key. |
	entry isBehavior
		ifTrue: [^ClassEntryPresenter onSubject: (ClassSubject onModel: (ClassMirror reflecting: entry) mixin declaration)].
	
	entry isKindOfNamespace
		ifTrue: [^NamespaceEntryPresenter onSubject: (NamespaceSubject onModel: entry key: key)].
		
	^(ValueEntryPresenter onSubject: (objectSubjectFor: entry)) key: key
)
respondToAddForCategory = (
	openMenuWithLabelsAndActions: {
		{'Add Class'. [addClassTemplate]}.
		(* 'Add Namespace' -> [addNamespaceTemplate]. *)
		{'Add Image From File'. [respondToAddImage].}.
		{'Add Text From File'. [respondToAddText]}.
		(* 'Add Value' -> [Error signal: 'Unimplemented']. *)
	}
)
respondToAddForRoot = (
	openMenuWithLabelsAndActions: {
		{'Add Namespace'. [addNamespaceTemplate]}.
	}
)
respondToAddImage = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Image files (*.png)' ->'*.png'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key form |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		form:: PNGReadWriter formFromFileNamed: fn.
		subject namespace at: key asSymbol put: form.
	].
)
respondToAddText = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Text files (*.txt)' ->'*.txt'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key text |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		text:: ((MultiByteFileStream oldFileNamed: fn)
			converter: (TextConverter newForEncoding: 'utf8')) contents.
		subject namespace at: key asSymbol put: text.
	].
)
row1: row1 row2: row2 = (
	^row: {
		(row: row1) width: 0 elasticity: 1.
		(row: {mediumBlank}, row2) width: 0 elasticity: 2.
	}
)
) : (
)
public class NamespaceSubject onModel: m <Map[Symbol, Object]> key: k <Symbol> = Subject onModel: m (|
	public key = k.
|ide namespacing refreshCategoryNamespaces) (
public = other ^<Boolean> = (
	^class = other class (* class is not public *)
		and: [namespace = other namespace]
		and: [key = other key].
)
public addClassFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]>= (
	| builder <ClassDeclarationBuilder> mixin klass |
	[builder:: ClassDeclarationBuilder fromSource: definition]
		on: Error
		do: [:ex | ^failureBlock value: ex description].
	(namespace includesKey: builder simpleName) ifTrue:
		[^failureBlock value: 'A class named ', builder simpleName, ' already exists in this namespace'].
	mixin:: builder install reflectee. (* issue 1: reflectee not public *)
	klass:: mixin apply: Object withName: builder simpleName. (* issue 2: no API to apply mixin *)
	namespace at: klass name put: klass. (* issue 3: Do namespaces hold classes or mirrors *)
	successBlock value
)
public addNamespaceFromDefinition: definition <String>  ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| selector <Symbol> = definition asSymbol. |
	model = ide namespacing Categories ifFalse: (* ? *)
		[Error signal: 'Not supported yet, only categories for now.'].
	
	selector isUnary ifFalse:
		[^failureBlock value: 'Must be a unary selector'].
	(namespace includesKey: selector) ifTrue:
		[^failureBlock value: 'A class named ', definition, ' already exists in this namespace'].
	ide namespacing categoryNamespace: selector.
	(* namespace at: selector put: (ide namespacing Namespace new). *)
	successBlock value
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
(*Describe the class in this comment.*)
|
	slot1
	slot2
|
) ()'
)
public colorizeClassSource: sourceText <String | Text> ^<Text> = (
	^ide newspeakColorization NS3BrowserColorizer new
		parseText: sourceText asString
		fromClass: Object mixin
		usingSelector: #classDeclaration
)
public createPresenter ^ <NamespacePresenter> = (
	^NamespacePresenter onSubject: self
)
public hash ^<Integer> = (
	^model hash bitXor: key hash
)
public namespace ^ <Map[Symbol, Object]> = (
	^self model
)
public refreshmentSubject = (
	^self class onModel: model key: key
)
public summaryText = (
  namespace keys isEmpty 
	ifFalse: [   | sb = StringBuilder new. keys = namespace keys asArray. |
		sb add: keys asArray first.
		keys allButFirst do: [:k |  sb add: ', '. sb add: k] .
		^sb asString
		].
	^''
)
public title ^<String> = (
	^key
)
) : (
public new = (
	#NAMESPACEBOGUS.
	^self onModel: ide namespacing Categories key: 'Root'
)
)
class ObjectPresenter onSubject: s = ProgrammingPresenter onSubject: s (| resultHolder public selfCaption ::= 'self'. |) (
captionBar: body = (
	^(column: {
		smallBlank.
		row: {
			mediumBlank.
			body elasticity: 1.
			smallBlank
			}.
	}) color: captionColor
)
classInfoLine = (
	^row: {
		(label: 'class') width: 0 elasticity: 1.
		(row: {
			link: subject className action: [enterSubject: subject classSubject].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public definition = (
	^column: {
		captionBar: (column: {
			selfInfoLine.
			enclosingInfoLine.
			classInfoLine.
			smallBlank.
			inspectSelf.
			TextEditorFragment new
				changeResponse: [:editor | evaluate: editor textBeingAccepted asString].
			smallBlank.
			resultHolder:: holder: [nothing].
		}).
		objectDetails.
	}
)
enclosingInfoLine = (
	^row: {
		(label: 'enclosingObject') width: 0 elasticity: 1.
		(row: {
			link: subject enclosingObjectName action: [enterSubject:: ObjectSubject onModel: subject classMirror enclosingObject].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
evaluate: expression <String> = (
	| result <ObjectMirror> |
	result:: subject objectMirror 
		evaluate: (withoutNbsp: expression)
		ifCompilerError: [:e | ^resultHolder content: (linkForError: e)]
		ifError: [:e | ^resultHolder content: (linkForError: e)].
	resultHolder content: (linkForResult: result).
)
goToSelf = (
	enterSubject: (ObjectSubject onModel: subject objectMirror)
)
inspectSelf = (
	^row:{filler. link:  'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]}
)
linkForError: exception = (
	^(link: exception printString
	action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: exception)])
		color: (Color r: 1 g: 0 b: 0)
)
linkForResult: objectMirror = (
	^link: objectMirror reflectee printString
	action: [enterSubject:: ObjectSubject onModel: objectMirror]
)
objectDetails = (
	^row: {
	mediumBlank.
	(column: ((subject classMirror) slots collect: [:slot |
		| val = subject objectMirror getSlot: slot name. |
		row: {
			(label: slot name) width: 0 elasticity: 1.
			(row: {
				link: val reflectee printString action: [enterSubject:: ObjectSubject onModel: val].
			}) width: 0 elasticity: detailAreaRatio.
		}
	])) elasticity: 1.
	smallBlank
	}
)
selfInfoLine = (
	^row: {
		(label: selfCaption (*asText allBold*)) width: 0 elasticity: 1.
		(row: {
			(link: subject title action: [goToSelf]) compressibility: 1.
			filler compressibility: 0.
			mediumBlank.
			(*dropDownMenu: [actionsMenu]*)
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public title = (
	^'Inspector on ', subject title
)
withoutNbsp: string = (
	|
	nonbreakingSpace = String fromRune: 160.
	space = String fromRune: 32.
	|
	^string replaceAll: nonbreakingSpace with: space.
)
) : (
)
public class ObjectSubject onModel: m = Subject onModel: m (|
|) (
public classMirror ^<ClassMirror> = (
	^model getClass
)
public className ^<String> = (
	^classMirror simpleName
)
public classSubject = (
	^ClassSubject onModel: classMirror mixin declaration
)
public createPresenter = (
	^ObjectPresenter onSubject: self
)
public enclosingObjectName = (
	^classMirror enclosingObject reflectee printString
)
public objectMirror ^<ObjectMIrror> = (
	^model
)
public title = (
	^objectMirror reflectee printString
)
) : (
)
class ProgrammingPresenter onSubject: s <Subject> = Presenter onSubject: s (
(* Common superclass for presenters of programming constructs. *)) (
addButtonWithAction: aBlock = (
	^imageButton: 
		{ide images addImage.
		ide images addOverImage.
		ide images addOutImage}
	action: aBlock
)
collapseButtonWithAction: aBlock = (

	^imageButton: 
		{ide images collapseImage.
		 ide images collapseOverImage.
		 ide images collapseDownImage}
	action: aBlock
)
expandButtonWithAction: aBlock = (

	^imageButton: 
		{ide images expandImage.
		 ide images expandOverImage.
		 ide images expandDownImage}
	action: aBlock
)
iconForAccessModifier: am = ( 
	am == #private ifTrue: [^ide images privateAccessImage].
	am == #protected ifTrue: [^ide images protectedAccessImage].
	^ide images publicAccessImage
)
largeBlank = (
	^blank: 20
)
minorHeadingBlock: body = (

	^(padded: body with: {10. 5. 5. 5.})
		color: minorHeadingColor
)
minorHeadingColor = (
^Gradient 
	from: (Color h: 240 s: 0.02 v: 0.94) 
	to: (Color h: 240 s: 0.02 v: 0.9)
)
public objectSubjectFor: anObject = (
	^objectSubjectForMirror: (ObjectMirror reflecting: anObject)
)
objectSubjectForMirror: objectMirror <ObjectMirror> = (
	^ObjectSubject onModel: objectMirror
)
respondToInspectPresenter = (
	enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)
)
secondaryTextColor ^ <Color> = (
	^Color gray: 0.6
)
smallBlank = (
	^blank: 5
)
) : (
)
crToLf: string = (
	|
	cr = String fromRune: 13.
	lf = String fromRune: 10.
	|
	^string replaceAll: cr with: lf.
)
) : (
)
