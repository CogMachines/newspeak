Newspeak3
'Samples'
class SimpleBrowsing usingPlatform: p  ide: webIde = (
(* An IDE for Newspeak on the web. 
Copyright 2016-2017 Google Inc.
*)|     (* imports *)      StringBuilder = p kernel StringBuilder.	Subject = p hopscotch core Subject.	Presenter = p hopscotch core Presenter.	TextEditorFragment = p hopscotch fragments TextEditorFragment.	Color = p graphics Color.	Gradient = p hopscotch Gradient.	List = p collections List.	Map = p collections Map.	ClassMirror = p mirrors ClassMirror.	ObjectMirror = p mirrors ObjectMirror.	ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.	(* module variables *)	ide = webIde.	detailAreaRatio = 1.6.	captionColor = Color h: 240 s: 0.05 v: 0.9.      |) (
public class BitOfWisdom text: s  <String> actionLabel: l  <String> actionBlock: b <[]> image: i = (|
	public text <String> = s.
	public image = i.
	public actionLabel <String> = l.
	public actionBlock <[]> = b.
|) (
) : (
public text: s <String> ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: nil
)
public text: s <String> actionLabel: l  <String> actionBlock: b <[]> ^ <BitOfWisdom> = (

	^self  
		text: s
		actionLabel: l
		actionBlock: b
		image: nil
)
public text: s image: i  ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: i
)
)
class ClassFactoryPresenter onSubject: s <ClassFactorySubject> = MethodPresenter onSubject: s (
(* WIP. Present the factory method, colorized *)) (
acceptResponse ^ <[:TextEditorFragment :Event]> = (
	^[:ed <TextEditorFragment> :event <Event> | 
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		b addFactoryFromSource: ed textBeingAccepted.
		b declaration install.
		ed text: (colorizeMethodSource: (crToLf: ed textBeingAccepted)).
		ed setCursor.
		ed leaveEditState.
		]	
)
colorizeMethodSource: s <String> ^ <TextFragment> = (
	^ text: (ide colorizer parseClassHeader: s fromClass: subject classDeclaration) 
)
) : (
)
class ClassFactorySubject onModel: m <ClassDeclarationMirror> = MethodSubject onModel: m (
(* WIP. *)) (
public accessModifier ^ <Symbol> = (
	^#public
)
public createPresenter ^ <ClassFactoryPresenter> = (
	^ClassFactoryPresenter onSubject: self
)
) : (
)
class ClassPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
collapsedHeadingDefinition = (
	^row: {
		blank: 5.
		image: ide images classIcon.
		blank: 5.
		link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror (* Why do we need a copy? *)]
		}.
)
public definition ^ <Fragment> = (
	^column: {
		headingDefinition.
		minorClassHeadingBlock: (label: 'Classes').
		column: (subject classMirror instanceSide nestedClasses collect: [:ea | nestedClass: ea]).
		minorClassHeadingBlock: (label: 'Methods').
		column: (subject classMirror instanceSide methods collect: [:ea | (MethodSubject onModel: ea) presenter]).
		minorClassHeadingBlock: (label: 'Class Methods').
		column: (subject classMirror classSide methods collect: [:ea | (MethodSubject onModel: ea) presenter]).
	}
)
expandedHeadingDefinition ^ <Fragment> = (
	| parts |
	parts:: List new.
	subject enclosingClassSubjects
		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]
		separatedBy: [parts add: ( label: ' in ')].
	^column: {
		blank: 5.
		row: {blank: 5. image: ide images classIcon. blank: 5. row: parts. filler. homeButton}.
		inspectSelf.
		label: 'Slots'.
		row: {
			mediumBlank.
			column: (subject classMirror instanceSide slots collect: [:ea | label: ea name]).
		}.
	}
)
headingDefinition ^ <Fragment> = (
	^(column: {
		expanded: [expandedHeadingDefinition]
		collapsed: [collapsedHeadingDefinition].
	}) color: (Color h: 240 s: 0.05 v: 0.9).
)
inspectSelf ^ <Fragment> = (
	^row: {filler. link:  'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]}
)
minorClassHeadingBlock: body = (
	^(padded: body with: {10. 5. 5. 5.})
		color: minorClassHeadingColor
)
minorClassHeadingColor = (
	^Gradient 
		from: (Color h: 240 s: 0.02 v: 0.94) 
		to: (Color h: 240 s: 0.02 v: 0.9)
)
nestedClass: cdm = (
	^collapsed: [row: {			
					image: (iconForAccessModifier: cdm accessModifier).
					blank: 3.
					link: cdm simpleName action: [enterSubject:: ClassSubject onModel: cdm]
					}
				]
	expanded: [(ClassSubject onModel: cdm) presenter]
)
) : (
)
public class ClassSubject onModel: m <ClassDeclarationMirror> = Subject onModel: m (|
|) (
public classCommentText ^<String> = (
	^model header classComment ifNil: ['']
)
public classMirror ^ <ClassDeclarationMirror> = (
	^model
)
public createPresenter = (
	^ClassPresenter onSubject: self
)
public enclosingClassSubjects = (
	| them = List new. c |
	c:: model.
	[c isNil] whileFalse: [them add: (ClassSubject onModel: c). c:: c enclosingClass].
	^them
)
public name = (
	^model simpleName
)
public title = (
	^name
)
) : (
)
public class DefinitionListPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* DefinitionListPresenter is an abstract superclass of presenters that displays helper ''transient'' presenters that visually appear to belong to the main list of subject presenters. One common example is a method list presenter which can at times include presenters for methods being added or residue presenters of removed methods. *)| prefixes <PresenterList> content <PresenterList> suffixes <PresenterList> |) (
public collapseAll = (
	(* Collapse all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	(*majorUpdate: [*)
		content presenters do: [:each | each collapse]
		(*]*)
)
contentList ^ <PresenterList> = (

	^list: [contentPresenters]
)
contentPresenters ^ <List[Presenter]> = (

	^List new
)
definition ^ <Fragment> = (

	prefixes:: list.
	content:: contentList.
	suffixes:: list.
	^column: {
		prefixes.
		content.
		suffixes.
		}
)
public expandAll = (
	(* Expand all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	(*majorUpdate: [*)
		content presenters do: [:each | each expand]
		(*]*)
)
) : (
)
class HomePresenter onSubject: s = ProgrammingPresenter onSubject: s (
(*  *)| helpHolder  |) (
aboutSystemDefinition = (

	^(link: 'About this system' action: [respondToAboutSystem]) smallFont.
)
column1: definitions1 column2: definitions2 column3: definitions3 = (
^row: {
	(column: definitions1) width: 0 elasticity: 1.
	(column: definitions2) width: 0 elasticity: 1.
	(column: definitions3) width: 0 elasticity: 1.
	}
)
definition = (
	helpHolder:: list.
^
	column: {
		helpHolder.
		majorHeadingBlock: (
			row: {
				label: 'Navigation'.
				filler.
				helpButton.
			}
		).
		mediumBlank.
		
		indentedBlock:
			(column1: {
				link: 'Newspeak Source'
					action: [enterSubject:: NamespaceSubject new].
				}
			column2: {
				link: 'Workspaces'
						action: [navigateToWorkspaces].
				}
			column3: {

				}
			).
		mediumBlank.

(*		majorHeadingBlock: (label: 'Recently Visited' asText allBold).
		mediumBlank.
		indentedBlock:
			(holder: [recentStuffDefinition]).
		largeBlank.*)
		
		majorHeadingBlock: (label: 'Did you know?').
		smallBlank.
		indentedBlock:
			(holder: [didYouKnow]).
		mediumBlank.
		indentedBlock: aboutSystemDefinition.
		}
)
didYouKnow = (

	| wisdom |
	^label: ''
	(*wisdom:: subject randomBitOfWisdom.
	wisdom actionLabel notNil ifTrue:
		[^textAndActionWisdom: wisdom].
	wisdom image notNil ifTrue:
		[^textAndImageWisdom: wisdom].
	^textDisplay: wisdom text*)
)
helpButton = (
^helpText isNil
	ifTrue: [nothing]
	ifFalse: [(link: '[?]' action: [respondToHelp]) smallFont]
)
helpText ^<String | nil> = (
(* If this method answers a string, a help button will appear on the Home page. Clicking on that button will display the string. *)
^'This is the home page. 
The home page includes links to a variety of useful places, like the IDE''s root namespace, which lists all top level classes, and the workspace manager, where you can evaluate code. 
Golden icons represent Newspeak3, which is the currently operational dialect of Newspeak.'
)
navigateToWorkspaces = (
	enterSubject:: ide theWorkspaceManager AllWorkspacesSubject new
)
respondToAboutSystem = (
	alert: 'WebIDEApp version 0.1984'
)
respondToHelp = (
helpHolder setPresenters: {
	row: {
		filler.
		(link: 'close help' action: [helpHolder setPresenters: {}]) smallFont.
	}.
	textDisplay: helpText.
}
)
textAndActionWisdom: wisdom = (
^
	column: {
		TextDisplayFragment new text: wisdom text.
		(link: wisdom actionLabel action: wisdom actionBlock) smallFont
		}
)
textAndImageWisdom: wisdom = (
^
	row: {
		image: wisdom image.
		mediumBlank.
		elastic: 
			(textDisplay: wisdom text).
		}
)
) : (
)
public class HomeSubject onModel: m = Subject onModel: m (|  |) (
public = anotherSubject <Subject> ^ <Boolean> = (
(* As there is just one possible logical home of the system, all subjects representing it are considered equal. *)
	^anotherSubject isKindOfHomeSubject
)
bitsOfWisdom = (
	(* This defines the bits of wisdom displayed at the bottom of the Hopscotch home page. Each time a page opens a new element is selected at random. An element may evaluate to nil, which will select another element at random. *)
	
^
	{
	[BitOfWisdom 
		text: 'This is the "expand all" button which appears in headers of expandable item groups.'
		image: ide images expandImage].
	
	[BitOfWisdom 
		text: 'This is the "collapse all" button which appears in headers of expandable item groups.'
		image: ide images collapseImage].

	[BitOfWisdom 
		text: 'This is the "add" button which appears in headers of groups of items you can add to, such as methods of a class or classes of a package.'
		image: ide images addImage].
	
	[BitOfWisdom
		text: 'War is peace. Freedom is slavery. Ignorance is strength.'].
	}
)
public createPresenter = (
	^HomePresenter onSubject: self
)
isKindOfHomeSubject  ^ <Boolean> = (
	^true
)
lateNightWisdom = (

	^BitOfWisdom 
		text: 'It''s ', Time now printString, '. Go get some rest!'
)
public randomBitOfWisdom = (

	| bits |
	(*Time now hour < 5 ifTrue: [^lateNightWisdom].*)
	bits:: bitsOfWisdom.
	^bits atRandom value ifNil: [randomBitOfWisdom]
)
public title = (
	^'Home'
)
) : (
public new = (
	^onModel: nil
)
)
class MethodPresenter onSubject: s <MethodSubject> = ProgrammingPresenter onSubject: s (
(* A presenter for a single method. *)) (
acceptResponse ^ <[:TextEditorFragment :Event]> = (
	^[:ed <TextEditorFragment> :event <Event> | 
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		(*('ed text:', ed textBeingAccepted) out.*)
		b methods addFromSource: ed textBeingAccepted.
		b declaration install.
		ed text: (colorizeMethodSource: (crToLf: ed textBeingAccepted)).
		ed setCursor.
		ed leaveEditState.
		]	
)
changeResponse ^ <[:TextEditorFragment :Event]> = (
	^[:ed <TextEditorFragment> :event <Event>  |  | cp <Integer> |
		ed textBeingAccepted out.
		cp:: ed cursorPosition.
		ed text: (colorizeMethodSource: (crToLf: ed textBeingAccepted)).
		ed setCursor: cp.
		ed enterEditState.
	  ]
)
colorizeMethodSource: s <String> ^ <TextFragment> = (
	^ text: (ide colorizer parseMethod: s fromClass: subject classDeclaration) 
)
public definition ^ <Fragment> = (
	| toggle |
	toggle:: 
		collapsed: [row: {
			image: (iconForAccessModifier: subject accessModifier).
			blank: 3.
			(link: subject name action: [toggle expand]) color: Color black
			}
		]
		expanded: [column: {
			row:{
			  image: (iconForAccessModifier: subject accessModifier).
			  blank: 3.
			  (link: subject name action: [toggle collapse]) color: Color black
			}.
			TextEditorFragment new
				text: (colorizeMethodSource: (crToLf: subject source));
				changeResponse: changeResponse; 
				acceptResponse: acceptResponse
		}].
	^toggle	
)
) : (
)
public class MethodSubject onModel: mm <MethodMirror> = Subject onModel: mm (
(* Manages the UI for a method. *)) (
public accessModifier ^ <Symbol> = (
	^methodMirror accessModifier
)
public classDeclaration ^ <ClassDeclarationMirror> = (
	^methodMirror definingMixin declaration
)
public createPresenter ^ <Presenter> = (
	^MethodPresenter onSubject: self
)
public methodMirror ^ <MethodMirror> = (
	^model
)
public name ^ <Symbol> = (
	^methodMirror name
)
public source ^ <String> = (
	^methodMirror source
)
) : (
)
class NamespacePresenter onSubject: s = DefinitionListPresenter onSubject: s (|
|) (
class ClassEntryPresenter onSubject: s <ClassSubject> = EntryPresenter onSubject: s () (
classCommentSummary ^ <String> = (
    | 
    fullComment <String> = subject classCommentText.
    endOfFirstSentence <Integer> = fullComment indexOf: ('.' at: 1).
    (* Needed is needed to get this to work on Squeak, where Strings and Characters are not the same *)
    firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
    |
    #BOGUS. (* because of hacky use of at: to get characters on Squeak *)
    ^ firstSentence(* need to trim blanks *)
)
collapsedDefinition = (
	| part |
	#BOGUS. 	(* BOGUS: we are displaying the class's name. we should display its key *)
	part:: row1: {
		image: ide images classIcon.
		smallBlank.
		row: {link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror]}.
	} row2: {
		(row: {deferred: [(label: classCommentSummary)
			smallFont; 
			color: secondaryTextColor]})
				compressibility: 1.
		filler 
			compressibility: 0.
			
		(* In the face of namespace nesting, should application and test configuration be invoked with the root namespace or the local namespace? If the local namespace, these links only make sense in the context of the namespace view and should not be part of the class presenter itself. *)
		(*ClassActionsPresenter onSubject: subject.*)
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: subject name].
	}.
	(* subject isRecentlyVisited ifTrue: [part color: recentlyVisitedColor]. *)
	^part
)
expandedDefinition = (
	^subject presenter
)
) : (
)
class EntryPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
public collapse = (
	substance collapse
)
definition = (
	^collapsed: [collapsedDefinition] expanded: [expandedDefinition]
)
public expand = (
	substance expand
)
) : (
)
class NamespaceEntryPresenter onSubject: s = EntryPresenter onSubject: s () (
collapsedDefinition = (
	^row1: {
		image: ide images classPresenterIcon.
		smallBlank.
		row: {link: subject key action: [
			(*ide defaultPopularityRecord
			rememberNamespaceVisit: subject key. (* Should be the namespace itself, but non-strings break the home page. *)*)
			enterSubject:: subject refreshmentSubject]}.
	} row2: {
		(label: subject summaryText)
				smallFont; 
				compressibility: 1;
				color: secondaryTextColor.
		filler 
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: subject key]
	}.
)
expandedDefinition = (
	^subject presenter
)
) : (
)
class ValueEntryPresenter onSubject: s = EntryPresenter onSubject: s (|
	public key
|) (
collapsedDefinition = (
	^row1: {
		image: ide images classUnknownIcon.
		smallBlank.
		link: key action: [enterSubject:: subject].
	} row2: {
		(label: subject title)
			smallFont; 
			compressibility: 1;
			color: secondaryTextColor.
		filler 
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: key]
	}
)
definition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^collapsed: [collapsedDefinition]
	expanded: [subject presenter selfCaption: key]
)
expandedDefinition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^subject presenter selfCaption: key
)
) : (
)
acceptNewClassDefinitionFrom: aTemplate = (
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
acceptNewNamespaceDefinitionFrom: aTemplate = (
	subject
		addNamespaceFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate. refresh]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
addClassTemplate = (
	prefixes add:
		(DefinitionTemplate new
			caption: 'Defining a new class:';
			initialText: subject classTemplateText;
			colorizerBlock: [:text | subject colorizeClassSource: text];
			acceptResponse: 
				[:template | acceptNewClassDefinitionFrom: template];
			cancelResponse:
				[:template | prefixes remove: template])
)
addNamespaceTemplate = (
	prefixes add:
		(DefinitionTemplate new
			caption: 'Defining a new namespace:';
			initialText: 'NewNamespace';
			colorizerBlock: [:text | ];
			acceptResponse: 
				[:template | acceptNewNamespaceDefinitionFrom: template];
			cancelResponse:
				[:template | prefixes remove: template])
)
contentList ^ <PresenterList> = (
	^zebra: super contentList
)
contentPresenters ^ <List[Presenter]> = (
      | lexicalOrder <[:Symbol :Symbol | Boolean]> |
     lexicalOrder:: [:a <Symbol> :b <Symbol> |
		lexicallyLessOrEqual: a than: b
	].
	^(subject namespace keys asArray sort: lexicalOrder) collect: [:key | presenterForEntryAt: key]
)
definition ^ <Fragment> = (
	^column: {
		minorHeadingBlock: (row: {
			label: subject key (*asText allBold*).
			largeBlank.
			subject namespace isKindOfCategoryNamespace
				ifTrue: [addButtonWithAction: [respondToAddForCategory]]
				ifFalse: [addButtonWithAction: [respondToAddForRoot]].
			filler.
			expandButtonWithAction: [expandAll].
			blank: 3.
			collapseButtonWithAction: [collapseAll].
			blank: 3.
			dropDownMenu: [namespaceMenu].
			largeBlank.
			homeButton.
		}).
		smallBlank.
		super definition.
	}
)
entryActionsMenuFor: key = (
	^menuWithLabelsAndActions: {
		{'Remove ', key. [ide namespacing removeKey: key.  refresh]}.
	}
)
lexicallyLessOrEqual: a <String> than: b <String> ^ <Boolean> = (
(* BOGUS: This should be a utility somewhere *)
	| length = a size min: b size. |
	1 to: length do: [: i | 
		(a runeAt: i) < (b runeAt: i) ifTrue: [^true].
		(a runeAt: i) > (b runeAt: i) ifTrue: [^false].		
		].
	^true
)
namespaceMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
presenterForEntryAt: key <Symbol> ^ <EntryPresenter> = (
	| entry = subject namespace at: key. |
	entry isBehavior
		ifTrue: [^ClassEntryPresenter onSubject: (ClassSubject onModel: (ClassMirror reflecting: entry) mixin declaration)].
	
	entry isKindOfNamespace
		ifTrue: [^NamespaceEntryPresenter onSubject: (NamespaceSubject onModel: entry key: key)].
		
	^(ValueEntryPresenter onSubject: (objectSubjectFor: entry)) key: key
)
respondToAddForCategory = (
	openMenuWithLabelsAndActions: {
		{'Add Class'. [addClassTemplate]}.
		(* 'Add Namespace' -> [addNamespaceTemplate]. *)
		{'Add Image From File'. [respondToAddImage].}.
		{'Add Text From File'. [respondToAddText]}.
		(* 'Add Value' -> [Error signal: 'Unimplemented']. *)
	}
)
respondToAddForRoot = (
	openMenuWithLabelsAndActions: {
		{'Add Namespace'. [addNamespaceTemplate]}.
	}
)
respondToAddImage = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Image files (*.png)' ->'*.png'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key form |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		form:: PNGReadWriter formFromFileNamed: fn.
		subject namespace at: key asSymbol put: form.
	].
)
respondToAddText = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Text files (*.txt)' ->'*.txt'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key text |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		text:: ((MultiByteFileStream oldFileNamed: fn)
			converter: (TextConverter newForEncoding: 'utf8')) contents.
		subject namespace at: key asSymbol put: text.
	].
)
row1: row1 row2: row2 = (
	^row: {
		(row: row1) width: 0 elasticity: 1.
		(row: {mediumBlank}, row2) width: 0 elasticity: 2.
	}
)
) : (
)
public class NamespaceSubject onModel: m <Map[Symbol, Object]> key: k <Symbol> = Subject onModel: m (|
	public key = k.
|ide namespacing refreshCategoryNamespaces) (
public = other ^<Boolean> = (
	^class = other class (* class is not public *)
		and: [namespace = other namespace]
		and: [key = other key].
)
public addClassFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]>= (
	| builder <ClassDeclarationBuilder> mixin klass |
	[builder:: ClassDeclarationBuilder fromSource: definition]
		on: Error
		do: [:ex | ^failureBlock value: ex description].
	(namespace includesKey: builder simpleName) ifTrue:
		[^failureBlock value: 'A class named ', builder simpleName, ' already exists in this namespace'].
	mixin:: builder install reflectee. (* issue 1: reflectee not public *)
	klass:: mixin apply: Object withName: builder simpleName. (* issue 2: no API to apply mixin *)
	namespace at: klass name put: klass. (* issue 3: Do namespaces hold classes or mirrors *)
	successBlock value
)
public addNamespaceFromDefinition: definition <String>  ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| selector <Symbol> = definition asSymbol. |
	model = ide namespacing Categories ifFalse: (* ? *)
		[Error signal: 'Not supported yet, only categories for now.'].
	
	selector isUnary ifFalse:
		[^failureBlock value: 'Must be a unary selector'].
	(namespace includesKey: selector) ifTrue:
		[^failureBlock value: 'A class named ', definition, ' already exists in this namespace'].
	ide namespacing categoryNamespace: selector.
	(* namespace at: selector put: (ide namespacing Namespace new). *)
	successBlock value
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
(*Describe the class in this comment.*)
|
	slot1
	slot2
|
) ()'
)
public colorizeClassSource: sourceText <String | Text> ^<Text> = (
	^ide newspeakColorization NS3BrowserColorizer new
		parseText: sourceText asString
		fromClass: Object mixin
		usingSelector: #classDeclaration
)
public createPresenter ^ <NamespacePresenter> = (
	^NamespacePresenter onSubject: self
)
public hash ^<Integer> = (
	^model hash bitXor: key hash
)
public namespace ^ <Map[Symbol, Object]> = (
	^self model
)
public refreshmentSubject = (
	^self class onModel: model key: key
)
public summaryText = (
  namespace keys isEmpty 
	ifFalse: [   | sb = StringBuilder new. keys = namespace keys asArray. |
		sb add: keys asArray first.
		keys allButFirst do: [:k |  sb add: ', '. sb add: k] .
		^sb asString
		].
	^''
)
public title ^<String> = (
	^key
)
) : (
public new = (
	#NAMESPACEBOGUS.
	^self onModel: ide namespacing Root key: 'Root'
)
)
class ObjectPresenter onSubject: s = ProgrammingPresenter onSubject: s (| resultHolder public selfCaption ::= 'self '. |) (
captionBar: body = (
	^(column: {
		smallBlank.
		row: {
			mediumBlank.
			body elasticity: 1.
			smallBlank
			}.
	}) color: captionColor
)
classInfoLine = (
	^row: {
		(label: 'class') width: 0 elasticity: 1.
		(row: {
			link: subject className action: [enterSubject: subject classSubject].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public definition = (
	^column: {
		captionBar: (column: {
			row: {selfInfoLine. filler. homeButton}.
			enclosingInfoLine.
			classInfoLine.
			smallBlank.
			inspectSelf.
			TextEditorFragment new
				changeResponse: [:editor | evaluate: editor textBeingAccepted asString].
			smallBlank.
			resultHolder:: holder: [nothing].
		}).
		objectDetails.
	}
)
enclosingInfoLine = (
	^row: {
		(label: 'enclosingObject') width: 0 elasticity: 1.
		(row: {
			link: subject enclosingObjectName action: [enterSubject:: ObjectSubject onModel: subject classMirror enclosingObject].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
evaluate: expression <String> = (
	| result <ObjectMirror> |
	result:: subject objectMirror 
		evaluate: (withoutNbsp: expression)
		ifCompilerError: [:e | ^resultHolder content: (linkForError: e)]
		ifError: [:e | ^resultHolder content: (linkForError: e)].
	resultHolder content: (linkForResult: result).
)
goToSelf = (
	enterSubject: (ObjectSubject onModel: subject objectMirror)
)
inspectSelf = (
	^row:{filler. link:  'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]}
)
linkForError: exception = (
	^(link: exception printString
	action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: exception)])
		color: (Color r: 1 g: 0 b: 0)
)
linkForResult: objectMirror = (
	^link: objectMirror reflectee printString
	action: [enterSubject:: ObjectSubject onModel: objectMirror]
)
objectDetails = (
	^row: {
	mediumBlank.
	(column: ((subject classMirror) slots collect: [:slot |
		| val = subject objectMirror getSlot: slot name. |
		row: {
			(label: slot name) width: 0 elasticity: 1.
			(row: {
				link: val reflectee printString action: [enterSubject:: ObjectSubject onModel: val].
			}) width: 0 elasticity: detailAreaRatio.
		}
	])) elasticity: 1.
	smallBlank
	}
)
selfInfoLine = (
	^row: {
		(label: selfCaption (*asText allBold*)) width: 0 elasticity: 1.
		(row: {
			(link: subject title action: [goToSelf]) compressibility: 1.
			filler compressibility: 0.
			mediumBlank.
			(*dropDownMenu: [actionsMenu]*)
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public title = (
	^'Inspector on ', subject title
)
withoutNbsp: string = (
	|
	nonbreakingSpace = String fromRune: 160.
	space = String fromRune: 32.
	|
	^string replaceAll: nonbreakingSpace with: space.
)
) : (
)
public class ObjectSubject onModel: m = Subject onModel: m (|
|) (
public classMirror ^<ClassMirror> = (
	^model getClass
)
public className ^<String> = (
	^classMirror simpleName
)
public classSubject = (
	^ClassSubject onModel: classMirror mixin declaration
)
public createPresenter = (
	^ObjectPresenter onSubject: self
)
public enclosingObjectName = (
	^classMirror enclosingObject reflectee printString
)
public objectMirror ^<ObjectMIrror> = (
	^model
)
public title = (
	^objectMirror reflectee printString
)
) : (
)
class ProgrammingPresenter onSubject: s <Subject> = Presenter onSubject: s (
(* Common superclass for presenters of programming constructs. *)) (
addButtonWithAction: aBlock = (
	^imageButton: 
		{ide images addImage.
		ide images addOverImage.
		ide images addOutImage}
	action: aBlock
)
collapseButtonWithAction: aBlock = (

	^imageButton: 
		{ide images collapseImage.
		 ide images collapseOverImage.
		 ide images collapseDownImage}
	action: aBlock
)
expandButtonWithAction: aBlock = (

	^imageButton: 
		{ide images expandImage.
		 ide images expandOverImage.
		 ide images expandDownImage}
	action: aBlock
)
homeButton = (
	^imageButton: {
		ide images homeImage.
		ide images homeOutImage.
		ide images homeOverImage.
		ide images homeDownImage
		}
		action: [enterSubject: HomeSubject new].
)
iconForAccessModifier: am = ( 
	am == #private ifTrue: [^ide images privateAccessImage].
	am == #protected ifTrue: [^ide images protectedAccessImage].
	^ide images publicAccessImage
)
indentedBlock: body = (

	^column: {
		mediumBlank.
		row: {
			mediumBlank.
			elastic: body
			}.
		mediumBlank
		}
)
largeBlank = (
	^blank: 20
)
majorHeadingBlock: body = (

	^(padded: body with: {10. 10. 5. 10.})
		color: majorHeadingColor
)
majorHeadingColor = (
	(* This color is used for major definitions such as class headings. *)
	^Gradient 
		from: (Color h: 240 s: 0.05 v: 0.92) 
		to: (Color h: 240 s: 0.05 v: 0.86)
)
minorHeadingBlock: body = (

	^(padded: body with: {10. 5. 5. 5.})
		color: minorHeadingColor
)
minorHeadingColor = (
^Gradient 
	from: (Color h: 240 s: 0.02 v: 0.94) 
	to: (Color h: 240 s: 0.02 v: 0.9)
)
public objectSubjectFor: anObject = (
	^objectSubjectForMirror: (ObjectMirror reflecting: anObject)
)
objectSubjectForMirror: objectMirror <ObjectMirror> = (
	^ObjectSubject onModel: objectMirror
)
respondToInspectPresenter = (
	enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)
)
secondaryTextColor ^ <Color> = (
	^Color gray: 0.6
)
smallBlank = (
	^blank: 5
)
) : (
)
crToLf: string = (
	|
	cr = String fromRune: 13.
	lf = String fromRune: 10.
	|
	^string replaceAll: cr with: lf.
)
) : (
)
