Newspeak3
'Samples'
class SimpleBrowsing usingPlatform: p = (|
	Subject = p hopscotch core Subject.
	Presenter = p hopscotch core Presenter.
	TextEditorFragment = p hopscotch fragments TextEditorFragment.
	Color = p graphics Color.
	Gradient = p hopscotch Gradient.
	List = p collections List.
	Map = p collections Map.
	ObjectMirror = p mirrors ObjectMirror.
	
	detailAreaRatio = 1.6.
	captionColor = Color h: 240 s: 0.05 v: 0.9.
|) (
class ClassPresenter onSubject: s = Presenter onSubject: s () (
'as yet unclassified'
collapsedHeadingDefinition = (
	^link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror (* Why do we need a copy? *)].
)
crToLf: string = (
	|
	cr = String fromRune: 13.
	lf = String fromRune: 10.
	|
	^string replaceAll: cr with: lf.
)
public definition = (
	^column: {
		headingDefinition.
		minorClassHeadingBlock: (label: 'Classes').
		column: (subject classMirror instanceSide nestedClasses collect: [:ea | nestedClass: ea]).
		minorClassHeadingBlock: (label: 'Methods').
		column: (subject classMirror instanceSide methods collect: [:ea | method: ea]).
		minorClassHeadingBlock: (label: 'Class Methods').
		column: (subject classMirror classSide methods collect: [:ea | method: ea]).
	}
)
expandedHeadingDefinition = (
	| parts |
	parts:: List new.
	subject enclosingClassSubjects
		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]
		separatedBy: [parts add: ( label: ' in ')].
	^column: {
		blank: 5.
		row: parts.
		inspectSelf.
		label: 'Slots'.
		row: {
			mediumBlank.
			column: (subject classMirror instanceSide slots collect: [:ea | label: ea name]).
		}.
	}
)
headingDefinition = (
	^(column: {
		expanded: [expandedHeadingDefinition]
		collapsed: [collapsedHeadingDefinition].
	}) color: (Color h: 240 s: 0.05 v: 0.9).
)
inspectSelf = (
	^row:{filler. link:  'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]}
)
method: mm = (
	| toggle |
	toggle:: 
		collapsed: [(link: mm name action: [toggle expand]) color: Color black]
		expanded: [column: {
			(link: mm name action: [toggle collapse]) color: Color black.
			TextEditorFragment new
				text: (crToLf: mm source);
				acceptResponse: [:ed | 
					| b = mm definingMixin asBuilder. |
					b methods addFromSource: ed textBeingAccepted.
					b declaration install.
					ed defaultAcceptResponse.
				]
		}].
	^toggle
)
minorClassHeadingBlock: body = (
	^(padded: body with: {10. 5. 5. 5.})
		color: minorClassHeadingColor
)
minorClassHeadingColor = (
	^Gradient 
		from: (Color h: 240 s: 0.02 v: 0.94) 
		to: (Color h: 240 s: 0.02 v: 0.9)
)
nestedClass: cdm = (
	^collapsed: [link: cdm simpleName action: [enterSubject:: ClassSubject onModel: cdm]]
	expanded: [(ClassSubject onModel: cdm) presenter]
)
) : (
)
public class ClassSubject onModel: m = Subject onModel: m (|
|) (
'as yet unclassified'
public classMirror = (
	^model
)
public createPresenter = (
	^ClassPresenter onSubject: self
)
public enclosingClassSubjects = (
	| them = List new. c |
	c:: model.
	[c isNil] whileFalse: [them add: (ClassSubject onModel: c). c:: c enclosingClass].
	^them
)
public name = (
	^model simpleName
)
public title = (
	^name
)
) : (
)
class ObjectPresenter onSubject: s = Presenter onSubject: s (|
	resultHolder
|) (
'as yet unclassified'
captionBar: body = (
	^(column: {
		smallBlank.
		row: {
			mediumBlank.
			body elasticity: 1.
			smallBlank
			}.
	}) color: captionColor
)
classInfoLine = (
	^row: {
		(label: 'class') width: 0 elasticity: 1.
		(row: {
			link: subject className action: [enterSubject: subject classSubject].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public definition = (
	^column: {
		captionBar: (column: {
			selfInfoLine.
			enclosingInfoLine.
			classInfoLine.
			smallBlank.
			inspectSelf.
			TextEditorFragment new
				changeResponse: [:editor | evaluate: editor textBeingAccepted asString].
			smallBlank.
			resultHolder:: holder: [nothing].
		}).
		objectDetails.
	}
)
enclosingInfoLine = (
	^row: {
		(label: 'enclosingObject') width: 0 elasticity: 1.
		(row: {
			link: subject enclosingObjectName action: [enterSubject:: ObjectSubject onModel: subject classMirror enclosingObject].
		}) width: 0 elasticity: detailAreaRatio.
	}
)
evaluate: expression <String> = (
	| result <ObjectMirror> |
	result:: subject objectMirror 
		evaluate: (withoutNbsp: expression)
		ifCompilerError: [:e | ^resultHolder content: (linkForError: e)]
		ifError: [:e | ^resultHolder content: (linkForError: e)].
	resultHolder content: (linkForResult: result).
)
goToSelf = (
	enterSubject: (ObjectSubject onModel: subject objectMirror)
)
inspectSelf = (
	^row:{filler. link:  'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]}
)
linkForError: exception = (
	^(link: exception printString
	action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: exception)])
		color: (Color r: 1 g: 0 b: 0)
)
linkForResult: objectMirror = (
	^link: objectMirror reflectee printString
	action: [enterSubject:: ObjectSubject onModel: objectMirror]
)
objectDetails = (
	^row: {
	mediumBlank.
	(column: ((subject classMirror) slots collect: [:slot |
		| val = subject objectMirror getSlot: slot name. |
		row: {
			(label: slot name) width: 0 elasticity: 1.
			(row: {
				link: val reflectee printString action: [enterSubject:: ObjectSubject onModel: val].
			}) width: 0 elasticity: detailAreaRatio.
		}
	])) elasticity: 1.
	smallBlank
	}
)
selfCaption = (
	^'self'
)
selfInfoLine = (
	^row: {
		(label: selfCaption (*asText allBold*)) width: 0 elasticity: 1.
		(row: {
			(link: subject title action: [goToSelf]) compressibility: 1.
			filler compressibility: 0.
			mediumBlank.
			(*dropDownMenu: [actionsMenu]*)
		}) width: 0 elasticity: detailAreaRatio.
	}
)
smallBlank = (
	^blank: 5
)
public title = (
	^'Inspector on ', subject title
)
withoutNbsp: string = (
	|
	nonbreakingSpace = String fromRune: 160.
	space = String fromRune: 32.
	|
	^string replaceAll: nonbreakingSpace with: space.
)
) : (
)
public class ObjectSubject onModel: m = Subject onModel: m (|
|) (
'as yet unclassified'
public classMirror ^<ClassMirror> = (
	^model getClass
)
public className ^<String> = (
	^classMirror simpleName
)
public classSubject = (
	^ClassSubject onModel: classMirror mixin declaration
)
public createPresenter = (
	^ObjectPresenter onSubject: self
)
public enclosingObjectName = (
	^classMirror enclosingObject reflectee printString
)
public objectMirror ^<ObjectMIrror> = (
	^model
)
public title = (
	^objectMirror reflectee printString
)
) : (
)
) : (
)
