Newspeak3
'NS2 Combinatorial Parsing'
class Grammar2NS usingPlatform: platform parser: p = (
"Compile EBNF/PEG DSL into Newspeak executable grammar."|
	parser <PegDslParsing>  = p Parser new.
	Stream = platform streams Stream.
|)
('as yet unclassified'
alternationNode: node <AlternationAST> = (
	^(node left apply: self), ' | ',  (node right apply: self)
)
compileGrammar: n <Symbol> from: input <Stream> ^ <String>  = (
	| output ast result <String> |
	output:: Stream new.
	ast:: parser parse: input.
	output nextPutAll: (headerFor: n).
	output nextPutAll: (ast apply: self).
	output nextPutAll:  classTail.
	result:: output contents.
	output close.
	^result
)
grammarNode: node <GrammarAST> = (
	| result  ::= ''. |
	node productions do:[:p <ProductionAST> |
		result:: result, (p apply: self), Character cr asString.
		].
	^result
)
headerFor: n <String> ^ <String> = (
	^'class ', n, 'parserLib: parsers = (
  ExecutableGrammar = parsers ExecutableGrammar.
  CollectingCommentParser = parsers CollectingCommentParser.
 
  PredicateTokenParser = parsers PredicateTokenParser.
|
)(

class Grammar = ExecutableGrammar (

|
'
)
negationNode: node <NegationAST> = (
	^(node operand apply: self), ' not'
)
oneOrMoreNode: node <OneOrMoreAST> = (
	^(node operand apply: self), ' plus'	
)
optionNode: node <OptionAST> = (
	^(node operand apply: self), ' opt'	
)
productionNode: node <ProductionAST> = (
	^node name, ': ', (node rhs apply: self), Character cr asString
)
productionReferenceNode: node <ProductionReferenceAST> = (
	^node identifier
)
sequenceNode: node <SequenceAST> = (
  | result  list ::= node sequence. |
	list isEmpty ifTrue:[^''].
	result:: list first apply: self.
	(2 to: list size) do:[:i <Integer> |  | element <AST> |
		element:: list at: i.
		result::  result, ', ', (element apply: self).

		].
	^result
)
stringNode: node <StringAST> = (
	^node val
)
zeroOrMoreNode: node <ZeroOrMoreAST> = (
	^(node operand apply: self), ' star'
)'private'
classTail ^ <String> = (
	^')()
	)'
)) : ()