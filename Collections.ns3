Newspeak3
'NSCollections'
class Collections usingPlatform: p = (
"This code was derived by converting the Strongtalk Collections classes to Newspeak, which is why the Sun Microsystems copyright and BSD license below applies.

Copyright (c) 1995-2006 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
Copyright 2008-2009 Yardena Meymann, Gilad Bracha and other contributors.
 
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, 
 this  list of conditions and the following disclaimer.

* Redistribution in binary form must reproduce the above copyright notice, 
this list of conditions and the following disclaimer in the documentation and/o other materials provided with the distribution.

Neither the name of Sun Microsystems or the names of contributors may 
be used to endorse or promote products derived from this software without 
specific prior written permission.

>>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS 
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGE.>>"|  	
	private Association = p kernel Association.
	
	private MutableAddableList = MutableList mixin |> AddableList.
	"-- collection aliases --"
	public OrderedCollection = MutableArrayList.
	public Dictionary = MutableHashedMap.
	public IdentityDictionary = IdentityMutableHashedMap.
	public SortedCollection = SortedList.
	"-- streams --"
	private ListReadStream = p streams SeqCltnReadStream. 
	private ListReadWriteStream = p streams SeqCltnReadWriteStream. 
	private BasicInputStream = p streams BasicInputStream. 
	private BasicOutputStream = p streams BasicOutputStream. 
	
	private IOSequence = Delay computation: [MutableList mixin |> (BasicInputStream mixin |> BasicOutputStream).].
	
	"magic collections"
	"Not yet supported by NS2JS"
	public WeakArray = Delay computation: [p blackMarket Collections WeakArray].
|)
(
class AddableList = List (
"AddableLists are Lists that support the Extensible protocol, 
and which support indexing in constant time."| 
	private contents <Array[E]>
	private startGap <Integer>  "number of empty slots at the beginning of contents"
	private lastIndex <Integer>  "(internal) index of last occupied table entry"
|initCapacity: self class defaultCapacity)
('accessing'
add: e <E> ^<E> = (
	subclassResponsibility
)
addAll: c <Collection[E]> ^<Collection[E]> = (
	c do: [ :el <E> |
		add: el	].
	^c
)
at: i <Integer> ^<E> = (
	| adjusted <Int> |
	adjusted:: i + startGap.
	((0 < i) and: [adjusted <= self lastIndex])
		ifFalse: [ error: 'invalid index' ].
	^contents at: adjusted

)
at: i <Integer> ifAbsent: f <[^X def]>  ^<E | X> = (
	| internal <Int> |
	internal:: i + self startGap.
	^(internalIndexIsValid: internal)
		ifTrue: [ contents at: internal ]
		ifFalse: [ f value ]
)
includeAll: c <Collection[E]> ^<Collection[E]> = (
	c do: [ :el <E> |
		include: el   ].
	^c
)
indexOf: el <Object> ifAbsent: f <[^X def]> ^<Integer | X> = (
	1 to: size do: [ :i <Integer> |
		(at: i) = el
			ifTrue: [ ^i ].	].
	^f value
)
remove: el <E> ifAbsent: f <[^X def]> ^<E|X> = (
	removeAt: (indexOf: el ifAbsent: [^f value]).
	^el
)
remove: nElements <Integer> at: i <Integer>
 = (
	| el <E> internal <Integer> |
	el:: at: i.
	internal:: startGap + i.
	internalRangeCheck: internal.
	internalRangeCheck: (internal + nElements) - 1.
	internal  to: lastIndex - nElements
		 do: [ :index <Integer> |
			  contents at: index put: (contents at: index + nElements).	].
	contents at: lastIndex put: nil.
	lastIndex: lastIndex - nElements.
)
removeAll = (

	startGap + 1 to: lastIndex do:
		[ :i <Integer> |
			contents at: i put: nil].
	lastIndex: startGap
)
removeAll: c <Collection[E]> ^<Collection[E]> = (

	c do: [ :el <E> |
		remove: el   ].
	^c
)
removeAt: index <Integer> ^<E> = (
	| el <E> |
	el:: at: index.
	remove: 1 at: index.
	^el
)
removeEvery: val <E> ^<E> = (
	^removeEvery: val startingAt: 1
)
removeEvery: val <X def> startingAt: start <Integer> ^<X> = (

	| index <Integer> |
	index:: indexOf: val ifAbsent: [ ^val ].
	removeAt: index.
	^removeEvery: val startingAt: index
)
removeFirst ^<E> = (
	^removeAt: 1
)
removeLast ^<E> = (
	^removeAt: size
)
size ^<Integer> = (
	^lastIndex - startGap
)
size: s <Integer> = (
	"Change the size of the ordered collection to s (not the capacity).  This will truncate elements at the end if the current size
	  is larger.  If the current size is smaller, the added elements will be undefined, in which case it is erroneous to access them until they have been set.
	  This method should be used very rarely and carefully as a result."

	| delta <Integer> newLastIndex <Integer> |
	delta:: s - size.
	newLastIndex:: lastIndex + delta.
	delta < 0
		ifTrue: [ newLastIndex + 1 to: lastIndex do:
					[ :i <Integer> |
						contents at: i put: nil]].
	delta > 0
		ifTrue: [ needSpaceAtEnd: delta ].
	lastIndex: lastIndex + delta.
)'adding/removing'
include: e <E> ^<E> = (
	^include: e ifNew: []
)
include: e <E> ifNew: blk <[]> ^<E> = (
	(includes: e)
		ifFalse: [	add: e.
						blk value. ].
	^e
)
remove: el <E> ^<E> = (

	^remove: el
		ifAbsent: [ error: 'element not found' ]
)
removeAllSuchThat: test <[E,^Boolean]>  = (

	| i <Integer> |
	i:: 1.
	[ i <= size ]
		whileTrue:
			[	(test value: (at: i))
					ifTrue: [ removeAt: i ]
					ifFalse: [ i:: i + 1 ]	]
)'as yet unclassified'
makeSpaceAtStart: nslots <Integer> ^<Integer> = (

	"Make sure that there are at least nslots of unused capacity at the low
	 end of contents.  The # of slots added at the beginning is returned."

	|	newGap <Integer>
		diff <Integer>
		newContents <AbsoluteArray[E]>
		sz <Integer>
		newLastIndex <Integer> |
	(isEmpty and: [nslots <= contents size])
		ifTrue: [startGap: nslots.
  				lastIndex: nslots.
				^nslots].

	sz:: size.
	newGap:: nslots max: sz.
	diff:: newGap - startGap.
	newLastIndex:: newGap + sz.
	newContents:: Array"[E]" new:
		contents size + diff.
	newContents
		replaceFrom: newGap + 1
		to: newLastIndex
		with: contents
		startingAt: firstIndex.
	startGap: newGap.
	contents: newContents.
	lastIndex: newLastIndex.
	^diff	
)'copying'
copyWithSize: s <Integer> ^<MutableList[EX]> = (
	"{where EX is returnType of #anElement message of receiverType}"

	| safeself <List[EX]> |

	"This guarantee is safe because the inference clause guarantees
		that E < EX at each call site"
	safeself:: "guaranteed <List[EX]>" self.

	^(Array"[EX]" new: s)
		replaceFrom: 1 to: (s min: size) with: safeself	
)'initialization-private'
initCapacity: c <Integer> = (
	contents:: Array"[E]" new: c.
	startGap:: 0.
	lastIndex:: 0.
)'iterating'
do: f <[E]>
 = (

	startGap + 1 to: lastIndex do:
		[ :i <Integer> |
			f value: (contents at: i)	]
)'private'
endGap ^<Integer> = (
	^contents size - lastIndex
)
firstIndex ^<Integer> = (
	^startGap + 1
)
internalIndexIsValid: index <Integer> ^<Boolean> = (
	^index > startGap and: [ index <= lastIndex ]
)
internalRangeCheck: index <Integer> = (
	(internalIndexIsValid: index )
		ifFalse: [ error: 'invalid index' ].
)
makeSpace: slots <Integer> beforeIndex: i <Integer> ^<Integer> = (

	"assume:  i is a valid internal index.  The index is returned, adjusted
	 for any resizing of the internal array that may have taken place 
	 (i.e. the index of the beginning of the created gap is returned)"

	"# before i is (i - startGap) - 1, # after is (lastIndex - i) + 1"
	^((i - startGap) - 1) > ((lastIndex - i) + 1)
		ifTrue: [ 	"fewer elements after, so move them"
			      	needSpaceAtEnd: slots.
			      	contents
					replaceFrom: i + slots
					to: lastIndex + slots
					with: contents
					startingAt: i.
			    	lastIndex:: lastIndex + slots.
				i	]
		ifFalse: [	"fewer elements before, so move them"
				| newI <Integer> |
				newI:: i + (needSpaceAtStart: slots) - slots.
				contents
					replaceFrom: (startGap + 1) - slots
					to:  newI - 1
					with: contents
					startingAt: startGap + 1.
				startGap:: startGap - slots.
				newI	].
)
needSpaceAtEnd: slots <Integer>
 = (

	slots > endGap
		ifTrue: [	contents:
							(contents copyWithSize:
								contents size + (slots max: size)	)]
)
needSpaceAtStart: nslots <Integer> ^<Integer> = (

	"Make sure that there are at least nslots of unused capacity at the low
	 end of contents.  The # of slots added at the beginning is returned."

	^nslots > startGap
		ifTrue: [makeSpaceAtStart: nslots]
		ifFalse: [ 0 ]
)
postCopy
 = (

	super postCopy.
	"We potentially may change the size of the contents array so that this can work for copyWithSize:
	  as well"
	contents: (contents copyWithSize: (contents size max: lastIndex))
)'private-internal accessing'
internalAt: index <Integer>  ^<E> = (
	^contents at: index
)
internalAt: index <Integer> put: el <E>  ^<E> = (
	^contents at: index put: el
)
internalOffset ^<Integer> = (
	^startGap
)'withable'
with: el <E> = (

	subclassResponsibility
)
withAll: els <Collection[E]> = (

	subclassResponsibility
)) : ('constants'
defaultCapacity ^<Integer> = (
	^5
)'instance creation'
new: capacity <Integer> ^<Instance> = (

	^new initCapacity: capacity
)
newWithSize: s <Integer> ^<Instance> = (

	"create a new instance of size s with all elements undefined (nil).
		This must be used very carefully, since each element should
		be set using at:put: before accessing it; failure to do this can
		lead to hard-to-debug crashes"
	^new initCapacity: s; size: s
)
with: val1 <E> ^<Instance> = (
	^(new: 1) add: val1; yourself
)
withAll: cltn <Collection[E]> ^<Instance> = (
	^(new: cltn size) addAll: cltn; yourself
))
class Bag new: capacity <Int> ^<Instance> = Collection (
"Bags are unordered collections of possibly duplicate elements.

Contrast this with Sets, which will hold no more than one entry
for a given object (as distinguished by #=)."|
	private contents_private <MutableMap[E,Int]> ::= MutableHashedMap new: capacity.	"holds (element -> occurrence)"
|)
('accessing'
occurrencesOf: o <Object> ^<Int> = (
	^contents at: o ifAbsent: [ 0 ]
)
size ^<Int> = (
	^contents inject: 0 into:
		[ :tot <Int> :occurrences <Int> |
			tot + occurrences	]
)'adding/removing'
add: el <E> ^<E> = (
	^add: el withOccurrences: 1
)
add: el <E> withOccurrences: oc <Int> ^<E>  = (
	contents at: el put: oc + (occurrencesOf: el) .
	^el
)
addAll: els <Collection[E]> ^<Collection[E]> = (
	^els do: [ :el <E> | add: el ]
)
include: el <E> ^<E> = (
	| ocs <Int> |
	ocs:: occurrencesOf: el.
	ocs > 0	
		ifFalse: [ contents at: el put: 1 ].
	^el
)
include: el <E> ifNew: blk <[]> ^<E> = (
	| isnew <Boolean> |
	isnew:: includes: el.
	include: el.
	isnew
		ifTrue: [ blk value ].
	^el
)
includeAll: els <Collection[E]> ^<Collection[E]> = (
	^els do: [ :el <E> |	include: el ]
)
remove: el <E> ^<E> = (
	^remove: el ifAbsent: [ error: 'Element not found' ]
)
remove: el <E> ifAbsent: f <[^X def]> ^<E | X> = (
	^remove: el withOccurrences: 1 ifAbsent: f
)
remove: el <E> withOccurrences: ocs <Int> ifAbsent: f <[^X def]> ^<E | X> = (
	| curOcs <Int> |
	curOcs:: occurrencesOf: el.
	^ocs > curOcs
		ifTrue: [ f value ]
		ifFalse: [  curOcs = ocs
					ifTrue: [	contents removeKey: el ]
					ifFalse: [	contents at: el put: curOcs - ocs ].
				   el	]
)'as yet unclassified'
contents: c <MutableMap[E,Int]> = (
	contents_private:: c.
)
isKindOfBag = (

	^ true
)
removeAll: els <Collection[E]> ^<Collection[E]> = (
	els do: [ :el <E> | remove: el ].
	^els
)
removeAllSuchThat: test <[E,^Boolean]> = (
	copy do:
		[ :el |
			(test value: el)
				ifTrue: [ self remove: el ]		]
)
removeEvery: el <E> ^<E> = (
	contents removeKey: el ifAbsent: [].
	^el
)'converting'
asBag ^<Bag[EX]> = (
	"{where EX is returnType of #anElement message of receiverType}"
	^"guaranteed <Bag[EX]> "self
)'initialization'
initCapacity: cap <Int> = (
	contents: (MutableHashedMap"[E,Int]" new: cap).
)'iterating'
do: f <[E]> = (
	contents keysAndValuesDo:
		[ :el <E> :occurrences <Int> |
			occurrences timesRepeat:
				[ f value: el ]		].
)'private'
equalsBag: other <Bag[Object]> ^<Boolean> = (


	"%kludge: This is ugly, but will have to do until typecase can deal with type variables.  It is safe
	  since we know that MutableHashedMaps can actually perform an at:ifAbsent: safely with
	  an arbitrary key type, even thought its signature doesn't reflect that currently (although it could)"

	contents size = other contents size
		ifFalse: [ ^false ].
	contents keysAndValuesDo:
		[ :el <E> :occurrences <Int> |
			(other contents at: el ifAbsent: [ 0 ]) = occurrences
				ifFalse: [ ^false ].	].
	^true
)
postCopy = (
	super postCopy.
	contents: contents copy.
)'restricted'
contents ^<MutableMap[E,Int]> = (
	^contents_private
)'testing'
= other <Object> ^<Boolean> = (
	^self == other
		or: [ equalsBag: (Bag"[Object]" coerce: other else: [ ^false ]) ]
)
includes: el <Object> ^<Boolean> = (
	^contents includesKey: el
)
~= other = (
	^(self = other) not.
)) : ('as yet unclassified'
defaultCapacity = (

	^ 8
)
with: el1 with: el2 = (
	^(with: el1) add: el2; yourself.
)
with: el1 with: el2 with: el3 = (
	^(with: el1 with: el2) add: el3; yourself
)'converting'
coerce: o <Object> else: fail <[^X def]>   ^<Instance|X> = (
	"%remove when typecase correctly implemented."

	"Explicit test for nil as long as the in-image nil is no Newspeak object"
	^ (o ~= nil and: [o isKindOfBag])
		ifTrue: [ o ]
		ifFalse: [ fail value ]
)'instance creation'
new = (
	^new: defaultCapacity
)
with: val1 <E> ^<Instance> = (
	^(new: 1) add: val1; yourself
)
withAll: cltn <Collection[E]> ^<Instance> = (
	^(new: cltn size) addAll: cltn; yourself
))
class Collection = (
"A Collection is an object that represents a group of objects.

The only message that must be implemented by subclasses is the #do: message.
All other Collection messages are then defined in terms of #do:.

%responsibility size
    Subclasses usually reimplement the #size message if possible, since the
	implementation provided in this class is very inefficient.
%responsibility collect:
    Subclasses may wish to consider overriding the #collect: (and #select: and #reject:)
    messages to specialize their return
    types to match the receiver type more closely."| |)
('TEMPORARY'
copy = (
	^self class withAll: self
)
postCopy = (
)
value = (
	^self
)'accessing'
anElement ^<E> = (
	"Return an arbitrary element of the collection, or cause an error if the collection is empty.
	This is almost never called; its most common usage
	 is to provide a convenient message signature for inference clauses to get the element
	type of a collection from, statically."

	^detect: [ :e <E> | true ]
)
hash  ^<Int> = (
	| count |
	count:: 0.
	^inject: 0 into: 
		[ :hash <Int> :el <E> |
			| newHash |
			newHash = hash bitXor: el hash.
			count:: count + 1.
			count > 2
				ifTrue: [ ^newHash ].
			newHash ]
)
occurrencesOf: o <Object> ^<Int> = (
	| c <Int> |
	c:: 0.
	do: [ :e <E> | e = o ifTrue:[ c = c + 1 ]].
	^c
)
size ^<Integer> = (
	| c <Int> |
	c:: 0.
	do: [ :e <E> | c:: c + 1 ].
	^c
)
species ^<Collection[E] class> = (
	^Set
)'as yet unclassified'
assert: value = (
)
do: blk <[E]> separatedBy: betweenBlk <[]> = (
	"Useful when you need to do something 'between' elements (i.e. not before the first one, and not after the last one).
		blk is evaluated the same way as for #do:, but betweenBlk is evaluated once between each pair of elements."

	| firstTime <Boolean> |
	firstTime:: true.
	do:
		[ :el <E> |
			firstTime
				ifTrue: [ firstTime:: false ]
				ifFalse: [ betweenBlk value ].
			blk value: el.
		]
)
isCollection = (
	^true
)
isKindOfCollection = (

	"Should be auto-generated"
	^ true
)
union: other <Collection[Object]> ^ <Set[Object]> = (

	^ self asSet addAll: other; yourself
)'converting'
asArray  ^<Array[EX]> = (
	"Return a new array holding the elements of this collection.  The element type of the array is whatever the
	 static type of the receiver is at the point of send."

	| a <Array[EX]> i <Int> |
	a:: Array new: size.
	i:: 1.
		do: [ :el <EX> |
				a at: i put: el.
				i::  i + 1. ].
	^a

)
asBag ^<Bag[EX]> = (
	"{where EX is returnType of #anElement message of receiverType}"
	"Return a new Bag holding the elements of this collection.  The element type of the bag is whatever the
	 static type of the receiver is at the point of send."

	^Bag withAll: self
)
asMutableArrayList ^<MutableArrayList[EX]> = (
	"{where EX is returnType of #anElement message of receiverType}"
"Return a new MutableArrayList holding the elements of this collection.  The element type of the ordered collection
       is whatever the static type of the receiver is at the point of send."
	^MutableArrayList"[EX]" withAll: "(guaranteed <CollectionEX]> "self")"
)
asSet ^<Extensible[EX]> = (
	 "Return a new extensible collection holding the elements of this collection."

	^Set"[EX]" withAll: "(guaranteed <Collection[EX]> "self")"
)
asSortedList ^<List[Object]> = (
	"This message is NOT typesafe, and should only be used for compatibility reasons, since there is
 	 no way of knowing whether the elements of this collection support #< or not.  You should use
	 #asSortedList: instead, if possible"

	^SortedList"[Object]" withAll: self
)
asSortedList: sortPredicate <[E,EX, ^Boolean]>	^<SortedList[EX]> = (
	"{ where EX is  arg 1 of #value:value: message of arg 1 }"
	"Return a new sorted collection ordered by the given sortPredicate.  Note that Magnitude
	 supports the defaultSort message for convenience, so that for example if you have a collection
	 of strings strc, you can say:
		strc asSortedList: String defaultSort
	"

	"This is typesafe despite the guarantee because the inference clause requires that E = EX at the
          call site"
	^(SortedList"[EX]" new: size sortBlock: "(guaranteed <[EX,EX,^Boolean]> "sortPredicate")")
		addAll: "(guaranteed <Collection[EX]> "self")"; yourself
)'iterating'
collect: map <[E, ^R def]> ^<Collection[R]> = (
	^collectUsingAdd: map
)
detect: predicate <[E,^Boolean]> ^<E> = (
	^detect: predicate ifNone: [ error: 'No matching element detected' ]
)
detect: predicate <[E,^Boolean]> ifNone: fail <[^X def]> ^<E|X> = (
	do: [ :e |
			(predicate value: e)
				ifTrue: [ ^e ]	].
	^fail value
)
do: f <[E]> = (
	subclassResponsibility
)
inject: val <X> into: f <[X def, E,^X]>  ^<X> = (
	| v <X> |
	v:: val.
	do: [ :e <X> |	v:: f value: v value: e ].
	^v
)
intersection: other <Collection[Object]> ^ <List[E]> = (

	^ self select: [:each | other includes: each]
)
reduce: reduceFn <[RE def,RE,^RE]>  ^<RE>  = (
	"{where CONSTRAINER <RE> is returnType of #anElement message of receiverType}"
	"Like reduce:ifEmpty: except that it is a dynamic error to send this to an empty collection"
	
	^"(guaranteed <Collection[RE]> self) "reduce: reduceFn ifEmpty: [ error: 'Cannot reduce an empty collection' ] 
)
reduce: reduceFn <[RE def,RE,^RE]> ifEmpty: onEmpty <[^X def]>  ^<RE | X> = (
	"{where CONSTRAINER <RE> is returnType of #anElement message of receiverType}"
	"Reduce is similar to inject except that the first element is used as the injected
	  element for the rest of the collection.  It is often handier than inject.  For example:
		(#(1 2 3 4) reduce: [ :a <Int> :b <Int> |   a + b ]) sums a collection of numbers."

	"esoteric typing %note: We need to ensure that E is a subtype of RE (the argument type for the reduction
		function), but since that would require a
		supertype constraint (which neither we nor anyone else support, we accomplish the same
	    thing indirectly by introducing an unreferenced type 
		variable CONSTRAINER that is inferred to be E at the call site, and then constraining it with a bound
		of RE.  This will prevent any call where E > RE from typechecking.  However, since the
		typesystem doesn't 'know' that, we have to tell it that with a guarantee in the method body.
		Because of the CONSTRAINER, we know that the guarantee is true for all calls that typecheck.
		Of course, this is tricky, but at least we can express it, and in a way that hides the guarantee from
		callers!"

	| current <RE> |
	do:
		[ :el <E> |
			| rel <RE> |
			rel:: el.
			current isNil
				ifTrue: [ current:: rel ]
				ifFalse: [ current:: reduceFn value: current value: rel ]	].
	^current isNil
		ifFalse: [ current ]
		ifTrue: [ onEmpty value ]
)
reject: predicate <[E,^Boolean]> ^<List[E]> = (
	^select: [ :e | (predicate value: e) not ]
)
select: predicate <[E,^Boolean]> ^<List[E]> = (
	"%todo: fix this so that for strings, arrays, etc. it returns the original collection type, even if it isn't extensible.
	  Fix the typing down in Str etc to return more specific types."

	| c <MutableArrayList[E]> |
	"See #newForCollectUsingAdd: for explanation of why the guarantee is safe"
	"Please replace 'self size' with 'MutableArrayList[E] defaultCapacity'"
	c: (newForCollectUsingAdd: size).
	do: [ :e |  
		(predicate value: e)
			ifTrue: [ c add: e ].	].
	^c
)'printing'
printOn: strm <CharOutputStream> = (

	| count <Int> first <Boolean> |
	strm	nextPutAll: class mixin simpleName;
			nextPut: $(.
	count:: 0.
	first:: true.
	printElementsDo:
		[ :el <Object> |
			first
				ifTrue: [ first:: false ]
				ifFalse: [ strm space ].
			el printOn: strm.
			count:: count + 1.
			count >= maxPrintElements
				ifTrue: [ strm nextPut: $<; print: size - count; nextPutAll: ' more elements>)'.
						^self	].	].
	strm nextPut: $).
)'private'
collectUsingAdd: map <[E, ^R def]> ^<Collection[R]> = (
	| c |
	"See #newForCollect: for explanation of why the guarantee is safe"
	c:: (newForCollectUsingAdd: size). 
	do: [ :e | c add: (map value: e) ].
	^c
)
maxPrintElements ^<Int> = (
	^100
)
newForCollectUsingAdd: size <Int> ^<MutableArrayList[Object]> = (
	"Return a new extensible collection that is as closely related to the receiver's class as possible.  The
	 returned collection must be unaliased and empty, so it is safe for the caller to guarantee that the type
	 variable is of a more specific type"

	^MutableArrayList new: size
)
printElementsDo: f <[Object]> = (
	"Evaluate the block with all the elements that should be shown as the contents
	  in the printstring.  This provides a hook for things like MutableHashedMaps, which want
	  to show their associations, not their values"

	do: f
)'testing'
= other <Object> ^<Boolean> = (
	^self == other or: [ class == other class
		and: ["We have the same class, so we can guarantee other is a collection"
			 hasSameElementsAs: "(guaranteed <Collection[Object]> "other")" ]]
)
hasSameElementsAs: other <Collection[Object]>  ^<Boolean> = (
	"Like =, but doesn't care whether the receiver and other are the same kind of collection or not"

	^size = other size  and:
		[ asBag = other asBag ] 
)
includes: o <Object> ^<Boolean> = (
	do: [ :e <E> | e = o ifTrue: [ ^true ] ].
	^false
)
isEmpty ^<Boolean> = (
	^size = 0
)'virtual operations'
virtualCollect: blk <[E, ^X def]> ^<Object> = (
	^VirtualCollector on: self map: blk
)
virtualSelect: blk <[E, ^Boolean]> ^<Object> = (
	^virtualSelectorClass on: self filter: blk 
)
virtualSelectorClass ^ <Object> = (
	^VirtualSelector 
)) : ()
class CustomMutableHashedMap new: cap = MutableHashedMap new: cap (
"CustomMutableHashedMaps are like regular MutableHashedMaps, except that they use blocks to
perform key hashing and comparison, so that key matching using a different
operator than #= can be done.  The default blocks compare using the standard
operator #=."| 
	compareBlock <[K,K,^Boolean]>
	hashBlock <[K, ^Int]>
|compareBlock:: [ :k1 <K> :k2 <K> |  k1 = k2 ].
	hashBlock:: [ :k <K> | k hash ])
() : ('constants'
defaultCapacity ^<Int> = (
	^0
)'instance creation'
new = (
	^new: defaultCapacity
)
withCompareBlock: compareBlock <[K,K,^Boolean]>
hashBlock: hashBlock <[K, ^Int]>
 ^<Instance> = (


	^withCompareBlock: compareBlock hashBlock: hashBlock capacity: defaultCapacity.
)
withCompareBlock: compareBlock <[K,K,^Boolean]>
hashBlock: hashBlock <[K, ^Int]>
capacity: cap
 ^<Instance> = (


	^(new: cap) compareBlock: compareBlock; hashBlock: hashBlock
))
class HashedCollection new: cap = Collection (|
	private table_0 <Array[A|Object]>
			"The table holds either included entries, or an object indicating a deleted entry,
			which is currently the table itself.  This of course means that the table is not allowed
			as a valid element of the collection, but this is only an issue when writing reflective
			system code that violates encapsulation."
	private size_0 <Integer> 
			"the number of collection elements (not the size of the table)"
	private deleted <Integer> 
			"the number of slots marked with the deletion placeholder"

|initCapacity: cap)
('accessing'
at: key <K> ^<E> = (
	^at: key ifAbsent: [ error: 'key not found' ] 
)
at: key <Object> ifAbsent: f <[^X def]> ^<E|X> = (
	^elementFor: 
			(valAt: key ifAbsent: [ ^f value ])
)
indexOf: el <Object> ^<K> = (
	^indexOf: el
			ifAbsent: [ error: 'Element not found' ]
)
indexOf: el <Object> ifAbsent: blk <[^X def]> ^<K | X> = (
	contentsDo:
		[ :v <A> |
			(elementFor: v) = el
				ifTrue: [ ^keyFor: v ]  ].
	^blk value
)
keyAtValue: v <Object> ^<K> = (
	^indexOf: v
)
keyAtValue: v <Object> ifAbsent: blk <[^X def]> ^<K | X> = (
	^indexOf: v ifAbsent: blk 
)
size ^<Int> = (
	^size_0
)
table = (
	^table_0
)'as yet unclassified'
firstTableSize ^<Integer> = (
	"The size used for the table when the capacity is 0 and the first element is added"
	
	^8
)'consistency testing'
checkValidity = (
	"This method performs various validity checks on the receiver"

	| c <Int> |
	c:: 0.
	contentsDo:
		[ :val <A> |
			assert: [ (at: (keyFor: val)) = (elementFor: val) ].
			c:: c + 1.		].

	assert: [ c = size ].
)'including/adding'
add: val <A> ^<A> = (
	^include: val
)
addAll: c <Collection[A]> ^<Collection[A]> = (

	c do: [ :e <A> |
		add: e. ].
	^c
)
include: val <A> ^<A> = (

	^include: val ifNew: []

)
include: val <A> ifNew: ifNew <[]> ^<A> = (

	^tableAt: (keyFor: val) put: (elementFor: val) ifNew: ifNew

)
includeAll: c <Collection[A]> ^<Collection[A]> = (

	c do: [ :el <A> |
		include: el   ].
	^c
)'iterating'
do: f <[E]> = (

	contentsDo:
		[ :val <A> |
			f value: (elementFor: val)		]
)
keysDo: f <[K]> = (

	contentsDo:
		[ :val <A> |
			f value: (keyFor: val)		]
)'private-accessing'
setTable: t <Array[A|Object]> = (
	table_0:: t.
)
size: s <Int> = (
	size_0:: s
)
table: t <Array[A|Object]> = (
	setTable: t.
	assert: [deleted = 0] message: ''.
)'private-computations'
advanceAmount ^<Int> = (
	"a large prime - 1"	
		^99990
)
indexOf: key <Object> tableMask: mask <Int> ^<Int> = (
	^((hashFor: key) bitAnd: mask) + 1
)
minTableSize ^<Int> = (
	^4
)
minTableSizeForCapacity: cap <Integer> ^<Integer> = (
	"max density is 50% full"
	^cap + cap
)
newTableWithSize: tableSize <Int>  ^<Array[A|Object]> = (
	^Array new: tableSize
)
occupied ^<Integer> = (
	^size + deleted
)
tableSizeForCapacity: cap <Integer> ^<Integer> = (
        | min <Integer> tsize <Integer> |
        min:: minTableSizeForCapacity: cap.
        "search for the smallest power of two that is >= min"
        tsize:: minTableSize.
        [ tsize < min ]
                whileTrue: [ tsize:: tsize + tsize ].
        ^tsize
)'private-initialization'
initCapacity: cap <Int> = (

	size: 0.
	deleted: 0.
	cap > 0
		ifTrue: [ table:: newTableWithSize: (tableSizeForCapacity: cap). ].

)'private-misc'
markDeleted: index <Int> = (

	| tbl <Array[A|Object]> |
	tbl:: table.
	tbl at: index put: tbl.
	deleted: deleted + 1
)
postCopy = (

	| tbl <Array[A|Object]> newtbl <Array[A|Object]> |

	super postCopy.
	tbl:: table.
	tbl == nil
		ifTrue: [ ^self ].

	newtbl:: newTableWithSize: tbl size.
	1 to: tbl size do:
		[ :index <Int> |
			atIndex: index
					inTable: tbl
					occupiedSlotDo:
						[ :val <A> |
							newtbl at: index put: (elementForCopy: val)	]
					emptySlotDo: [ ]
					deletedSlotDo:
						[	newtbl at: index put: newtbl		]
		].
	setTable: newtbl
)
printElementsDo: f <[Object]> = (
	
	contentsDo: f
)'private-subclass responsibility'
buildValForKey: k <K> element: el <E> ^<A> = (
	"construct an A from a K and an E"
	subclassResponsibility
)
elementFor: val <A> ^<E> = (
	"extract an E from an A"
	subclassResponsibility
)
elementForCopy: el <A> ^<A> = (

	"When a copy of the collection is made, this method implements what happens
	  to each element.  For example, MutableHashedMaps copy their elements, since the
	  associations are really part of the MutableHashedMap, whereas KeyedSets don't since the
	  associations are really elements of the collection."

	subclassResponsibility
)
hashFor: key <Object> ^<Int> = (
	"return the appropriate hash value for a key"
	subclassResponsibility
)
key: key1 <Object> matches: key2 <Object> ^<Boolean> = (

	"Test whether two keys match"
	self subclassResponsibility
)
keyFor: val <A> ^<K> = (

	"extract an K from an A"
	subclassResponsibility
)
objToIncludeFor: new <A> withExisting: other <A> ^<A> = (

	"In the situation where a new value  is being 'include'ed in the collection, and there is already an existing
	 value with a matching key, this method determines what value is actually placed in the collection"

	subclassResponsibility
)'private-subroutines for #tableAt:put:ifNew:'
tableAt: key <K>
put: el <E>
inDeletedSlot: index <Integer>
^<A> = (

	| val <A> |
	val:: tableAt: key put: el inUnusedSlot: index.
	deleted: deleted - 1.
	"we don't have to check for growth when reusing a previously used slot"
	^val
)
tableAt: key <K>
put: el <E>
inEmptySlot: index <Integer>
^<A> = (

	| val <A> |
	val:: tableAt: key put: el inUnusedSlot: index.
	growIfNeeded.
	^val
)
tableAt: key <K>
put: el <E>
inMatchingSlot: index <Integer>
value: val <A>
^<A> = (

	| newVal <A> |
	newVal:: objToIncludeFor: (buildValForKey: key element: el)
								withExisting: val.
	table at: index put: newVal.
	^newVal
)
tableAt: key <K>
put: el <E>
inUnusedSlot: index <Integer>
^<A> = (

	"This does the core work for #tableAt:put:[inDeletedSlot:|inEmptySlot:]"

	| newVal <A> |
	newVal:: buildValForKey: key element: el.
	table at: index put: newVal.
	size: size + 1.
	^newVal
)'private-table manipulation'
atIndex: i <Int>
inTable: tbl <Array[Object|A]>
occupiedSlotDo: occupied <[A,^X def]>
emptySlotDo: empty <[^Y def]>
deletedSlotDo: deleted <[^Z def]>
^<X|Y|Z> = (

	"This is the core method that does the case analysis for a slot to
		determine whether it is occupied, deleted, or empty"

	| el <A|Object>  |
	el:: tbl at: i.
	el == nil
		ifTrue: [ ^empty value ].
	el == tbl
		ifTrue: [ ^deleted value ].

	"The following guarantee is because the table uses a non-typesafe trick in 
	  which the table pointer itself is used to indicate a deleted slot; thus the table
	  doesn't hold only values of type A.  The guarantee is safe because we know that
	  we only put either values or the table into the table, and the previous
	  statement already handled the case when el is the table pointer-
	  thus at this point by elimination el has to be a value of type A"		
	^occupied value: "(guaranteed <A> "el")"
)
contentsDo: f <[A]>
 = (

	| tbl <Array[A|Object]> |
	tbl:: table.
	tbl == nil
		ifTrue: [ ^self ].

	1 to: tbl size do:
		[ :index <Int> |
				atIndex: index
					inTable: tbl
					occupiedSlotDo:
						[ :val <A> |
							f value: val	]
					emptySlotDo: [ ]
					deletedSlotDo: [ ]
		]

)
createFirstTable = (
	table:: newTableWithSize: firstTableSize.
)
growIfNeeded = (

	(minTableSizeForCapacity: occupied) > table size
		ifTrue: [ growTable ]
)
growTable
 = (

	| new <Array[A|Object]> |
	new:: newTableWithSize: table size + table size.
	contentsDo:
		[ :a_value <A> |
				lookup: (keyFor: a_value)
					inTable: new
					matchingSlotDo:
						[ :index <Int> :val <A> |
							shouldNotHappen	]
					emptySlotDo:
						[ :index <Int> |
							new at: index put: a_value	]
					deletedSlotsDo:
						[ :index <Int> |
							shouldNotHappen ]
					mismatchingSlotsDo:
						[ :index <Int> | "ignore" ]
		].
	deleted: 0.
	table: new.
)
lookup: key <Object>
inTable: tbl <Array[Object|A]>
matchingSlotDo: matching <[Int,A,^X def]>
emptySlotDo: empty <[Int, ^Y def]>
deletedSlotsDo: marked <[Int]>
mismatchingSlotsDo: mismatch <[Int]>
^<X|Y> = (

	"This is the core method that looks for a slot suitable for the key,
		and evaluates the appropriate blocks.
	   The lookup process is iterative, terminating when a slot that is empty
	   or has a matching key is found"

	| i <Int> mask <Int> |
	mask:: tbl size - 1.
	i:: indexOf: key tableMask: mask.
	[ 			atIndex: i
				inTable: tbl
				occupiedSlotDo:
					[ :val <A> |
						(key: key matches: (keyFor: val))
							ifTrue: [ ^matching value: i value: val	 ]
							ifFalse: [ mismatch value: i	 ]
					]
				emptySlotDo:
					[ ^empty value: i ]
				deletedSlotDo:
					[	marked value: i	 ].
		i:: ((i + advanceAmount) bitAnd: mask) + 1.
	] repeat
)
lookup: key <Object>
matchingSlotDo: matching <[Integer,A,^X def]>
emptySlotDo: empty <[Integer, ^Y def]>
deletedSlotsDo: marked <[Integer]>
^<X|Y> = (


	^self		lookup: key
				inTable: self table
				matchingSlotDo: matching
				emptySlotDo: empty
				deletedSlotsDo: marked
				mismatchingSlotsDo: [ :index <Integer> | "ignore" ]
)
tableAt: key <K> put: el <E> ifNew: onNew <[]> ^<A> = (

	"put a value for el in the right spot in the table, and return the val"

	| reusableSlot <Integer> |
	table == nil
		ifTrue: [	self createFirstTable.	 ].
	^			lookup: key
				matchingSlotDo:
						[ :index <Integer> :val <A> |
							self tableAt: key put: el inMatchingSlot: index value: val		]
				emptySlotDo:
						[ :index <Integer> |
							| newVal <A> |
							reusableSlot == nil
								ifTrue: [ newVal:: self tableAt: key put: el inEmptySlot: index ]
								ifFalse: [ newVal:: self tableAt: key put: el inDeletedSlot: reusableSlot ].
							onNew value.
							newVal	]
				deletedSlotsDo:
						[ :index <Integer> |
							reusableSlot == nil
								ifTrue: [ reusableSlot:: index ].
						]
)
valAt: key <Object> ifAbsent: f <[^X def]> ^<A|X> = (

	table == nil
		ifTrue: [	^f value ].
		
	^			lookup: key
				matchingSlotDo:
					[ :index <Integer> :val <A> |
						val	]
				emptySlotDo:
					[ :index <Integer> |
						f value	]
				deletedSlotsDo:
					[ :index <Integer> |
						"ignore deleted slots" ]
)'removing'
remove: val <A> ^<A> = (
	^remove: val ifAbsent: [ error: 'value not in collection' ]
)
remove: val <A> ifAbsent: f <[^X def]> ^<A|X> = (
	removeKey: (keyFor: val) ifAbsent: f.
	^val
)
removeAll: c <Collection[A]> ^<Collection[A]> = (

	c do: [ :el <A> |
		remove: el   ].
	^c
)
removeAllSuchThat: test <[A, ^Boolean]>  = (

	copy contentsDo:
		[ :el <A> |
			(test value: el)
				ifTrue: [ remove: el ]		]
)
removeAt: k <K> ^<E> = (
	"A synonym for #removeKey: for consistency with AddableList"

	^removeKey: k
)
removeAt: k <K> ifAbsent: f <[^X def]> ^<E|X> = (
	"A synonym for #removeKey:ifAbsent: for consistency with AddableList"

	^removeKey: k ifAbsent: f
)
removeEvery: val <A> ^<A> = (
	remove: val ifAbsent: [].
	^val
)
removeKey: key <K> ^<E> = (
	^removeKey: key ifAbsent: [ error: 'key not found' ]
)
removeKey: key <K> ifAbsent: f <[^X def]> ^<E|X> = (
	table == nil
		ifTrue: [	^f value	 ].
	^			lookup: key
				matchingSlotDo:
						[ :index <Int> :val <A> |
							markDeleted: index.
							size: size - 1.
							elementFor: val		]
				emptySlotDo:
						[ :index <Int> |
							f value	]
				deletedSlotsDo:
						[ :index <Int> |
							"ignore"
						]
)'testing'
includesElement: val <A> ^<Boolean> = (

	"This is like includes: but it requires an A as an argument, which allows a faster
	  search"

	^includesKey: (keyFor: val)
)
includesIndex: k <Object> ^<Boolean> = (

	valAt: k ifAbsent: [ ^false ].
	^true
)
includesKey: k <Object> ^<Boolean> = (

	^includesIndex: k
)) : ('constants'
defaultCapacity ^<Integer> = (
	^0
)
firstTableSize ^<Integer> = (
	"The size used for the table when the capacity is 0 and the first element is added"
	
	^8
))
class IdentityMutableHashedMap new: cap = MutableHashedMap new: cap (
"IdentityMutableHashedMaps are efficient HashedCollections that let you dynamically associate key->value
pairs,  where the keys are matched using the #== message. ")
('restricted'
hashFor: key <Object> ^<Int> = (
	^key identityHash
)
key: k <Object> matches: another <Object> ^<Boolean> = (
	^k == another
)) : ('as yet unclassified'
new = (
	^new: defaultCapacity
)'constants'
defaultCapacity ^<Int> = (
	^0
))
class IdentitySet new: cap <Integer> = Set new: cap ()
('restricted-  table decoding'
hashFor: key <Object> ^<Int> = (
		^key identityHash
)
key: k <Object> matches: another <Object> ^<Boolean> = (
	^k == another
)) : ('as yet unclassified'
defaultCapacity = (

	^ 0
)
new ^ <Instance> = (
	^self new: defaultCapacity
))
class Interval from: p_start <Number> to: p_stop <Number> by: p_step <Number> = List (
"Intervals are Lists that generate their contents on the fly as a progression
of numbers from a start number to a stop number, separated by a step number.  Usually, the
to:[by:]do: messages defined in the Number subclasses are used instead of Intervals
when just a control structure is needed, since they are much faster.

Note on strong typing issues:

The to:[by:]do: messages in the Number hierarchy are typed restrictively, in such a way that they
can only be used in non-coercive situations (i.e. where the start, stop, and step are all integers,
or all floats, etc.).  This is done to preserve the type of the iteration value passed to the iteration block
in the pure integer form, so that bit operations etc. can be performed etc.  This would not be possible
if Number was the type for the step.  Although this may seem restrictive, the following points should
be noted about this design:

	1) explicit coercions handle the vast majority of these cases;
		for example, use (j asFloat to: k asFloat by: 0.1) rather than
		 (j to: k by: 0.1) when j and k are typed as Numbers or Integers.
	2) this scheme is perfectly compatible with untyped code, since the typed versions will work correctly
	    even if called with arguments of mismatched numeric types, so that things like (1 to: 10 by: 0.1) will 
	    work, even though they don't typecheck.
	3) If full coercive generality is needed in typesafe code, the Interval class can be used, which has been
	    designed using values of type Number, so that things like (1 to: 10 by: 0.1) are ok.  They cannot, however,
		preserve more detailed information about the kinds of numbers in the Interval."|
	start <Number> ::= p_start.
	stop <Number> ::= p_stop.
	increment <Number> ::= p_step.
|)
('accessing'
at: index <Int>  ^<Number> = (

	(start - stop) sign = increment sign
		ifFalse: [	| value <Number> |
						value: start + (increment * (index - 1)).
						increment positive
							ifTrue: [	( value between: start and: stop)
												ifTrue: [ ^value ]	]
							ifFalse: [	(value between: stop and: start)
												ifTrue: [ ^value ]	]	].
	error: 'Index out-of-range'.
)
do: fn <[Number]>
 = (

	| value <Number> incr <Number> stp <Number> |
	value:: start.
	incr:: increment.
	stp:: stop.
	incr positive
		ifTrue: [	[ value <= stp ]
							whileTrue: [	fn value: value.
												value:: value + incr.	]	]
		ifFalse: [	[ value >= stp ]
							whileTrue: [ fn value: value.
												value:: value + incr.	]	]
)
size ^<Int> = (
	^((stop - start) // increment) + 1 max: 0
)'copying'
copyWithSize: s <Int> ^<MutableList[EX]> = (
	"{where EX is returnType of #anElement message of receiverType}"
	self unimplemented
)) : ('instance creation'
from: start <Number> to: stop <Number>  ^<Instance> = (
	^from: start to: stop by: 1
))
class KeyedSet new: capacity <Int> keyedBy: kf <[E,^K]>  ^<Instance> = HashedCollection new: capacity (|
	extractKey <[E,^K]> = kf.
|)
('restricted'
buildValForKey: k <K> element: el <E> ^<E> = (
	^el
)
elementFor: el <E> ^<E> = (
	^el
)
elementForCopy: el <E> ^<E> = (
	^el
)
hashFor: key <Object> ^<Int> = (
	^key hash
)
key: k <Object> matches: another <Object> ^<Boolean> = (
	^k = another
)
keyFor: el <E> ^<K> = (
	^extractKey value: el
)
objToIncludeFor: the_new <E> withExisting: existing <E> ^<E> = (
	^the_new
)'testing'
includes: o <Object> ^<Boolean> = (

	"For keyed sets, this message is inefficient, since we don't know if o is the right kind of
	object to extract a key from, so the elements must be tested sequentially.  Use includesElement: 
	for an efficient implementation"

	^super includes: o
)) : ('constants'
defaultCapacity ^<Int> = (
	^0
)'instance creation'
newKeyedBy: kf <[E,^K]> ^<Instance> = (
	^new: defaultCapacity keyedBy: kf
))
class List = Collection (
"This class implements the read-only protocol for indexed collections that order their elements using integer indices.")
('accessing'
after: o <Object> ^<E> = (
	^at: (indexOf: o) + 1
)
at: i <Integer> ^<E> = (
	subclassResponsibility
)
at: index <Integer> ifAbsent: fail <[^X def]> ^<E|X> = (
	^(index between: 1 and: size)
		ifTrue: [ at: index ]
		ifFalse: [ fail value ]
)
before: o <Object> ^<E> = (
	^at: (indexOf: o) - 1
)
collection: cltn <List[Object]>
matchesElementsAt: index <Integer>
^<Boolean> = (

	"Test whether we contain the given subcollection at index.  This method assumes
	  that there are at least as many elements in this collection after index as cltn size"

	| offset <Integer> |
	offset:: index - 1.
	1 to: cltn size do:
		[ :i <Integer> |
			(cltn at: i) = (at: i+offset)
				ifFalse: [ ^false ]		].
	^true
)
findFirst: predicate <[E,^Boolean]>  ^<Integer> = (

	1 to: size do:
		[ :i <Integer> |
			(predicate value: (at: i))
				ifTrue: [ ^i ]	].
	^0
)
findLast: predicate <[E,^Boolean]>  ^<Integer> = (

	size to: 1 by: -1 do:
		[ :i <Integer> |
			(predicate value: (at: i))
				ifTrue: [ ^i ]	].
	^0
)
first ^<E> = (
	^at: 1
)
hash ^<Integer> = (

	"This function should not be changed, since it is designed to produce the
		same results as the identityHash primitive, for strings and symbols"
	| sz <Integer> val <Integer> |
	sz:: size.
	sz < 2
		ifTrue: [ ^sz = 1 ifTrue: [ self hashAt: 1 ] ifFalse: [ 1 ] ].
	val:: hashAt: 1.
	val:: (val bitShift: 3) bitXor: ((hashAt: 2) bitXor: val).
	val:: (val bitShift: 3) bitXor: ((hashAt: sz) bitXor: val).
	val:: (val bitShift: 3) bitXor: ((hashAt: sz - 1) bitXor: val).
	val:: (val bitShift: 3) bitXor: ((hashAt: (sz bitShift: -1) + 1) bitXor: val).
	val:: (val bitShift: 3) bitXor: (sz bitXor: val).

	"mask it to 20 bits to match VM"
	val:: val bitAnd: 16rFFFFF.
	^val
)
indexOf: el <Object> ^<Integer> = (

	^indexOf: el ifAbsent: [ 0 ]
)
indexOf: el <Object> ifAbsent: f <[^X def]>  ^<Integer | X> = (

	1 to: size do:
		[ :i <Integer> |
			(at: i) = el
				ifTrue: [ ^i ]	].
	^f value
)
indexOfSubCollection: sub <List[Object]>
startingAt: index <Integer>
^<Integer> = (

	^indexOfSubCollection: sub
		startingAt: index
		ifAbsent: [ error: 'subcollection not found' ]
)
indexOfSubCollection: sub <List[Object]>
startingAt: index <Integer>
ifAbsent: f <[^X def]>
^<Integer | X> = (

	index to: (size - sub size) + 1 do:
		[ :i <Integer> |
			(collection: sub matchesElementsAt: i)
				ifTrue: [ ^i ]		].
	^f value
)
indicesOfSubCollection: sub <List[Object]>
startingAt: index <Integer>
^<List[Integer]> = (

	| indices <MutableArrayList[Integer]> subSize <Integer> current <Integer> |
	indices:: MutableArrayList"[Int]" new.
	subSize:: sub size.
	current:: index.
	[ current:: self indexOfSubCollection: sub startingAt: current ifAbsent: [ 0 ].
	  current = 0
		] whileFalse: 
			[	indices addLast: current.
				current:: current + subSize.		].
	^indices
)
indicesOfSubCollection: sub <List[Object]>  ^<List[Int]> = (

	^indicesOfSubCollection: sub startingAt: 1
)
last ^<E> = (
	^at: size
)
size ^<Integer> = (
	subclassResponsibility
)
species ^<Collection[E] class> = (
	^Array"[E]"
)'as yet unclassified'
isSequenceable = (
	^true
)'copying'
concatenate: other <List[X]>  ^<MutableList[EX | X]> = (
	"{where EX is returnType of #anElement message of receiverType;
			where X is returnType of #anElement message of arg 1}"

	"Return a new MutableList holding the elements of self followed by the elements of other.  This
	  is the generalized equivalent of the string #, operation.  It should be used instead of #, for non-strings;
	  it is more general because other can contain any kind of element"

	| safeself <List[EX]> |

	"The following guarantee is safe because the inference clause ensures that E < EX
		at the call site"
	safeself:: "guaranteed <List[EX]>" self.

	^safeself copyReplaceFrom: size + 1 to: size with: other
)
copyFrom: start <Integer> to: stop <Integer>   ^<MutableList[EX]> = (
	"{where EX is returnType of #anElement message of receiverType}"

	"The guarantee is typesafe since the inference clause guarantees that E < EX at the call site"
	| cp <MutableList[EX]> safeme <List[EX]> |
	safeme:: "guaranteed <List[EX]>" self.
	cp:: "guaranteed <MutableList[EX]>" 
				newCopyOfSize: (stop - start) + 1 thatCanAlsoHoldElementsOf: safeme.
	cp replaceFrom: 1 to: cp size with: safeme startingAt: start.
	^cp
)
copyReplaceAll: oldSub <List[Object]> with: newSub <List[X]>  ^<MutableList[EX | X]> = (
	"{where EX is returnType of #anElement message of receiverType;
			where X is returnType of #anElement message of arg 2}"

	|	spots <List[Integer]>
		subDelta <Integer>
		copy <MutableList[EX | X]>
		current <Integer>
		offset <Integer>
		newSubSize <Integer>
		oldSubSize <Integer>
		safeself <List[EX]>
		|
	newSubSize:: newSub size.
	oldSubSize:: oldSub size.
	subDelta:: newSub size - oldSubSize.
	spots:: indicesOfSubCollection: oldSub.

	"This guarantee is typesafe since the inference clause guarantees that E < EX at the call site"
	safeself:: "guaranteed <List[EX]>" self.

	spots size = 0 
		ifTrue: [	copy::  safeself newCopyOfSize: size
								thatCanAlsoHoldElementsOf: newSub.
						copy replaceFrom: 1 to: size with: safeself.
						^copy
						].

	copy:: safeself newCopyOfSize: size + (spots size * subDelta)
				thatCanAlsoHoldElementsOf: newSub.
	current:: 1.
	offset:: 0.
	spots do: 
		[ :spot <Int> |	| offspot <Int> |
			offspot:: spot + offset.

			"copy segment of self before the next occurrence"
			copy	replaceFrom: current + offset
					to: offspot - 1
					with: safeself
					startingAt: current.
			"copy the new subcollection at the next occurrence"
			copy	replaceFrom: offspot
					to: (offspot + newSubSize) - 1
					with: newSub.
			current:: spot + oldSubSize.
			offset:: offset + subDelta.	].
	"copy the final segment from self after the last occurrence"
	copy	replaceFrom: current + offset
			to: copy size
			with: safeself
			startingAt: current.
	^copy
)
copyReplaceFrom: start <Integer> to: stop <Integer> with: other <List[X]>  ^<MutableList[EX | X]> = (
	"{where EX is returnType of #anElement message of receiverType;
			where X is returnType of #anElement message of arg 3}"

	|	copy <MutableList[EX | X]>
		sizeChange <Integer>
		sz <Integer>
		afterNew <Integer>
		safeself <List[EX]> |

	"The guarantee is typesafe since the inference clause guarantees that E < EX at the call site"
	safeself:: "guaranteed <List[EX]>" self.

	sizeChange:: other size - ((stop - start) + 1).
	sz:: size.
	copy:: safeself newCopyOfSize: sz + sizeChange
				thatCanAlsoHoldElementsOf: other.
	afterNew:: start + other size.
	copy replaceFrom: 1 to: start - 1 with: safeself startingAt: 1.
	copy replaceFrom: start to: afterNew - 1 with: other.
	copy replaceFrom: afterNew to: copy size with: ("guaranteed <List[EX]>" self) startingAt: stop + 1.
	^copy	
)
copyWith: el <X>  ^<MutableList[EX | X]> = (
	"{where EX is returnType of #anElement message of receiverType;
			where X is arg 1}"

	| safeself <List[EX]> |

	"The following guarantee is safe because the inference clause ensures that E < EX
		at the call site"
	safeself:: "guaranteed <List[EX]>" self.

	^safeself concatenate: (Array"[X]" with: el)	
)
copyWithSize: s <Integer> ^<MutableList[EX]> = (
	"{where EX is returnType of #anElement message of receiverType}"
	
	"return a mutable copy of the receiver of a different size, that is either truncated
		or extended with nils as necessary.  Note this works even if the receiver itself
		is not mutable"

	"%note: the inference clause above is a tricky way of doing something very difficult:
	  it allows us to effectively return a mutable copy of the receiver in a typesafe way,
	  even though the
	  receiver itself may not be mutable.  This would be impossible to type reasonably
	  without the inference clause, because we would have to have a return type of
	  <MutableList[E]>, which isn't typesafe since  E is a 'covariant' generic variable of this
	  class, whereas E is an 'unrelated' generic variable in MutableList. - D.G."
	  
	"%note: The inference clause above should really read ... EX <E> ..., but the type
		system implementation for some reason can't deal with implementations
		of such a method in subclasses that have bound E (i.e. are not generic on E).
		For an example, see the implementation in ReadString, which would not have to
		have a guarantee in the method body if this worked right - D.G."

	subclassResponsibility	
)
copyWithout: el <Object>  ^<MutableList[EX]> = (
	"{where EX is returnType of #anElement message of receiverType}"

	| safeself <List[EX]> |

	"The following guarantee is safe because the inference clause ensures that E < EX
		at the call site"
	safeself:: "guaranteed <List[EX]>" self. 

	^safeself copyReplaceAll: (Array"[Object]" with: el) with: {} 	
)
reverse   ^<MutableList[EX]> = (
	"{where EX is returnType of #anElement message of receiverType}"

	"The guarantees are typesafe since the inference clause guarantees that E < EX at the call site"
	| copy <MutableList[EX]> |
	copy:: "guaranteed <MutableList[EX]>"
		(newCopyOfSize: size thatCanAlsoHoldElementsOf: self).
	1 to: size do: 
		[ :i <Integer> |
			| el <EX> |
			el:: ("guaranteed <MutableList[EX]>" self) at: i.
			copy at: size + 1 - i put: el.	].
	^copy	
)'iterating'
collect: map <[E, ^R def]> ^<List[R]> = (
	^collectUsingAtPut: map
)
do: f <[E]> = (

	1 to: size do:
		[ :i <Integer> |
			f value: (at: i)	]
)
keysAndValuesDo: f <[Integer,E]> = (

	1 to: size do:
		[ :i <Integer> |
			f value: i value: (at: i)	]
)
reverseDo: f <[E]> = (

	size to: 1 by: -1 do:
		[ :i <Integer> |
			f value: (at: i)	]
)
with: other <List[X def]> do: f <[E,X]> = (

	assert: [ size = other size ] message: 'Cannot jointly interate collections of different size'.
	1 to: size do:
		[ :i <Integer> |
			f value: (at: i) value: (other at: i)	].
)'private'
collectUsingAtPut: map <[E, ^R def]> ^<List[R]> = (


	| c <MutableList[R]> |
	"See #newForCollect: for explanation of why the guarantee is safe"
	c:: "guaranteed <MutableList[R]> ("newForCollectUsingAtPut: size")".
	1 to: self size do:
		[ :i <Integer> |
			c at: i put: (map value: (at: i))  ].
	^c
)
hashAt: index <Integer> ^<Integer> = (
	^(at: index) hash
)
newForCollectUsingAtPut: size <Integer> ^<MutableList[Object]> = (
	"Return a new extensible collection that is as closely related to the receiver's class as possible.  The
	 returned collection must be unaliased and empty, so it is safe for the caller to guarantee that the type
	 variable is of a more specific type"

	^Array"[Object]" new: size
)'restricted'
newCopyOfSize: size <Integer>
thatCanAlsoHoldElementsOf: other <List[X]>
^<MutableList[EX | X]> 
= (
		"{where X is returnType of #anElement message of arg 2;
		     where EX is returnType of #anElement message of receiverType}"

	"Return a fresh collection of a closely related type
	that can hold both elements of self and elements of the other collection"

	^Array"[EX | X]" new: size
	
)'streaming'
readStream ^<ReadStream[E]> = (
	^ListReadStream"[E]" on: self
)'testing'
= other <Object> ^<Boolean> = (

	^self == other
		or: [ class = other class
				and: [ "We have the same class, so we can guarantee other is a List"
					  hasSameElementsAndOrderAs: ("guaranteed <List[Object]>" other)   ]]
)
hasSameElementsAndOrderAs: other <List[Object]>  ^<Boolean> = (

	"Like #hasSameElementsAs:, but also requires the elements to be in the same order"

	size = other size
		ifFalse: [ ^false ].  
	1 to: size do:
		[ :i <Integer> |
			(at: i) = (other at: i)
				ifFalse: [ ^false ]	].
	^true
)
includesIndex: index <Integer> ^<Boolean> = (
	^index between: 1 and: size
)
isSortedBy: compare <[E,E,^Boolean]> ^<Boolean> = (

	"Returns true if the receiver is in sorted order, using the specified comparison"

	| last <E> |
	size < 2
		ifTrue: [ ^true ].
	last:: at: 1.
	2 to: size do:
		[ :i <Integer> |
			(compare value: last value: (at: i))
				ifFalse: [ ^false ]	].
	^true
)'utility'
binarySearchFor: el <EL>
between: start <Integer>
and: end <Integer>
toCompare: compare <[EL def,EL,^Boolean]>
^<Int>
= (
			"{where CONSTRAINER <EL> is returnType of #anElement message of receiverType}"
	"This does a binary search for the index such that if el was inserted before it
	  the receiver would remain sorted.  The receiver must be sorted relative to the
	  comparison block.  The comparison block should return true if the first block argument
	  cannot appear after the second block argument"

	| low <Integer> high <Integer> |
	low:: start.
	high:: end.
	[ low <= high ]
		whileTrue:
				[	| mid <Integer> |
					mid:: (low + high)  // 2.
	  				"The guaranteed below is safe because of the inference clause"
					(compare value: ("guaranteed <EL>" (at: mid)) value: el)
						ifTrue: [ low:: mid + 1 ]	
						ifFalse: [ high:: mid - 1 ].
				].
	^low
	
)
binarySearchFor: el <EL>
toCompare: compare <[EL def,EL,^Boolean]>
^ <Integer>
= (
	"{where CONSTRAINER <EL> is returnType of #anElement message of receiverType}"

	"The guarantee is safe because of the inference clause"
	^("guaranteed <List[EL]>" self)
			binarySearchFor: el
			between: 1
			and: size
			toCompare: compare	
)'virtual'
virtualCollect: blk <[E, ^X def]> ^<VirtualCollector[X]> = (
	^ListVirtualCollector"[X]" on: self map: blk
)
virtualSelectorClass  ^<ListVirtualSelector[E] class> = (
	^ListVirtualSelector"[E]"
)) : ()
class ListVirtualCollector = List (| cltn map  |)
('as yet unclassified'
at: i <Int > ^ <T> = (
    ^map value: (cltn at: i)
)
at: i <Int > ifAbsent: blk  <[^V def]>  ^ <T|V> = (
    ^map value: (cltn at: i ifAbsent: blk)
)
cltnSpecies = (
	^cltn cltnSpecies
)
do: blk <[T,^Object] > ^ <Self> = (
    cltn do: [ :e <X>  | blk value: (map value: e) ]
)
on: c <List[X] >map: b <[X def,^T] > ^ <Self> = (
    cltn:: c.
    map:: b.
)
size ^ <Int> = (
    ^cltn size
)) : ('as yet unclassified'
on: c <List[X] >map: b <[X def,^T] > ^ <Instance> = (
    ^super new on: c map: b
))
class ListVirtualSelector = List (| cltn filter  |)
('as yet unclassified'
at: i <Int > ^ <T> = (
	^at: i ifAbsent: [error: 'Index out of bounds'].
)
at: i <Int > ifAbsent: blk <[^V]>  ^ <T> = (

    	| j <Int>  |

	j:: 0.
	cltn do:[: e <T>  |  (self filter value: e) ifTrue:[j:: j+1]. j = i ifTrue:[^e]].
	^blk value

)
cltnSpecies = (
	^cltn cltnSpecies
)
do: blk <[T,^Object] > ^ <Self> = (
    cltn do: [ :e <X>  | (filter value: e) ifTrue:[ blk value: e] ]
)
on: c <Collection[T] >filter: b <[T,^Boolean] > ^ <Self> = (
    cltn:: c.
    filter:: b.
)
size ^ <Int> = (
    ^cltn size
)) : ('as yet unclassified'
on: c <Collection[T] >filter: b <[X,^Boolean] > ^ <Instance> = (
    ^super new on: c filter: b
))
class MapMerge = MutableHashedMap (| map1 map2  |)
('as yet unclassified'
associationsDo: blk <[T,^Object] > ^ <Self> = (
	map1 associationsDo: blk.
	map2 associationsDo: blk.
)
at: key <K > ^ <V> = (
	^at: key ifAbsent: [error: 'Key is missing']
)
at: key <K >ifAbsent: b <[^V] > ^ <V> = (
	"This is not elegant but avoids excessive stack usage"
	| val absent |
	absent:: false.
	val:: map1 at: key ifAbsent: [absent:: true].
	^absent
		ifTrue: [map2 at: key ifAbsent: b]
		ifFalse: [val]
)
do: blk <[V,^Xdef] > ^ <Self> = (
	map1 do: blk.
	map2 do: blk.
)
includesKey: key = (
	^(map1 includesKey: key) or:[map2 includesKey: key].
)
keys ^ <Set> = (
    ^map1 keys addAll: map2 keys; yourself
)
map1: m1 <Map[K,V] >map2: m2 <Map[K,V] > ^ <Self> = (
	map1:: m1.
	map2:: m2
)
size ^ <Int> = (
    ^map1 size + map2 size
)
values ^ <Bag> = (
    ^map1 values addAll: map2 values; yourself
)'virtual operations'
virtualSelectorClass ^ <Self> = (
    ^VirtualMapSelector
)) : ()
class MapOverride = MapMerge ()
('as yet unclassified'
associationsDo: blk <[T,^Object] > ^ <Self> = (

	map1 associationsDo: blk.
	map2 associationsDo: [ :a <Assoc[Symbol, Object]>  |
		(map1 includesKey: a key) ifFalse: [blk value: a]
	]

)
do: blk <[T,^Object] > ^ <Self> = (

	map1 do: blk.
	map2 associationsDo: [ :a <Assoc[Symbol, Object]>  |
		(map1 includesKey: a key) ifFalse: [blk value: a value]
	]

)) : ()
class MutableArrayList = MutableAddableList (
"MutableArrayLists are AddableLists that also support setting
elements in place (the MutableList protocol).")
('accessing'
add: e <E> ^<E> = (
	^addLast: e
)
add: el <E> after: existing <E> ^<E> = (

	| index <Int> |
	index:: indexOf: existing.
	index = size
		ifFalse: [ index:: makeSpace: 1
							beforeIndex: index + startGap + 1 ]
		ifTrue: [ needSpaceAtEnd: 1.
						index:: index + startGap + 1.	].
	^contents at: index put: el.
)
add: el <E> afterIndex: i <Int> ^<E> = (
	^add: el beforeIndex: i + 1
)
add: el <E> before: existing <E> ^<E> = (

	| index <Int> |
	index:: indexOf: existing.
	index:: makeSpace: 1 beforeIndex: index + startGap.
	^contents at: index put: el.
)
add: el <E> beforeIndex: i <Int> ^<E> = (

	| index <Int> |
	i > size
		ifFalse: [	index:: makeSpace: 1 beforeIndex: i + startGap.	]
		ifTrue: [	needSpaceAtEnd: 1.
					index:: i + startGap. ].
	^contents at: index put: el.
)
addAllFirst: c <Collection[E]> ^<Collection[E]> = (
	c do: [ :el <E> | 	addFirst: el ].
	^c
)
addAllLast: c <Collection[E]> ^<Collection[E]> = (
	c do: [ :el <E> | 	addLast: el ].
	^c
)
addFirst: e <E> ^<E> = (

	needSpaceAtStart: 1.
	contents at: startGap put: e.
	startGap: startGap - 1.
	^e
)
addLast: e <E> ^<E> = (

	needSpaceAtEnd: 1.
	lastIndex: lastIndex + 1.
	contents at: lastIndex put: e.
	^e
)
at: i <Int> put: el <E> ^<E> = (

	| adjusted <Int> |
	adjusted:: i + startGap.
	((0 < i) and: [adjusted <= lastIndex])
		ifFalse: [ error: 'invalid index' ].
	^contents at: adjusted put: el

)
with: el <E>  = (
	add: el
)
withAll: els <Collection[E]> ^<Self> = (
	addAll: els
)'converting'
asMutableArrayList ^<MutableArrayList[EX]>  = (
		"{where EX is returnType of #anElement message of receiverType}"

	"the guarantee is safe because of the inference clause"
	^"guaranteed <MutableArrayList[EX]>" self
)'copying'
copyWithSize: s <Int> ^<MutableArrayList[EX]> = ( 
	"{where EX is returnType of #anElement message of receiverType}"

	"Note: this method temporarily mutates the receiver, so it should not be sent to an object that
		another process might be accessing."

	"We use a trick here: we temporarily fudge the lastIndex to be the value we want to use in the copy,
	  which will cause postCopy to copy the contents with a different size, and then we restore the old
	  lastIndex value for this instance.  This lets the normal copy mechanism handle subclass instance
	  variable copying."
	| oldLastIndex <Int> safeself <MutableArrayList[EX]> copy <MutableArrayList[EX]> |

	"This guarantee is safe because the inference clause guarantees
		that E < EX at each call site"
	safeself:: "guaranteed <MutableArrayList[EX]>" self.

	oldLastIndex:: lastIndex.
	lastIndex: s + startGap.
	copy:: safeself copy.
	lastIndex: oldLastIndex.

	^copy
)'iterating'
collect: map <[E, ^R def]> ^<MutableArrayList[R]> = (
	^(collectUsingAdd: map) asMutableArrayList
)'replacing'
replaceFrom: start <Int>
to: stop <Int>
with: other <List[E]>
startingAt: repStart <Int>
 = (

	"replace the elements of the receiver from start to stop with elements from other,
	  starting with the element of other with index repStart."

	| otheri <Int> |
	(start >= 1 and: [ stop <= size ])
		ifFalse: [ error: 'range out of bounds' ].

	contents replaceFrom: start + startGap to: stop + startGap with: other startingAt: repStart
)'restricted'
newCopyOfSize: size <Int>
thatCanAlsoHoldElementsOf: other <List[X]>
^<MutableArrayList[EX | X]>
 = (
		"{where X is returnType of #anElement message of arg 2;
		     where EX is returnType of #anElement message of receiverType}"

	^(MutableArrayList"[EX | X]" new: size) size: size
)'stack operations'
bottomToTopDo: blk <[E]> = (
	do: blk
)
pop ^<E> = (
	^removeLast
)
push: el <E> = (
	addLast: el
)
top ^<E> = (
	^last
)
topToBottomDo: blk <[E]> = (
	reverseDo: blk
)) : ('constants'
defaultCapacity ^<Int> = (
	^5
)'instance creation'
new: capacity <Int> ^<Instance> = (
	^new initCapacity: capacity
)
newWithSize: s <Int> ^<Instance> = (

	"create a new instance of size s with all elements undefined (nil).
		This must be used very carefully, since each element should
		be set using at:put: before accessing it; failure to do this can
		lead to hard-to-debug crashes"
	^new initCapacity: s; size: s
)
with: val1 <E> ^<Instance> = (
	^(new: 1) add: val1; yourself
)
withAll: cltn <Collection[E]> ^<Instance> = (
	^(new: cltn size) addAll: cltn; yourself
))
class MutableHashedMap new: cap = HashedCollection new: cap (
"MutableHashMaps are efficient HashedCollections that let you dynamically associate key->value
pairs,  where the keys are matched using the #= message.  Equal keys must have equal #hash
values.")
('accessing'
keys ^<Set[K]> = (

	| s <Set[K]> |

	s:: Set new: size.
	keysDo:
		[ :key <K> |
			s include: key ].
	^s
)
values ^<MutableArrayList[E]> = (

	^inject: (MutableArrayList new: size) into:
		[ :oc <MutableArrayList[E]>  :el <E> |
			oc add: el; yourself  ]
)'adding'
at: key <K> put: el <E> ^<E> = (
	^at: key put: el ifNew: []
)
at: key <K> put: el <E> ifNew: blk <[]> ^<E> = (
	tableAt: key put: el ifNew: blk.
	^el
)'as yet unclassified'
isDictionary = (
	^true
)'associations'
addAssociation: assoc <Assoc[K,E]> ^<Assoc[K,E]> = (
	"we don't use the incoming association, for safety"
	^self include: (Association key: assoc key value: assoc value)
)
associationAt: key <K> ^<Assoc[K,E]> = (
	^associationAt: key ifAbsent: [ error: 'key not found' ]
)
associationAt: key <K> ifAbsent: failBlock <[^X def]> ^<Assoc[K,E] | X> = (
	^valAt: key ifAbsent: failBlock
)
associations ^<MutableArrayList[Assoc[K,E]]> = (
	| oc <MutableArrayList[Assoc[K,E]]> |

	oc:: MutableArrayList new: size.
	associationsDo:
		[ :assoc <Assoc[K,E]> |
			oc add: assoc	].
	^oc
)
associationsDo: f <[Assoc[K,E]]>
 = (
	contentsDo:
		[ :assoc <Assoc[K,E]> |
			f value: assoc ]
)
includesAssociation: assoc <Assoc[K,Object]>  ^<Boolean> = (
	^(at: assoc key ifAbsent: [ ^false ]) = assoc value
)
removeAssociation: assoc <Assoc[K,E]> ^<Assoc[K,E]> = (
	^removeAssociation: assoc ifAbsent: [ error: 'Association not found' ].
)
removeAssociation: assoc <Assoc[K,E]> ifAbsent: fn <[^X def]>  ^<Assoc[K,E] | X> = (
	removeKey: assoc key ifAbsent: [ ^fn value ].
	^assoc
)'combined getting/putting'
at: key <K> ifPresent: pblk <[E]> ifAbsentPut: ablk <[^E]> ^<E> = (

	"This is a method that is useful in the common case when you want
		to find out if a key is present, and if it isn't, put an entry in for it.
		It is much faster than a construct like (hc at: k ifAbsent: [ hc at: k put: e ])
		for the case when a new entry must be added.
		If the key is present, pblk is evaluated with the associated element.
		If it is absent, then ablk is evaluated, and the value that it returns
		is associated with k in the receiver.  In either case, the associated element
		is returned."

	| reusableSlot <Int> |
	table == nil
		ifTrue: [	createFirstTable.	 ].
	^lookup: key
				matchingSlotDo:
						[ :index <Int> :assoc <VarAssoc[K,E]> |
							| el <E> |
							el:: assoc value.
							pblk value: el.
							el		]
				emptySlotDo:
						[ :index <Int> |
							| newEl <E> |
							newEl:: ablk value.
							reusableSlot == nil
								ifTrue: [ tableAt: key put: newEl inEmptySlot: index ]
								ifFalse: [ tableAt: key put: newEl inDeletedSlot: reusableSlot ].
							newEl	]
				deletedSlotsDo:
						[ :index <Int> |
							reusableSlot == nil
								ifTrue: [ reusableSlot:: index ].
						]
)'iterating'
keysAndValuesDo: f <[K,E]>
 = (
	contentsDo:
		[ :assoc <Assoc[K,E]> |
		   f value: assoc key value: assoc value ]
)'private'
tableAt: key <K>
put: el <E>
inMatchingSlot: index <Int>
value: val <VarAssoc[K,E]>
^<VarAssoc[K,E]> = (

	val value: el.
	^val
)'private-superclass implementation'
buildValForKey: k <K> element: el <E> ^<VarAssoc[K,E]> = (
	^Association key: k value: el
)
elementFor: assoc <Assoc[K,E]> ^<E> = (
	^assoc value
)
elementForCopy: el <VarAssoc[K,E]> ^<VarAssoc[K,E]> = (
	^el copy
)
hashFor: key <Object> ^<Int> = (
	^key hash
)
key: k <Object> matches: another <Object> ^<Boolean> = (
	^k = another
)
keyFor: assoc <Assoc[K,E]> ^<K> = (
	^assoc key
)
objToIncludeFor: newAssoc <VarAssoc[K,E]>
withExisting: assoc <VarAssoc[K,E]>
^<VarAssoc[K,E]> = (

	"MutableHashMaps reuse the previous association"
	assoc value: newAssoc value.
	^assoc
)'testing'
= other <Object> ^<Boolean> = (
	^super = other and: [
		self == other or: [
			"We already know that the other object must be a MutableHashedMap"
			self keys = other keys	]]
)'virtual operations'
merge: map <MutableHashedMap[K,E]> ^ <MutableHashedMapMerge> = (
	^MutableHashedMapMerge new map1: self map2: map
)
override: map <MutableHashedMap[K,E]> ^ <MutableHashedMapOverride> = (
	^MutableHashedMapOverride new map1: self map2: map
)
virtualCollect: blk <[E, ^X def]> ^<VirtualCollector[X]> = (
	^ VirtualMapCollector on: self map: blk
)
virtualSelectorClass^ <VirtualMapSelector[K,E] class> = (
	^VirtualMapSelector
)) : ('constants'
defaultCapacity ^<Int> = (
	^0
)'instance creation'
new = (
	^new: defaultCapacity
)
with: val1 <A> ^<Instance> = (
	^(new: 1) include: val1; yourself
)
withAll: cltn <Collection[A]> ^<Instance> = (
	^(new: cltn size) includeAll: cltn; yourself
))
class MutableList = List (
"This class extends List[E] with mutation operations defined in terms of #at:put:. 
The List[E] protocol is defined from this class' interface.")
('accessing'
at: index <Int> put: el <E> ^<E> = (
	self subclassResponsibility
)
atAll: indices <Collection[Int]> put: val <E> = (

	indices do:
		[ :i <Int> |
			at: i put: val		].
)
atAllPut: val <E> = (

	1 to: size do:
		[ :i <Int> |
			at: i put: val		].
)'private'
defaultMedianOf: a <Int> and: b <Int> and: c <Int> ^<Int> = (


	"This is an untypesafe method that only works for MutableLists of elements that
		have Magnitude relationships with each other.  It is used by the default sorting
		method."

	| atA <E> atB <E> atC <E> |
	atA:: at: a.
	atB:: at: b.
	atC:: at: c.
	^ atB <= atA
		ifFalse: [ atC <= atB
							ifFalse:[ b ]
							ifTrue: [	 atC <= atA
												ifFalse: [ c ]
												ifTrue: [ a ] 	] ]
		ifTrue: [ atB <= atC
							ifFalse:[ b ]
							ifTrue: [	 atA <= atC
												ifFalse: [ c ]
												ifTrue: [ a ] 	] ]

)
medianOf: a <Int> and: b <Int> and: c <Int> using: compare <[E,E,^Boolean]> ^<Int> = (


	| atA <E> atB <E> atC <E> |
	atA:: at: a.
	atB:: at: b.
	atC:: at: c.
	^(compare value: atB value: atA)
		ifFalse: [	(compare value: atC value: atB)
							ifFalse:[ b ]
							ifTrue: [	(compare value: atC value: atA)
												ifFalse: [ c ]
												ifTrue: [ a ] 	] ]
		ifTrue: [	(compare value: atB value: atC)
							ifFalse:[ b ]
							ifTrue: [	(compare value: atA value: atC)
												ifFalse: [ c ]
												ifTrue: [ a ] 	] ]

)
swap: i <Int> with: j <Int>
 = (
	| t <E> |
	t:: at: i.
	at: i put: (at: j).
	at: j put: t.
)
swap: i1 <Int> with: i2 <Int> count: n <Int>
 = (

	| c <Int> |
	c:: 0.
	[ c < n ]
		whileTrue: 
			[	swap: i1 + c with: i2 + c.
				c:: c + 1.		]
)'replacing'
replaceFrom: start <Int>
to: stop <Int>
with: other <List[E]>
 = (

	"replace the elements of the receiver from start to stop with elements from other,
	  starting with the first element of other."

	^replaceFrom: start to: stop with: other startingAt: 1
)
replaceFrom: start <Int>
to: stop <Int>
with: other <List[E]>
startingAt: repStart <Int>
 = (

	"replace the elements of the receiver from start to stop with elements from other,
	  starting with the element of other with index repStart."

	| otheri <Int> |

	repStart < start
		ifFalse: [ otheri:: repStart.
				  start to: stop do:
					[ :i <Int> |
						at: i put: (other at: otheri).
						otheri:: otheri + 1.	]]
		ifTrue: [ otheri:: repStart + (stop - start).
				stop to: start by: -1 do:
					[ :i <Int> |
						at: i put: (other at: otheri).
						otheri:: otheri - 1.	]]
)'streaming'
readWriteStream ^<ReadWriteStream[E]> = (
    ^ListReadWriteStream"[E]" on: self
)
writeStream ^<WriteStream[E]> = (
    ^readWriteStream
)'utility'
defaultSort: l <Int> to: r <Int>
 = (
	"This is an untypesafe method that only works for MutableLists of elements that
		have Magnitude relationships with each other"

	| i <Int> j <Int> x <E> m <Int> n <Int> |
	i:: l.
	j:: r.
	n:: ((r - l) + 1).
	n == 0
		ifTrue: [ ^self ].

	"Pick the partition value.  For <=7 elements, use the middle element.
		For more than 7 but <= 40, use a median of three elements.  For > 40,
		use a median of three medians of three"
	m:: (l + r) // 2.
	n > 7
		ifTrue: [	| pl <Int> pn <Int> s <Int> |
						pl:: l.
						pn:: r.
						n > 40
							ifTrue: [	s::  n // 8.
											pl:: defaultMedianOf: pl and: pl+s and: pl+s+s.
											m:: defaultMedianOf: m-s and: m and: m+s.
											pn:: defaultMedianOf: (pn-s)-s and: pn-s and: pn.	].
						m:: defaultMedianOf: pl and: m and: pn.		].
	x:: at: m.

	[i <= j]
		whileTrue: 
			[	| ati <E> atj <E> |
			 	[ x <= (ati:: at: i)]
					whileFalse: [i:: i + 1].
				[(atj:: at: j) <=  x]
					whileFalse: [j:: j - 1].
				i <= j
					ifTrue: [	at: i put: atj.
									at: j put: ati.
									i:: i + 1.
									j:: j - 1.	]
			].
	l < j ifTrue: [defaultSort: l to: j ].
	i < r ifTrue: [defaultSort: i to: r ].
)
sort: l <Int> to: r <Int> using: compare <[E,E,^Boolean]>
 = (

	| i <Int> j <Int> x <E> m <Int> n <Int> |
	i:: l.
	j:: r.
	n:: ((r - l) + 1).
	n == 0
		ifTrue: [ ^self ].

	"Pick the partition value.  For <=7 elements, use the middle element.
		For more than 7 but <= 40, use a median of three elements.  For > 40,
		use a median of three medians of three"
	m:: (l + r) // 2.
	n > 7
		ifTrue: [	| pl <Int> pn <Int> s <Int> |
						pl:: l.
						pn:: r.
						n > 40
							ifTrue: [	s::  n // 8.
											pl:: medianOf: pl and: pl+s and: pl+s+s using: compare.
											m:: medianOf: m-s and: m and: m+s using: compare.
											pn:: medianOf: (pn-s)-s and: pn-s and: pn using: compare.	].
						m:: medianOf: pl and: m and: pn using: compare.		].
	x:: at: m.

	[i <= j]
		whileTrue: 
			[	| ati <E> atj <E> |
			 	[compare value: x value: (ati:: at: i)]
					whileFalse: [i:: i + 1].
				[compare value: (atj:: at: j) value: x]
					whileFalse: [j:: j - 1].
				i <= j
					ifTrue: [	at: i put: atj.
									at: j put: ati.
									i:: i + 1.
									j:: j - 1.	]
			].
	l < j ifTrue: [self sort: l to: j using: compare].
	i < r ifTrue: [self sort: i to: r using: compare].
)
sortUsing: compare <[E,E,^Boolean]>
 = (
	"Sort the elements of the collection using the specified comparison test, which must return true if
	  its first argument should not appear after its second argument (e.g. <=).   This is handy when you
	  want to sort an existing collection, rather than create a new SortedList, or if you need to
	  perform a number of changes without sorting, and then resort explicitly.  Note that this does NOT
	  cause the receiver to stay sorted after later changes, unlike a SortedList."

	sort: 1 to: size using: compare
)) : ()
class Queue = IOSequence (
"The Queue class of collections. ."|
	private head <DoubleLink[E]>
	private tail <DoubleLink[E]>
	private actualSize <Int> ::= 0.
|)
(
class DoubleLink = (|
	prev <DoubleLink[T]>
	value <T>
	next <DoubleLink[T]>
|)
() : ()'accessing'
at: index <Int> ^<E> = (
	^havePeeked
		ifFalse: [ (linkAt: index) value ]
		ifTrue: [ index = 1
						ifFalse: [ (linkAt: index - 1) value ]
						ifTrue: [ peekVal ]
					]
)
at: index <Int> put: el <E>  ^<E> = (
	havePeeked
		ifFalse: [ (linkAt: index) value: el ]
		ifTrue: [ index = 1
						ifFalse: [ (linkAt: index - 1) value: el ]
						ifTrue: [ peekVal: el ]
					].
	^el
)
nextPut: el <E> ^<E> = (
	| l <DoubleLink[E]> |
	l:: DoubleLink"[E]" new value: el.
	tail isNil
		ifFalse: [	tail next: l.
						l prev: tail.	]
		ifTrue: [ head: l ].
	tail: l.
	actualSize: actualSize + 1.
	^el
)
size ^<Int> = (
	^havePeeked
		ifFalse: [ actualSize ]
		ifTrue: [ actualSize + 1 ]
)'as yet unclassified'
assert: value = (
	
)'consistency checking'
checkValidity
 = (

	| c <Int> l <DoubleLink[E]> peekCount <Int> |
	peekCount:: havePeeked ifTrue: [ 1 ] ifFalse: [ 0 ].
	l:: head.
	l isNil
		ifTrue: [ assert: ( size = peekCount and: [ tail isNil ] ).
						^self ].
	assert: ( l prev isNil ).

	c:: 1.
	[ l next isNil ]
		whileFalse: [	| next <DoubleLink[E]> |
								next:: l next.
								assert: ( next prev == l ).
								l:: next.
								c:: c + 1 ].
	assert: (tail == l).
	assert: ( (c + peekCount) = size ).
)'copying'
copyWithSize: s <Int> ^<MutableList[EX]> = (
	"{where EX is returnType of #anElement message of receiverType}"

	"The guarantee is safe because of the inference clause"
	^(Array"[EX]" new: s) replaceFrom: 1 to: (size min: s) with: ("guaranteed <List[EX]>" self)	
)'private'
actualAtEnd ^<Boolean> = (
	^head isNil
)
actualNext ^<E> = (

	| l <DoubleLink[E]> |
	l:: head.
	head: l next.
	head isNil
		ifTrue: [ tail: head ].
	actualSize: actualSize - 1.
	^l value
)
linkAt: index <Int> ^<DoubleLink[E]> = (

	| i <Int> next <DoubleLink[E]> |
	i:: 1.
	next:: head.
	[ i < index ]
		whileTrue: [ next:: next next.
								i:: i + 1. ].
	^next
)
linkHolding: el <E> ^<DoubleLink[E]> = (

	"return the link holding el.  Note that an element can be in the peek buffer as well as in 
		a link, so this can't be done for all queue elements"

	| next <DoubleLink[E]> |
	next:: head.
	[ next value = el ]
		whileFalse: [ next:: next next ].
	^next
)
removeLink: l <DoubleLink[E]>
 = (
	"remove the link holding el.  Note that an element can be in the peek buffer as well as in 
		a link, so this can't be done for all queue elements"

	l == head
		ifTrue: [ head: l next ]
		ifFalse: [ l prev next: l next ].
	l == tail
		ifTrue: [ tail: l prev ]
		ifFalse: [ l next prev: l prev ].
	actualSize: actualSize - 1.
)'removing'
remove: el <E> ^<E> = (
	(havePeeked and: [ peekVal = el ])
		ifTrue: [	next.	]
		ifFalse: [ removeLink: (linkHolding: el) ].
	^el
)) : ()
class Set new: cap = HashedCollection new: cap ()
('converting'
asSet ^<Extensible[EX]> = (
		"{where EX is returnType of #anElement message of receiverType}"

	"The guarantee is safe because of the inference clause"
	^"guaranteed <Set[EX]>" self
)'private'
newForCollect: sz <Integer> ^<Extensible[Object]> = (
	^Set"[Object]" new: sz
)'restricted- table decoding'
buildValForKey:  key <Object> element: el <E> ^<E> = (
	^el
)
elementFor: el <E> ^<E> = (
	^el
)
elementForCopy: el <E> ^<E> = (
	^el
)
hashFor: key <Object> ^<Int> = (
	^key hash
)
key: k <Object> matches: another <Object> ^<Boolean> = (
	^k = another
)
keyFor: e <E> ^<Object> = (
	^e
)
objToIncludeFor: new <E> withExisting: other <E> ^<E> = (
	^new
)'testing'
hasSameElementsAs: other <Collection[Object]>  ^<Boolean> = (
	"A faster reimplementation of the inherited version, to speed up set comparisons"

	| otherSet <Extensible[Object]> |
	size = other size
		ifFalse: [ ^false ].
	otherSet:: other asSet.
	size = otherSet size
		ifFalse: [ ^false ].
	do:
		[ :el <Object> |
			(otherSet includes: el)
				ifFalse: [ ^false ]  ].
	^true
)
includes: o <Object> ^<Boolean> = (
	^includesKey: o
)) : ('as yet unclassified'
defaultCapacity = (

	^ 0
)
new = (
	^new: defaultCapacity
)
with: val1 <A> ^<Instance> = (
	^(new: 1) include: val1; yourself
)
withAll: cltn <Collection[A]> ^<Instance> = (
	^(new: cltn size) includeAll: cltn; yourself
))
class SortedList = AddableList (
	"Sorted collections are addable collections that always keep their elements in sorted order.  The
	sort order is determined by the sortPredicate, which is a function that compares 2 elements and
	returns true if the first argument should be before the second argument in the collection.
	The sortPredicate should be provided when the collection is created.

	Unfortunately, Smalltalk defines SortedList as having a default sortPredicate that uses #<= to compare
	elements.  This is NOT typesafe, since there are many kinds of objects that you might want to sort that don't support
	the #<= operator; however, this feature is retained in Strongtalk for compatibility.   If you wish to write typesafe programs,
	then SortedLists should always be given a sort block when they are created.  This involves using the creation
	messages #new:sortBlock:, #sortBlock: and the Collection utility message #asSortedList: instead of #new:, #new,
	and #asSortedList, respectively."|
	private usesDefaultSortBlock_private <Boolean>
	private sortBlock_private <[E,E,^Boolean]>
|initCapacity: self class defaultCapacity. 
	sortBlock_private:: SortedList defaultSortBlock.
	usesDefaultSortBlock_private:: true)
('accessing'
add: el <E> ^<E> = (


	| index <Int> |
	index::indexFor: el.
	index > contents size
		ifFalse: [ index:: makeSpace: 1 beforeIndex: index. ]
		ifTrue: [	needSpaceAtEnd: 1.
						lastIndex: lastIndex + 1. ].
	^contents at: index put: el.
)
addAll: els <Collection[E]> ^<Collection[E]> = (


	els size > (size // 8) 		 "%todo: do measurements to see if 8 is reasonable"
		ifTrue: [ 	needSpaceAtEnd: els size.
				els do: [ :el <E> |
					lastIndex: lastIndex + 1.
					contents at: lastIndex put: el.	].
				sort.		]
		ifFalse: [ els do: [ :el <E> |
					add: el	]].
	^els
)
sortBlock ^<[E,E,^Boolean]> = (

	^sortBlock_private
)
sortBlock: sortBy <[E,E,^Boolean]>
 = (

	sortBlock_private:: sortBy.
	usesDefaultSortBlock_private:: false.
	isEmpty
		ifFalse: [ sort. ].
)
usesDefaultSortBlock ^<Boolean> = (
	^usesDefaultSortBlock_private
)'converting'
asSortedList ^<List[Object]> = (
	^self
)'initialization'
initCapacity: cap <Int> = (
	super initCapacity: cap.
)'private'
indexFor: el <E> ^<Integer> = (

	"This returns an internal index such that if el was inserted before it
	  the collection would remain sorted"

	^contents
		binarySearchFor: el
		between: startGap + 1
		and: lastIndex
		toCompare: sortBlock
)
sort = (
	usesDefaultSortBlock
		ifTrue: [	contents defaultSort: startGap + 1 to: lastIndex ]
		ifFalse: [ 	contents sort: startGap + 1 to: lastIndex using: sortBlock ]
)'testing'
isSorted ^<Boolean> = (

	"testing function used for sort routine validation"

	^isSortedBy: sortBlock
)) : ('as yet unclassified'
defaultCapacity ^<Int> = (
	^5
)
defaultSortBlock ^<[E,E,^Boolean]> = (


	^[ :el1 <E> :el2 <E> |
		"The default sort block for SortedLists is is not typesafe, but is included for
		 Smalltalk compatibility (that's the way Smalltalk is!)."
		("guaranteed <Magnitude[E]>" el1) <= el2	].
)
new: capacity <Int>
sortBlock: sort <[E,E,^Boolean]>
^<Instance> = (

	^(new: capacity) sortBlock: sort
)
new: capacity <Int> ^<Instance> = (
	^new initCapacity: capacity
)
sortBlock: sort <[E,E,^Boolean]> ^<Instance> = (
	^new: defaultCapacity sortBlock: sort
)
with: val1 <E> ^<Instance> = (
	^(new: 1) add: val1; yourself
)
withAll: cltn <Collection[E]> ^<Instance> = (
	^(new: cltn size) addAll: cltn; yourself
))
class VirtualCollector = Collection (| 
	cltn <Collection[Object]> 
	map <[DoesNotMatter, ^T]> 
|)
('as yet unclassified'
cltnSpecies = (
	^cltn cltnSpecies
)
do: blk <[T,^Object] > ^ <Self> = (
    cltn do: [ :e <X>  | blk value: (map value: e) ]
)
on: c <Collection[X] >map: b <[X def,^T] > ^ <Self> = (
    cltn:: c.
    map:: b.
)
size ^ <Int> = (
    ^cltn size
)) : ('as yet unclassified'
on: c <Collection[X] >map: b <[X def,^T] > ^ <Instance> = (
    ^super new on: c map: b
))
class VirtualMapCollector = VirtualCollector ()
('as yet unclassified'
associationsDo: blk <[T,^Object] > ^ <Self> = (
	cltn associationsDo: [ :a | blk value: (Association key: a key value: (map value: a value)) ]
)
at: key <K > ^ <V> = (
	^at: key ifAbsent:[error: 'Element ', key printString, ' not found'].
)
at: key <K >ifAbsent: blk <[^V] > ^ <V> = (
	| e <V>  |
	e:: cltn at: key ifAbsent:[^blk value].
	^(map value: e).
)
includesIndex: index <Object> = (
	^cltn includesIndex: index.
)
includesKey: key <Object> = (
	^cltn includesKey: key.
)
keys ^ <Set[K]> = (
	^cltn keys
)
merge: map <Map[K,V] > ^ <Map[K,V]> = (
    ^MutableHashedMapMerge  new map1: self map2: map
)
override: map <Map[K,V] > ^ <Map[K,V]> = (
    ^MutableHashedMapOverride  new map1: self map2: map
)
values ^ <Set[K]> = (
    ^cltn values virtualCollect: self map
)'virtual operations'
virtualCollect: blk <[E, ^X def]> ^<VirtualCollector[X]> = (
	^ VirtualMapCollector on: self map: blk
)
virtualSelectorClass ^ <VirtualMapSelector[K,V] class> = (
    ^VirtualMapSelector
)) : ()
class VirtualMapSelector = VirtualSelector ()
('as yet unclassified'
associationsDo: blk <[T,^Object] > ^ <Self> = (
	| val |
	cltn associationsDo: [ :a | (filter value: (val:: a value)) ifTrue: [blk value: (Association key: a key value: val)] ]
)
at: key <K > ^ <V> = (
	^at: key ifAbsent:[error: 'Element ', key printString, ' not found'].
)
at: key <K >ifAbsent: blk <[^V] > ^ <V> = (
	| e <V>  |
	e:: cltn at: key ifAbsent:[^blk value].
	^(filter value: e) ifTrue:[e]
                                ifFalse:[blk value].
)
includesIndex: index <Object> = (
	^includesKey: index.
)
includesKey: key <Object> = (
	^(cltn includesKey: key) and: [filter value: (cltn at: key)].
)
keys ^ <Set[K]> = (
    ^cltn keys select:[:k <Key> | filter value: (cltn at: k) ]
)
merge: m <Map[K,V] > ^ <Map[K,V]> = (
    ^MutableHashedMapMerge new map1: self map2: m
)
override: m <Map[K,V] > ^ <Map[K,V]> = (
    ^MutableHashedMapOverride new map1: self map2: m
)
values ^ <Set[V]> = (
    ^cltn values virtualSelect: self filter
)'virtual operations'
virtualCollect: blk <[E, ^X def]> ^<VirtualCollector[X]> = (
	^ VirtualMapCollector on: self map: blk
)
virtualSelectorClass ^ <Self> = (
    ^VirtualMapSelector
)) : ()
class VirtualSelector = Collection (|
	cltn filter
|)
('as yet unclassified'
cltnSpecies = (
	^cltn cltnSpecies
)
do: blk <[T,^Object] > ^ <Self> = (
    cltn do: [ :e <X>  | (filter value: e) ifTrue:[ blk value: e] ]
)
on: c <Collection[T] >filter: b <[T,^Boolean] > ^ <Self> = (
    cltn:: c.
    filter:: b.
)
size ^ <Int> = (
    ^cltn size
)) : ('as yet unclassified'
on: c <Collection[T] >filter: b <[X,^Boolean] > ^ <Instance> = (
    ^super new on: c filter: b
))'as yet unclassified'
error: msg <String> = (
	^Error signal: msg
)) : ()