Newspeak3
'NS2JS'
class Newspeak2JavascriptCompilation usingPlatform: platform 
                                           newspeakParser: ns2Parser <Newspeak2Parsing>
							javascriptGeneration: jsGeneration <JavascriptGeneration>
                                           mirrorLib: mirrors = (
"This is a cross-compilation module for compiling  Newspeak to Javascript. It includes a Newspeak-to-Javascript cross compiler (Compiler) as well as a number of other classes used in compilation. For a  detailed overview of compilation see Compiler.

The current compilation scheme ignores issues of access control and/or security. It also ignores issues of reflective modification. It is just enough to get
going for simple, non-reflective code.

At runtime, a Newspeak (NS) object O is represented as a Javascript (JS) object J with slots corresponding directly to the Newspeak slots. The prototype of J is a runtime-class JRC: a JS object whose slots correspond to the instance methods of O's class NC, including any necessary synthetic methods. The prototype of JRC is likewise a run-time class object corresponding to the superclass of NC. The chain continues up to NewspeakObject (after that it is slightly problematic).

JRC includes  synthetic slots that refer to its mixin and its enclosng object chain. JRC's mixin, JM, is a JS object corresponding to the Newspeak mixin of NC, NM.

The compiler does not produce instances like JS, or even classes like JRC, though it must be aware of their representation to an extent. Rather, the compiler produces mixins like JM.

Each Newspeak class declaration is compiled into a JS object representing a mixin such as JM. JM will include a set of instance methods,  including synthetic methods. Almost all of these methods are shared with JRC. Unlike in the Smalltalk implementations, the slot accessors can be defined in the mixin and shared with the run time class as well. 

If the class is not a metaclass, then JM will include two additional synthetic methods: createSlots() and instanceInitializer().

createSlots adds the slots defined by NM to ''this'' and sets them to NewspeakUndefinedObject.  JRC will also have a createSlots() method, that will call the createSlots() method of its runtime superclass, and then call the one defined by its mixin JM. After calling createSlots(), the object will be similar to a fresh Smalltalk object after calling basicNew - it has all slots, but they are initialized to nil (Newspeak's nil, not JS null or undefined).

Likewise, JRC will have its own instanceInitializer(), which also calls the superclass version folowed by the mixin version. JM's instanceInitializer corresponds to the code in the instance initializer defined in the NS source.

The compiler is only concerned with creating the mixin versions of these methods. The runtime class versions are created at runtime by the mixin application operation that is part of the NSJS runtime.

If the class is a metaclass, JM is a meta-mixin. All of JRC's instances will be factory objects - that is, they represent Newspeak base level classes.  It follows that each such factory object will have JRC as its prototype.  Since the superclass of each metaclass is Class in Newspeak, the prototype of JRC will necessarily be NewspeakClass, as provided by the NSJS runtime.

JM's instance methods will in fact be the class methods of NC. 

JM will also have the primary factory, whose general form is:

function (a1 ... aN){
	return this.basicNew().instanceInitializer(a1 ... aN);
}

The arity of the instance initializer will vary from one mixin to another, as will the name of the slot in which the primaryFactory is stored. The basicNew() method will be inherited from NewspeakClass. It allocates a fresh instance of the appropriate class and calls createSlots() on it, thereby emulating the behavior of basicNew in Smalltalk. The result is an object with all required slots set to nil, as discussed above. We then run its instance initializer - this is very close to what we do in the Smalltalk based implementations.

Each factory object has a runtimeClass slot, pointing to the corresponding runtime class JRC.   The basicNew() method uses this in order to create instances with the correct prototype. JRC has a slot named factory pointing back at the factory object. The default implementation of the class method in NewspeakObject accesses this slot.

In summary, JM  has the form (obsolete)

{enclosingMixin:  ... , 
metadata: {name: MixinName, factoryName:, userSlotNames: ,  nestedMixins: },
// the methods common to the mixin instance side
classMixin: , //  mixin of the class side
MixinName: this, // a way of capturing the mixin for other pieces
apply: function(S, SC){...} 
// takes a superclass and a superclass constructor function
}

* should we make this even closer to the existing Smalltalk based implementations, with a metadata field that includes the nested and enclosing mixins?

The representation of a class is an object of the form

{
metadata: {name: ''ClassName'' , ...} ,
enclosingObject: ... ,
methodDict: ..., // the per class method dictionary
basicNew: function(S){...},
// A generator function. This function fullfills the role of basicNew, and 
// closely corresponds to the formal semantics.  It is redundant in principle. 
// but very useful in practice. It is very handy for actually creating 
// instances and for subclassing.

mixin: ... , // the mixin of the class
superclass: ..., // its superclass
factory: ..., // the class object
superConstructor: ... 
// a function that calls the superclass constructor; takes the same args as
// the mixin's factory, and calls superclass' primary, converting args per
// source code
}

The apply() function takes such an object and returns another.
It also takes a super class constructor function. This is a peculiarity of
the Newspeak semantics, but is necessary to specify how the mixin
passes factory parameters for the superclass part of the object it creates.

The above is very close to the way the existing Newspeak compilers
structure things.

Now we turn to the compilation of class members.

Nested classes follow the scheme above, recursively.
Slots are mapped by the front end into instance variables, locals and
parameters. Instance variables are discussed above. Their initializers
go in the instance initializer method. Locals and parameters map
directly to JS.

Methods are compiled into JS methods. We
prefix all method names with #, to ensure that they never conflict with ordinary javascript code (such as synthetic methods we create, or inherited/global JS stuff). Method bodies include assignment statements.
expression statements and return statements.

Each method we compile includes a nested function NLR that returns
from the outer function. This can be optimized if there are no NLRs.
(How does this work? We create a new exception on entry, and wrap everything in a handler for it. NLR() simply slams its argument into such an exception
and throws it.)

The front end already identifies assignments to locals, which are
compiled as JS assignments.

As for expressions - we only have sends and literals.

All sends should be wrapped with code to emulate the correct doesNotUnderstand: semantics. That is, test if the method exists in the receiver by accessing the slot containing it; if the result is undefined, call doesNotUnderstand:, otherwise, apply it.

Ordinary sends compile directly. Self sends compile to this sends.
Implicit receiver sends are compiled as*

getImplicitReceiver(this, 'messageName'). messageName(args);

and outer sends as*

getOuterReceiver(this, 'outerClassName').messageName(args)

* This may change; we intend to use arrays of outer objects per class, as in the Strongtalk implementation. The downside is that it isn't clear how to implement reflective modifications without access to the both Newspeak source and the compiler.

This leaves us with literals:

As a first approximation, we may choose to compile literals as
themselves if they are numbers, booleans, strings/characters. We
compile symbols as calls to some interning function.

Blocks are compiled as lambdas, with special attention to returns. The
front end already makes note of NLRs. These are compiled as calls to
NLR(). The last statement of a block is compiled as a return; this is easy, as the front end already recognizes this situation and rewrites it into a special local return AST node.

Return statements otherwise compile directly to JS.

Given a class

class MixinName factory: x = (
      |
      slot1
      roSlot2 = e2.
      mutableSlot3 = e3.
      |
      initExpr.
)(

	class NestedClass1 = ...

	'cat1'
	method1: a1 = (....)
	* x = (...)
): (

   classMethod1: a1 = (...)
)


We would compile it as (using //e// to denote the compilation of e)

{
enclosingMixin: undefinedObject,
metadata: {
	name: ''MixinName'', // can be extended to document all member names 
	NestedClass1: {
	    	enclosingMixin: mixinName,
		metadata: {name: ''NestedClass1'',
					NestedClass1: this,
					....
					}
	    },		
MixinName: this,
''#method1'': .... ,
 ''#*'': ... ,
// synthetic methods are already here 
basicNew: function(){
	this.slot1 = NewspeakUndefinedObject;
	this.roSlot2 = NewspeakUndefinedObject;
	this.mutableSlot3 = NewspeakUndefinedObject;
	},
instanceInitializer: function() {
	roSlot2 = // e2 //;
	mutableSlot3 = // e3 //;
	// initExpr //;
	},
classSide:{
	    ''#classMethod1'': ... ,
	    // factory will be here necessarily
	},



apply: function(superKlass, superclassConstructor) {

	var mDict = methodDict.clone(); // build class method dictionary

	generator: function(s) {
	  	 superKlass.basicNew(s);
	  	 s[''slot1''] = undefinedObject; // not undefined, but an object
	  	 s[''roSlot2''] = undefinedObject; 
	  	 s[''mutableSlot3''] = undefinedObject;
		 s[... synthetic slots] ...
	  	 return s;
	  };
// One could build the generator using generic code based on meta-info,
// but this would only slow down mixin application. One could even do without
// the generator and build the objects based on this info - but this gets
// called on every object creation.

	var classObject = {basicNew: generator}; 

	var metaclass = {}; // the metaclass object is per class.  The metaclass object will inherit all code from shared code in the mixin.
// the factory method creates a blank object with all required slots using
// basicNew.
// it then initializes it per Newspeak source. 

	metaclass.prototype = classSide; // add shared class side behavior
	classObject.prototype = metaclass; // tie class object to metaclass

	mDict.prototype = superKlass.methodDictionary; 
	// tie in superclass instance side behavior


	return {
	       name: MixinName name ++ ''|>'' ++ superKlass.name,
	       methodDictionary: mDict,
	       basicNew: generator,
	       mixin: MixinName,
	       superclass: superKlass,
	       factory: classObject,
	       enclosingObject: undefinedObject, // to be set externally
	       superConstructor: superclassConstructor
	} // package class representation

       }
}

Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"|

      astModule = ns2Parser ASTModule.
	Collection = platform collections Collection.
	Dictionary = platform collections Dictionary.
	IdentityDictionary = platform collections IdentityDictionary.
	OrderedCollection = platform collections OrderedCollection.
	SortedList = platform collections SortedList.
	Set = platform collections Set.
	ReadStream = platform streams CharacterReadStream.
	WriteStream = platform streams CharacterReadWriteStream.
	"Class = platform Kernel Class.	" "temporarily disabled until we get the class story right on the JS side"
	Error = platform exceptions Error.
	MutableString = platform kernel MutableString.
	
	Parser = ns2Parser Parser.
	parsedLanguage = ns2Parser language.
	
	javascriptGeneration = jsGeneration.
	JavascriptWriter = jsGeneration Writer.
	IdentifierRewriter = jsGeneration IdentifierRewriter.
	ReturnedExpressionExtractor = jsGeneration ReturnedExpressionExtractor.
	js = jsGeneration factory.

	ASTTool = astModule ASTTool.
      ASTCopier = astModule ASTCopier.
      SuperFalseVisitor = astModule FalseVisitor.
      AST = astModule AST.
	AssignmentAST = astModule AssignmentAST.
	BlockAST = astModule BlockAST.
	CascadedSendAST = astModule CascadedSendAST.
	CodeBodyAST = astModule CodeBodyAST.
	MessageAST = astModule MessageAST.
      MessagePatternAST = astModule MessagePatternAST.
	MethodAST = astModule MethodAST.
	NormalSendAST = astModule NormalSendAST.
	NumberAST = astModule NumberAST.
	ReturnStatAST = astModule ReturnStatAST.
      SendAST = astModule SendAST.
	SymbolAST = astModule SymbolAST.
	TupleAST = astModule TupleAST.
      VarDeclAST = astModule VarDeclAST.
	VariableAST = astModule VariableAST.

	"{Newspeak-core-mirror}"  "a bunch of mirror stuff"
	
	LowLevelMirror = mirrors LowLevelMirror.
	LowLevelMixinMirror = mirrors LowLevelMixinMirror.
	InstanceVariableMirror = mirrors InstanceVariableMirror.
	
	"Module variables"
	parser = Parser new.
	getterPool = Array new: 256.
      setterPool = Array new: 256.
	protected StringAST = astModule StringAST.
	
	protected sendAritySpecialCaseLimit = 10.

	"Generate message sends as direct property invocations instead of sendMessage*() calls. Collect all selectors sent in methods of classes being compiled. Derive all objects in the world from a single prototypical object that binds all known selectors to a function sending DNU to the receiver."
	protected useDnuCatcher ::= false.
	"Generate message sends as direct property invocations instead of sendMessage*() calls. Derive all objects in the world from a single prototypical object that binds the '__noSuchMethod__' property to a function sending DNU to the receiver. Cheaper and smaller than useDnuCatcher since no call information is collected, but will only work for Rhino."
	protected useNoSuchMethod ::= false.
	
	jsNodeMap = IdentityDictionary new.
|)
(
class CodeInterval start: s <Integer> end: e <Integer> = (|
	start = s.
	end = e.
	reference <CodeInterval>
|)
() : ()
class CompiledMixinMirror language: l header: h mirror: llm <LowLevelMixinMirror> = (
"Represents a compiled (but uninstalled) NS3 class declaration."|
	language <Language> = l.
	header <String> = h.
	lowLevelMirror <LowLevelMixinMirror> = llm.
	factoryName
	commentString
	slots
|)
('as yet unclassified'
category ^ <String> = (
	^lowLevelMirror category
)
category: c <String>  = (
	lowLevelMirror category: c
)
comment ^ <String> = (
	commentString ifNil:[^''].
	^commentString

)
comment: c <String> = (
	commentString: c
)
isMeta = (

	^ lowLevelMirror isMeta
)
methods = (

	^ lowLevelMirror methods
)
name ^ <String> = (
	^lowLevelMirror name
)) : ()
class Compiler2 = (
"A work-in-progress Compiler reimplementation, with Javascript AST as the output. This makes automated testing easier and provides control over formatting (for example, placing every expression on its own line to allow for precise breakpoint placement in substandard JS debugger implementations)."|
	scopeMap = Dictionary new.
	scope
	scopeStack = OrderedCollection new.
	literalTable
	input
	sentSelectors

	rewriter = Rewriter new.	
	translator = DebuggableTranslator new.
	"translator = Translator new."
	currentDepth
	currentMixinUID
	jsTree
	"jsWriter = JavascriptWriter new."
	jsWriter = DebuggableJavascriptWriter new.
	supportDoesNotUnderstand ::= true.
	inlineOperators ::= false.
|)
(
class DebuggableTranslator = Translator (
"Describe the class in this comment.")
('as yet unclassified'
assignmentNode: node <AST> ^ <Node> = (
	^associateJsNode: (super assignmentNode: node) with: node
)
associateJsNode: jsNode with: nsNode <AST>  = (
	jsNodeMap at: jsNode put: nsNode.
	^ jsNode.
)
blockLocalReturnNode: node <BlockLocalReturnAST> ^ <Node> = (
	^associateJsNode: (super blockLocalReturnNode: node) with: node
)
blockNode: node <BlockAST> ^ <Node> = (
	^associateJsNode: (super blockNode: node) with: node
)
boolNode: node <BoolAST> ^ <Node> = (
	^associateJsNode: (super boolNode: node) with: node
)
cascadedSendNode: node <CascadedSendAST> ^ <Node> = (
	^associateJsNode: (super cascadedSendNode: node) with: node
)
charNode: node <CharAST> ^ <Node> = (
	^associateJsNode: (super charNode: node) with: node
)
codeBodyNode: node <CodeBodyAST> ^ <Node> = (
	^associateJsNode: (super codeBodyNode: node) with: node
)
explicitOuterReceiverASTNode: node <ExplicitOuterReceiverAST> ^ <Node> = (
	^associateJsNode: (super explicitOuterReceiverASTNode: node) with: node
)
ifNode: node <IfAST> ^ <Node> = (
	^associateJsNode: (super ifNode: node) with: node
)
implicitSendNode: node <ImplicitRcvrSendAST> ^ <Node> = (
	^associateJsNode: (super implicitSendNode: node) with: node
)
messageNode: node <MessageAST> ^ <Node> = (
	^associateJsNode: (super messageNode: node) with: node
)
messagePatternNode: node <MessagePatternAST> ^ <Node> = (
	^associateJsNode: (super messagePatternNode: node) with: node
)
methodNode: node <MethodAST> ^ <Node> = (
	^associateJsNode: (super methodNode: node) with: node
)
nilNode: node <AST> ^ <Node> = (
	^associateJsNode: (super nilNode: node) with: node
)
normalSendNode: node <NormalSendAST> ^ <Node> = (
	^associateJsNode: (super normalSendNode: node) with: node
)
numberNode: node <NumberAST> ^ <Node> = (
	^associateJsNode: (super numberNode: node) with: node
)
parameterDeclNode: node <VarDeclAST> ^ <Node> = (
	^associateJsNode: (super parameterDeclNode: node) with: node
)
parameterNode: node <ParameterAST> ^ <Node> = (
	^associateJsNode: (super parameterNode: node) with: node
)
propertyCallNode: node <PropertyCallAST> ^ <Node> = (
	^associateJsNode: (super propertyCallNode: node) with: node
)
receiverNode: node <ReceiverAST> ^ <Node> = (
	^associateJsNode: (super receiverNode: node) with: node
)
returnStatNode: node <ReturnStatAST> ^ <Node> = (
	^associateJsNode: (super returnStatNode: node) with: node
)
stringNode: node <StringAST> ^ <Node> = (
	^associateJsNode: (super stringNode: node) with: node
)
superSendNode: node <SuperSendAST> ^ <Node> = (
	^associateJsNode: (super superSendNode: node) with: node
)
symbolNode: node <SymbolAST> ^ <Node> = (
	^associateJsNode: (super symbolNode: node) with: node
)
temporaryDeclNode: node <ParameterAST> ^ <Node> = (
	^associateJsNode: (super temporaryDeclNode: node) with: node
)
varDeclNode: node <VarDeclAST> ^ <Node> = (
	^associateJsNode: (super varDeclNode: node) with: node
)
variableNode: node <VariableAST> ^ <Node> = (
	^associateJsNode: (super variableNode: node) with: node
)) : ()
class Rewriter = ASTTool (
"A visitor that rewrites the AST into a form more suitable for compilation to Javascript. It may be possible to combine the pass that constructs the scopes with the rewriting pass, but this may be messy once we start inlining blocks etc."| 
	scope <Scope> 
	scopeStack <OrderedCollection[Scope]> = OrderedCollection new.
	protected readMap <Map[TemporaryAST, Integer]> = Dictionary new.
	protected writeMap <Map[TemporaryVariableAST, {Integer. Integer}]> = Dictionary new.
	protected valueExpected <Boolean> = true. "A flag set by visitor methods to indicate whether the parent AST uses the value of the currently visited node or not."
	protected areReturnsLocal <Boolean> = true. "Set to true while visiting nodes contained within a method and its inlined blocks, false in non-inlined blocks."
	protected rewritingMethodBody <Boolean> = true. "Set to true prior to visiting the code body of a method, to false prior to visiting one of a block."
	protected conditionalSelectors = Set withAll: {#ifTrue:ifFalse:. #ifFalse:ifTrue:. #ifTrue:. #ifFalse:}.
	protected inlinableOperators <Dictionary[String, String]> = Dictionary new.
	protected inlinableNumericOperators <Dictionary[String, String]> = Dictionary new.
|inlinableOperators
		at: #+ put: '+';
		at: #- put: '-';
		at: #* put: '*';
		at: #/ put: '/';
		at: #'==' put: '==='.
	inlinableNumericOperators	
		at: #'<' put: '<';
		at: #'<=' put: '<=';
		at: #'>' put: '>';
		at: #'>=' put: '>=')
(
class BlockLocalReturnAST expression: x start: s end: e = AST (
"This class represents a 'local return' (LR) -  a return from a block to its caller, as opposed to the caller of its enclosing method (a 'non-local return' or NLR).

An actual return statement in a block means an NLR; an LR is implicit in the source language, and occurs on the last statement of the block, unless that statement is a true return (NLR).  However, the back end of the compiler requires that this information be represented explicitly. This node does that."|
 expr <ExpressionAST> = x.
|start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool>  = (
	^aTool blockLocalReturnNode: self
)
isBlockLocalReturnAST ^<Boolean> = (
	^true
)) : ()
class BoolAST withValue: aBool <Boolean> start: s end: e = VariableAST (
""| val = aBool. |start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool boolNode: self
)
name = (
	^val printString asSymbol
)) : ()
class BoolVisitor = FalseVisitor ()
('as yet unclassified'
boolNode: node = (^true)) : ()
class ContextAST = VariableAST (
"Represents uses of thisContext. I expect these to be restricted in future versions. Currently, we use it for outer sends and super sends")
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool contextNode: self
)
name = (
	^#thisContext
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(thisContext)'
)) : ()
class ContextVisitor = FalseVisitor ()
('as yet unclassified'
contextNode: node = (^true)) : ()
class ExplicitReceiverVisitor = FalseVisitor ()
('as yet unclassified'
explicitOuterReceiverNode: aNode <ExplicitOuterRcvrAST> ^ <Boolean> = (
	^true
)) : ()
class ExplicitRecvrAST send: sym <Symbol> depth: d <Integer> = AST (
"Represents the receiver of an explicit outer send."|
	outerClassName <Symbol> = sym.
	depth <Integer> = d.
	selector <Symbol>
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool explicitOuterReceiverNode: self
)
isExplicitRcvrNode ^ <Boolean> = (
	^true
)
isExpressionNode ^ <Boolean> = (
	^true
)) : ()
class FalseVisitor = SuperFalseVisitor (
"Extends the standard FalseVisitor with methods for dealing with the node types introduced by the rewriter..")
('as yet unclassified'
boolNode: node = (^false)
contextNode: node = (^false)
ifNode: aNode <IfAST> ^ <Boolean> = (
	^false
)
implicitSendNode: aNode <ImplicitRcvrSendAST> ^ <Boolean> = (
	^false
)
loopNode: aNode <LoopAST> ^ <Boolean> = (
	^false
)
nilNode: node = (^false)
parameterNode: aNode <ParameterAST> ^ <Boolean> = (
	^false
)
receiverNode: aNode <ReceiverAST> ^ <Boolean> = (
	^false
)
returnInstVarMethodNode: aNode <ReturnInstVarMethodAST> ^ <Boolean> = (
	^false
)
returnSelfMethodNode: aNode <ReturnSelfMethodAST> ^ <Boolean> = (
	^false
)
superSendNode: aNode <SuperSendAST> ^ <Boolean> = (
	^false
)
superVarNode: aNode <SuperVarAST> ^ <Boolean> = (
	^false
)
temporaryNode: aNode <TemporaryVariableAST> ^ <Boolean> = (
	^false
)
variableNode: aNode = (
	^false
)) : ()
class ImplicitRecvrSendAST send: aMsg <MessageAST> depth: d <integer> = SendAST send: aMsg (
"
Represent a send of a message with an implicit receiver (aka a here send).
"| depth <Integer> ::= d. |)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool implicitSendNode: self
)
isExpressionNode ^ <boolean> = (
	^true
)
recv ^ <VarDeclAST> = (
  ^ assert:[false] message: 'There is no receiver node. It is implicit'
)) : ()
class ImplicitRecvrVisitor = FalseVisitor ()
('as yet unclassified'
implicitSendNode: aNode <ImplicitRcvrSendAST> ^ <Boolean> = (
	^true
)) : ()
class InlinableAsExpressionConditionalAST = NormalSendAST (
"Produced by the rewriter for the conditional messages whose value is required and which can be compiled into a Javascript ternary operator."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinableAsExpressionConditionalNode: self
)) : ()
class InlinableConditionalAST = NormalSendAST (
"Produced by the rewriter for conditional messages (ifTrue: and the like) that can be compiled into Javascript if statements instead of real message sends. To qualify, the message arguments should be literal blocks and the value of the message send should be ignored (for example, '^x ifTrue: [foo]' is not inlinable, while 'x ifTrue: [^foo]' is)."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinableConditionalNode: self
)) : ()
class InlinedOperatorAST = NormalSendAST (
"When the inlineOperators mode is on, message sends with certain selectors are replaced with this node. Javascript code generated for those nodes uses native Javascript operators instead of real message sends. The selector of the message of this AST is not a real Newspeak selector but rather the Javascript operator such as &&."|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinedOperatorNode: self
)) : ()
class InstVarVisitor = FalseVisitor ()
('node traversal'
instVarNode: node = (^true)) : ()
class NilAST = VariableAST (
"")
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool nilNode: self
)
name = (
	^#nil
)) : ()
class NilVisitor = FalseVisitor ()
('as yet unclassified'
nilNode: node = (^true)) : ()
class ParameterAST name: n type: t = VarDeclAST name: n type: t (
"")
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool parameterDeclNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(', name, ')'
)'as yet unclassified'
variableClass ^ <ParameterVariableAST class> = (
	^ParameterVariableAST
)) : ()
class ParameterVariableAST name: n start: s end: e = VariableAST (
""name: n. start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool parameterNode: self
)) : ()
class ReceiverAST = VariableAST (
"")
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool receiverNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(self)'
)'as yet unclassified'
name = (
	^#self
)) : ()
class ReceiverVisitor = FalseVisitor ()
('node traversal'
receiverNode: node = (^true)) : ()
class SuperSendAST send: aMsg <MessageAST> = SendAST send: aMsg (
"This code is currently unused.  
Unlike Smalltalk, super calls in Newspeak cannot be statically bound.
Hence, we cannot use the Squeak VM's  super send byte codes. Currently, super sends are rewritten into a complex call structure by the rewriter, to ensure the correct binding of super.

When the Newspeak VM is modified to support dynamic binding of super sends, we will probably use this node and allied code,  which can easily be processed by the byte code compiler and code generator.")
('Unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool superSendNode: self
)
recv ^ <SuperVarAST> = (
  ^SuperVarAST new
)'as yet unclassified'
isExpressionNode ^ <boolean> = (
	^true
)) : ()
class SuperSendVisitor = FalseVisitor ()
('node traversal'
superSendNode: node <SuperSendAST> = (
      ^true
   )) : ()
class SuperVarAST = VarDeclAST name: #super type: nil (
"")
('Unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool superVarNode: self
)) : ()
class TemporaryAST name: n type: t = VarDeclAST name: n type: t (
""| initializer |)
('Unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool temporaryDeclNode: self
)
printOn: strm <CharOutputStream>
 = (

	super printOn: strm.
	strm nextPutAll: '(', name, ')'
)'as yet unclassified'
isTemporaryAST ^ <Boolean> = (
	^true
)
variableClass ^ <TemporaryVariableAST class> = (
	^TemporaryVariableAST
)) : ()
class TemporaryVariableAST name: n start: s end: e = VariableAST (
"This node represents reference to a temporary variable."name: n.  start: s. end: e)
('as yet unclassified'
apply: aTool <ASTTool > ^ <Self> = (
	^aTool temporaryNode: self
)) : ()'as yet unclassified'
addLiteralConstant: s <Character | Number | String | Symbol> = ( 
	(literalTable includesKey: s) ifFalse: [literalTable at: s put: literalTable size].
)
addNumericLiteral: n <Number> = ( 
   addLiteralConstant: n
)
applyForEffectTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: false.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
applyForValueTo: node <Node> = (
	| original result |
	original:: valueExpected.
	valueExpected:: true.
	result:: node apply: self.
	valueExpected:: original.
	^result
)
assignmentFrom: aMsg <MessageAST> decl: vd <VarDeclAST> ^ <AssignmentNode> = (
	| var <VariableAST> varName <String> args selector <String> |
	assert: [aMsg args size = 1].
	selector:: aMsg sel asString.
	varName:: selector copyWithSize: (selector size -1).
	assert: [(currentScope at: varName asSymbol) isTemporaryAST].
	"what about setter methods - then we might have an inst var? this cannot happen, because this is only called when processing variables"
	var:: TemporaryVariableAST
		name: varName
		start: aMsg start
	 	end: aMsg end.

	args:: applyForValueTo: aMsg args first. "recurse on RHS"
	"this is where we note that a temporary is being written to; this information is necessary to determine which temporaries can be copied into closures and which have to be 'remote'"
	noteWriteOf: var.     
	"create an assignment"

	^AssignmentAST new 
		to: var assign: args;
		start: aMsg start;
		end: aMsg end                     
)
boolNode: node = (
	"Should not normally be invoked; only possible when rewriting an already rewritten tree."
	halt.
	^node
)
currentScope ^ <Scope> = (
	^scopeStack last
)
enclosingObjSendOfDepth: n <Integer> to: recv <AST> start: start <Integer> end: end <Integer>  ^ <NormalSendAST> = (
	^NormalSendAST new 
		recv: recv; 
		msg:(MessageAST new sel: (enclosingObjectMsgForDepth: n); args: {}; start: start; end: end);
		start: start; 
		end: end.
)
enclosingObjectMsgForDepth: n <Integer> ^ <String> = (
"Compute the selector necessary for obtaining the nth enclosing object wrt to the current lexical scope."
	| otable  <Dictionary[Symbol, Tuple[Class, Integer]]> ec <Class> |
	"What if n has no corresponding entry in the outer table? This should not happen, as this method is called on the basis of an n value found in the table to begin with."
	otable:: currentScope at: #outer.
	ec:: (otable values detect: [:some | (some at: 2) = (n-1)]) at: 1.
	^(Compiler new enclosingObjectMsgFor: ec) asSymbol
)
explicitOuterReceiverNode: node = (
	assert: [node apply: ExplicitReceiverVisitor new].
	^node
)
hereName = (
	^#'_here'
)
hereNode ^<AST> = (
	^VariableAST new name: hereName
)
inline: node as: sendClass selector: selector rewriteArgsAs: argRewriteBlock = (
	| receiver message |
	receiver:: applyForValueTo: node recv.
	message:: MessageAST new
		send: selector
		with: (node msg args collect: argRewriteBlock).
	^sendClass new
		to: receiver send: message;
		start: node start;
		end: node end
)
isHereNode: aNode <AST> ^ <Boolean> = (
	aNode isVariableNode ifFalse: [^false].
	(isPseudoVariableNode: aNode) ifTrue: [^false].
	assert: [aNode name = hereName].
	^true
)
isInlinableAsExpressionConditional: node <NormalSendAST> ^ <Boolean> = (
	(node msg sel = 'ifTrue:ifFalse:' and: [valueExpected]) ifFalse: [^false].
	node msg args do:
		[:each <AST> |
		((isRemovableBlock: each withArgs: 0)
			and: [each body statements size = 1
			and: [each body statements first isReturnStatNode not]])
				ifFalse: [^false]].
	^true
)
isInlinableBooleanOperator: node <NormalSendAST> = (
	| selector |
	selector:: node msg sel.
	^(selector = 'or:' or: [selector = 'and:'])
		and: [node msg args size = 1
		and: [node msg args first isBlockNode
		and: [node msg args first body statements size = 1]]]
)
isInlinableConditional: node <NormalSendAST> ^ <Boolean> = (
	((conditionalSelectors includes: node msg sel) and: [valueExpected not]) ifFalse: [^false].
	node msg args do: [:each <AST> | (isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
	^true
)
isInlinableNumericOperator: node <NormalSendAST> = (
	| args |
	args:: node msg args.
	args size = 1 ifFalse: [^false].
	(inlinableNumericOperators includesKey: node msg sel) ifFalse: [^false].
	(node recv isLiteralNode and: [node recv val isNumber]) ifTrue: [^true].
	(args first isLiteralNode and: [args first val isNumber]) ifTrue: [^true].
	^false
)
isInlinableOperator: node <NormalSendAST> = (
	^(inlinableOperators includesKey: node msg sel)
		and: [node msg args size = 1]
)
isInlineableLoop: node <NormalSendAST> ^ <Boolean>= (
	| selector <Symbol>  args |
	selector:: node msg sel.
	args:: node msg args.
	({#whileTrue. #whileFalse. #whileTrue:. #whileFalse:. #repeat} includes:  selector) ifTrue:
		[args do:
			[:each |
			(isRemovableBlock: each withArgs: 0) ifFalse: [^false]].
		^isRemovableBlock: node recv withArgs: 0].
	
	(selector = #timesRepeat:) ifTrue:[^isRemovableBlock: args last withArgs: 0].
	({#to:do:. #to:do:by:}  includes:  selector) ifFalse:[^false].
	(isRemovableBlock: args last withArgs: 1) ifFalse:[^false].
	(selector = #to:do:) ifTrue:[^true].
	args size = 3 ifFalse:[^false].
)
isOuterNode: aNode <AST> ^ <Boolean> = (
	aNode isVariableNode ifFalse: [^false].
	^aNode name = #outer
)
isPseudoVariableNode: aNode <VariableAST> ^ <Boolean> = (
	^aNode name = #self
		or: [aNode name = #super
		or: [aNode name = #outer
		or: [aNode name = #thisContext]]]
)
isSuperNode: aNode <VariableAST> ^ <Boolean> = (
	aNode isVariableNode ifFalse:[^false].
	^aNode name =  #super 
)
mixinApplication: node <MixinApplicationAST> = (
	| msg |
"For now, just compile it as a regular message send"
	msg:: MessageAST new
			send: #apply:
			with: (OrderedCollection with: node superclassExpr);
			start: node start;
			end: node end.

	^(NormalSendAST new
		to: node mixinExpr send: msg;
		start: node start;
		end: node end) apply: self
)
nilNode: node = (
	"Should not normally be invoked; only possible when rewriting an already rewritten tree."
	halt.
	^node
)
noteReadOf: t <TemporaryAST>  = (
	| lastRead <integer> |
"earliest read nested in a closure"
	lastRead:: readMap at: t ifAbsent: [readMap at: t put: currentScope end. ^self].
	"if t has not yet been read, record this read in the map and exit; otherwise, find out what the last recorded value was"
	readMap at: t put: (lastRead min: currentScope end)
	"record the minimum of the last recorded value and the end of the current block. If a read occurs in a nested block, that block will end before the enclosing block or method,  and the block's ending will be recorded"
)
noteWriteOf: t <TemporaryVariableAST>  = (
"Location of last write, and minimal block ending."
	| lastWrite <Integer> prevBlockEnd <Integer> |
	
	prevBlockEnd:: (writeMap at: t ifAbsent:[{0. 0}]) last.
	lastWrite:: Array new: 2.
	lastWrite at:1  put: t start. "record source start index of last write"
	lastWrite at: 2 put: (currentScope end min: prevBlockEnd). "record end of block of any nested write"
	writeMap at: t put: lastWrite.
)
oldProcessExplicitOuterSend: aMsg <MessageAST> atDepth: n = (


| holder <NormalSendAST>  ctxt <VariableAST> start <Integer> end <integer> 
enclosingObj <NormalSendAST>  nonMeta  <NormalSendAST> 
 |
"For n > 0, return
thisContext methodClass enclosingObject`Cn ... C0 
                                         class enclosingObject`Cn ...`C1  ...  
                                            class enclosingObject`Cn`Cn-1 msg

which is the equivalent of

outer X msg

where X is the nth lexically enclosing class. Otherwise, do a self send"

n = 0 ifTrue:[^selfSendFrom: aMsg].
start:: aMsg start.
end:: aMsg end.
ctxt:: VariableAST new name: #thisContext; start: start; end: end.

holder:: NormalSendAST new recv: ctxt;
                                             msg: (MessageAST new sel:#lexicalClass; args: {});
                                              start: start; end: end.

nonMeta:: NormalSendAST new recv: holder;
                                             msg: (MessageAST new sel:#theNonMetaClass; args: {});
                                              start: start; end: end.

enclosingObj::  enclosingObjSendOfDepth: 1 to: nonMeta start: start end: end. 

enclosingObj:: (2 to: n) inject: enclosingObj into:[:r <NormalSendAST> :i <Integer> | 
	| csend <NormalSendAST> |
	  csend::  NormalSendAST new recv: r; 
	                                               msg:(MessageAST new sel: #class; args: {}; start: start; end: end);
	                                               start: start; 
	                                               end: end.
	 enclosingObjSendOfDepth: i to: csend start: start end: end. 
	 ].
^(NormalSendAST new recv: enclosingObj; msg: aMsg; start: start; end: end) apply: self
)
parameterNode: node <ParameterVariableAST> = (
	^node
)
processExplicitOuterReceiver: aMsg <MessageAST> = (
	| selectorBinding <AST> depth <integer> |
	assert:[aMsg args isEmpty]. "this had better be a unary message"
	selectorBinding:: currentScope at: aMsg sel.
	"assert:[selectorBinding data  isClassDeclarationAST]."
	depth: currentDepth -  selectorBinding depth -1.
	addNumericLiteral: depth. "the backend checks that depth in 0 - 256"
	^(ExplicitRecvrAST send: aMsg sel depth: depth)
		start: aMsg start;
		end: aMsg end
)
processExplicitOuterSend: aMsg <MessageAST> = (
"Unused at the moment"
)
processHereSend: aMsg <MessageAST> = (
	| binding <AST> |
	binding:: currentScope at: aMsg sel ifAbsent: [MessageAST new].
	binding isMessagePatternNode ifTrue:
		["this is a message send for a lexically defined method"
		^processImplicitOuterSend: aMsg atDepth: binding depth].
	binding isVarDeclNode
		ifTrue: [^ processVariable: aMsg decl: binding].
	({#true. #false. #nil} includes: aMsg sel) ifTrue:
		[^processVariable: aMsg decl: nil].
	^selfSendFrom: aMsg
)
processImplicitOuterSend: aMsg <MessageAST> atDepth: n <Integer> ^ <SendNode> = (
	"In this case, we don't care about the depth; but when compiling to other platforms, we might, so we maintain the API"
	| selectorBinding <AST> depth <integer> |
	selectorBinding:: currentScope at: aMsg sel.
	"assert:[selectorBinding data  isClassDeclarationAST]."
	depth: currentDepth -  selectorBinding depth.
	addNumericLiteral: depth. "the backend checks that depth in 0 - 256"
	^(ImplicitRecvrSendAST send: (aMsg apply: self) depth: depth) start: aMsg start; end: aMsg end
)
processOuterSend: aMsg <MessageAST> = (
	| holder <NormalSendAST> depth <Integer> binding <AST>  meMsg <MessageAST> |
	assert: [aMsg args isEmpty]. "this had better be a unary message"
	binding:: (currentScope at: #outer) at: aMsg sel.
	"assert binding makes sense "
	assert: [binding isKindOf: Collection].
	"assert: [binding first isKindOf: Class]." "disabled temporarily until we get the class story straight on the JS side"
	assert: [binding last isKindOf: Integer].

	meMsg:: MessageAST new sel: #yourself; args: {}; start: aMsg start; end: aMsg end. "hack!"
	^processOuterSend: meMsg atDepth: binding last
)
processOuterSend: aMsg <MessageAST> atDepth: n = (
"For n > 0, return
thisContext methodClass enclosingObject`Cn ... C0 
                                         class enclosingObject`Cn ...`C1  ...  
                                            class enclosingObject`Cn`Cn-1 msg

which is the equivalent of

outer X msg

where X is the nth lexically enclosing class. Otherwise, do a self send"

	| holder <NormalSendAST> ctxt <VariableAST> start <Integer> end <integer> 
	enclosingObj <NormalSendAST> nonMeta <NormalSendAST>  |

	n = 0 ifTrue: [^selfSendFrom: aMsg].
	start:: aMsg start.
	end:: aMsg end.
	ctxt:: VariableAST new name: #thisContext; start: start; end: end.

	holder:: NormalSendAST new
		recv: ctxt;
	 	msg: (MessageAST new sel: #lexicalClass; args: {});
		start: start; end: end.
	nonMeta:: NormalSendAST new
		recv: holder;
		msg: (MessageAST new sel: #theNonMetaClass; args: {});
		start: start; end: end.
	enclosingObj:: enclosingObjSendOfDepth: 1 to: nonMeta start: start end: end. 

	enclosingObj:: (2 to: n) inject: enclosingObj into:
		[:r <NormalSendAST> :i <Integer> | 
		| csend <NormalSendAST> |
		csend:: NormalSendAST new
			recv: r; 
			msg: (MessageAST new sel: #class; args: {}; start: start; end: end);
			start: start; 
			end: end.
		enclosingObjSendOfDepth: i to: csend start: start end: end].
	^(NormalSendAST new recv: enclosingObj; msg: aMsg; start: start; end: end) apply: self
)
processVariable: aMsg <MessageAST> decl: vd <VarDeclAST>  ^ <AssignmentNode | VariableNode> = (
	^aMsg sel last = $:
		ifTrue: "it is a temporary write"
			[assignmentFrom: aMsg decl: vd]
		ifFalse: "it is a parameter or temporary read"
			[variableFrom: aMsg decl: vd]
)
propertyCallNode: node <PropertyCallAST> ^ <PropertyCallAST> = (
	| args |
	assert: [node isMessageNode].
	args:: OrderedCollection new.
	node args do: [:each | args add: (applyForValueTo: each)].
	addLiteral: node sel.
	^PropertyCallAST new
		send: node sel with: args;
		start: node start;
		end: node end
)
returnsAreNonLocalWhile: block = (
	| originalValue |
	originalValue: areReturnsLocal.
	areReturnsLocal: false.
	^block ensure: [areReturnsLocal: originalValue]
)
rewriteInlinedBlockNode: node <BlockAST> ^ <BlockAST> = (
"An empty block evaluates to nil when called. This method performs the necessary transformation if the block is empty; otherwise it recursively rewrites the block body. This rewrite is done on all blocks, regardless of whether they are inlined."
	| 
	rewrittenNode <BlockAST> 
      params <Collection[ParameterAST]>  
      bodyScope <Scope> 	
	| 
	assert: [node isBlockNode].
	"this shouldn't be handled here, but I'm not sure where the block / codebody 
	comes from."
	node body start isNumber
		ifFalse: [ node body start: node start. node body end: node end ].
	
	params:: node parameters collect:
		[:p <VarDeclAST> |
		(ParameterAST name: p name type: p type)  start: p start; end: p end].
	bodyScope:: scopeMap at: node body.
	params do: [:each | (bodyScope at: each name) data: each].
	addNumericLiteral: node parameters size.
	rewritingMethodBody: false.
	rewrittenNode:: BlockAST new body: (node body apply: self).
	rewrittenNode start: node start; end: node end.
	rewrittenNode body parameters: params.
	node body statements isEmpty ifTrue:
		[rewrittenNode body statements add: (NilAST new start: node body start; end: node body end)].
    ^rewrittenNode
)
selfSendFrom: aMsg <MessageAST>  ^ <MessageNode> = (
	^(NormalSendAST new
		msg: aMsg; 
		recv: (selfNode start: aMsg start; end: aMsg end);
		start: aMsg start; end: aMsg end) apply: self
)
setterBlockArgName = (
	^ ('setter_arg') asSymbol
)
xsetterSendNode: node <SetterSendAST> ^ <AST> = (
"Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send."
	| binding block blockArg send rewrittenSetterSend |
	assert: [node isSetterSendNode ].
	binding:: currentScope at: node msg sel ifAbsent: [MessageAST new].
	binding isVarDeclNode ifTrue:
		"This is an assignment to a temporary; no special handling is needed
		as the value of the expression is the value being assigned."
		[^processVariable: node msg decl: binding].
	valueExpected ifFalse:
		"The parent ignores the expression value; use a plain cheap here message send."
		[^processHereSend: 
			(MessageAST new
				sel: node msg sel;
				args: {applyForValueTo: node msg args first})].
	"The value is used by the parent; rewrite the whole thing as
		setter:: expr  =>  [:a | setter: a. a] value: expr"
	"a -- ok to use a constant name as long as it cannot collide with a user's name"
	blockArg:: ParameterVariableAST name: setterBlockArgName start: nil end: nil.
	"setter: a"
	send:: processHereSend:
		(MessageAST new
			sel: node msg sel;
			args: {blockArg}).
	"send:: applyForEffectTo: send."
	"[:a | setter: a. a]"
	block:: BlockAST new body:
		(CodeBodyAST new
			parameters: {ParameterAST name: setterBlockArgName type: nil}
			temporaries: {}
			statements: {
				send.
				"Need an explicit return because this is not rewritten again."
				BlockLocalReturnAST
					expression: blockArg
					start: node start
					end: node end
			}).
	"[:a | setter: a. a] value: expr"
	rewrittenSetterSend::
		NormalSendAST new
			to: block
			send: (MessageAST new
				sel: #value:;
				args: {applyForValueTo: node msg args first}).
	"TBD: What am I supposed to do with scopeMap here? Original code follows."
	"cb:: (CodeBodyAST new
			parameters: {};
			temporaries: {};
			statements: {sTempAssign. send. sTemp})."
	"scopeMap at: cb put: currentScope."
	^rewrittenSetterSend
)'closures'
currentSegment ^ <Integer> = (
	^0 "default until we implement it properly"
)
lastWriteOf: t <TemporaryAST> ^ <Integer> = (
	^0 "default for now"
)
readsOf: t <TemporaryAST> ^ <Set[Integer]> = (
	^Set new
)
segmentOf: t <TemporaryAST> ^ <Integer> = (
	^0 "default until we get a real implementation"
)
setSegmentOf: t <TemporaryAST> to: i <Integer> = (
	"default until we get a real implementation"
)'node traversal'
assignmentNode: node <AssignmentAST> ^ <AssignmentAST> = (
	assert: [node isAssignmentNode].
	"note write to target variable!"
	^AssignmentAST new
		to: (node var apply: self) assign: (applyForValueTo: node expr);
		start: node start; end: node end
)
blockLocalReturnNode: node = (
	^node
)
blockNode: node <BlockAST> ^ <BlockAST> = (
	" This method should only be called on a block that is not going to be inlined.

	There are two things that require rewriting in blocks.

	1. a.  Non-empty blocks must have their body rewritten recursively
	    b. Empty blocks need a nil expression in them.
	    c. All blocks must have their parameters rewritten from generic VarDecls to ParameterASTs. 
	2. If the last statement in a block is not a return, the block returns
	the expression to its caller. So the last expression needs to be replaced by a 'local return'.

	We accomplish (1) by calling rewriteInlinedBlockNode:, and then do  (2) explicitly.

	The reason for this separation is that step (1) is always needed; step (2) is only needed if the block is not inlined.
	"
	| rewrittenBlock <BlockAST> last <AST> |
	rewritingMethodBody: false.
	returnsAreNonLocalWhile:
		[rewrittenBlock:: rewriteInlinedBlockNode: node.
		last:: rewrittenBlock body statements last.
		(last isReturnStatNode or: [last isBlockLocalReturnAST]) ifFalse:
			["The last expression in a block is returned by it."
			rewrittenBlock body statements removeLast.
			rewrittenBlock body statements add:
				(BlockLocalReturnAST expression: last start: last start end: last end)].
  	  scopeMap at: rewrittenBlock put: (scopeMap at: node)].
    ^rewrittenBlock
)
cascadedSendNode: node <CascadeSendAST> ^ <CascadeSendAST> = ( 
	| prevSend msg |
	assert: [node isCascadedSendNode].
	prevSend:: applyForValueTo: node prevSend.
	msg:: applyForValueTo: node msg.
	^CascadedSendAST new to: prevSend cascade: msg;
							start: node start;
							end: node end;
							yourself
)
charNode: node <CharAST> = (
	addLiteralConstant: node val.
	^node
)
codeBodyNode: node <CodeBodyAST> ^ <CodeBodyAST> = (
	| 
	bodyScope <Scope>
	statements <OrderedCollection[StatementAST]>
	temps <OrderedCollection[TemporaryAST]> 
	result <CodeBodyAST>
	|
	assert: [node isCodeBodyNode].
	pushScopeForNode: node. 
	temps:: node temporaries collect:
		[:each <VarDeclAST> |
		(TemporaryAST name: each name type: each type)
			initializer: (each initializer ifNotNil: [:it | self applyForValueTo: it]);
			start: each start;
			end: each end.
		].
	bodyScope:: scopeMap at: node.
	temps do:
		[: t | (bodyScope at: t name)  data: t].
	statements:: OrderedCollection new.
	node statements keysAndValuesDo:
		[:index :statement | 
		| rewritten |
		rewritten:: (index = node statements size and: [rewritingMethodBody not])
			ifTrue: [applyForValueTo: statement]
			ifFalse: [applyForEffectTo: statement].
		statements add: rewritten].
	result:: CodeBodyAST new
		parameters: node parameters temporaries: temps statements: statements;
		start: node start;
		end: node end.
	popScope.
	scopeMap at: result put: bodyScope.
	^result.
)
genericApplicationExpressionNode: node = (
	assert: [node isGenericApplicationExpressionNode].
	^applyForValueTo: node target
)
guaranteedNode: node = (
	assert: [node isGuaranteedNode].
	^applyForValueTo: node expr
)
ifNode: node <ifAST> ^ <ifAST> = (
	assert: [ node isIfNode ].
	^node
)
implicitSendNode: node = (
    assert: [node apply: ImplicitRecvrVisitor new].
    ^node
)
loopNode: node <LoopAST> ^ <LoopAST> = (
    ^node
)
messageNode: node <MessageAST> ^ <MessageAST> = (
    | args |
    assert: [node isMessageNode].
    args:: OrderedCollection new.
    node args do: [ :arg | args add: (applyForValueTo: arg)].
    addLiteral: node sel.
    ^MessageAST new send: node sel with: args; start: node start; end: node end
)
messagePatternNode: node <MessagePatternAST> ^ <MessagePatternAST> = (
	| params <OrderedCollection[ParameterAST]>  patternScope <Scope> |
	params:: node parameters collect:
		[:p <VarDeclAST> | 
		(ParameterAST name: p name type: p type)
			start: p start;
			end: p end].
	patternScope:: scopeMap at: node.
	params do:
		[:p | (patternScope at: p name) data: p].
	^MessagePatternAST new
		selector: node selector parameters: params;
		start: node start;
		end: node end.
)
methodNode: node <MethodAST> ^<MethodAST | ReturnSelfMethodAST | ReturnInstVarMethodAST>
= (
	| 
	pattern <MessagePatternAST>  
	body <CodeBodyAST>
	result <MethodAST>
	|
	assert: [ node isMethodNode ].
	literalTable:: Dictionary new.
	pattern:: applyForValueTo: node pattern.
	rewritingMethodBody: true.
	body::  applyForValueTo: node body.
	body parameters: pattern parameters.
	body start: node start; end: node end.
	"Append ^self if there is no explicit return terminating the body.
	We are at the method level so that return should have been rewritten as a block local one."
	(body statements isEmpty not and: [body statements last isBlockLocalReturnAST]) ifFalse:
		[assert: [ body start isNumber ]. 		
		body statements addLast:
			(BlockLocalReturnAST
				expression: (ReceiverAST new start: body end; end: body end)
				start: body end
				end: body end)].
	result:: MethodAST new 
		pattern: pattern
		body: body
		visibility: node visibility;
		start: node start; end: node end; yourself.
	scopeMap at: result put: (scopeMap at: node).
	^result
)
mixinClassNode: node = (
	^node
)
normalSendNode: node <NormalSendAST> ^ <AST> = (
	| recv <AST> msg <MessageAST> sel <Symbol> |
	assert: [node isNormalSendNode].

	(isHereNode: node recv) ifTrue:
		[^processHereSend: node msg].
	(isOuterNode: node recv) ifTrue:
		[^processExplicitOuterReceiver: node msg].
	(isSuperNode: node recv) ifTrue:
		[^SuperSendAST send: (applyForValueTo: node msg)].

	(isInlinableAsExpressionConditional: node) ifTrue:
		[^inline: node as: InlinableAsExpressionConditionalAST
			selector: node msg sel
			rewriteArgsAs: [:each | rewriteInlinedBlockNode: each]].
	(isInlinableConditional: node) ifTrue:
		[^inline: node as: InlinableConditionalAST
			selector: node msg sel
			rewriteArgsAs: [:each | rewriteInlinedBlockNode: each]].
	(inlineOperators and: [isInlinableNumericOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableNumericOperators at: node msg sel)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableOperators at: node msg sel)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableBooleanOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (node msg sel = 'and:' ifTrue: ['&&'] ifFalse: ['||']) "BOGUS"
			rewriteArgsAs: [:each <BlockAST> | applyForValueTo: each body statements first]].		

	recv:: applyForValueTo: node recv.
	msg:: applyForValueTo: node msg.
	sel:: msg sel.
	^NormalSendAST new
		to: recv send: msg;
		start: node start;
		end: node end
)
numberNode: node = (
	assert: [node isNumberNode].
	addNumericLiteral: node val.
	^node
)
receiverNode: node <ReceiverAST> = (
	^ node
)
returnInstVarMethodNode: node = (
	^node
)
returnStatNode: node <ReturnStatAST> ^ <ReturnStatAST> = (
	assert: [node isReturnStatNode].
	^areReturnsLocal
		ifTrue:
			[BlockLocalReturnAST
				expression: (applyForValueTo: node expr)
				start: node start
				end: node end]
		ifFalse:
			[ReturnStatAST new
				expr: (applyForValueTo: node expr); 
		 		start: node start;
				end: node end]
)
selfNode ^ <VariableAST> = (
"shouldn't this be a ReceiverAST?"
"generate a an AST representing self; used for implicit self sends"
	^VariableAST new name: #self; start: 0; end: 0
)
setterSendNode: node <SetterSendAST> ^ <AST> = (
"Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send."
	| binding block blockArg blockParam blockScope send rewrittenSetterSend |
	assert: [node isSetterSendNode ].
	binding:: currentScope at: node msg sel ifAbsent: [MessageAST new].
	binding isVarDeclNode ifTrue:
		"This is an assignment to a temporary; no special handling is needed
		as the value of the expression is the value being assigned."
		[^processVariable: node msg decl: binding].
	valueExpected ifFalse:
		"The parent ignores the expression value; use a plain cheap here message send."
		[^processHereSend: 
			(MessageAST new
				sel: node msg sel;
				args: {node msg args first};
				start: node msg start; end: node msg end)].
	"The value is used by the parent; rewrite the whole thing as
		setter:: expr  =>  [:a | setter: a. a] value: expr"
	"a -- ok to use a constant name as long as it cannot collide with a user's name"
	blockArg:: ParameterVariableAST 
					name: setterBlockArgName 
					start: node msg start 
					end: node msg end.
	blockParam:: ParameterAST name: setterBlockArgName type: nil.
	"setter: a"
	send:: NormalSendAST new to: node recv send:
		(MessageAST new sel: node msg sel; args: {blockArg};
		start: node msg start; end: node msg end; yourself);
		start: node  start; end: node  end.
	"[:a | setter: a. a]"
	block:: BlockAST new body:
		(CodeBodyAST new
			parameters: {blockParam}
			temporaries: {}
			statements: {
				send.
				blockArg
			};			
			start: node start; end: node end);
			start: node start; end: node end.
	blockScope:: Scope new.
	blockScope
		superScope: currentScope;
		at: setterBlockArgName put: (SemanticVarDecl decl: {blockParam}).
	scopeMap at: block put: blockScope.
	scopeMap at: block body put: blockScope.
	"[:a | setter: a. a] value: expr"
	rewrittenSetterSend::
		NormalSendAST new
			to: block
			send: (MessageAST new
				sel: #value:;
				args: {node msg args first};
				start: node msg start; end: node msg end);
				start: node  start; end: node  end.
	^applyForValueTo: rewrittenSetterSend
)
stringNode: node = (
	assert: [node isStringNode].
	addLiteralConstant: node val.
	^node
)
superSendNode: node = (
	assert: [node apply: SuperSendVisitor new].
	^node
)
symbolNode: node = (
	assert: [node isSymbolNode].
	addLiteralConstant: node val.
	^node
)
temporaryNode: node <TemporaryVariableAST> = (
	"Possibily " #BOGUS.
	^node
)
tupleNode: aNode <TupleAST> = (
"Rewrite into a tree representing the expression
	(Array new:  n) at: 1 put:: e1 ; ...  at: n put: en; yourself
where n is the size of the tuple."
	|
	arrayNode <NormalSendAST> 
	arrayLengthNode <NumberAST> 
	tupleInitializationNodes <List[NormalSendAST]>
	index <Integer>
	|
	arrayLengthNode:: NumberAST new val: aNode elements size.
	arrayLengthNode start: aNode start; end: aNode end.
	arrayNode:: NormalSendAST new
		to: (NormalSendAST new 
				to: hereNode 
				send:  (MessageAST new
					sel: #Array;
					args: {};
					start: aNode start;
					end: aNode end)) 
		send: (MessageAST new
				sel: #new:;
				args: {arrayLengthNode};
				start: aNode start;
				end: aNode end).
	arrayNode start: aNode start; end: aNode end.
	aNode elements size = 0 ifTrue: [^applyForValueTo: arrayNode].
	index:: 0.
	tupleInitializationNodes:: aNode elements inject: arrayNode into:
		[:r : e |  | msg <MessageAST> |
	      index:: index + 1.
	      msg:: MessageAST new
			sel: #at:put:; 
			args: 
				{NumberAST new val: index; start: aNode start; end: aNode end.
				e}.
		msg start: aNode start; end: aNode end.
	      index = 1 
			ifTrue: 
				[NormalSendAST new to: r send: msg; start: aNode start; end: aNode end] 
				"(Array new: n) at:1 put: e1"
	      	ifFalse: 
				[CascadedSendAST new to: r cascade: msg; start: aNode start; end: aNode end].
				"...; at: k put: ek"
		].
	^applyForValueTo:
		((CascadedSendAST new
			to: tupleInitializationNodes
			cascade:
					(MessageAST new
						sel: #yourself;
						args: {};
						start: aNode start;
						end: aNode end))
				start: aNode start;
				end: aNode end)
)
variableNode: aNode <VariableAST> = (
	assert: [ aNode start isNumber ].
	aNode name = #self ifTrue:
		[^ReceiverAST new start: aNode start; end: aNode end].
	aNode name = #nil ifTrue:
		[^NilAST new start: aNode start; end: aNode end].
	aNode name = #true ifTrue:
		[^BoolAST withValue: true start: aNode start end: aNode end].
	aNode name = #false ifTrue:
		[^BoolAST withValue: false start: aNode start end: aNode end].		
	aNode name = #thisContext ifTrue:
		[^ContextAST new start: aNode start; end: aNode end].
	"recognize inst vars for accessor methods? handle temps etc."
	^aNode
)'private'
addLiteral: literal <Character | Number | String | Symbol> = ( 
	(literalTable includesKey: literal) ifFalse:
		[literalTable at: literal put: literalTable size].
)
at: node error: msg = (
	"Simple solution for now - fix this at some point"
	('error: ', msg) out.
	halt
)
isRemovableBlock: block <BlockAST> withArgs: nofArgs <Integer> ^ <Boolean> = (
"Answers true if block can be removed (inlined) within another block."
	block isBlockNode ifFalse: [^false].
	block parameters size = nofArgs ifFalse: [^false].
	^true
)
parameters: pars matchArguments: args
 = (
 | i |
	#BOGUS yourself. "appears to be unused; delete if so"
 i:: pars size.
 
 "Proceed if no. of parameter matches no. of arguments"
 pars size = args size ifFalse: [ ^ false ].
 
 "check individual arguments, starting with last one"
 i:: pars size.
 [ i > 0 ] whileTrue: [
  (args at: i) isRefNode ifFalse: [ ^ false ].
  (pars at: i) == (args at: i) decl ifFalse: [ ^ false ].
  i:: i - 1
 ].
 
 "parameters & arguments match 1-to-1, in same order"
 ^ true
)
popScope ^ <Scope> = (
	^scopeStack removeLast
)
pushScope: s <Scope> = (
	scopeStack addLast: s
)
pushScopeForNode: n <AST> = (
	scopeStack addLast: (scopeMap at: n)
)
variableFrom: message <MessageAST> decl: declaration <VarDeclAST>  ^ <VariableNode> = (
	assert: [message args isEmpty].
	declaration isNil ifTrue:
		[^(VariableAST new
			name: message sel;
			start: message start;
			end: message end)
				apply: self].
	declaration isTemporaryAST ifTrue: [noteReadOf: declaration].
	^declaration variableClass
		name: message sel
		start: message start
		end: message end                    
)) : ()
class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = ASTTool ("The scope builder is a visitor on the AST. It computes a tree of scopes that shadows the AST itself.  More precisely, it computes a mapping from ASTs to their scopes. This allows us to get to the appropriate scope for an abstract syntax node without pollluting the AST with extraneous data like scopes.

We could associate each node in the AST with the scope in which it is found, but this would be overkill. Instead, only nodes that actually introduce new scopes (such as class sides, message patterns, code bodies and blocks) actually get mapped in this manner. The intent is that later phases of compilation will visit the tree and look up the scopes at the points where they are introduced.

The builder starts at a given node, in the context of some mixin, described by a mirror.  This is because, in an incremental environment, we may not have the complete AST for a module, but instead be asked to process a part of that module, such as a nested class, slot definition or method. The surrounding scope can be computed from the mirror representing the immediately enclosing mixin.

Then we traverse the tree, creating and populating new scopes as needed. We maintain a stack of scopes (scopeStack) that initially contains only the surrounding scope.  Scopes get pushed on to the stack when we encounter a node that introduces a scope, and popped when we finish with that node. The scopes are chained to their super scopes (the scope below them on the stack).

A possible optimization is to avoid a traversal of an entire side of a class.
One can process only a side without its subtrees (i.e., methods and nested classes). These can be visited later,  as long as we ensure that the processing of the subtree begins with a proper super scope on top of the scope stack."| 
  scopeStack = OrderedCollection new.
  
  currentDepth ::= initialDepth. "The lexical nesting level of the class declaration currently 
						being visited; top level classes are level 0"
|pushScope: initialScope)
('as yet unclassified'
blockNode: aNode <BlockAST> = (
	| ps <Scope> |
	ps:: Scope new.
	"establish parameter scope"
	aNode parameters do:[:p <VarDeclAST> | ps at: p name put: (SemanticVarDecl decl: {p. currentDepth})].
	nestScope: ps.
	"visit body"
	aNode body apply: self.
	scopeMap at: aNode put: (scopeMap at: aNode body).
	popScope "pop the parameter scope, ps"
)
buildScopeFor: m <MixinMirror> ^ <Scope> = (
	^prvtScopeFor: m.
)
cascadedSendNode: aNode <CascadedSendAST> = (
"generic traversal code"
"visit receiver and messages"
	aNode prevSend apply: self.
	aNode msg apply: self.
)
charNode: aNode <CharAST> = (
"do nothing"
)
classHeaderNode: aNode = (
	aNode constructor apply: self.
	aNode slots do: [:s |  s initializer ifNotNil: [:i | i apply: self]].
	aNode initExprs do: [: e | e apply: self].
)
classNode: aNode <ClassDeclarationAST> = (
	| vs <Scope> |
	currentScope
		at: aNode name 
		put: (SymbolTableEntry for: {MessagePatternAST new selector: aNode name. currentDepth}).
	vs:: Scope new. "establish instance side scope"
	currentDepth:: currentDepth + 1.
	aNode hdr slots do:
		[:v <SlotDeclAST> | 
		vs at: v name put: (SymbolTableEntry for: {MessagePatternAST new selector: v name. currentDepth}).
		v isMutable ifTrue:
			[vs at: (v name asString, ':') asSymbol
				put: (SymbolTableEntry for: {MessagePatternAST new selector: (v name asString, ':') asSymbol. currentDepth}) "setter"]
    	 ].
	self nestScope: vs.
  	aNode instanceSide apply: self.
	popScope.
  	aNode classSide apply: self.
	currentDepth:: currentDepth - 1.
)
codeBodyNode: aNode <CodeBodyAST> = (
	| ts <Scope> |
	"establish local slot scope"
	ts:: Scope new.
	aNode temporaries do:
		[:t <SlotDefAST> | 
		ts at: t name put: (SemanticVarDecl decl:{t slotDecl. currentDepth}); " getter"
		at: (t name asString, ':') asSymbol put: t slotDecl "setter"].
	ts end: aNode end. "we need to know where this scope ends"
	nestScope: ts.
	scopeMap at: aNode put: ts.
	"visit statements"
	aNode statements do:[: s <ReturnStatementAST | SendAST>  | s apply: self].
	popScope.
)
currentScope ^ <Scope> = (
	^scopeStack last
)
enclosingMixinsOf: m <MixinMirror> ^ <Collection[MixinMirror]> = (
	| e enclosers |
	^m enclosingClassStencil enclosingClassStencils collect: [:stencil | stencil mixin]
)
isPseudoVariableNode: aNode <VariableAST> ^ <Boolean> = (
	^aNode name = #self or:
		[aNode name = #super or:
		[aNode name = #outer or:
		[aNode name = #thisContext]]]
)
messageNode: aNode <MessageAST> = (
"generic traversal code"
"visit arguments"
	aNode args do: [:a <SendAST> | a apply: self]
)
messagePatternNode: aNode <MessagePatternAST> = (
	| ps <Scope> |
	ps:: Scope new.
	"establish parameter scope"
	aNode parameters do:
		[:p <VarDeclAST> |
		ps at: p name put: (SemanticVarDecl decl: {p. currentDepth})].
	nestScope: ps.
	scopeMap at: aNode put: ps.
	"the pattern scope, ps, must be popped by the caller"
	"establish type parameter scope - skip for now"
)
methodNode: aNode <MethodAST> = (
	"register method in current scope"
	currentScope
		at: aNode pattern selector
		put: (SymbolTableEntry for: {aNode pattern. currentDepth}).
	"visit pattern"
	aNode pattern apply: self.
	"visit body"
	aNode body apply: self.
	scopeMap
		at: aNode
		put: (scopeMap at: aNode body).
	popScope "Pop pattern scope"
)
mixinApplication: node <MixinApplicationAST> = (
	node mixinExpr apply: self.
	node superclassExpr apply: self
)
mixinClassNode: aNode = (
	"do nothing"
)
nestScope: s <Scope> = (
"Hook up a new lexically nested scope, and push onto the scope stack"
	s superScope: currentScope.
	pushScope: s
)
normalSendNode: aNode <NormalSendAST> = (
"generic traversal code"
"visit recvr and msg"
	aNode recv apply: self.
	aNode msg apply: self.
)
numberNode: aNode <NumberAST> = (
"do nothing"
)
popScope ^ <Scope> = (
	^scopeStack removeLast
)
propertyCallNode: aNode <PropertyCallAST> = (
	messageNode: aNode
)
prvtScopeFor: c <MixinMirror> ^<Scope> = (
"When incrementally compiling a nested class, we need to reconstruct its scope."
	| 
	s <Scope> 
	outerMixins <Collection[MixinMirror]>
	depth <Integer>
	|
	outerMixins:: enclosingMixinsOf: c."should use a cleaner API"
	currentDepth:: outerMixins size - 1.
	depth:: 0.
	outerMixins do: [:o |
		s:: Scope new superScope: s.
		(selectorsFor: o) do:
			[: sel |
			s at: sel 
				put: (SymbolTableEntry for:{MessagePatternAST new selector: sel. depth})].
		depth:: depth + 1].
	^s
)
pushScope: s <Scope> = (
	scopeStack addLast: s
)
returnStatNode: aNode <ReturnStatAST> = (
"generic traversal code"
	"visit expression"
	aNode expr apply: self
)
selectorsFor: m <MixinMirror> ^ <Collection[Symbol]> = (
"Should add a convenience method to mirrors to do this"
	| result <Collection[Symbol]> |
	result:: m methods asOrderedCollection collect:[:s <MethodMirror> | s name].
	result addAll: (m slots asOrderedCollection collect:[: s <SlotMirror> | s name]).
	result addAll: 
		((m slots asOrderedCollection select:[: s | s isMutable]) 
			collect:[: s <SlotMirror> | s name, ':']).
	result addAll: (m classes asOrderedCollection collect:[:s <ClassStencilMirror> | s name]).
	^result
)
setterSendNode: aNode <SetterSendAST> = (
	aNode recv apply: self.
	aNode msg apply: self.
)
sideNode: aNode <SideAST> = (
	scopeMap at: aNode put: currentScope.
	"visit methods"
	aNode categories do:
		[: c <CategoryAST> | c methods do:[:m <MethodAST> | m apply: self]].
	"visit nested classes"
	aNode nestedClasses do: [:nc <ClassDeclarationAST> | nc apply: self].
)
stringNode: aNode <StringAST> = (
"do nothing"
)
symbolNode: aNode <SymbolAST> = (
"do nothing"
)
tupleNode: aNode <TupleAST> = (
"visit elements"
	aNode elements do: [:e <SendAST> | e apply: self]
)
varDeclNode: aNode <VarDeclAST> = (
"Do nothing. It could arguably add aNode's data to current scope - but in practice, the context knows better how to do this"
)
variableNode: aNode <VariableAST> = (
	assert: [aNode name = #'_here' or: [isPseudoVariableNode: aNode]]
		message: 'Unexpected variable name'.
)
visitMethod: aNode <MethodAST> within: m <MixinMirror> ^ <Dictionary[AST, Scope]> = (
	^visitNode: aNode within: m
)
visitNode: aNode <AST> within: m <MixinMirror> ^ <Dictionary[AST, Scope]> = (
	pushScope: (buildScopeFor: m).
	aNode apply: self.
	^scopeMap
)) : ('as yet unclassified'
new ^ <Instance> = (
	^self nestedIn: Scope new atLevel: 0
))
class Translator = ASTTool (
"Visits nodes of an NS AST to produce a Javascript AST. The usual translation unit is a method. Translation is initiated by sending the translateMethodNode: message. The argument is the method to translate, the returned value is the translation."|
	scopeStack
	currentSelector
	protected containsNonLocalReturn <Boolean> "Set to false at the beginning of translating a method. The code that emits a non-local return sets this to true. The top-level code checks the value to see whether to emit a try-catch wrapper for an NLR."

|)
(
class ASTDescriber = ASTTool (
"Convert an AST into JS code that constructs an identical AST.

We need to ensure we cover all relevant ASTs (for now, blocks and their contents) and that we capture start and end info (here and in the JS code we call).

We cover rewritten nodes like assignments out of an abundance of caution. ")
('as yet unclassified'
arrayNode: aNode <ArrayAST> = (
halt. 
 ^'ast.arr(', (convertList: aNode elements), ')'.	
)
assignmentNode: aNode  <AssignmentAST> = (
halt.
	^'ast.assign(', (aNode var apply: self), ', ', (aNode expr apply: self), ')'
)
binaryTypeOpNode: aNode <BinaryTypeOpAST>  = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js ident: 'binaryType')) with: {js literal: aNode operator asString. aNode lOperand apply: self. aNode rOperand apply: self}"
	^'ast.binaryType(', aNode operator asString printString, ', ', (aNode lOperand apply: self), ', ',  (aNode rOperand apply: self),  ')'
")
blockNode: aNode  <BlockAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'block')) with: {aNode body apply: self}"
	^'ast.block(', (aNode body apply: self),  ')'"
)
cascadedSendNode: aNode  <CascadedSendAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'cascade')) with: {aNode prevSend apply: self. aNode msg apply: self}"
	^'ast.cascade(', (aNode prevSend apply: self), ', ', (aNode msg apply: self), ')'"
)
charNode: aNode  <CharacterAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'character')) with: {js literal: aNode val asString}"
	^'ast.character(""', aNode val asString,  '"")'"
)
codeBodyNode: aNode  <CodeBodyAST> = (
	| ps ts ss |
	ps:: convertList: aNode parameters.
	ts:: convertList: aNode temporaries.
	ss:: convertList: aNode statements.
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'codeBody')) with: {ps. ts. ss}"	
	^'ast.codeBody(', ps, ', ', ts, ', ', ss, ')'"
)
genericInvocationNode: aNode = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'genericInvoke')) with: {aNode generic apply: self. convertList: aNode arguments}"
 ^'ast.genericInvoke(', (aNode generic apply: self), ', ', (convertList: aNode arguments), ')'"
)
messageNode: aNode  <MessageAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'message')) with: {js literal: aNode sel. convertList: aNode args}"
	^'ast.message(', aNode sel asString printString, ',', (convertList: aNode args), ')'"
)
normalSendNode: aNode  <NormalSendAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'send')) with: {aNode recv apply: self. aNode msg apply: self}"

	^'ast.send(', (aNode recv apply: self), ', ', (aNode msg apply: self), ')'"
)
numberNode: aNode  <NumberAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'num')) with: {js literal: aNode val}"
	^'ast.num(', aNode val printString,  ')'"
)
returnStatNode: aNode  <ReturnStatAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'ret')) with: {aNode expr apply: self}"
	^'ast.ret(', (aNode expr apply: self), ')'"
)
setterSendNode: aNode  <SetterSendAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'setter')) with: {aNode recv apply: self. aNode msg apply: self}"
	^'ast.setter(', (aNode recv apply: self), ', ', (aNode msg apply: self), ')'"
)
slotDefNode: aNode <SlotDefAST> = (
	| init <String>  |	
	
	init:: aNode initializer ifNil:[js literal: nil] ifNotNil: [: i | i apply: self].	
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'slotDef')) with: {aNode slotDecl apply: self. init. js literal: aNode isMutable. js literal: aNode accessModifier}"
	init:: aNode initializer ifNil:['null'] ifNotNil: [: i | i apply: self].
	^'ast. slotDef(', (aNode slotDecl apply: self), ', ', init, ', ', aNode isMutable printString, ', ', aNode accessModifier asString printString,  ')'"
)
stringNode: aNode  <StringAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'str')) with: {js literal: aNode val}"
	^'ast.str(""', aNode val,  '"")'"
)
symbolNode: aNode  <SymbolAST> = (
	^stringNode: aNode
)
tupleNode: aNode <TupleAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'tuple')) with: {convertList: aNode elements}"
 ^'ast.tuple(', (convertList: aNode elements), ')'."	
)
typeIdNode: aNode  <TypeIdAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'typeId')) with: {js literal: aNode name}"
	^'ast.typeId(', aNode name asString printString,  ')'"
)
unaryTypeOpNode: aNode <UnaryTypeOpAST>  = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'unaryType')) with: {js literal: aNode operator asString. aNode operand apply: self}"
	^'ast.unaryType(', aNode operator printString, ', ', (aNode operand apply: self),  ')'"
)
varDeclNode: aNode  <VarDeclAST> = (
	| typ <String> |
		
	typ:: aNode type ifNil:[js ident: 'null'] ifNotNil: [: t | t apply: self].	
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'vdecl')) with: {js literal: aNode name. typ}"
	typ:: aNode type ifNil:['null'] ifNotNil:[: t | aNode type apply: self].
	^'ast.vdecl(', aNode name asString printString, ', ', typ, ')'"
)
variableNode: aNode  <VariableAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'variable')) with: {js literal: aNode name}"
	^'ast.variable(', aNode name asString printString,  ')'"
)'private'
convertList: l = (
 | elements |

	elements:: l collect:[:e | e apply: self].
	^js array: elements
"
	elements:: ''.
	l do:[:e | elements:: elements, (e apply: self)] separatedBy:[elements:: elements, ', '].	
	^'[', elements, ']'"
)) : ()
class FreeVariableDetector for: codeBody <CodeBodyAST> = (
"Discover all free names in the code body. Note that names may be free in a nested closure but not free in the overall  code body.

The motivation for detecting the free names is that a Newspeak closure must provide reflective access to its free variables, but a Javascript closure does not.
Therefore, the compiler needs to collect this information and build a representation that will be accessible at run time.

In practice, free names fall into two categories: true messages to enclosing objects, and variable accesses in the surrounding scope. Conceptually, these are all message sends, but they are treated very differently during compilation.

The second category is primarily what we want to detect. Message sends can be directed at the enclosing object (starting with self) and looked up via standard lookup rules."|
freeVariables <Set[Symbol]> = Set new.
boundVariableStack = OrderedCollection new add: Set new; yourself.
|codeBody apply: self)
('as yet unclassified'
assignmentNode: node = (
	node expr apply: self.
	node var apply: self.
)
blockLocalReturnNode: node  = (
	node expr apply: self
)
blockNode: node <BlockAST> = (
	pushScope: node body.
	node body apply: self.
	popScope.
)
boolNode: node = (
	
)
cascadedSendNode: node <CascadedSendAST> = (
	node prevSend apply: self.
	node msg apply: self.
)
charNode: node <CharAST> = (
	
)
codeBodyNode: node <CodeBodyAST> = (
	pushScope: node.
	"who takes care of slot initializers? they have already been rewritten"
	node statements do: [:each <StatementAST>  | each apply: self].
	popScope.
)
explicitOuterReceiverNode: node <ExplicitOuterReceiverAST> = (
	
)
freeNames = (
	^freeVariables asMutableArrayList
)
hereName = (
	^#'_here'
)
implicitSendNode: node = (
	| b <AST> aMsg <MessageAST> |
	aMsg:: node msg.
	aMsg apply: self.  
	b:: currentScope at: aMsg sel ifAbsent: [MessageAST new].
	b isMessagePatternNode ifTrue:
		["this is a message send for a lexically defined method"
		^processImplicitOuterSend: aMsg atDepth: b depth].
	b isVarDeclNode
		ifTrue: [freeVariables add: aMsg sel]."a real variable in scope"
)
inlinableAsExpressionConditionalNode: node = (
	normalSendNode: node	
)
inlinableConditionalNode: node = (
	normalSendNode: node
)
isHereNode: aNode <AST> ^ <Boolean> = (
	aNode isVariableNode ifFalse: [^false].
	^aNode name = hereName
)
isPseudoVariableNode: aNode <VariableAST> ^ <Boolean> = (
	^aNode name = #self
		or: [aNode name = #super
		or: [aNode name = #outer
		or: [aNode name = #thisContext]]]
)
keywordPatternNode: node <KeywordPatternAST> = (
)
literalPatternNode: aNode <LiteralPatternAST> = (
)
messageNode: node <MessageAST> = (	
	node args do: [:each | each apply: self].
)
mixinClassNode: node = (
	
)
nilNode: node = (
	
)
normalSendNode: node <NormalSendAST> = (
	
	"temp reads and writes are here sends"
	(isHereNode: node recv) ifTrue: [^self processHereSend: node msg].	
		"this is post-rewriter. Do we ever need the above?"
	node recv apply: self.
	node msg apply: self.
)
numberNode: node <NumberAST> = (
	
)
parameterDeclNode: node = (
	
)
parameterNode: node = (
	processName: node name	
)
receiverNode: node = (
	"freeVariables add: #self"
)
returnStatNode: node <ReturnStatAST> = (
	node expr apply: self
)
setterSendNode: node <SetterSendAST> = (
 	normalSendNode: node.
)
stringNode: node <StringAST> = (
	
)
superSendNode: node = (
	node msg apply: self.
	"freeVariables add: #self"
)
symbolNode: node <SymbolAST> = (
	
)
temporaryDeclNode: node = (
	
)
temporaryNode: node = (
	processName: node name	"what if it is synthetic/"
)
tupleNode: node <TupleAST> = (
	node elements do: [:each | each apply: self]
)
varDeclNode: node = (
	
)
variableNode: node = (
	processName: node name	
)
wildcardPatternNode: aNode <WildcardPatternAST> = (
)'private'
currentScope = (
	^boundVariableStack last.
)
popScope ^ <Set[Symbol]> = (
	^boundVariableStack removeLast.
)
processHereSend: aMsg <MessageAST> = (
	| b <AST> | "is this ever called, given we are post rewriter?"
	aMsg apply: self.  
	b:: currentScope at: aMsg sel ifAbsent: [MessageAST new].
	b isMessagePatternNode ifTrue:
		["this is a message send for a lexically defined method"
		^processImplicitOuterSend: aMsg atDepth: b depth].
	b isVarDeclNode
		ifTrue: [processName: aMsg sel]."a real variable in scope"
)
processImplicitOuterSend: aMsg <MessageAST> atDepth: depth <Integer> = (
	"stub. At some point, we may want to produce a mapping of free names to the lexical depth they come from to make things easier and more efficient for the closure mirror"
)
processName: n <Symbol> = (
	boundVariableStack detect:[: s | s includes: n] ifNone:[freeVariables add: n].
	
)
pushScope: s <CodeBodyAST> = (
	| bvs <Set[Symbol]> |
	bvs:: Set new.
	currentScope do:[:v <Symbol> | bvs add: v].
	s parameters do:[: p | bvs add: p name].
	s temporaries do:[: t | bvs add: t name].
	boundVariableStack add: bvs
)) : ()'AST visiting'
ifNode: node <IfAST> = (
	^js if: (node cond apply: self)
		then: (node then apply: self)
		else: (node else ifNotNil: [:else | else apply: self])
)
messagePatternNode: node <MessagePatternAST> ^<List[String]> = (
	currentSelector:: node selector.
	^node parameters collect: [:each | each apply: self]
)
methodNode: node <MethodAST> ^<Node> = (
	| translatedBody |
	translatedBody:: node body apply: self.
	^js functionOf: (node pattern apply: self) asArray
		body: (containsNonLocalReturn
			ifTrue: [wrapBodyForNlrHandling: translatedBody]
			ifFalse: [wrapBodyNoNlrHandling: translatedBody]).
)
parameterNode: node <ParameterAST> = (
	^js ident: (mangleVarName: node name)
)'accessing'
translateMethodNode: node <MethodAST> ^<Node> = (
	| translation |
	beginNewTranslationCycle.
	pushScope: (scopeMap at: node).
	currentScope at: (syntheticNameSeparator, 'currentMethod') asSymbol put: (SemanticMethod decl: node).
	translation:: node apply: self.
	popScope.
	^translation.
)'as yet unclassified'
addCascadedSend: node to: statements = (
	node isCascadedSendNode ifTrue:
		[addCascadedSend: node prevSend to: statements].
	statements add:
		(js call: (js propertyOf: (js ident: 'cascadeReceiver') at: (js literal: (mangleMethodName: node msg sel)))
			with: (node msg args collect: [:each | each apply: self]) asArray). 
)
assignmentNode: node = (
	^js assign: (node var apply: self) toBe: (node expr apply: self)
)
astForBlock: node <BlockAST> ^ <Node> = (
	| tree <BlockAST> body <CodeBodyAST> params |
	
	params:: node parameters collect:[:p | VariableAST new name: p name].
	(params size = 1and:[params first name = rewriter setterBlockArgName])
		ifTrue:[^js verbatim:'{}'].
		"A gross hack to avoid blocks that are produced by rewriting setter sends, as these do not have parseable block source"
	"parse the source to obtain unrewritten AST"
	tree:: parser block parse: (ReadStream  on: (sourceForNode: node)).
	tree isCodeBodyNode ifTrue:[body:: tree] ifFalse:[body:: tree body].
	body parameters: params.
	"make sure we get a code body, and update any parameters"
	"The above is only needed for sugar that hides the actual closure"
	^(body apply: ASTDescriber new)
)
astFunctionForBlock: node <BlockAST> ^ <Node> = (
	| body |
	body:: astForBlock: node.
	^js functionOf: {} body: (js block:{
		js var: (js ident: 'ast') value: (js call: (js ident: 'populateAST') with: {}).
		js return: (astForBlock: node).
		}).
)
beginNewTranslationCycle = (
	scopeStack:: OrderedCollection new.
	containsNonLocalReturn:: false.
)
blockLocalReturnNode: node <BlockLocalReturnAST> = (
"	(node expr isNormalSendNode and: [isInlinableConditionalNode: node expr]) ifTrue:
		""Optimize the common special case of returning the value of an ifTrue:ifFalse: message send.
		The clauses already have the necessary local returns of the last expression of each clause
		inserted by the rewriter.""
		[^js if: (node expr recv apply: self)
			then: (node expr msg args first body apply: self)
			else: ((node expr msg args at: 2) body apply: self)]."
	^js return: (node expr apply: self)
)
blockNode: node <BlockAST> = (
       ^js new: (js ident: #JsBlock) with: {
		js functionOf: (node parameters collect: [:each | each apply: self]) asArray
			body: (node body apply: self).
		freeNameLiteralOf: node.
		astFunctionForBlock: node. "
		js literal:  (sourceForNode: node). "
		js literal: parsedLanguage
		}
)
boolNode: node <BoolAST> = (
	^js literal: node val
)
cascadedSendNode: node <CascadedSendAST> = (
	| statements |
	statements:: OrderedCollection new.
	addCascadedSend: node to: statements.
	statements at: statements size put: (js return: statements last).
	^js call: (js functionOf: {'cascadeReceiver'} body: (js block: statements))
		with: {node recv apply: self}
)
charNode: node <CharAST> = (
	"Javascript has no characters, only strings."
	^js literal: node val asString
)
codeBodyNode: node <CodeBodyAST> = (
	| locals statements |
	locals:: node temporaries collect: [:each | each apply: self].
	statements:: node statements collect: [:each | each apply: self].
	^js block: (locals asArray, statements) asArray
)
explicitOuterReceiverNode: node <ExplicitOuterReceiverAST> = (
	^processOuterReceiverAtDepth: node depth
)
freeNamesOf: block  <BlockAST> ^ <Set[Symbol]> = (
	^(FreeVariableDetector for: block body) freeNames
)
implicitSendNode: node <ImplicitRcvrSendNode> = (
	^processSend: node msg to: (processOuterReceiverAtDepth: node depth) with: node msg args
)
inlinableAsExpressionConditionalNode: node <InlinableConditionalAST> = (
	| inverseCondition condition |
	inverseCondition:: node msg sel = 'ifFalse:ifTrue:'.
	condition:: node recv apply: self.
	^js ternaryIf: (inverseCondition ifTrue: [js prefixOperator: '!' on: condition] ifFalse: [condition])
		then: (node msg args first body statements first apply: self)
		else: ((node msg args at: 2) body statements first apply: self)
)
inlinableConditionalNode: node <InlinableConditionalAST> = (
	| selector inverseCondition hasElseClause condition |
	selector:: node msg sel.
	inverseCondition:: selector = 'ifFalse:ifTrue:' or: [selector = 'ifFalse:'].
	hasElseClause:: node msg args size = 2.
	condition:: node recv apply: self.
	^js if: (inverseCondition ifTrue: [js prefixOperator: '!' on: condition] ifFalse: [condition])
		then: (node msg args first body apply: self)
		else: (hasElseClause ifTrue: [(node msg args at: 2) body apply: self] ifFalse: [nil])
)
inlinedOperatorNode: node <InlinedOperatorAST> = (
	"We are not modeling JS operator precedence, so just parenthesize everything."
	^js operator: node msg sel
		with: (node recv apply: self)
		and: (node msg args first apply: self)
)
mangleMethodName: name <String> = (
	^'#', name
)
mangleVarName: name <String> ^<String> = (
	^'l_', name
)
messageNode: node = (
	useDnuCatcher ifTrue: [sentSelectors add: node sel].
	^js literal: (mangleMethodName: node sel)
)
nilNode: node = (
	^js ident: 'newspeakUndefinedObject'
)
nlrName = (
	^'NLR'
)
nlrValuePropertyName = (
	^'value'
)
normalSendNode: node <NormalSendNode> = (
	^processSend: node msg to: (node recv apply: self) with: node msg args
)
numberNode: node <NumberAST> = (
	assert: [node isNumberNode].
	^js literal: node val
)
parameterDeclNode: node <ParameterAST> = (
	^mangleVarName: node name
)
processOuterReceiverAtDepth: depth <Integer> = (
	| slotName |
	depth = 0 ifTrue: [^js ident: 'self'].
	slotName:: 'enclosingObjects', syntheticNameSeparator, currentMixinUID.
	^js propertyOf: (js propertyOf: (js ident: 'self') at: (js literal: slotName))
		at: (js literal: depth - 1) "adjust for JS's 0-based indexing"
)
processSend: message to: receiver with: args = (
	^(supportDoesNotUnderstand and: [useDnuCatcher not and: [useNoSuchMethod not]])
		ifTrue:
			[ | arity |
			arity:: args size.
			js call: (js ident: 'sendMessage', (arity <= sendAritySpecialCaseLimit ifTrue: [arity printString] ifFalse: ['N']))
				with: {
					receiver.
					message apply: self
				}, (args collect: [:each | each apply: self])]
		ifFalse:
			[js call: 
				(js propertyOf: receiver at: (message apply: self))
			with: 
				(args collect: [:each | each apply: self]) asArray]
)
propertyCallNode: node <PropertyCallAST> = (
	^js literal: node sel
)
receiverNode: node <ReceiverNode> = (
	"assert: [ node apply: rewriter ReceiverVisitor new] message: 'ReceiverNode expected'."
	#BOGUS yourself.
	^js ident: selfName
)
returnStatNode: node <ReturnAST> = (
	containsNonLocalReturn:: true.
	^js block: {
		js assign: (js propertyOf: (js ident: nlrName) at: (js literal: nlrValuePropertyName)) toBe: (node expr apply: self).
		js throw: (js ident: nlrName)
	}
)
selfName = (
	^'self'
)
stringNode: node <StringAST> = (
	^js literal: node val
)
superSendNode: node <SuperSendAST> = (
	| superSlotName |
	superSlotName:: 'super', syntheticNameSeparator, currentMixinUID.
	^(supportDoesNotUnderstand and: [useDnuCatcher not and: [useNoSuchMethod not]])
		ifTrue:
			[ | arity |
			arity:: node msg args size.
			js call: (js ident: 'sendSuperMessage', (arity <= sendAritySpecialCaseLimit ifTrue: [arity printString] ifFalse: ['N']))
				with: {
					js ident: 'self'.
					js propertyOf: (js ident: 'self') at: (js literal: superSlotName).
					node msg apply: self
				}, (node msg args collect: [:each | each apply: self])]
		ifFalse:
			[ | args |
			args:: OrderedCollection new.
			args add: (js ident: 'self').
			node msg args do: [:each | args add: (each apply: self)].
			js call:
				(js propertyOf:
					(js propertyOf: (js propertyOf: (js ident: 'self') at: (js literal: superSlotName))
						at: (node msg apply: self))
					at: (js literal: 'call'))
				with:
					args asArray]
)
symbolNode: node <SymbolAST> = (
	assert: [node isSymbolNode].
	^js literal: node val
)
temporaryDeclNode: node <ParameterAST> ^<String> = (
	^js var: (mangleVarName: node name)
		value: (node initializer = nil
			ifTrue: [js ident: 'newspeakUndefinedObject']
			ifFalse: [ node initializer apply: self])
)
temporaryNode: node <TemporaryVariableAST> = (
	^js ident: (mangleVarName: node name)
)
varDeclNode: node <VarDeclNode> = (
	"Produce the corresponding local decl."
	^js var: (mangleVarName: node name)
)
variableNode: node <VariableAST> = (
	^js ident: (mangleVarName: node name)
)
wrapBodyForNlrHandling: body <Block> = (
	| nlrVarNode nlrParamName nlrParamNode |
	nlrVarNode:: js ident: nlrName.
	nlrParamName:: nlrName, '_exception'.
	nlrParamNode:: js ident: nlrParamName.
	^js block: {
		js var: selfName value: (js ident: 'this').
		js var: nlrName value: (js new: (js ident: 'Object') with: {}).
		js try: body catch: nlrParamName with:
			(js block: {
				js if: (js operator: '==' with: nlrVarNode and: nlrParamNode)
					then: (js return: (js propertyOf: nlrParamNode at: (js literal: nlrValuePropertyName)))
					else: (js throw: nlrParamNode)
			})
	}
)
wrapBodyNoNlrHandling: body <Block> = (
	^js block: {js var: selfName value: (js ident: 'this')}, body statements
)'private'
freeNameLiteralOf: block <BlockAST> ^ <Node> = (
	| freeNames <List[Symbol]> vals |
	freeNames:: freeNamesOf: block.
	vals:: freeNames collect:[:n <Symbol> | slotForFreeName: n].
	^js objectLiteralSlotNames: freeNames values: vals
)
slotForFreeName: n <Symbol> ^ <Node> = (
	^js functionOf: {} body:(js return:(js ident:  (mangleVarName:  n)))
)) : ()'as yet unclassified'
accessorForNestedClassNamed: simpleName <String> in: mixinName  <String> superName: superAccessor <Node> ^ <String> = (
"Build  a method that will lazily create a nested class 'simpleName' with superclass defined by 'superAccessor' via mixin application, and cache it.  Maybe replace null slot with self-replacing function that computes class and stores in its closure?"

	| nestedName <String> nestedSlotName <String> nestedSlotNode <Node> |
	nestedName:: fullyQualifySimpleName: simpleName with: mixinName.
	nestedSlotName:: nestedName, syntheticNameSeparator, 'slot'.
	nestedSlotNode:: js propertyOf: (js ident: 'this') at: (js literal: nestedSlotName).
	^js functionOf: {} body: (js block: {
		"if (null == this[<nestedSlotName>] {"
		js if: (js operator: '==' with: (js ident: 'null') and: nestedSlotNode)
			then: (js block: {
				"var nestedMixin = lookupNestedMixin(this, <nestedName>);"
				js var: 'nestedMixin'
					value: (js call: (js ident: 'lookupNestedMixin') with: {js ident: 'this'. js literal: nestedName}).
				"if (nestedMixin == null) internalError(''nested mixin not found'');"
				js if: (js operator: '==' with: (js ident: 'nestedMixin') and: (js ident: 'null'))
					then: (js call: (js ident: 'internalError') with: {js literal: 'nested mixin not found'}).
				"var myNested = invokeMixin(nestedMixin, <superAccessor>().runtimeClass);"
				js var: 'myNested'
					value: (js call: (js ident: 'invokeMixin')
							with: {
								js ident: 'nestedMixin'.
								js propertyOf: superAccessor at: (js literal: 'runtimeClass')
							}).
				"var depth = this['enclosingObjects`<mixinName>'].length;"
				js var: 'depth'
					value: (js operator: '+'
						with: (js ident: 'this["', 'enclosingObjects', syntheticNameSeparator, mixinName, '"].length') "cheat"
						and: (js literal: 1)).
				"var enclosingObjectArray = new Array(depth);"
				js var: 'enclosingObjectArray'
					value: (js new: (js ident: 'Array') with: {js ident: 'depth'}).
				"enclosingObjectArray[0] = this;"
				js assign: (js propertyOf: (js ident: 'enclosingObjectArray') at: (js literal: 0))
					toBe: (js ident: 'this').
				"for (var i = 1; i < depth; i++) { enclosingObjectArray[i] = this.enclosingObjects`<mixinName>[i - 1]; }"
				js for: (js var: 'i' value: (js literal: 1))
					while: (js operator: '<' with: (js ident: 'i') and: (js ident: 'depth'))
					step: (js postfixOperator: '++' on: (js ident: 'i'))
					do: (js assign: (js propertyOf: (js ident: 'enclosingObjectArray') at: (js ident: 'i'))
						toBe: (js propertyOf: (js ident: 'this["enclosingObjects',  syntheticNameSeparator, mixinName, '"]')
								at: (js operator: '-' with: (js ident: 'i') and: (js literal: 1)))).
				"myNested[''enclosingObject`<nestedName>''] = enclosingObjectArray;"
				js assign:
						(js propertyOf: (js ident: 'myNested')
							at: (js literal: 'enclosingObjects', syntheticNameSeparator, nestedName))
					toBe: (js ident: 'enclosingObjectArray').
				"Object.getPrototypeOf(myNested.factory)[''enclosingObjects`<nestedName>''] = enclosingObjectArray;"
				js assign:
					(js propertyOf:
							(js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'getPrototypeOf'))
								with: {js propertyOf: (js ident: 'myNested') at: (js literal: 'factory')})
						at: (js literal: 'enclosingObjects', syntheticNameSeparator, nestedName))
					toBe: (js ident: 'enclosingObjectArray').
				js assign: nestedSlotNode toBe: (js ident: 'myNested').
			}).
		js return: (js propertyOf: nestedSlotNode at: (js literal: 'factory')).
		})
)
accessorForSuperclass: aSelector <String> inScope: s ^ <String> = (
	| dummyMethod <MethodAST> method <Node>  stmt <ReturnStatAST> expression |
	"compute code for accessing superclass. Probably general enough for any code that does not introduce new name bindings "
	stmt:: ReturnStatAST new expr: 
		(NormalSendAST new to: hereNode send: (MessageAST new send: aSelector asSymbol with:{})) .
	dummyMethod:: MethodAST new
		pattern: (MessagePatternAST new selector: #___ parameters:{}) 
		body:(CodeBodyAST new temporaries: {} statements:{stmt}) 
		visibility: #private.
	dummyMethod start: 2; end: 3.
	"create MethodAST representing code"
	scopeMap 
		at: dummyMethod put: currentScope;
	 	at: dummyMethod body put: currentScope;
	 	at: dummyMethod pattern put: currentScope.
	"associate AST with suitable scope"
	method:: (computeMethod: dummyMethod inScope: s) method.
	"compile method and extract source"
	expression:: ReturnedExpressionExtractor new rewrite: method.
	^(IdentifierRewriter replacing: 'self' with: 'this') rewrite: expression
)
addMetadataFor: mixin <ClassMixinMirror> to: object <ObjectLiteral> = (

	| metadataSlots | 

	#BOGUS yourself. "this is not the whole thing"

	metadataSlots:: OrderedCollection withAll: {
		"MKL: We should change this to fullyQualifiedName"
		'name'.
			js literal: mixin name. 
		'simpleName'.
			js literal: (fullyQualifiedNameToSimple: mixin name).
		'isMeta'.
			js literal: mixin isMeta. 
		'language'.
			js literal: parsedLanguage. 
		'methods'.
			js array: ((mixin methods mirrors reject: [:each | each isSynthetic])
					collect: [:each |
							js objectLiteral: {
								'language'. js literal: parsedLanguage. 
								'name'. js literal: each name.
								'source'. js literal: (each src ifNil: [emptyMethodForSelector: each name])}])}.

	mixin isMeta
		ifTrue: [metadataSlots addAll: {
			'slots'. js array: {}}]
		ifFalse: [metadataSlots addAll: {
		"We could store the header only and refrain from storing the source of single slots explicitly. Reconstructing the slots from the source requires the Newspeak parser to be working though, which itself relies on class/slot mirrors being functional to a certain extent. Thus we store the sources of single slots, so that we can at least report the names of slots. Nothing more is required by the parser."
			'header'. js literal: mixin header.
			'slots'. js array: (mixin slots collect: [:each |
				js objectLiteral: {
					'language'. js literal: parsedLanguage. 
					'name'. js literal: each name.
					'source'. js literal: each source.
					'isMutable'. js literal: each isMutable}])},
			(useDnuCatcher
				ifTrue: [{'sentSelectors'. js array: (sentSelectors asArray collect: [:each | js literal: each])}]
				ifFalse: [{}])].
	
	object addSlot: 'metadata' value: (js objectLiteral: metadataSlots).
)
addMethodsOf: mirror <LowLevelMixinMirror> to: object <ObjectLiteral> = (
	mirror methods do:
		[:method <MethodMirror> |
		| nameMustBeQuoted properName |
		nameMustBeQuoted:: method isSynthetic not or: [method isAccessor or: [method isFactory]].
		properName:: nameMustBeQuoted
			ifTrue: ['''#', method name, '''']
			ifFalse: [method name].
		object addSlot: properName value: method method]
)
addMixinHandleAccessorTo: object = (

	| mixinAccessor |
	"We used to generate a single mixin accessor method in newspeakClassRC. We changed to generating a method per mixin, so that mixin handles can also be accessed when only the mixin object is available."
	mixinAccessor:: js
		functionOf: {}
		body: (js block: {
			js return: (js call: (js ident: 'mixinHandleFor') with: {js ident: 'this'})}).

	object
		addSlot: 'mixinHandle'
		value: mixinAccessor
)
addNestedClassesFor: mixin <MixinRep> to: object <ObjectLiteral> = (
	| nestedMixins |
	nestedMixins:: js objectLiteral.
	mixin last do:
		[:rep <MixinRep> |
		nestedMixins
			addSlot: rep first name
			value: (translateMixinRep: rep)].
	object addSlot: 'nestedMixins' value: nestedMixins.
)
addNestedMixinsFromNamespaceFor: mixin <MixinRep> to: object <ObjectLiteral> = (
	| nestedMixins |
	nestedMixins:: js objectLiteral.
	mixin last do:
		[:rep <MixinRep> |
		nestedMixins
			addSlot: rep first name
			value: (js
				propertyOf: (js ident: mixinNamespace)
				at: (js literal: rep first name))].
	object addSlot: 'nestedMixins' value: nestedMixins.
)
beginNewCompileCycle = (
	scopeStack:: OrderedCollection new.
)
checkForDuplicateNames: aNode = (

	| namesWithDuplicates names duplicateNames |
	
	namesWithDuplicates:: OrderedCollection new.
	aNode instanceSide categories do: [:cat |
		cat methods do: [:each | namesWithDuplicates add: each selector]].
	
	aNode hdr slots do: [:each |
		namesWithDuplicates add: each name.
		each isMutable ifTrue: [namesWithDuplicates add: each name, ':']].
	
	namesWithDuplicates
		addAll: (aNode instanceSide nestedClasses collect: [:each | each name]).

	names:: Set new.
	duplicateNames:: Set new.
	namesWithDuplicates do: [:each | | present |
		present:: true.
		names include: each ifNew: [present:: false].
		present ifTrue: [duplicateNames add: each]].
	
	duplicateNames isEmpty ifFalse: [ | message |
		message:: String streamContents: [:s |
			s
				nextPutAll: 'Class ';
				nextPutAll: aNode name;
				nextPutAll: '" has multiple definitions for '.
			duplicateNames
				do: [:each | s nextPutAll: each asString]
				separatedBy: [ s nextPutAll: ','].
			s nextPutAll: '.'.].
		assert: false message: message].

)
classNode: aNode <ClassDeclarationAST> ^ <MixinRep> = (
"type MixinRep = {CompiledMixinMirror. {MixinRep}}"
	| mixinMirror <LowLevelMixinMirror> nestedClasses <Collection[MixinRep]> priorMixinUID <String> |
	assert: [aNode hdr category notNil] message: 'No category for class header'.
	checkForDuplicateNames: aNode.
	mixinMirror:: computeMixinFrom: aNode hdr.
	priorMixinUID:: currentMixinUID.
	currentMixinUID::  mixinMirror name.
	currentDepth::currentDepth + 1.
	nestedClasses:: processInstanceSideOf: aNode ofMixin: mixinMirror lowLevelMirror.
	generateSlotAccessorsFor: mixinMirror lowLevelMirror. 
	"must be called after nested classes are processed, so all synthetic slots have been added"
	processClassSideOf: aNode ofMixin: mixinMirror lowLevelMirror classMixin.
	currentDepth::currentDepth - 1.
	currentMixinUID:: priorMixinUID.
	^{mixinMirror. nestedClasses}
)
compileClassSource: source <ReadStream> within: enclosing <MixinMirror> ^<CompiledMixinMirror> = (
	| tree <AST> mixinRep <MixinRep> |
	tree:: parser classDefinition parse: source.
	setInput: source.
	setScopeFor: tree in: enclosing.
	sentSelectors:: Set new.
	mixinRep:: classNode: tree.
	scopeMap:: Dictionary new.
	^enclosing isNil ifTrue:[mixinRep] ifFalse:[{enclosing. mixinRep}].
)
compileMethodSource: source <ReadStream> within: enclosing <MixinMirror> ^<MethodMirror> = (
	| tree <AST> |
	tree:: parser methodDecl parse: source.
	setScopeFor: tree in: enclosing.
	jsTree:: translateMethodNode: tree.
	scopeMap:: Dictionary new.
	^jsTree
)
compileNestedClasses: nestedClasses <Collection[ClassDeclarationAST]> within: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	| results <OrderedCollection[MixinRep]> |
      results:: OrderedCollection new.
	nestedClasses do:
		[ :nc <ClassDeclarationAST> |  
			| nSlotName <String> nSlot <InstanceVariableMirror> |
		nc hdr category: mixinMirror category, '-nested'.
		nSlotName:: slotNameForNestedClassNamed: nc name 
		                   within: mixinMirror name.
		nSlot:: InstanceVariableMirror named: nSlotName.
		nSlot metadata at: #isSynthetic put: true.
		mixinMirror instVars addMirror: nSlot.
		results add: (classNode: (nestedMixinWrapperFor: nc in: mixinMirror)). "make 'mixin' (a Smalltalk subclass of ProtoObject) for nested class"
		createNestedClassAccessorFrom: nc within: mixinMirror
		].
	^results
)
compileNestedClassesOf: aNode <SideAST> within: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	"where do we check that nested classes do not conflict with each other, or with methods or slots?"
	^compileNestedClasses: aNode nestedClasses within: mixinMirror
)
compileWithFullInfoTopLevelClassSource: source <ReadStream> = (
	| tree rep mixinAst ast output |
	tree:: parser classDefinition parse: source.
	setInput: source.
	setScopeFor: tree in: nil.
	sentSelectors:: Set new.
	rep:: classNode: tree.
	mixinAst:: translateMixinRep: rep. 
	ast:: js
		propertyOf: (js
			call: (js ident: 'makeTopLevelClass')
			with: {mixinAst})
		at: (js literal: 'factory').
	output:: WriteStream on: (MutableString new: 100).
	jsWriter generateSourceFor: ast on: output.
	^{	output contents.
		jsWriter nsIntervals.
		jsWriter jsIntervals.
		tree.
		ast
	}
)
computeMethod: aNode <MethodAST> inScope: s <Scope> = (
	|  scopeBuilder <ScopeBuilder>  |
	scopeBuilder:: ScopeBuilder nestedIn: s atLevel: currentDepth.
	aNode apply: scopeBuilder.
	"need to build scope for method before visiting it"
	^methodNode: aNode.
)
computeMixinFrom: aNode <ClassHeaderAST> ^ <LowLevelMixinMirror> = (
	| ivNames <Collection[String]> mixinMirror <LowLevelMixinMirror> hdrString <String> |
	ivNames::   aNode slots collect:[:s | s name].
	mixinMirror:: LowLevelMixinMirror named: aNode name isMeta: false.
	ivNames do:
		[:iv | 
		mixinMirror instVars addMirror: (InstanceVariableMirror named: iv)].
	hdrString:: input contents copyFrom: aNode start to: aNode end.
	^(CompiledMixinMirror language: language header: hdrString mirror: mixinMirror)
		factoryName: aNode constructor selector;
		category: aNode category;
		comment: (aNode classComment isNil 
			ifTrue: [''] 
			ifFalse: [aNode classComment]);
		slots: (
			aNode slots collect: [:each | | source |
				source:: input contents copyFrom: each start to: each end.
				SlotMirror named: each name source: source isMutable: each isMutable]).
)
createNestedClassAccessorFrom: classDecl <ClassDeclarationAST> within: mixinMirror <LowLevelMixinMirror> = (
"Create an accessor method for the nested class represented by the incoming class tree.
This accessor will lazily generate the nested class when its enclosing instance is first asked for it."

	| n <String>  accessorString <String> methodSrc <String>  hdr <ClassHeaderAST> accessor <MethdMirror>  |
	hdr:: classDecl hdr.
	n:: hdr name. 
	methodSrc:: 
		accessorForNestedClassNamed: n 
		in:  mixinMirror name 
		superName: (accessorForSuperclass: hdr superclassName inScope:  (scopeMap at: classDecl instanceSide)).
	accessor:: MethodMirror named: (translator mangleMethodName: classDecl name asSymbol).
	accessor method: methodSrc.
	accessor isSynthetic: true.
	mixinMirror methods addMirror: accessor.
)
createSlotsFor: aNode <ClassHeaderAST> ^ <String> = (
	| assignments |
	assignments:: aNode  slots collect:
		[:slot <SlotDefAST> |
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: slot name))
			toBe: (js ident: 'newspeakUndefinedObject')].
 	^js functionOf: {}
		body: (js block: (assignments asArray, {js return: (js ident: 'this')}))
)
currentScope ^<Scope> = (
	^scopeStack last
)
emptyMethodForSelector: selector = (

	| result counter |
	result:: ''.
	counter:: 1.
	"Could use some generic substring-replacement mechanism.
	Should not construct a new string on every iteration."
	selector do: [:each | | next |
		next:: each = $:
			ifTrue: [': x', counter asString]
			ifFalse: [each asString].
		result:: result, next.].
	^ result, ' = ("generated")'
)
generateSlotAccessorsFor: m <MixinMirror>  = (
"We need getter FUNCTIONS so we can call them uniformly with arguments (albeit empty ones)"
	|  ivs <Collection[InstanceVariableMirror]> |
	ivs:: m instVars collect: [:iv | iv]. "Gross - extract a collection from the mirror group"
	ivs do: [: iv  | 
		| getter <MethodMirror> getterJS <Node> setter <MethodMirror> setterJS <Node> ivName <String> |
		ivName:: iv name.
		getter:: MethodMirror named: ivName.
		getterJS:: js functionOf: {} body: (js block: {
			js return: (js propertyOf: (js ident: 'this') at: (js literal: ivName))
			}).
		getter method: getterJS.	
		getter isAccessor: true.				
		m methods addMirror:  getter.
		setter:: MethodMirror named: (ivName, ':') asSymbol. "produce setters only for mutable slots?"
		setterJS:: js functionOf: {'v'} body: (js block: {
			(js assign: (js propertyOf: (js ident: 'this') at: (js literal: ivName))
				toBe: (js ident: 'v')).
			js return: (js ident: 'this')
			}).
		setter method: setterJS.
		setter isAccessor: true.				
		m methods addMirror:  setter.
		]	
)
hereNode ^ <VariableAST> = (
"Generate a an AST representing `here; used for here sends. We use a string so that we can represent a name that is not a legal identier."

	^VariableAST new name: #'_here' ; start: 0; end: 0.
)
initializerFor: aNode <ClassHeaderAST> ^ <MethodAST> = (
| 
stmts  <Collection[StatementAST]>
start <Integer>  
end <Integer> 
initHdr <MessagePatternAST>
body <CodeBodyAST> 
copier <ASTCopier> 
params <List[VarDeclAST]>
|

 start:: aNode superConstructorCall start.
 end::  aNode  superConstructorCall end.
 copier:: ASTCopier new.
  params:: aNode constructor parameters collect:[:formal | formal apply: copier].
  initHdr:: MessagePatternAST new selector: #instanceInitializer parameters: params;
				start: start; end: end. 
"set up scope with constructor parameters"
 stmts::  aNode  slots collect:[:slot <SlotDefAST> | | aMsg <MessageAST> |
	aMsg:: MessageAST new send: (slot name, ':') asSymbol 
					   with:  {slot initializer apply: copier} ;
					   start: slot  start; end: slot end.
	"still relying on setter for slot initialization - probably fixable here"
	NormalSendAST new msg: aMsg; 
                          recv: (selfNode start: aMsg start; end: aMsg end);
                          start: aMsg start; end: aMsg end.			
	].

 stmts addAll: (aNode initExprs collect:[:ie | ie apply: copier]).
 body:: CodeBodyAST new temporaries: OrderedCollection new
                                       statements: stmts; 
                                       start: start; end: end.
 ^MethodAST new pattern: initHdr
                            body: body
                            visibility: #public; 
                            start: start; end: end.
)
language = (
	^#NewspeakLanguage2
)
makeCreateSlotsFor: hdr <ClassHeaderAST>  within: mixinMirror <LowLevelMixinMirror> ^ <MethodAST> = (
"Create the method that initializes the slots defined by the class declaration to nil"
	| accessor <MethdMirror>  |
	accessor:: MethodMirror named: #createSlots.
	accessor method: (createSlotsFor: hdr).
	accessor isSynthetic: true.
	mixinMirror methods addMirror: accessor.
)
methodNode: aNode <MethodAST> ^ <MethodMirror> = (
	| tree <AST> jsTree |
	tree:: aNode apply: rewriter.  "rewrite ast"
	translator beginNewTranslationCycle.
	jsTree:: tree apply: translator.	 "final pass: visit rewritten ast"
	"pop scope?"
	^((MethodMirror named: translator currentSelector)
		method: jsTree)
			src: (sourceForNode: aNode)
)
mixinNamespace = (

	^ 'globalMixinNamespace'
)
nestScope: scope <Scope> = (
	"Hook up a new lexically nested scope, and push onto the scope stack"
	scope superScope: currentScope.
	pushScope: scope
)
nestedMixinWrapperFor: nested <ClassDeclarationAST> in: outerClass <MixinMirror>  ^ <ClassDeclarationAST> = (
"Wrap a class declaration to make it look like a nested mixin within outerClass should. This includes making the name be the fully qualified name, and hiding the superclass."

	| wrapper <ClassDeclarationAST> |
	wrapper:: nested clone.
	wrapper hdr: nested hdr clone.
	wrapper hdr name: (fullyQualifySimpleName: nested name with: outerClass name).
	^wrapper
)
outputClass: mixinRep <MixinRep> toNamespace: namespace <FilePattern> = (

	| ast simpleName |
	
	simpleName:: (fullyQualifiedNameToSimple: mixinRep first name).
	
	mixinRep last do: [:each |
		outputClass: each toNamespace: namespace / simpleName].
	
	ast:: js script: {js
		assign: (js propertyOf: (js ident: mixinNamespace) at: (js literal: mixinRep first name))
		toBe: (translateMixinRepWithNestedMixinsFromNamespace: mixinRep)}.
	
	(namespace / (simpleName, '.js')) stream: [:stream |
		jsWriter generateSourceFor: ast on: stream].
	
)
outputCreationOfClass: mixinRep <MixinRep> to: stream<[WriteStream]> = (

	| ast |
	ast:: js
		propertyOf: (js
			call: (js ident: 'makeTopLevelClass')
			with: {js propertyOf: (js ident: mixinNamespace) at: (js literal: mixinRep first name)})
		at: (js literal: 'factory').

	jsWriter generateSourceFor: ast on: stream
)
outputInfrastructureCodeTo: stream = (

	InfrastructureFunctions new outputTo: stream.
	Phase1Platform new outputTo: stream.
)
outputTopLevelClass: rep <MixinRep> to: stream <WriteStream> = (
	| mixinAst ast |
	mixinAst:: translateMixinRep: rep. 
	ast:: js
		propertyOf: (js
			call: (js ident: 'makeTopLevelClass')
			with: {mixinAst})
		at: (js literal: 'factory').
		
	jsWriter generateSourceFor: ast on: stream.
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
processClassSideOf: aNode <ClassAST> ofMixin: mixinMirror <LowLevelMixinMirror> = (
	"| primaryFactory <MethodMirror> factoryAST <MethodAST> |"
	processFactoryFor: aNode in: mixinMirror.
	processSide: aNode classSide ofMixin: mixinMirror. "compile class methods"
)
processFactoryFor: aNode <ClassAST> in: mixinMirror <LowLevelMixinMirror> = (
	| accessor <MethdMirror> argNames ast |
	accessor:: MethodMirror named: aNode hdr constructor selector.
	argNames:: (aNode hdr constructor parameters collect: [:each | translator mangleVarName: each name]) asArray.
	ast:: js functionOf: argNames body: (js block: {
		js return:
			(js call: (js ident: 'this.basicNew().instanceInitializer') "cheat!"
				with: (argNames collect: [:each | js ident: each]))
		}).
	accessor method: ast.
	mixinMirror methods addMirror: accessor.
)
processInitializerFor: aNode <ClassAST> in: mixinMirror <LowLevelMixinMirror> = (
	processMethod: (superConstructorMethodFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinMirror. 
	makeCreateSlotsFor: aNode hdr within: mixinMirror.
	processMethod: (initializerFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinMirror.
)
processInstanceSideOf: aNode <ClassAST> ofMixin: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	| side <SideAST> |
	processInitializerFor: aNode in: mixinMirror.
	side:: aNode instanceSide.
	processSide: side ofMixin: mixinMirror. "compile instance methods"
	^compileNestedClassesOf: side within: mixinMirror. "gather nested classes"
)
processMethod: aNode <MethodAST> inScope: s <Scope>  in: mixinMirror <LowLevelMixinMirror> = (
	|  method <MethodMirror> |
	method:: computeMethod: aNode inScope: s.
	method isSynthetic: true.
	mixinMirror methods addMirror: method.
	"install method"	
)
processSide: side <SideAST> ofMixin: mixinMirror <LowLevelMixinMirror> = (
	side categories do:
		[:cat |
		| mirror <MethodMirror> |
		cat methods do: [:m | 
			"who checks that the methods do not conflict with each other or with another slot or class in the same enclosing class? The mirror or the compiler?"
			mirror:: methodNode: m.
			mirror metadata at: #category put: cat.
			mixinMirror methods addMirror: mirror]].
)
pushScope: scope <Scope> = (
	scopeStack addLast: scope
)
selfNode ^ <VariableAST> = (
	"generate a an AST representing self; used for implicit self sends"
	^VariableAST new name: #self; start: 0; end: 0
)
setInput: source <ReadStream> = (
	source position: 1.
	input: source. "save the input"
)
setScopeFor: node <AST> in: enclosing <MixinMirror | nil> = (
	| scopeBuilder |
	pushScope: Scope new.
	enclosing notNil ifTrue: [nestScope:: ScopeBuilder new buildScopeFor: enclosing].
	currentDepth:: currentScope depth - 1.
	scopeBuilder:: ScopeBuilder nestedIn: currentScope atLevel: currentDepth.
	node apply: scopeBuilder
)
slotNameForNestedClassNamed: ncn <String> within: outerName <String> ^ <String> = (
	^mixinSlotNameFor:
		(fullyQualifySimpleName: ncn with: outerName). 
)
sourceForNode: node <AST> ^ <String> = (
	| savedPos <Integer> pos <Integer> len <Integer> s <String> |
	"^String withAll: (input copyFrom: node start to: node end"
	savedPos:: input position.
	len: (node end - node start) + 1.
	s:: MutableString new: len.
	input position: node start -1.
	1 to: len do:
		[:index |
		s at: index put: input next].	
	input position: savedPos.
	^s
)
superConstructorMethodFor:  aNode <ClassHeaderAST> ^ <MethodAST> = (
| 
start <Integer> 
end <Integer>
stmts <List[StmtAST]> 
var  <VariableAST> 
initHdr <MessagePatternAST>
superMsg <MessageAST> 
send <NormalSendAST>
body  <CodeBodyAST>
copier <ASTCopier>
params <List[VarDeclAST]>
args <List>
|

	start:: aNode superConstructorCall start.
	end::  aNode  superConstructorCall end.
	copier:: ASTCopier new.
	params:: aNode constructor parameters collect:[:formal | formal apply: copier].
	initHdr:: MessagePatternAST new selector: (superConstructorNameFor: aNode) parameters: params;
				start: start; end: end. 
	"set up scope with constructor parameters"
	"create call to superclass initializer"
	stmts:: OrderedCollection new. 
	var:: VariableAST new name: #super; start: start; end: end.
	args:: aNode superConstructorCall args collect:[:actual | actual apply: copier].
	superMsg::  PropertyCallAST new send: 'instanceInitializer' with: args; 
				start: start; end: end. 
	"only copy actual args"
	"send these as a tuple? to super instance initializer?"
	send:: NormalSendAST new to: var send: superMsg; start: start; end: end. 
	stmts addFirst: send.
	body:: CodeBodyAST new temporaries: OrderedCollection new
                                       	statements: stmts;
                                      	start: start; end: end.
	^MethodAST new pattern: initHdr
                            body: body
                            visibility: #private;
                            start: start; end: end	
)
superConstructorNameFor: aNode <ClassHeaderAST> ^ <Symbol> = (
	^#superInit
)
translateMethodNode: method <MethodAST> = (
	| tree <AST> |
	tree:: method apply: rewriter.
	translator beginNewTranslationCycle.
	^tree apply: translator.
)
translateMixinRep: mixin <MixinRep> = (
	| mirror <LowLevelMixinMirror> object |
	mirror:: mixin first lowLevelMirror.
	object:: js objectLiteral.
	mirror isMeta ifFalse: [
		| classMixinObject |
		classMixinObject:: js objectLiteral.
		addMetadataFor: mirror classMixin to: classMixinObject.
		addMixinHandleAccessorTo: classMixinObject.
		addMethodsOf: mirror classMixin to: classMixinObject.
		object addSlot: 'classMixin' value: classMixinObject.
		addNestedClassesFor: mixin to: object.
		addMetadataFor: mixin first to: object].
	addMixinHandleAccessorTo: object.
	addMethodsOf: mirror to: object.
	^object
)
translateMixinRepWithNestedMixinsFromNamespace: mixin <MixinRep> = (
	| mirror <LowLevelMixinMirror> object |
	mirror:: mixin first lowLevelMirror.
	object:: js objectLiteral.
	mirror isMeta ifFalse: [
		| classMixinObject |
		classMixinObject:: js objectLiteral.
		addMetadataFor: mirror classMixin to: classMixinObject.
		addMixinHandleAccessorTo: classMixinObject.
		addMethodsOf: mirror classMixin to: classMixinObject.
		object addSlot: 'classMixin' value: classMixinObject.
		addNestedMixinsFromNamespaceFor: mixin to: object.
		addMetadataFor: mixin first to: object].
	addMixinHandleAccessorTo: object.
	addMethodsOf: mirror to: object.
	^object
)
writeJascriptAST: node <Node> ^<String> = (
	| writer |
	writer:: JavascriptWriter on: '' writeStream.
	writer generateSourceFor: node.
	^writer contents
)) : ()
class DebuggableJavascriptWriter = JavascriptWriter (
"Extends the superclass with behavior that computes debugging info.."| 
nsIntervals = SortedList
	sortBlock:[:ci1 <CodeInterval>  :ci2 <CodeInterval> | ci1 start <= ci2 start]. 
jsIntervals =  SortedList
	sortBlock:[:ci1 <CodeInterval>  :ci2 <CodeInterval> | ci1 start <= ci2 start]. 
|)
('as yet unclassified'
addDebugInfoFor: node <Node> start: start <integer>  = (
| jsci <CodeInterval> nsci <CodeInterval> nsNode <AAST> |
	nsNode:: jsNodeMap at: node ifAbsent: [ nil ]. 
	nsNode = nil
		ifFalse: [
			jsci:: CodeInterval start: start end: output position -1. " JS info"
			nsci:: CodeInterval start: nsNode start end: nsNode end. "NS info"
			assert: [ start isNumber ].
			assert: [ nsNode start isNumber ].
			assert: [ nsNode end isNumber ].
			nsci reference: jsci.
			jsci reference: nsci.
			nsIntervals add: nsci.
			jsIntervals add: jsci ]
		ifTrue: [
			jsci:: CodeInterval start: start end: output position - 1.
			jsIntervals add: jsci ]
			
)
visitArrayExpression: node <ArrayExpression> = (
	| start <Integer> |
	start:: output position.
	super visitArrayExpression: node.
	addDebugInfoFor: node start: start.
)
visitAssignmentExpression: node <AssignmentExpression> = (
	| start <Integer> |
	start:: output position.
	super visitAssignmentExpression: node.
	addDebugInfoFor: node start: start.
)
visitBlock: node <Block> = (
	| start <Integer> |
	start:: output position.
	super visitBlock: node.
	addDebugInfoFor: node start: start.
)
visitBooleanLiteral: node <BooleanLiteral> = (
	| start <Integer> |
	start:: output position.
	super visitBooleanLiteral: node.
	addDebugInfoFor: node start: start.
)
visitCallExpression: node <CallExpression> = (
	| start <Integer> |
	start:: output position.
	super visitCallExpression: node.
	addDebugInfoFor: node start: start.
)
visitForInStatement: node <Node> = (
	| start <Integer> |
	start:: output position.
	super visitForInStatement: node.
	addDebugInfoFor: node start: start.
)
visitForStatement: node <Node> = (
	| start <Integer> |
	start:: output position.
	super visitForStatement: node.
	addDebugInfoFor: node start: start.
)
visitFunctionExpression: node <FunctionExpression> = (
	| start <Integer> |
	start:: output position.
	super visitFunctionExpression: node.
	addDebugInfoFor: node start: start.
)
visitFunctionStatement: node <FunctionStatement> = (
	| start <Integer> |
	start:: output position.
	super visitFunctionStatement: node.
	addDebugInfoFor: node start: start.
)
visitIdentifierExpression: node <IdentifierExpression> = (
	| start <Integer> |
	start:: output position.
	super visitIdentifierExpression: node.
	addDebugInfoFor: node start: start.
)
visitIfStatement: node <IfStatement> = (
	| start <Integer> |
	start:: output position.
	super visitIfStatement: node.
	addDebugInfoFor: node start: start.
)
visitIntegerLiteral: node <IntegerLiteral> = (
	| start <Integer> |
	start:: output position.
	super visitIntegerLiteral: node.
	addDebugInfoFor: node start: start.
)
visitMemberExpression: node <MemberExpression> = (
	| start <Integer> |
	start:: output position.
	super visitMemberExpression: node.
	addDebugInfoFor: node start: start.
)
visitNewExpression: node <NewExpression> = (
	| start <Integer> |
	start:: output position.
	super visitNewExpression: node.
	addDebugInfoFor: node start: start.
)
visitObjectLiteral: node <ObjectLiteral> = (
	| start <Integer> |
	start:: output position.
	super visitObjectLiteral: node.
	addDebugInfoFor: node start: start.
)
visitOperatorExpression: node <OperatorExpression> = (
	| start <Integer> |
	start:: output position.
	super visitOperatorExpression: node.
	addDebugInfoFor: node start: start.
)
visitReturnStatement: node <ReturnStatement> = (
	| start <Integer> |
	start:: output position.
	super visitReturnStatement: node.
	addDebugInfoFor: node start: start.
)
visitScript: node <Script> = (
	| start <Integer> |
	start:: output position.
	super visitScript: node.
	addDebugInfoFor: node start: start.
)
visitStringLiteral: node <StringLiteral> = (
	| start <Integer> |
	start:: output position.
	super visitStringLiteral: node.
	addDebugInfoFor: node start: start.
)
visitThrowStatement: node <ThrowStatement> = (
	| start <Integer> |
	start:: output position.
	super visitThrowStatement: node.
	addDebugInfoFor: node start: start.
)
visitTryStatement: node <TryStatement> = (
	| start <Integer> |
	start:: output position.
	super visitTryStatement: node.
	addDebugInfoFor: node start: start.
)) : ()
class InfrastructureFunctions = (
"Definitions of basic JS functions required to construct classes, etc. A Phase1Platform loaded later provides the official definitions of Object, String, Array and similar classes."|
|)
('as yet unclassified'
blockPrototype  = (
 ^js objectLiteral: {
			'#numArgs'. js functionOf: {}
				body: (js block: {js verbatim: 'return this.jsFun.length'}).
			'#class'. js functionOf: {}
				body: (js block: ({js verbatim: 'return newspeakBlockFactory'})).
			'#ensure:'. js functionOf: {'b'}
				body: (js block: {
					js try: (js block: {
						js return: (js verbatim: 'this.jsFun.call(this.jsFun)')
					}) finally: (js block: {
						js verbatim: 'b["#value"]()'
					})
				}).
			'#on:do:'. js functionOf: {'errorSpec'. 'handler'}
				body: (js block: {
					js try: (js block: {
						js return: (js verbatim: 'this.jsFun.call(this.jsFun)')
					}) catch: 'e' with: (js block: {
						js if: (js call:
									(js propertyOf: (js propertyOf: (js ident: 'errorSpec') at: (js literal: 'runtimeClass'))
										at: (js literal: 'isPrototypeOf')) 
								with: {js ident: 'e'})
							then: (js block: {
								js return: (js verbatim: 'handler.call(handler, e)')
								})
							else: (js block: {
								js throw: (js ident: 'e')
							})
					})
				}).
			'#value'. js functionOf: {}
				body: (js block: {js verbatim: 'return this.jsFun.call(this.jsFun)'}).
			'#value:'.  js functionOf: {'a'}
				body: (js block: {js verbatim: 'return this.jsFun.call(this.jsFun, a)'}).
			'#value:value:'. js functionOf: {'a'. 'b'}
				body: (js block: {js verbatim: 'return this.jsFun.call(this.jsFun, a, b)'}).
			'#value:value:value:'. js functionOf: {'a'. 'b'. 'c'}
				body: (js block: {js verbatim: 'return this.jsFun.call(this.jsFun, a, b, c)'}).
			'#value:value:value:value:'. js functionOf: {'a'. 'b'. 'c'.'d'}
				body: (js block: {js verbatim: 'return this.jsFun.call(this.jsFun, a, b, c, d)'}).
			'#valueWithArguments:'. js functionOf: {'args'}
				body: (js block:{js verbatim: 'return this.jsFun.apply(this.jsFun, args)'}).
			'#whileFalse:'. js functionOf: {'b'}
				body: (js block: {js verbatim: 'while(!this.jsFun.call(this.jsFun)) {b["#value"]()}'}).
			'#whileTrue:'. js functionOf: {'b'}
				body: (js block: {js verbatim: 'while(this.jsFun.call(this.jsFun)) {b["#value"]()}'})
} 
)
dnuCatcher = (
	^useNoSuchMethod
		ifTrue: [js objectLiteral: {'__noSuchMethod__'. dnuHandler}]
		ifFalse: [js objectLiteral: {'dnuHandler'. dnuHandler}]
)
dnuHandler = (
"function (selector, args) {
	return this['#doesNotUnderstand:'](constructMessageFromArgumentsObject(selector, args, 0));
	}
}"
	^js functionOf: {'selector'. 'args'} body: (js block: {
		js return:
			(js call: (js propertyOf: (js ident: 'this') at: (js literal: '#doesNotUnderstand:'))
				with: {js call: (js ident: 'constructMessage')
						with: {js ident: 'selector'. js ident: 'args'. js literal: 0}})
	})
)
exportName: name = (
	^js if: (js operator: '==' with: (js call: (js ident: 'javascriptEngineName') with: {}) and: (js literal: 'NodeJS'))
			then: (js block: {js assign: (js propertyOf: (js ident: 'this') at: (js literal: name)) toBe: (js ident: name)})
)
exportedFunction: name of: args body: body = (
	^{
		js function: name of: args body: body.
		exportName: name
	}
)
exportedVariable: name value: value = (
	^{
		js var: name value: value.
		exportName: name
	}
)
fastRdlConfigExpression = (
	^{
	js verbatim: 'if (typeof sap != "undefined") {
	if (typeof sap.river.config.fastRdl == "undefined" || sap.river.config.fastRdl == false)  {
		sap.river.config.fastRdl = false;
		globalAlienFlag = "Smart";
	} else {
		globalAlienFlag = "Naive";
	}
}'
	}
)
functionAddAlienCompatibilityMarkers = (

	| primitivePrototypes respondToNewspeakMessages |
	primitivePrototypes::
		{'Array'. 'Boolean'. 'Function'. 'Number'. 'String'} collect: [:each |
			 js
				propertyOf: (js ident: each)
				at: (js literal: 'prototype')].

	respondToNewspeakMessages:: primitivePrototypes,
		{js ident: 'blockPrototype'. js ident: 'newspeakObjectRC'. js ident: 'newspeakClassRC'}.

	^{js function: 'addAlienCompatibilityMarkers' of: {} body: (js block: 
		 (respondToNewspeakMessages collect: [:each |
			js
				assign: (js
					propertyOf: each
					at: (js literal: 'respondsToNewspeakMessages'))
				toBe: (js ident: 'true')]),
		(primitivePrototypes collect: [:each |
			js call: (js ident: 'makePropertyNotEnumerable') with: {each. js literal: 'respondsToNewspeakMessages'}]),
		 (primitivePrototypes collect: [:each |
			js
				assign: (js
					propertyOf: each
					at: (js literal: 'canActAsExpat'))
				toBe: (js ident: 'true')]),
		(primitivePrototypes collect: [:each |
			js call: (js ident: 'makePropertyNotEnumerable') with: {each. js literal: 'canActAsExpat'}])
	)}
)
functionAugmentArray = (
	"No need to export, this function is only invoked once right after it is declared."
	^{js function: 'augmentArray' of: {} body:
		(js block:
			(augmentPrototypeOf: 'Array' withMethod: '#value' args: {}
				body: {js verbatim: 'return this'}),
			(augmentPrototypeOf: 'Array' withMethod: '#class' args: {}
				body: {js verbatim: 'return newspeakArrayFactory'}), "var newspeakArrayFactory, defined later by Phase1Platform"
			(augmentPrototypeOf: 'Array' withMethod: '#size' args: {}
				body: {js verbatim: 'return this.length'}),
			(augmentPrototypeOf: 'Array' withMethod: '#at:' args: {'i'}
				body: {
					js verbatim: 'var elt = this[i-1]'.
					js verbatim: 'return elt == undefined ? newspeakUndefinedObject : elt'
				}),
			(augmentPrototypeOf: 'Array' withMethod: '#at:put:' args: {'i'. 'v'}
				body: {js verbatim: 'return this[i-1]=v'}),
			(augmentPrototypeOf: 'Array' withMethod: '#do:' args: {'b'}
				body: {
					js verbatim: 'for (var i=0; i<this.length; i++) {
						var elt = this[i];
						b["#value:"](elt == undefined ? newspeakUndefinedObject : elt);
					}'.
					js verbatim: 'return this'
				}),
			(augmentPrototypeOf: 'Array' withMethod: '#keysAndValuesDo:' args: {'b'}
				body: {
					js verbatim: 'for (var i=0; i<this.length; i++) {
						var elt = this[i];
						b["#value:value:"](i+1, elt == undefined ? newspeakUndefinedObject : elt);
					}'.
					js verbatim: 'return this'
				}),
			(augmentPrototypeOf: 'Array' withMethod: '#add:' args: {'newElement'}
				body: {
					js verbatim: 'this.push(newElement)'.
					js verbatim: 'return this;'
				}),
"			(augmentPrototypeOf: 'Array' withMethod: '#,' args: {'otherArray'}
				body: {js verbatim: 'return this.concat(otherArray)'}),"
			(augmentPrototypeOf: 'Array' withMethod: '#reverse' args: {}
				body: {
					js verbatim: 'var result = [];
					for (var i=this.length - 1; i>=0; i--) {
							result.push(this[i]);
					}'.
					js verbatim: 'return result'
				})
		)
	}
)
functionAugmentBoolean = (
	"No need to export, this function is only invoked once right after it is declared."
	^{js function: 'augmentBoolean' of: {} body:
		(js block:
			(augmentPrototypeOf: 'Boolean' withMethod: '#value' args: {}
				body: {js verbatim: 'return this'}),
			(augmentPrototypeOf: 'Boolean' withMethod: '#=' args: {'o'}
				body: {js verbatim: 'return this.valueOf() == o'}),
			(augmentPrototypeOf: 'Boolean' withMethod: '#==' args: {'o'}
				body: {js verbatim: 'return this == o'}),
			(augmentPrototypeOf: 'Boolean' withMethod: '#and:' args: {'b'}
				body: {js verbatim: 'return (this == true) && b["#value"]()'}),
			(augmentPrototypeOf: 'Boolean' withMethod: '#class' args: {'o'}
				body: {js verbatim: 'return this.valueOf() ? newspeakTrueFactory : newspeakFalseFactory'}),
			"The explicit tests for 'this == true' are necessary because 'this' is a boxed boolean value,
			and a boxed false is 'truthy' with respect to the if statement and the ?: operator."
			(augmentPrototypeOf: 'Boolean' withMethod: '#ifFalse:' args: {'b'}
				body: {js verbatim: 'return this == true ? newspeakUndefinedObject : b["#value"]()'}),
			(augmentPrototypeOf: 'Boolean' withMethod: '#ifFalse:ifTrue:' args: {'fb'. 'tb'}
				body: {js verbatim: 'return this == true ? tb["#value"]() : fb["#value"]()'}),
			(augmentPrototypeOf: 'Boolean' withMethod: '#ifTrue:' args: {'b'}
				body: {js verbatim: 'return this == true ? b["#value"]() : newspeakUndefinedObject'}),
			(augmentPrototypeOf: 'Boolean' withMethod: '#ifTrue:ifFalse:' args: {'tb'. 'fb'}
				body: {js verbatim: 'return this == true ? tb["#value"]() : fb["#value"]()'}),
			(augmentPrototypeOf: 'Boolean' withMethod: '#not' args: {}
				body: {js verbatim: 'return !this.valueOf()'}),
			(augmentPrototypeOf: 'Boolean' withMethod: '#or:' args: {'b'}
				body: {js verbatim: 'return (this == true) || b["#value"]()'})
		)
	}
)
functionAugmentFunction = (
	"No need to export, this function is only invoked once right after it is declared."
	"function augmentFunction(){
		Function.prototype[''#value''] = function () {return this.apply();};
	}"
	^{js function: 'augmentFunction' of: {} body:
		(js block:
			(augmentPrototypeOf: 'Function' withMethod: '#numArgs' args: {}
				body: {js verbatim: 'return this.length'}),
			(augmentPrototypeOf: 'Function' withMethod: '#class' args: {}
				body: {js verbatim: 'return newspeakBlockFactory'}),
			(augmentPrototypeOf: 'Function' withMethod: '#ensure:' args: {'b'}
				body: {
					js try: (js block: {
						js return: (js verbatim: 'this.call(this)')
					}) finally: (js block: {
						js verbatim: 'b["#value"]()'
					})
				}),
			(augmentPrototypeOf: 'Function' withMethod: '#on:do:' args: {'errorSpec'. 'handler'}
				body: {
					js try: (js block: {
						js return: (js verbatim: 'this.call(this)')
					}) catch: 'e' with: (js block: {
						js if: (js call:
									(js propertyOf: (js propertyOf: (js ident: 'errorSpec') at: (js literal: 'runtimeClass'))
										at: (js literal: 'isPrototypeOf')) 
								with: {js ident: 'e'})
							then: (js block: {
								js return: (js verbatim: 'handler.call(handler, e)')
								})
							else: (js block: {
								js throw: (js ident: 'e')
							})
					})
				}),
			(augmentPrototypeOf: 'Function' withMethod: '#value' args: {}
				body: {js verbatim: 'return this.call(this)'}),
			(augmentPrototypeOf: 'Function' withMethod: '#value:' args: {'a'}
				body: {js verbatim: 'return this.call(this, a)'}),
			(augmentPrototypeOf: 'Function' withMethod: '#value:value:' args: {'a'. 'b'}
				body: {js verbatim: 'return this.call(this, a, b)'}),
			(augmentPrototypeOf: 'Function' withMethod: '#value:value:value:' args: {'a'. 'b'. 'c'}
				body: {js verbatim: 'return this.call(this, a, b, c)'}),
			(augmentPrototypeOf: 'Function' withMethod: '#value:value:value:value:' args: {'a'. 'b'. 'c'.'d'}
				body: {js verbatim: 'return this.call(this, a, b, c, d)'}),
			(augmentPrototypeOf: 'Function' withMethod: '#valueWithArguments:' args: {'args'}
				body: {js verbatim: 'return this.apply(this, args)'}),
			(augmentPrototypeOf: 'Function' withMethod: '#whileFalse:' args: {'b'}
				body: {js verbatim: 'while(!this.call(this)) {b["#value"]()}'}),
			(augmentPrototypeOf: 'Function' withMethod: '#whileTrue:' args: {'b'}
				body: {js verbatim: 'while(this.call(this)) {b["#value"]()}'})
		)
	}
)
functionAugmentNumber = (
	"No need to export, this function is only invoked once right after it is declared."
	^{js function: 'augmentNumber' of: {} body:
		(js block:
			(augmentPrototypeOf: 'Number' withMethod: '#value' args: {}
				body: {js verbatim: 'return this'}),
			(augmentPrototypeOf: 'Number' withMethod: '#=' args: {'o'}
				"must do valueOf() on the receiver to convert it back to a primitive
				because ==  is false on two Number objects with equal values."
				body: {js verbatim: 'return this.valueOf() == o'}),
			(augmentPrototypeOf: 'Number' withMethod: '#<' args: {'n'}
				body: {js verbatim: 'return this < n'}),
			(augmentPrototypeOf: 'Number' withMethod: '#>' args: {'n'}
				body: {js verbatim: 'return this > n'}),
			(augmentPrototypeOf: 'Number' withMethod: '#<=' args: {'n'}
				body: {js verbatim: 'return this <= n'}),
			(augmentPrototypeOf: 'Number' withMethod: '#>=' args: {'n'}
				body: {js verbatim: 'return this >= n'}),
			(augmentPrototypeOf: 'Number' withMethod: '#+' args: {'n'}
				body: {js verbatim: 'return this + n'}),
			(augmentPrototypeOf: 'Number' withMethod: '#-' args: {'n'}
				body: {js verbatim: 'return this - n'}),
			(augmentPrototypeOf: 'Number' withMethod: '#*' args: {'n'}
				body: {js verbatim: 'return this * n'}),
			(augmentPrototypeOf: 'Number' withMethod: '#**' args: {'n'}
				body: {js verbatim: 'return Math.pow(this, n)'}),
			(augmentPrototypeOf: 'Number' withMethod: '#/' args: {'n'}
				body: {js verbatim: 'return this / n'}),
			(augmentPrototypeOf: 'Number' withMethod: '#//' args: {'n'}
				body: {js verbatim: 'return Math.floor(this / n)'}),
			(augmentPrototypeOf: 'Number' withMethod: '#bitAnd:' args: {'n'}
				body: {js verbatim: 'return this & n'}),
			(augmentPrototypeOf: 'Number' withMethod: '#bitInvert' args: {''}
				body: {js verbatim: 'return ~ this'}),
			(augmentPrototypeOf: 'Number' withMethod: '#bitOr:' args: {'n'}
				body: {js verbatim: 'return this | n'}),
			(augmentPrototypeOf: 'Number' withMethod: '#bitShift:' args: {'n'}
				body: {js verbatim: 'return (n < 0) ? (this >> -n) : (this << n)'}),
			(augmentPrototypeOf: 'Number' withMethod: '#bitXor:' args: {'n'}
				body: {js verbatim: 'return this ^ n'}),
			(augmentPrototypeOf: 'Number' withMethod: '#class' args: {}
				body: {js verbatim: 'return newspeakNumberFactory'}),
			(augmentPrototypeOf: 'Number' withMethod: '#even' args: {}
				body: {js verbatim: 'return this.toFixed() % 2 == 0'}),
			(augmentPrototypeOf: 'Number' withMethod: '#printString' args: {}
				body: {js verbatim: 'return this.toString()'}),
			(augmentPrototypeOf: 'Number' withMethod: '#asString' args: {}
				body: {js verbatim: 'return this.toString()'}),
			(augmentPrototypeOf: 'Number' withMethod: '#to:do:' args: {'n'. 'b'}
				body: {js verbatim: 'for (var i=this; i<=n; i++) {b["#value:"](i)}; return this;'}),
			(augmentPrototypeOf: 'Number' withMethod: '#to:by:do:' args: {'n'. 's'. 'b'}
				body: {js verbatim: 'for (var i=this; (s > 0 && i <= n) || (s < 0 && i >= n); i+=s) {b["#value:"](i)}; return this;'})
		)
	}
)
functionAugmentString = (
	"No need to export, this function is only invoked once right after it is declared."
	^{js function: 'augmentString' of: {} body:
		(js block:
			(augmentPrototypeOf: 'String' withMethod: '#value' args: {''}
				body: {js verbatim: 'return this'}),
			(augmentPrototypeOf: 'String' withMethod: '#asciiValue' args: {'o'}
				body: {js verbatim: 'return this.charCodeAt(0)'}),
			(augmentPrototypeOf: 'String' withMethod: '#>=' args: {'o'}
				body: {js verbatim: 'return this.valueOf() >= o'}),
			(augmentPrototypeOf: 'String' withMethod: '#<=' args: {'o'}
				body: {js verbatim: 'return this.valueOf() <= o'}),
			(augmentPrototypeOf: 'String' withMethod: '#>' args: {'o'}
				body: {js verbatim: 'return this.valueOf() > o'}),
			(augmentPrototypeOf: 'String' withMethod: '#<' args: {'o'}
				body: {js verbatim: 'return this.valueOf() < o'}),
			(augmentPrototypeOf: 'String' withMethod: '#=' args: {'o'}
				body: {js verbatim: 'return this.valueOf() == o'}),
			(augmentPrototypeOf: 'String' withMethod: '#==' args: {'o'}
				body: {js verbatim: 'return this === o'}),
			(augmentPrototypeOf: 'String' withMethod: '#,' args: {'s'}
				body: {js verbatim: 'return this + s'}),
			(augmentPrototypeOf: 'String' withMethod: '#at:' args: {'i'}
				body: {js verbatim: 'return this.slice(i - 1, i)'}),
			(augmentPrototypeOf: 'String' withMethod: '#class' args: {}
				body: {js verbatim: 'return newspeakStringFactory'}), "newspeakStringFactory provided by Phase1Platform"
			(augmentPrototypeOf: 'String' withMethod: '#hash' args: {} "implemented here for speed"
				body: {
					js var: 'l' value: (js propertyOf: (js ident: 'this') at: (js literal: 'length')).
					js if: (js operator: '==' with: (js ident: 'l') and: (js literal: 0))
						then: (js block: {js return: (js literal: 0)})
						else: (js block: {
							js verbatim: 'return (l * 32 ^ this.charCodeAt(0)) * 32 ^ this.charCodeAt(l - 1)'
						})
				}),
			(augmentPrototypeOf: 'String' withMethod: '#printString' args: {}
				body: {js verbatim: 'return "''" + this.toString() + "''"'}),
			(augmentPrototypeOf: 'String' withMethod: '#includesSubString:' args: {'string'}
				body: {js verbatim: 'return this.indexOf(string) != -1'}),
			(augmentPrototypeOf: 'String' withMethod: '#size' args: {}
				body: {js verbatim: 'return this.length'}),
			(augmentPrototypeOf: 'String' withMethod: '#copyFrom:to:' args: {'start'. 'end'}
				"1-based"
				body: {js verbatim: 'return this.slice(start -1, end)'}),
			(augmentPrototypeOf: 'String' withMethod: '#do:' args: {'b'}
				body: {
					js verbatim: 'for (var i=0; i<this.length; i++) {b["#value:"](this[i])}'.
					js verbatim: 'return this'
				}),
			(augmentPrototypeOf: 'String' withMethod: '#isSeparator' args: {}
				"1-based"
				body: {js verbatim: 'return this == " " || this == "\t" || this == "\n" || this == "\r";
'})
		)
	}
)
functionConstructMessage = (
"function constructMessage(selector, argumentsObject, firstArgIndex) {
	var unmangledSelector = selector.substring(1);
	var args = new Array();
	for (var i = firstArgIndex; i < argumentsObject.length; i++) {
		args.push(argumentsObject[i]);
	}
	return messageFactory['#selector:arguments:'](unmangledSelector, args);
}"
	"NOTE: this one may not really need to be exported."
	^exportedFunction: 'constructMessage' of: {'selector'. 'argumentsObject'. 'firstArgIndex'} body: (js block: {
		js var: 'unmangledSelector'
			value: (js call: (js propertyOf: (js ident: 'selector') at: (js literal: 'substring'))
						with: {js literal: 1}).
		js var: 'args' value: (js new: (js ident: 'Array') with: {}).
		js for: (js var: 'i' value: (js ident: 'firstArgIndex'))
			while: (js operator: '<' with: (js ident: 'i') and: (js propertyOf: (js ident: 'argumentsObject') at: (js literal: 'length')))
			step: (js postfixOperator: '++' on: (js ident: 'i'))
			do: (js call: (js propertyOf: (js ident: 'args') at: (js literal: 'push'))
					with: {js propertyOf: (js ident: 'argumentsObject') at: (js ident: 'i')}).
		"Using direct invocations instead of the standard sendMessage mechanism.
		The selectors involved better be there. This is OK though, because sendMessage
		would loop infinitely if they were not."
		js return:
			(js call: (js propertyOf: (js ident: 'messageFactory') at: (js literal: '#selector:arguments:'))
				with: {js ident: 'unmangledSelector'. js ident: 'args'})
	})
)
functionCreateDnuCatcherChild = (
	"function createDnuCatcherChild(objectLiteral){
		function Child() {
			for (var p in objectLiteral) {
				this[p] = objectLiteral[p];
			}
		}
		Child.prototype = dnuCatcher;
		return new Child();
	}"
	"NOTE: this one may not really need to be exported."
	^exportedFunction: 'createDnuCatcherChild' of: {'objectLiteral'} body:
		(js block: {
			js function: 'Child' of: {} body: (js block: {
				js for: (js var: 'p') in: (js ident: 'objectLiteral') do: (js block: {
					js assign: (js propertyOf: (js ident: 'this') at: (js ident: 'p'))
						toBe: (js propertyOf: (js ident: 'objectLiteral') at: (js ident: 'p')).
				}).
			}).
			js assign: (js propertyOf: (js ident: 'Child') at: (js literal: 'prototype'))
				toBe: (js ident: 'dnuCatcher').
			js return: (js new: (js ident: 'Child') with: {}).
		})
)
functionFixGetPrototypeOf = (

	"If missing, adds getPrototypeOf to Object. Works for rhino. For a more comprehensive fix see http://forrst.com/posts/Object_getPrototypeOf_shim-eNB"
"	
	if (!Object.getPrototypeOf) {
		Object.getPrototypeOf = function (obj) {
			return obj.__proto__;
		};
	}"
	
	| getPrototypeOf |
	getPrototypeOf:: js
		propertyOf: (js ident: 'Object')
		at: (js literal: 'getPrototypeOf').
	^{js function: 'fixGetPrototypeOf' of: {} body: (js block: {
		js
			if: (js prefixOperator: '!' on: getPrototypeOf)
			then: (js
				assign: getPrototypeOf
				toBe: (js
					functionOf: {'object'}
					body: (js block: {
						js return: (
"Don't use propertyOf:at:, as it doesn't seem to work with __proto__"
							js verbatim: 'object.__proto__')})))}).
		}
)
functionFixPrintForNodeJS = (
	^{js function: 'fixPrintForNodeJS' of: {} body: (js block: {
		js
			if: (js operator: '&&' with: (js propertyOf: (js ident: 'this') at: (js literal: 'console')) and: (js ident: 'console.log')) "if defined we are in node.js"
			then: (js
				assign: (js ident: 'print')
				toBe: (js ident: 'console.log'))
			})
	}
)
functionFixPrototypesOfFactory = (
	"Required for factories that are created before newspeakMetaclassRC and newspeakClassRC exist in their final form."
	"We must make use of verbatim Javascript, as __proto__ can only be accessed using '.'-notation in rhino"
	^exportedFunction: 'fixPrototypesOfFactory' of: {'factory'} body:
		(js block: {
			js verbatim: '
		//This still refers to the old newspeakMetaclassRC
		factory.__proto__.factory.__proto__ = newspeakMetaclassRC;
		//This still refers to the old newspeakClassRC
		factory.__proto__.__proto__ = newspeakClassRC;'})

	"^js function: 'fixPrototypesOfFactory' of: {'factory'} body:
		(js block: {
			js assign: (
					js
						propertyOf: (js ident: 'factory')
						atPath: {
							js literal: '__proto__'.
							js literal: 'factory'.
							js literal: '__proto__'})
				toBe: (js ident: 'newspeakMetaclassRC').
			js assign: (
					js
						propertyOf: (js ident: 'factory')
						atPath: {
							js literal: '__proto__'.
							js literal: '__proto__'})
				toBe: (js ident: 'newspeakClassRC').
		})"
)
functionGlobalExpatNameMapping = (
	^{js if: (js operator: '==' 
			 with: (js prefixOperator: 'typeof ' on: (js ident: 'globalExpatNameMapping')) 
			 and: (js literal: 'undefined'))
		then: ( js assign: (js ident: 'globalExpatNameMapping')
				   toBe: (js objectLiteral))
	}
)
functionInternalError = (
	"function internalError(errorMessage) {
		print('[ERROR] ', errorMessage);
		quit();
	}"
	^exportedFunction: 'internalError' of: {'errorMessage'} body: (js block: {
		js call: (js ident: 'print') with: {js literal: '[ERROR] '. js ident: 'errorMessage'}.
		js call: (js ident: 'quit') with: {}.
	})
)
functionInvokeMixin = (
	"function invokeMixin(mixin, superclass){
		var klass;

		function MakeRuntimeClass(f) { ... }
		function MakeRuntimeMetaClass() { ... }
		function Factory() { ... }
		function MetaFactory() { ... }

		MakeRuntimeClass.prototype = superclass;
		MakeRuntimeMetaClass.prototype = newspeakClassRC;
		MetaFactory.prototype = newspeakMetaclassRC;
		var metaFactory = new MetaFactory();
		var metaClass = metaFactory.runtimeClass;
		Factory.prototype = metaClass;
		new Factory();
		return klass;
	}"

	^exportedFunction: 'invokeMixin' of: {'mixin'. 'superclass'} body:
		(js block: {
			js var: 'klass'.
			functionInvokeMixinMakeRuntimeClass.
			functionInvokeMixinMakeRuntimeMetaClass.
			functionInvokeMixinFactory.
			functionInvokeMixinMetaFactory},
		(useDnuCatcher
			ifTrue: [{
					js call: (js ident: 'registerDnuSelectors') with: {js verbatim: 'mixin.metadata.sentSelectors'}
				}] 
			ifFalse: [{}]),
		{
			js assign: (js propertyOf: (js ident: 'MakeRuntimeClass') at: (js literal: 'prototype')) toBe: (js ident: 'superclass').
			js assign: (js propertyOf: (js ident: 'MakeRuntimeMetaClass') at: (js literal: 'prototype')) toBe: (js ident: 'newspeakClassRC').
			js assign: (js propertyOf: (js ident: 'MetaFactory') at: (js literal: 'prototype')) toBe: (js ident: 'newspeakMetaclassRC').
			js var: 'metaFactory' value: (js new: (js ident: 'MetaFactory') with: {}).
			js var: 'metaClass' value: (js propertyOf: (js ident: 'metaFactory') at: (js literal: 'runtimeClass')).
			js assign: (js propertyOf: (js ident: 'Factory') at: (js literal: 'prototype')) toBe: (js ident: 'metaClass').
			js new: (js ident: 'Factory') with: {}.
			js return: (js ident: 'klass').
		})
)
functionInvokeMixinFactory = (
	"function Factory(){
		this.runtimeClass = new MakeRuntimeClass(this);
		this.newspeakMetaobjectType = ''Factory'';
		klass = this.runtimeClass;
	}"
	^js function: 'Factory' of: {} body:
		(js block: {
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'runtimeClass'))
				toBe: (js new: (js ident: 'MakeRuntimeClass') with: {js ident: 'this'}).
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'newspeakMetaobjectType'))
				toBe: (js literal: 'Factory').
			js assign: (js ident: 'klass') toBe: (js propertyOf: (js ident: 'this') at: (js literal: 'runtimeClass')).
		})
)
functionInvokeMixinMakeRuntimeClass = (
	"function MakeRuntimeClass(f){
		var method;
		this.factory = f;
		this.mixin = mixin;
		this.newspeakMetaobjectType = ''RuntimeClass'';
		for (property in mixin) {
			var value = mixin[property];
			if (mixin.hasOwnProperty(property) && typeof value == 'function')
				this[property] = value;
		}
		this[''enclosingObjects`'' + mixin.metadata.name] = newspeakUndefinedObject;
		this[''super`'' + mixin.metadata.name] = superclass;
		// copy mixin methods into class
		this.createSlots = function() {
			superclass.createSlots.apply(this);
			mixin.createSlots.apply(this);
			return this;
		};
		// create class-specific createSlots
		this.instanceInitializer = function() {
			// need a function parameter that takes arguments
			// and massages them into form required for super call
			superclass.instanceInitializer.apply(this, arguments);
			mixin.instanceInitializer.apply(this, arguments);
			return this;
		};
		// create class specific instance initializer
		this.superclass = superclass; // support super calls
	}"
	^js function: 'MakeRuntimeClass' of: {'f'} body:
		(js block: {
			js var: 'method'.
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'factory')) toBe: (js ident: 'f').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'mixin')) toBe: (js ident: 'mixin').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'newspeakMetaobjectType')) toBe: (js literal: 'RuntimeClass').
			js for: 'property' in: (js ident: 'mixin') do:
				(js block: {
					js var: 'value' value: (js propertyOf: (js ident: 'mixin') at: (js ident: 'property')).
				(js if: (js operator: '&&'
						with:(js call: (js propertyOf: (js ident: 'mixin') at: (js literal: 'hasOwnProperty')) with: {js ident: 'property'})
						and: (js operator: '==' with: (js verbatim: 'typeof value') and: (js literal: 'function')))
					then: (js assign: (js propertyOf: (js ident: 'this') at: (js ident: 'property'))
							toBe: (js ident: 'value'))).
				}).
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'newspeakMetaobjectType'))
				toBe: (js literal: 'RuntimeClass').
			js assign:
				(js propertyOf: (js ident: 'this') at:
					(js operator: '+'
						with: (js literal: 'enclosingObjects', syntheticNameSeparator)
						and: (js propertyOf: (js propertyOf: (js ident: 'mixin') at: (js literal: 'metadata')) at: (js literal: 'name'))))
				toBe: (js array: {js ident: 'newspeakUndefinedObject'}).
			js assign:
				(js propertyOf: (js ident: 'this') at:
					(js operator: '+'
						with: (js literal: 'super', syntheticNameSeparator)
						and: (js propertyOf: (js propertyOf: (js ident: 'mixin') at: (js literal: 'metadata')) at: (js literal: 'name'))))
				toBe: (js ident: 'superclass').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'createSlots'))
				toBe: functionInvokeMixinMakeRuntimeClass_createSlotsFunction.
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'instanceInitializer'))
				toBe: functionInvokeMixinMakeRuntimeClass_instanceInitializerFunction.
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'superclass')) toBe: (js ident: 'superclass')
		})
)
functionInvokeMixinMakeRuntimeClass_createSlotsFunction = (
	"function() {
		superclass.createSlots.apply(this);
		mixin.createSlots.apply(this);
		return this;
	}"

	^js functionOf: {} body: (js block: {
		js call: (js propertyOf: (js propertyOf: (js ident: 'superclass') at: (js literal: 'createSlots')) at: (js literal: 'apply'))
			with: {js ident: 'this'}.
		js call: (js propertyOf: (js propertyOf: (js ident: 'mixin') at: (js literal: 'createSlots')) at: (js literal: 'apply'))
			with: {js ident: 'this'}.
		js return: (js ident: 'this').
	})
)
functionInvokeMixinMakeRuntimeClass_instanceInitializerFunction = (
	"function() {
		klass.superInit.apply(this, arguments);
		mixin.instanceInitializer.apply(this, arguments);
		return this;	
	}"

	^js functionOf: {} body: (js block: {
		js call: (js propertyOf: (js propertyOf: (js ident: 'klass') at: (js literal: 'superInit')) at: (js literal: 'apply'))
			with: {js ident: 'this'. js ident: 'arguments'}.
		js call: (js propertyOf: (js propertyOf: (js ident: 'mixin') at: (js literal: 'instanceInitializer')) at: (js literal: 'apply'))
			with: {js ident: 'this'. js ident: 'arguments'}.
		js return: (js ident: 'this').
	})
)
functionInvokeMixinMakeRuntimeMetaClass = (
	"function MakeRuntimeMetaClass(f){
		var method;
		var metaMixin = mixin.classMixin;
		this.mixin = metaMixin;
		this.factory = f;
		this.newspeakMetaobjectType = ''RuntimeMetaclass'';
		for (property in metaMixin) {
			var value = metaMixin[property];
			if (metaMixin.hasOwnProperty(property) && typeof value == 'function') 
				this[property] = value;
		}
		this[''enclosingObjects`'' + mixin.metadata.name] = newspeakUndefinedObject;
		this[''super`'' + mixin.metadata.name] = superclass;
	}"

	^js function: 'MakeRuntimeMetaClass' of: {'f'} body:
		(js block: {
			js var: 'method'.
			js var: 'metaMixin' value: (js propertyOf: (js ident: 'mixin') at: (js literal: 'classMixin')).
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'mixin')) toBe: (js ident: 'metaMixin').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'factory')) toBe: (js ident: 'f').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'newspeakMetaobjectType')) toBe: (js literal: 'RuntimeMetaclass').
			js for: 'property' in: (js ident: 'metaMixin') do:
				(js block: {
					js var: 'value' value: (js propertyOf: (js ident: 'metaMixin') at: (js ident: 'property')).
				(js if: (js operator: '&&'
						with:(js call: (js propertyOf: (js ident: 'metaMixin') at: (js literal: 'hasOwnProperty')) with: {js ident: 'property'})
						and: (js operator: '==' with: (js verbatim: 'typeof value') and: (js literal: 'function')))
					then: (js assign: (js propertyOf: (js ident: 'this') at: (js ident: 'property'))
							toBe: (js ident: 'value'))).
				}).
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'newspeakMetaobjectType'))
				toBe: (js literal: 'RuntimeMetaClass').
			js assign:
				(js propertyOf: (js ident: 'this') at:
					(js operator: '+'
						with: (js literal: 'enclosingObjects', syntheticNameSeparator)
						and: (js propertyOf: (js propertyOf: (js ident: 'mixin') at: (js literal: 'metadata')) at: (js literal: 'name'))))
				toBe: (js array: {js ident: 'newspeakUndefinedObject'}).
			js assign:
				(js propertyOf: (js ident: 'this') at:
					(js operator: '+'
						with: (js literal: 'super', syntheticNameSeparator)
						and: (js propertyOf: (js propertyOf: (js ident: 'mixin') at: (js literal: 'metadata')) at: (js literal: 'name'))))
				toBe: (js array: {js ident: 'superclass'}).
		})
)
functionInvokeMixinMetaFactory = (
	"function MetaFactory(){
		this.runtimeClass = new MakeRuntimeMetaClass(this);
		this.newspeakMetaobjectType = ''MetaFactory'';
	}"
	^js function: 'MetaFactory' of: {} body:
		(js block: {
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'runtimeClass'))
				toBe: (js new: (js ident: 'MakeRuntimeMetaClass') with: {js ident: 'this'}).
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'newspeakMetaobjectType'))
				toBe: (js literal: 'MetaFactory').
		})
)
functionInvokeTopLevelMixin = (
	"function invokeTopLevelMixin(m, s) {
		var tc = invokeMixin(m, s);
		tc[''enclosingObjects`'' + m.metadata.name] = [newspeakUndefinedObject];
		return tc;
	}"

	^exportedFunction: 'invokeTopLevelMixin' of: {'m'. 's'} body:
		(js block: {
			js var: 'tc' value: (js call: (js ident: 'invokeMixin') with: {js ident: 'm'. js ident: 's'}).
			js assign:
				(js propertyOf: (js ident: 'tc') at:
					(js operator: '+'
						with: (js literal: 'enclosingObjects', syntheticNameSeparator)
						and: (js propertyOf: (js propertyOf: (js ident: 'm') at: (js literal: 'metadata')) at: (js literal: 'name'))))
				toBe: (js array: {js ident: 'newspeakUndefinedObject'}).
			js return: (js
				call: (js ident: 'runtimeClassWithPrimitiveMethodsIncludedInMetadata')
				with: {js ident: 'tc'}).
		})
)
functionJavascriptEngineName = (
"
function javascriptEngineName() {
    if (typeof process == 'object'
	&& typeof console == 'object')
    {
	return 'NodeJS';
    }
    else 
    {
	if(typeof java == 'object')
	{
		return 'Rhino';
	}
	else {
		// default to V8
		return 'V8';
	}
    }
};
"
	^exportedFunction: 'javascriptEngineName' of: {} body: (js block: {
		js if: (js operator: '&&'
					with: (js operator: '==' with: (js verbatim: 'typeof process') and: (js literal: 'object'))
					and: (js operator: '==' with: (js verbatim: 'typeof console') and: (js literal: 'object')))
		    then: (js block: {js return: (js literal: 'NodeJS')})
		    else: ( js
			if: (js operator: '==' with: (js verbatim: 'typeof java') and: (js literal: 'object'))
			then: (js block: {js return: (js literal: 'Rhino')})
			else: (js block: {js return: (js literal: 'V8')}))})
)
functionJsBlock  = (

^exportedFunction: 'JsBlock'  of: {'f'. 'freeNames'. 'astFun'. 'lang'} body:(js block: {
	js assign: (js propertyOf: (js ident: 'this') at: (js literal:'jsFun')) toBe: (js ident: 'f').
	js assign: 
		(js propertyOf: (js ident: 'this') 
			at: (js literal:'freeVariables')) toBe: (js ident: 'freeNames'
		).
	js assign: 
		(js propertyOf: (js ident: 'this') at: (js literal:'ast')) toBe: (js ident: 'astFun').
	js assign: 
		(js propertyOf: (js ident: 'this') 
			at: (js literal:'language')) toBe: (js ident: 'lang').
	})
)
functionLookupNestedMixin = (
	"function lookupNestedMixin(runtimeClass, name) {
		// used by generated class accessors, see Compiler2>>accessorForNestedClassNamed:...
		var mixin = runtimeClass.mixin;
		if (mixin) {
			var nestedMixins = mixin.nestedMixins;
			if (nestedMixins) {
				var nested = nestedMixins[name];
				if (nested) return nested;
			}
		}
		var proto = Object.getPrototypeOf(runtimeClass);
		return proto ? lookupNestedMixin(proto, name) : null;
	}"
	^exportedFunction: 'lookupNestedMixin' of: {'runtimeClass'. 'name'} body: (js block: {
		js var: 'mixin' value: (js propertyOf: (js ident: 'runtimeClass') at: (js literal: 'mixin')).
		js if: (js ident: 'mixin') then: (js block: {
			js var: 'nestedMixins' value: (js propertyOf: (js ident: 'mixin') at: (js literal: 'nestedMixins')).
			js if: (js ident: 'nestedMixins') then: (js block: {
				js var: 'nested' value: (js propertyOf: (js ident: 'nestedMixins') at: (js ident: 'name')).
				js if: (js ident: 'nested') then: (js block: {
					js return: (js ident: 'nested')
				}).
			}).
		}).
		js var: 'proto' value: (js call: (js verbatim: 'Object.getPrototypeOf') with: {js ident: 'runtimeClass'}).
		js if: (js ident: 'proto')
			then: (js block: {js return: (js call: (js ident: 'lookupNestedMixin') with: {js ident: 'proto'. js ident: 'name'})})
			else: (js block: {js return: (js ident: 'null')})
	})
)
functionMakePropertyNotEnumerable = (

"makePropertyNotEnumerable(object, property) {

	if(javascriptEngineName() == 'Rhino') {
   java.lang.Class.forName('org.mozilla.javascript.ScriptableObject').
    getMethod('setAttributes', java.lang.String, java.lang.Integer.TYPE).
    invoke(object, property, new java.lang.Integer(org.mozilla.javascript.ScriptableObject.DONTENUM));

	} else {
		//What about keeping other properties intact?
		Object.defineProperty(object, property, {enumerable: false}).
	}
}"

	| scriptableObjectClass setAttributes |

	scriptableObjectClass:: js
		call: (js propertyOf: (js ident: 'java') atPath: {js literal: 'lang'. js literal: 'Class'. js literal: 'forName'})
		with: {js literal: 'org.mozilla.javascript.ScriptableObject'}.
		
	setAttributes:: js
		call: (js propertyOf: scriptableObjectClass at: (js literal: 'getMethod'))
		with: {js literal: 'setAttributes'.
			js propertyOf: (js ident: 'java') atPath: {js literal: 'lang'. js literal: 'String'} .
			js propertyOf: (js ident: 'java') atPath: {js literal: 'lang'. js literal: 'Integer'. js literal: 'TYPE'}
		}.

	^exportedFunction: 'makePropertyNotEnumerable' of: {'object'. 'property'} body: (js block: {
		js if: (js operator: '==' with: (js call: (js ident: 'javascriptEngineName') with: {}) and: (js literal: 'Rhino'))
				    then: (js
						call: (js propertyOf: setAttributes at: (js literal: 'invoke'))
						with: {js ident: 'object'.
							js ident: 'property'.
							js prefixOperator: 'new ' on: (js call: (js propertyOf: (js ident: 'java') atPath: {js literal: 'lang'. js literal: 'Integer'}) with: {
							js propertyOf: (js ident: 'org') atPath: {js literal: 'mozilla'. js literal: 'javascript'. js literal: 'ScriptableObject'. js literal: 'DONTENUM'}})})
				    else: (js block: {js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'defineProperty')) with: {js ident: 'object'. js ident: 'property'. js objectLiteral: {'enumerable'. js ident: 'false'}}})})

)
functionMakeTopLevelClass = (
	"function makeTopLevelClass(m) {
		return invokeTopLevelMixin(m, newspeakObjectRC);
	}"

	^exportedFunction: 'makeTopLevelClass' of: {'m'} body:
		(js block: {
			js call: (js ident: 'setEnclosingMixins') with: {js ident: 'm'}.
			js return:
				(js call: (js ident: 'invokeTopLevelMixin') with: {
					js call: (js ident: 'mixinWithInstanceMixinSetInClassMixins') with: {js ident: 'm'}.
					js ident: 'newspeakObjectRC'.
				})
		})
)
functionMixinHandleFor = (

	^exportedFunction: 'mixinHandleFor' of: {'mixin'. 'klass'} body: (
		js block: {
			js var: 'm' value: (js call: (js propertyOf: (js ident: 'mixinHandleFactory') at: (js literal: '#new')) with: {}).
			js assign: (js propertyOf: (js ident: 'm') at: (js literal: 'underlyingMixin')) toBe: (js ident: 'mixin').
			js assign: (js propertyOf: (js ident: 'm') at: (js literal: 'definingClass')) toBe: (js ident: 'klass').
			js return: (js ident: 'm')}).
)
functionMixinWithInstanceMixinSetInClassMixins = (
	^exportedFunction: 'mixinWithInstanceMixinSetInClassMixins' of: {'mixin'} body:
		(js block: {
			"mixin.classMixin.instanceMixin = mixin;"
			js assign: (js propertyOf: (js propertyOf: (js ident: 'mixin') at: (js literal: 'classMixin')) at: (js literal: 'instanceMixin'))
				toBe: (js ident: 'mixin').
			"for (var nestedMixin in mixin.nestedMixins) {
					mixinWithInstanceMixinSetInClassMixins( mixin.nestedMixins[nestedMixin]);
			}"
			js for: 'nestedMixin'
				in: (js propertyOf: (js ident: 'mixin') at: (js literal: 'nestedMixins'))
				do: (js block: {
					js call: (js ident: 'mixinWithInstanceMixinSetInClassMixins') with: {
						js propertyOf: (js propertyOf: (js ident: 'mixin') at: (js literal: 'nestedMixins'))
							at: (js ident: 'nestedMixin')
					}
				}).
			"return mixin;"
			js return: (js ident: 'mixin').
		})
)
functionPopulateAST = (
"Set up global JS function that creates an object that allows AST
construction from anywhere, so runtime parsing is not needed. This function
should be called during infrastructure set up"
^exportedFunction: 'populateAST'  of: {} body: (js verbatim:
    '
    if (globalASTService === null) {

  var MutableArrayList =
sendMessage0(rdlPlatform.realNewspeakObject["#collections"](),
"#MutableArrayList");
  function mkList(l) {return MutableArrayList["#withAll:"](l);}
  var astModule =

rdlPlatform.realNewspeakObject["#mirrors"]()["#parsers"]()["#at:"]("RiverBed")["enclosingObjects`RiverBedParser`Parser"][0]["#ASTModule"]();

  // extract relevant AST classes

  var BlockAST = astModule["#BlockAST"]();

  var CodeBodyAST = astModule["#CodeBodyAST"]();

  var NormalSendAST = astModule["#NormalSendAST"]();

  var CascadedSendAST = astModule["#CascadedSendAST"]();

  var SetterSendAST = astModule["#SetterSendAST"]();

  var MutableSlotDefAST = astModule["#MutableSlotDefAST"]();

  var ImmutableSlotDefAST = astModule["#ImmutableSlotDefAST"]();

  var VarDeclAST = astModule["#VarDeclAST"]();

  var VariableAST = astModule["#VariableAST"]();

  var MessageAST = astModule["#MessageAST"]();

  var AssignmentAST = astModule["#AssignmentAST"]();

  var ReturnStatAST = astModule["#ReturnStatAST"]();

  var StringAST = astModule["#StringAST"]();

  var NumberAST = astModule["#NumberAST"]();

  var CharAST = astModule["#CharAST"]();

  var ArrayAST = astModule["#ArrayAST"]();

  var TupleAST = astModule["#TupleAST"]();

  var TypeIdAST = astModule["#TypeIdAST"]();

  var UnaryTypeOpAST = astModule["#UnaryTypeOpAST"]();

  var BinaryTypeOpAST = astModule["#BinaryTypeOpAST"]();

  var GenericInvocationAST = astModule["#GenericInvocationAST"]();

  globalASTService = {

  block: function(body){
      var b = BlockAST["#new"]();
      b["body:"](body);
      return b;
    },

  codeBody: function(plist, tlist, slist){
      var cb = CodeBodyAST["#new"]();
    cb["#parameters:temporaries:statements:"](mkList(plist), mkList(tlist),
mkList(slist));
    return cb;
  },

 // define JS interface for building AST

 send: function(recv, msg){
    var ns = NormalSendAST["#new"]();
    ns["#to:send:"](recv, msg);
    return ns;
  },

 cascade: function(psend, msg){
    var c = CascadedSendAST["#new"]();
    c["#to:cascade:"](psend, msg);
    return c;
   },

 setter: function(recv, msg){
    var s = SetterSendAST["#to:send:start:end:"](recv, message, 0, 0);
    return s;
  },

 slotDef: function(def,init, mutable, accessModifier){
    var astClass = mutable ? MutableSlotDefAST : ImmutableSlotDefAST;
    var sd = astClass["new"]();
    sd["#slotDecl:"](def);
    if (i !== null) {sd["#initializer:"](i);};
    sd["#accessModifier:"](accessModifier);
    return astClass;
   },

 vdecl: function(n, t){
    return VarDeclAST["#name:type:"](n,t);
   },

 variable: function(n){
      var v = VariableAST["#new"]();
    v["#name:"](n);
    return v;
   },

 assign: function(v, e){
    var a = AssignmentAST["#new"]();
    a["#to:assign:"](v, e);
    return a;
  },

 str: function(aString){
    var s = StringAST["#new"]();
    s["#val:"](aString);
    return s;
   },

 character: function(aChar){
    var c = CharAST["#new"]();
    c["#val:"](aChar);
    return c;
   },

 num: function(aNumber){
    var n = NumberAST["#new"]();
    n["#val:"](aNumber);
    return n;
   },

 tuple: function(elist){
    var t = TupleAST["#new"]();
    t["#elements:"](mkList(elist));
    return t;
   },

 arr: function(elist){
    var a = ArrayAST["#new"]();
    a["#elements:"](elist);
    return a;
   },

 message: function(sel, alist){
    var m = MessageAST["#new"]();
    m["#send:with:"](sel, mkList(alist));
    return m;
  },

 ret: function(e){
    var r = ReturnStatAST["#new"]();
    r["#expr:"](e);
    return r;
    },

 genericInvoke: function(g, alist){
    var gi = GenericInvocationAST["#new"]();
    gi["#generic:"](g);
    gi["#arguments:"](mkList(alist));
    return gi;
  },

 binaryType: function(l, r, operator){
    var b = BinaryTypeOpAST["#new"]();
    b["#loperand:"](l);
    b["#roperand:"](r);
    b["#operator:"](operator);
    return b;
  },

 unaryType: function(op, operand){
    var u = UnaryTypeOpAST["#new"]();
    u["#operand:"](operand);
    u["#operator:"](op);
    return u;
  },

 typeId: function(n){
    var tid = TypeIdAST["#new"]();
    tid["#name:"](n);
    return tid;
  }};
 };
return globalASTService;
')
)
functionPrintObject = (
	"function printObject (object) {
		print(''--------------------'');
		print(''this ='', this);
		print(''[[Prototype]] ='', Object.getPrototypeOf(object));
		for (prop in object) {
			var own;
			if (object.hasOwnProperty(prop)) {
				own = ''(own)'';
			} else {
				own = "";
			}
			print(prop, own, ''='', object[prop]);
		}
		print(''--------------------'');
	}"
	^exportedFunction: 'printObject' of: {'object'} body: (js block: {
		js call: (js ident: 'print') with: {js literal: '--------------------'}.		
		js call: (js ident: 'print') with: {js literal: 'this ='. js ident: 'object'}.		
		js call: (js ident: 'print') with: {
			js literal: '[[Prototype]] ='.
			js call: (js propertyOf: (js ident: 'Object') at: (js literal: 'getPrototypeOf')) with: {js ident: 'object'}.
		}.
		js for: 'prop' in: (js ident: 'object') do: (js block: {
			js var: 'own'.
			js if: (js call: (js propertyOf: (js ident: 'object') at: (js literal: 'hasOwnProperty')) with: {js ident: 'prop'})
				then: (js block: {js assign: (js ident: 'own') toBe: (js literal: '(own)')})
				else: (js block: {js assign: (js ident: 'own') toBe: (js literal: '')}).
			js call: (js ident: 'print') with: {
				js ident: 'prop'.
				js ident: 'own'.
				js literal: '='.
				js propertyOf: (js ident: 'object') at: (js ident: 'prop').
			}
		}).
		js call: (js ident: 'print') with: {js literal: '--------------------'}.
	})
)
functionRegisterDnuSelectors = (
"function registerDnuSelectors (selectors) {
	function dnuCatcherFor(selector) {
		return function () {
				return this.dnuHandler(selector, arguments));
		}
	}
	for (var i = 0; i < selectors.length; i++) {
		var selector = '#' + selectors[i];
		if (dnuCatcher[selector] === undefined) {
			dnuCatcher[selector] = dnuCatcherFor(selector);
		}
	}
	}
}"
	^exportedFunction: 'registerDnuSelectors' of: {'selectors'} body: (js block: {
		js function: 'dnuCatcherFor' of: {'selector'} body: (js block: {
			js return: (js functionOf: {} body: (js block: {
				js return: (js call: (js propertyOf: (js ident: 'this') at: (js literal: 'dnuHandler')) with: {js ident: 'selector'. js ident: 'arguments'})
			}))
		}).
		js for: (js var: 'i' value: (js literal: 0))
			while: (js operator: '<' with: (js ident: 'i') and: (js propertyOf: (js ident: 'selectors') at: (js literal: 'length')))
			step: (js prefixOperator: '++' on: (js ident: 'i'))
			do: (js block: {
				js var: 'selector' value: (js operator: '+' with: (js literal: '#') and: (js propertyOf: (js ident: 'selectors') at: (js ident: 'i'))).
				js if: (js operator: '===' with: (js propertyOf: (js ident: 'dnuCatcher') at: (js ident: 'selector')) and: (js ident: 'undefined'))
					then: (js block: {
						js var: 'catcher' value: (js call: (js ident: 'dnuCatcherFor') with: {js ident: 'selector'}).
						js assign: (js propertyOf: (js ident: 'dnuCatcher') at: (js ident: 'selector')) toBe: (js ident: 'catcher').
						"js assign: (js propertyOf: (js verbatim: 'Array.prototype') at: (js ident: 'selector')) toBe: (js ident: 'catcher').
						js assign: (js propertyOf: (js verbatim: 'Boolean.prototype') at: (js ident: 'selector')) toBe: (js ident: 'catcher').
						js assign: (js propertyOf: (js verbatim: 'Function.prototype') at: (js ident: 'selector')) toBe: (js ident: 'catcher').
						js assign: (js propertyOf: (js verbatim: 'Number.prototype') at: (js ident: 'selector')) toBe: (js ident: 'catcher').
						js assign: (js propertyOf: (js verbatim: 'String.prototype') at: (js ident: 'selector')) toBe: (js ident: 'catcher')."
					})
			}).
	})
)
functionRuntimeClassWithPrimitiveMethodsIncludedInMetadata = (

"This method ensures that no new metadata is added for Javscript methods that correspond to existing methods/slots/nested classes. For the current use cases it would be sufficient to check only for methods."

	"mkl: Will be rewritten to use js generator soon"
	^exportedFunction: 'runtimeClassWithPrimitiveMethodsIncludedInMetadata' of: {'runtimeClass'} body:
		(js verbatim:'{

  var mixin = runtimeClass.mixin;

  function includeProperty(property) {

    if(property[0] != "#") {
      return;
    }

    if(typeof runtimeClass[property] != "function") {
      return;
    }

    if(property.indexOf("`") != -1) {
      return;
    }

    var demangledProperty = property.slice(1, property.length);

    var methodMetadata = mixin.metadata.methods;
    for(i = 0; i < methodMetadata.length; i++) {
      var metadata = methodMetadata[i];
      if(metadata["name"] == demangledProperty) {
        //print("Existing method ", demangledProperty);
        return;
      }
    }

    var slotMetadata = mixin.metadata.slots;
    for(i = 0; i < slotMetadata.length; i++) {
      var metadata = slotMetadata[i];
      if(metadata["name"] == demangledProperty || metadata["name"] + ":" == demangledProperty) {
        //print("Existing slot ", demangledProperty);
        return;
      }
    }

    var nestedMixins = mixin.nestedMixins;
    for(nestedMixin in nestedMixins) {
      if(nestedMixins[nestedMixin].metadata.simpleName == demangledProperty) {
        //print("Existing nested class ", demangledProperty);
        return;
      }
    }

    //print("Including ", demangledProperty);
    methodMetadata.push( {
              "name": demangledProperty,
              "source": demangledProperty + "= (\"primitive\")"
          });
  }

  for(property in runtimeClass) {
    includeProperty(property);
  }

  return runtimeClass;
}

')
)
functionSendMessageN = (
"function sendMessageN (receiver, selector) {
	var method = receiver[selector];
	if (method) {
		var args = new Array();
		for (var i = 2; i < arguments.length; i++) {
			args.push(arguments[i]);
		}
		return method.apply(receiver, args)
	} else {
		return receiver['#doesNotUnderstand:'](constructMessageFromArgumentsObject(selector, arguments));
	}
}"
	^exportedFunction: 'sendMessageN' of: {'receiver'. 'selector'} body: (js block: {
		js var: 'method' value: (js propertyOf: (js ident: 'receiver') at: (js ident: 'selector')).
		js if: (js ident: 'method')
			then: (js block: {
				js var: 'args' value: (js new: (js ident: 'Array') with: {}).
				js for: (js var: 'i' value: (js literal: 2))
					while: (js operator: '<' with: (js ident: 'i') and: (js propertyOf: (js ident: 'arguments') at: (js literal: 'length')))
					step: (js postfixOperator: '++' on: (js ident: 'i'))
					do: (js call: (js propertyOf: (js ident: 'args') at: (js literal: 'push'))
							with: {js propertyOf: (js ident: 'arguments') at: (js ident: 'i')}).
				(js return:
					(js call: (js propertyOf: (js ident: 'method') at: (js literal: 'apply'))
						with: {js ident: 'receiver'. js ident: 'args'}))
			})
			else:
				(js return:
					(js call: (js propertyOf: (js ident: 'receiver') at: (js literal: '#doesNotUnderstand:'))
						with: {js call: (js ident: 'constructMessage')
								with: {js ident: 'selector'. js ident: 'arguments'. js literal: 2}}))
	})
)
functionSendMessageSpecialCaseFor: arity <Integer> = (
"function sendMessage<N> (receiver, selector, a1 ... aN) {
	var method = receiver[selector];
	if (method) {
		return method.call(receiver, a1 ... aN);
	} else {
		return receiver['#doesNotUnderstand:'](constructMessage(selector, a1 ... aN));
	}
}"
	| argNames |
	argNames:: (1 to: arity) collect: [:each | 'a', each printString].
	^exportedFunction: 'sendMessage', arity printString of: {'receiver'. 'selector'}, argNames body: (js block: {
		js var: 'method' value: (js propertyOf: (js ident: 'receiver') at: (js ident: 'selector')).
		js if: (js ident: 'method')
			then:
				(js return:
					(js call: (js propertyOf: (js ident: 'method') at: (js literal: 'call'))
						with: {js ident: 'receiver'}, (argNames collect: [:each | js ident: each])))
			else:
				(js return:
					(js call: (js propertyOf: (js ident: 'receiver') at: (js literal: '#doesNotUnderstand:'))
						with: {js call: (js ident: 'constructMessage')
								with: {js ident: 'selector'. js ident: 'arguments'. js literal: 2}}))
	})
)
functionSendSuperMessageN = (
"function sendSuperMessageN (receiver, lookup, selector) {
	var method = lookup[selector];
	if (method) {
		var args = new Array();
		for (var i = 3; i < arguments.length; i++) {
			args.push(arguments[i]);
		}
		return method.apply(receiver, args)
	} else {
		return receiver['#doesNotUnderstand:'](constructMessageFromArgumentsObject(selector, arguments));
	}
}"
	^exportedFunction: 'sendSuperMessageN' of: {'receiver'. 'lookup'. 'selector'} body: (js block: {
		js var: 'method' value: (js propertyOf: (js ident: 'lookup') at: (js ident: 'selector')).
		js if: (js ident: 'method')
			then: (js block: {
				js var: 'args' value: (js new: (js ident: 'Array') with: {}).
				js for: (js var: 'i' value: (js literal: 3))
					while: (js operator: '<' with: (js ident: 'i') and: (js propertyOf: (js ident: 'arguments') at: (js literal: 'length')))
					step: (js postfixOperator: '++' on: (js ident: 'i'))
					do: (js call: (js propertyOf: (js ident: 'args') at: (js literal: 'push'))
							with: {js propertyOf: (js ident: 'arguments') at: (js ident: 'i')}).
				(js return:
					(js call: (js propertyOf: (js ident: 'method') at: (js literal: 'apply'))
						with: {js ident: 'receiver'. js ident: 'args'}))
			})
			else:
				(js return:
					(js call: (js propertyOf: (js ident: 'receiver') at: (js literal: '#doesNotUnderstand:'))
						with: {js call: (js ident: 'constructMessage')
								with: {js ident: 'selector'. js ident: 'arguments'. js literal: 3}}))
	})
)
functionSendSuperMessageSpecialCaseFor: arity <Integer> = (
"function sendSuperMessage<N> (receiver, lookup, selector, a1 ... aN) {
	var method = lookup[selector];
	if (method) {
		return method.call(receiver, a1 ... aN);
	} else {
		return receiver['#doesNotUnderstand:'](constructMessage(selector, a1 ... aN));
	}
}"
	| argNames |
	argNames:: (1 to: arity) collect: [:each | 'a', each printString].
	^exportedFunction: 'sendSuperMessage', arity printString of: {'receiver'. 'lookup'. 'selector'}, argNames body: (js block: {
		js var: 'method' value: (js propertyOf: (js ident: 'lookup') at: (js ident: 'selector')).
		js if: (js ident: 'method')
			then:
				(js return:
					(js call: (js propertyOf: (js ident: 'method') at: (js literal: 'call'))
						with: {js ident: 'receiver'}, (argNames collect: [:each | js ident: each])))
			else:
				(js return:
					(js call: (js propertyOf: (js ident: 'receiver') at: (js literal: '#doesNotUnderstand:'))
						with: {js call: (js ident: 'constructMessage')
								with: {js ident: 'selector'. js ident: 'arguments'. js literal: 3}}))
	})
)
functionSetEnclosingMixins = (

"function setEnclosingMixins(mixin) {
  var nestedMixins = mixin.nestedMixins;
  for (var p in nestedMixins) {
    var nestedMixin = nestedMixins[p];
    setEnclosingMixins(nestedMixin);
    nestedMixin.enclosingMixin = mixin;
  }
}
"

	^exportedFunction: 'setEnclosingMixins' of: {'mixin'} body:
		(js block: {
			js
				var: 'nestedMixins'
				value: (js
					propertyOf: (js ident: 'mixin')
					at: (js literal: 'nestedMixins')).
			js
				for: (js var: 'p')
				in: (js ident: 'nestedMixins')
				do: (js block: {
					js var: 'nestedMixin' value: (js
						propertyOf: (js ident: 'nestedMixins')
						at: (js ident: 'p')).
					js
						call: (js ident: 'setEnclosingMixins')
						with: {js ident: 'nestedMixin'}.
					js
						assign: (js
							propertyOf: (js ident: 'nestedMixin')
							at: (js literal: 'enclosingMixin'))
						toBe: (js ident: 'mixin')
				})
		})
)
functionWrapMethodForExpat = (

	"mkl: Will be rewritten to use js generator soon"
	^exportedFunction: 'wrapMethodForExpat' of: {'expatClass'. 'alienClass'. 'selector'. 'propertyStoringRealObject'} body:
		(js verbatim: '{
			var mangledSelector = "#" + selector;
			
			function makeExpat(o) {
				return expatClass["#onNewspeakObject:"](o);	
			}
			
			function unwrap(o) {
				if(o.hasOwnProperty(propertyStoringRealObject)) {
					return o[propertyStoringRealObject];
				}
				else if(typeof o == "function") {
					return wrapFunction(o);
				}
				else {
					return alienClass["#covertAlienOnJavascriptObject:"](o);
				}
			}
			
			function wrapFunction(f) {
				return function() {
					var args = [];
					for (var i = 0; i < arguments["length"]; i++) {
						args["push"](makeExpat(arguments[i]));
					}
					return f.apply(null, args);
				}
			}
		
			return (function() {
				var args = [this[propertyStoringRealObject], mangledSelector];
				for (var i = 0; i < arguments["length"]; i++) {
					args["push"](unwrap(arguments[i]));
				};
				return makeExpat(sendMessageN.apply(null, args));		
			});		
		}')
)
globalMixinNamespace = (
	^{js assign: (js var: 'globalMixinNamespace') toBe: (js objectLiteral)}
)
infrastructureScript ^<Script> = (
"This is the master definition of everything that gets written out to a script to set up Newspeak infrastructure."

	^js script:
		"globalAlienFlag must be declared at the top because the users expect it there.
		It should be exported later, after the script knows the javascript engine name."
		{js var: 'globalAlienFlag' value: (js literal: 'Naive')},
		fastRdlConfigExpression, "BOGUS, should not be done here"
		functionJavascriptEngineName,
		{exportName: 'globalAlienFlag'},
		functionMakePropertyNotEnumerable,
		functionGlobalExpatNameMapping,
		storeCommandLineArguments, "depends on javascriptEngineName"
		functionFixGetPrototypeOf,
		{js call: (js ident: 'fixGetPrototypeOf') with: {}},
		functionFixPrintForNodeJS,
		{js call: (js ident: 'fixPrintForNodeJS') with: {}},
		functionWrapMethodForExpat,
		functionFixPrototypesOfFactory,
		globalMixinNamespace,
		functionRuntimeClassWithPrimitiveMethodsIncludedInMetadata,
		functionMixinHandleFor,
		functionAugmentArray,
		functionAugmentBoolean,
		functionAugmentFunction,
		functionAugmentNumber,
		functionAugmentString,
		{js call: (js ident: 'augmentArray') with: {}},
		{js call: (js ident: 'augmentBoolean') with: {}},
		{js call: (js ident: 'augmentFunction') with: {}},
		{js call: (js ident: 'augmentNumber') with: {}},
		{js call: (js ident: 'augmentString') with: {}},
		functionConstructMessage,
		{js var: 'globalASTService' value: (js ident: 'null') },
		functionPopulateAST,
		{exportName: 'globalASTService'},
		{js var: 'blockPrototype' value: blockPrototype},
		functionJsBlock,
		{js assign: (js propertyOf: (js ident: 'JsBlock') at: (js literal: 'prototype')) toBe: (js ident: 'blockPrototype')},
		functionSendMessageN,
		functionSendSuperMessageN,
		functionSetEnclosingMixins,
		sendMessageSpecialCaseFunctions,
		sendSuperMessageSpecialCaseFunctions,
		((useDnuCatcher or: [useNoSuchMethod])
			ifTrue: 
				[{js var: 'dnuCatcher' value: dnuCatcher},
				functionCreateDnuCatcherChild,
				functionRegisterDnuSelectors]
			ifFalse: [{}]),
		(exportedVariable: 'newspeakUndefinedObject'
			value: (makeDnuCatcherChildIfNeeded: newspeakUndefinedObject)),
		(exportedVariable: 'newspeakClassRC'
			value: (makeDnuCatcherChildIfNeeded: newspeakClassRC)),
		(exportedVariable: 'newspeakObjectRC'
			value: (makeDnuCatcherChildIfNeeded: newspeakObjectRC)),
		(exportedVariable: 'newspeakMetaclassRC'
			value: (makeDnuCatcherChildIfNeeded:  (js verbatim: 
			'{"#=": function (x) { return this === x; }, "#class": function () { return newspeakMetaclassFactory; }}'))),
			"This fake RC for metaclasses is replaced with the real thing once we have it. However, metaclasses of two classes
			created early in the sequence, Object and Metaclass, have this thing as their prototype, hence the need to fake some
			behavior. TODO: clean up the boot process to erase all traces of this."
		functionAddAlienCompatibilityMarkers,
		{js call: (js ident: 'addAlienCompatibilityMarkers') with: {}},
		functionLookupNestedMixin,
		functionInternalError,
		functionInvokeMixin,
		functionInvokeTopLevelMixin,
		functionMakeTopLevelClass,
		functionMixinWithInstanceMixinSetInClassMixins,
		functionPrintObject
)
makeDnuCatcherChildIfNeeded: expr = (
	^(useDnuCatcher or: [useNoSuchMethod])
		ifTrue: [js call: (js ident: 'createDnuCatcherChild') with: {expr}]
		ifFalse: [expr]
)
newspeakClassRC = (
	"{
		basicNew: function () {
				function FreshInstance(){
					this.createSlots();
				}
				FreshInstance.prototype = this.runtimeClass;
				return new FreshInstance();
			},
		''#class'': function () {
				return Object.getPrototypeOf(this).factory;
			},
		toString: function() { return ''NewspeakClassRC'' }
         }"
	^js objectLiteral: {
		'basicNew'.
			js functionOf: {} body: (js block: {
				js function: 'FreshInstance' of: {} body: (js block: {
					js call: (js propertyOf: (js ident: 'this') at: (js literal: 'createSlots')) with: {}.
				}).
				js assign: (js propertyOf: (js ident: 'FreshInstance') at: (js literal: 'prototype'))
					toBe: (js propertyOf: (js ident: 'this') at: (js literal: 'runtimeClass')).
				js return: (js new: (js ident: 'FreshInstance') with: {}).
			}).
		'toString'.
			js functionOf: {} body: 
				(js block: {
					js return: (js literal: 'Newspeak Class, a metaclass, or a factory')
				}).
		'#='.
			js functionOf: {'o'} body: (js block: {
				js verbatim: 'return this===o'
			}).
		'#~='.
			js functionOf: {'o'} body: (js block: {
				js verbatim: 'return this!==o'
			}).
		'#class'.
			js functionOf: {} body: (js block: {
				js return: (js ident: 'this.factory')
			}).
		'#superclass'.
			js functionOf: {} body: (js block: {
				js return: (js ident: 'this.runtimeClass.superclass.factory')
			}).
		'#mixin'.
			js functionOf: {} body: (js block: {
				js return: (js call: (js ident: 'mixinHandleFor') with: {js verbatim: 'this.mixin.instanceMixin'. js ident: 'this'}).
			}).
		'#addLowLevelObjectMirrorPrimitiveMethods'.
			js functionOf: {} body: (js block: {
				js verbatim: '
				this.runtimeClass["#hasOwnProperty:"] = function(property) {
				 	return this["#reflectee"]().hasOwnProperty(property)
				};
				this.runtimeClass["#propertyAt:"] = function(property) {
				 	return this["#reflectee"]()[property];
				};
				this.runtimeClass["#hasProperty:"] = function(property) {
					return 		(undefined != this["#reflectee"]())
							&&  (undefined != this["#reflectee"]()[property]);
				};
				this.runtimeClass["#propertyAt:put:"] = function(property, value) {
				 	return this["#reflectee"]()[property] = value;
				};
				this.runtimeClass["#propertiesDo:"] = function(block) {
					for (var i in this["#reflectee"]()) {block["#value:"](i)};
					return this;
				};
				this.runtimeClass["#type"] = function() {
					return typeof this["#reflectee"]();
				};
				this.runtimeClass["#on:apply:"] = function(receiver, arguments) {
					return this["#reflectee"]().apply(receiver, arguments);
				};
				this.runtimeClass["#call:with:"] = function(property, arguments) {
					var r = this["#reflectee"]();
					return r[property].apply(r, arguments);
				};
				this["#emptyObject"] = function() {
					return this["#reflecting:"](new (function(){}));
				};
				this["#hasObject:property:"] = function(obj, property) {
					return 		(undefined != obj)
							&&  (undefined != obj[property]);
				};'.
			}).
			
		'#addMakeNaiveExpatFactory'.
		js functionOf: {} body: (js verbatim: '
this.runtimeClass["#makeNaiveExpatFactoryForExpatClass:alienClass:propertyStoringRealObject:"] = function(expatClass, alienClass, propertyStoringRealObject) {

var MakeNaiveExpat = function(object) {
    var className = object["#class"]().runtimeClass.mixin.metadata.name;
    var requestedNameMapping = globalExpatNameMapping[className];
    this[propertyStoringRealObject] = object;
    this.canActAsExpat = true;
    
    function mapNameFromJavascriptToNewspeak(nm) {
	
        if(requestedNameMapping && requestedNameMapping[nm]) {
            return requestedNameMapping[nm];
        }
	
        if (nm.indexOf("set_") == 0) {
            return nm.substring(4, nm.length) + ":"
        }
        var result = nm.replace(/_/g, ":");
        if(object["#" + result]) {
            return result;
        }
        var resultColon = result + ":";
        if(object["#" + resultColon]) {
            return resultColon;
        }
        print("Tried to call non-existant method", nm);
        triedToCallNonExistantMethod();
    };
    
    function makeExpat(o) { return expatClass["#onNewspeakObject:"](o);	};	    
    
    function unwrap(o) {
        if(o.hasOwnProperty(propertyStoringRealObject)) { 
	    return o[propertyStoringRealObject];
        }
        else if(typeof o == "function") {
            return wrapFunction(o);
        }
        else {
            return alienClass["#covertAlienOnJavascriptObject:"](o);
        }
    };	    
    
    function wrapFunction(f) {
        return function() {
            var args = [];
            for (var i = 0; i < arguments["length"]; i++) {
                args["push"](makeExpat(arguments[i]));
            }
            return f.apply(null, args);
        }
    };

    function createFunction(selector) {
        var mangledSelector = "#" + mapNameFromJavascriptToNewspeak(selector);	    
        return  function () {
            var receiverSelectorAndArgs = [this[propertyStoringRealObject], mangledSelector];
		var args = arguments[0];
            for (var i = 0; i < args.length; i++) {
                receiverSelectorAndArgs.push(unwrap(args[i]));
            };
            return makeExpat(sendMessageN.apply(null, receiverSelectorAndArgs));				
        }
    };

    this.__noSuchMethod__ = function() {
        var selector = arguments[0];
        var args = [];
        var newFunction = createFunction(selector);
	
        this[selector] = newFunction;
	
        for (var i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        return newFunction.apply(this, args);
    };
    
    this["invokeOn"] = function(selector, args) {
	      
        var mangledSelector = "#" + mapNameFromJavascriptToNewspeak(selector);	    
        var wrappedArgs = [this[propertyStoringRealObject], mangledSelector];
        for (var i = 0; i < args["length"]; i++) {
            wrappedArgs["push"](unwrap(args[i]));
        };
        return makeExpat(sendMessageN.apply(null, wrappedArgs));				
	
    }
}

    return function(object) { return new MakeNaiveExpat(object);};
}

		').
		
		'#addObjectMirrorPrimitiveMethods'.
		
			js functionOf: {} body: (js block: {
				js verbatim: 'this.runtimeClass["#perform:with:"] = function(selector, args) {
					var result = sendMessageN.apply(
						undefined, 
						[this["#reflectee"](), "#" + selector].concat(args));
					return this["#class"]()["#reflecting:"](result);
				};'.
			}).
		'#addJavascriptEvaluatorPrimitiveMethods'.
			js functionOf: {} body: (js block: {
				js verbatim: '
				this.runtimeClass["#eval:"] = function(source) {
				 	return eval(source);
				};
				this.runtimeClass["#evalFunction:with:"] = function(source, arguments) {
				 	return eval("(" + source + ")").apply(null, arguments);
				};'
			}).
	}
)
newspeakObjectFactory = (
"The object to play the role of the Object class' factory. Pretty bogus for now as it doesn't have the prototype chain properly set up."
	^js objectLiteral: {
		'runtimeClass'. js verbatim: 'newspeakObjectRC'.
	}
)
newspeakObjectRC = (
"The definition of PrehistoricObject, the Phase 0 runtime class used as a superclass of the actual Object compiled from Newspeak source at Phase 1. This object is the prototype of the Object runtime class. However, the superclass slot of Object is reset to contain nil rather than a reference to this runtime class object, so this runtime class object is not visible to Newspeak code. The methods defined here are methods of Object that cannot be expressed in Newspeak (i.e. primitives). They are also copied to prototypes of Javascript values used as runtime objects of classes such as Number and Array."

	^js objectLiteral: {
		'superclass'. js verbatim: 'newspeakUndefinedObject'.
		'createSlots'.
			js functionOf: {} body: (js block: {
				js verbatim: 'return this'.
			}).
		'instanceInitializer'.
			js functionOf: {} body: (js block: {
				js verbatim: 'return this'.
			}).
		'toString'.
			js functionOf: {} body: 
				(js block: {
					js if: (js propertyOf: (js ident: 'this') at: (js literal: 'mixin'))
						then: (js return: (js call: (js propertyOf: (js ident: 'this') at: (js literal: '#printString')) with: {}))
						else: (js return: (js literal: '<a malformed object with no mixin property>')).
				}).

		'#='.
			js functionOf: {'o'} body: (js block: {
				js verbatim: 'return this===o'
			}).	
		'#=='.
			js functionOf: {'o'} body: (js block: {
				js verbatim: 'return this===o'
			}).	
		'#class'.
			js functionOf: {} body: (js block: {
				js verbatim: 'return this.factory'
			}).
		'#doesNotUnderstand:'.
			"Not using any of the official sendMessage mechanism because we neither expect nor
			can afford a real DNU here."
			js functionOf: {'message'} body: (js block: {
				js var: 'ex' value: 
					(js call: (js propertyOf: (js ident: 'messageNotUnderstoodFactory') at: (js literal: '#message:'))
						with: {js ident: 'message'}).
				js return: (js call: (js propertyOf: (js ident: 'ex') at: (js literal: '#signal')) with: {}).
			}).
		'#identityHash'.
			js functionOf: {} body: (js block: {
				js var: 'hash' value: (js propertyOf: (js ident: 'this') at: (js literal: '$idHash')).
				js if: (js operator: '==' with: (js ident: 'hash') and: (js ident: 'undefined'))
					then: (js block: {
						js assign: (js ident: 'hash')
							toBe: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: '$idHash'))
									toBe: (js verbatim: 'Math.round(Math.random() * 100000)'))
					}).
				js return: (js ident: 'hash')
			}).
		'#out'.
			js functionOf: {} body: (js block: {
				js verbatim: 'print(this.toString())'.
			}).
		'#printString'.
			js functionOf: {} body: (js block: {
				js return: (js operator: '+' with: (js verbatim: 'this.mixin.metadata.name') and: (js literal: ':instance')).
			}).
		'#yourself'.
			js functionOf: {} body: (js block: {
				js verbatim: 'return this'
			}).
		
		'#Array'.
			js functionOf: {} body: (js block: {
				js verbatim: 'return newspeakArrayFactory'.
			}).
		'#Character'.
			js functionOf: {} body: (js block: {
				js verbatim: 'return newspeakStringFactory'.
			}).
		'#Delay'.
			js functionOf: {} body: (js block: {
				js verbatim: 'return delayFactory'.
			}).
		'#Error'.
			js functionOf: {} body: (js block: {
				js verbatim: 'return newspeakErrorFactory'.
			}).
		'#Object'.
			js functionOf: {} body: (js block: {
				js verbatim: 'return newspeakObjectFactory'.
			}).
		'#String'.
			js functionOf: {} body: (js block: {
				js verbatim: 'return newspeakStringFactory'.
			}).
			
		'#print:'. "Temporary. This method will go away."
			js functionOf: {'s'} body: (js block: {
				js call: (js ident: 'print') with: {js ident: 's'}.
			}).
		'#printSelf'. "Temporary. This method will go away."
			js functionOf: {} body: (js block: {
				js call: (js ident: 'printObject') with: {js ident: 'self'}.
			}).
		'#quit'. "Temporary. This method will go away."
			js functionOf: {} body: (js block: {
				js call: (js ident: 'quit') with: {}.
			}).
		'#clone'.
			js functionOf: {} body: (js block: {
				js verbatim: '
					var result = this["#class"]()["basicNew"]();
					for(var p in this) {
						result[p] = this[p];
					}
					return result'.
			}).

	}
)
newspeakUndefinedObject = (
"This is a temporary definition, later replaced by a properly compiled UndefinedObject class and its sole instance."
	"var newspeakUndefinedObject = {
		toString: function() { return ''nil'' }
	}"
	^js objectLiteral: {
		'toString'.
			js functionOf: {} body: (js block: {
				js return: (js literal: 'prehistoricNil')
			}).
		'#='.
			js functionOf: {'o'} body: (js block: {
				js verbatim: 'return this===o'
			}).			
		}
)
outputTo: stream <WriteStream> = (
	JavascriptWriter new generateSourceFor: infrastructureScript on: stream
)
sendMessageSpecialCaseFunctions = (
	| functions |
	functions:: OrderedCollection new.
	((0 to: sendAritySpecialCaseLimit) do:
		[:each | functions addAll: (functionSendMessageSpecialCaseFor: each)]).
	^functions
)
sendSuperMessageSpecialCaseFunctions = (
	| functions |
	functions:: OrderedCollection new.
	((0 to: sendAritySpecialCaseLimit) do:
		[:each | functions addAll: (functionSendSuperMessageSpecialCaseFor: each)]).
	^functions
)
storeCommandLineArguments = (
"
if (javascriptEngineName() == 'NodeJS') {
    commandLineArguments = new Array();

    for(var idx = 2; idx < process['argv'].length; idx++)
    {
	commandLineArguments.push(process['argv'][idx]);
    }
} else {
	commandLineArguments = arguments;
};
"
	^{js if: (js operator: '==' with: (js call: (js ident: 'javascriptEngineName') with: {}) and: (js literal: 'NodeJS'))
		    then: (js block: {
			js assign: (js ident: 'commandLineArguments') toBe: (js new: (js ident: 'Array') with: {}).
			
			js for: (js var: 'idx' value: (js literal: 2))
				while: (js operator: '<' 
							with: (js ident: 'idx')
							and: (js propertyOf: (js propertyOf: (js ident: 'process') at: (js literal: 'argv')) at: (js literal: 'length')))
				step: (js postfixOperator: '++' on: (js ident: 'idx'))
				do: (js call: (js propertyOf: (js ident: 'commandLineArguments') at: (js literal: 'push'))
						with: { js propertyOf: (js propertyOf: (js ident: 'process') at: (js literal: 'argv')) at: (js ident: 'idx') })})

		    else: (js block: {
			js if: (js operator: '==' with: (js prefixOperator: 'typeof ' on: (js ident: 'arguments')) and: (js literal: 'object'))
				then: (js assign: (js ident: 'commandLineArguments') toBe: (js ident: 'arguments'))
				else: (js assign: (js ident: 'commandLineArguments') toBe: (js new: (js ident: 'Array') with: {}))})
	}
)'private'
augmentPrototypeOf: className <String> withMethod: selector <String> args: args <List> body: statements <List[Node]> ^<Node> = (
	^{
		js assign: (js propertyOf: (js propertyOf: (js ident: className) at: (js literal: 'prototype')) at: (js literal: selector))
			toBe: (js functionOf: args body: (js block: statements)).
		js call: (js ident: 'makePropertyNotEnumerable')
			with: {js propertyOf: (js ident: className) at: (js literal: 'prototype'). js literal: selector}
	}
)) : ()
class MethodMirror named: s <Symbol> = LowLevelMirror (
"A descriptor for a Javascript method or accessor."| 
	selector <Symbol> = s.
	method <String>  "Javascript code"
	src <String> "Newspeak source - optional"
	|)
('as yet unclassified'
isAccessor ^ <Boolean> = (
	^metadata at: #isAccessor ifAbsent:[false]
)
isAccessor: b <Boolean> = (
	isSynthetic: b.
	metadata at: #isAccessor put: b
)
isFactory ^ <Boolean> = (
	^metadata at: #isFactory ifAbsent:[false]
)
isFactory: b <Boolean> = (
	isSynthetic: b.
	metadata at: #isFactory put: b
)
isSynthetic ^ <Boolean> = (
	^metadata at: #isSynthetic ifAbsent:[false]
)
isSynthetic: b <Boolean> = (
	metadata at: #isSynthetic put: b
)
name ^ <Symbol> = (
	^selector
)) : ()
class Phase1Platform = (
"Describe the class in this comment."|
	compiler = Compiler2 new.
	source = Source new.
	objectClass <CompiledMixinMirror>
	classClass <CompiledMixinMirror>
	metaclassClass <CompiledMixinMirror>
	undefinedObjectClass <CompiledMixinMirror>
	coreClassesClass <CompiledMixinMirror>
|objectClass:: compileClass: objectClassSource.
	classClass:: compileClass: (sourceFromClass: source Class mixin definingClass).
	metaclassClass:: compileClass: (sourceFromClass: source Metaclass mixin definingClass).
	undefinedObjectClass:: compileClass: (sourceFromClass: source UndefinedObject mixin definingClass).
	coreClassesClass:: compileClass: (sourceFromClass: source CoreClasses mixin definingClass))
(
class Source = (
"Contains classes that are transformed into text for being compiled into Javascript."||)
(
class Class = (|
|)
() : ()
class CoreClasses = (|
	uniqueObject = Object new.
	|)
(
class Array = ()
('as yet unclassified'
, list = (
	| newArray |
	newArray:: self Array new.
	newArray addAll: self.
	newArray addAll: list.
	^newArray
)
= another = (
	self size = another size ifFalse: [^false].
	self keysAndValuesDo:
		[:index :value |
		value = (another at: index) ifFalse: [^false]].
	^true.
)
addAll: array = (
	array do: [:each | self add: each]
)
asArray = (
	^self
)
asSortedList = (

	^ sort: 1 to: size  using: [:a :b | a <= b]
)
atAllPut: anObject = (
	1 to: self size do: [:index | self at: index put: anObject]
)
binarySearchFor: el between: start and: end toCompare: compare =(
	"This does a binary search for the index such that if el was inserted before it
	  the receiver would remain sorted.  The receiver must be sorted relative to the
	  comparison block.  The comparison block should return true if the first block argument
	  cannot appear after the second block argument"

	| low high |
	low:: start.
	high:: end.
	[ low <= high ]
		whileTrue:
				[	| mid |
					mid:: (low + high) // 2.
	  				(compare value: (self at: mid) value: el)
						ifTrue: [ low:: mid + 1 ]	
						ifFalse: [ high:: mid - 1 ]].
	^low
)
clone = (

	^ self collect: [:each | each]
)
collect: aBlock = (
	| result |
	result:: self Array new.
	self do: [:each | result add: (aBlock value: each)].
	^result
)
copyWithSize: s = (

	| safeself |
	safeself:: self.
	^ (self Array new: s) replaceFrom: 1 to: (s min: self size) with: safeself
)
defaultSort: from to: to = (

	^self mergeSortFrom: from to: to by: [:a :b | a <= b]
)
detect: aBlock = (

	self do: [:each | (aBlock value: each) ifTrue: [^ each]].
	Error signal: 'Object is not in the collection.'
)
do: aBlock separatedBy: betweenBlock = (
	self keysAndValuesDo:
		[:index :element |
		aBlock value: element.
		(index = self size) ifFalse: [betweenBlock value]].
)
doWithIndex: aBlock = (
	^self keysAndValuesDo: aBlock
)
first = (

	^ self at: 1
)
includes: element = (

	self do: [:each | each = element ifTrue: [^ true]].
	^ false
)
inject: val into: f = (

	"Taken from NSCollections"
	| v <X> |
	v:: val.
	self do: [ :e <X> |	v:: f value: v value: e ].
	^v
)
isEmpty = (

	^ 0 = size
)
last = (

	^ self at: self size
)
mergeFirst: first middle: middle last: last into: dst by: aBlock = (
	"Private. Merge the sorted ranges [first..middle] and [middle+1..last] 
	of the receiver into the range [first..last] of dst."

	| i1 i2 val1 val2 out |
	i1:: first.
	i2:: middle + 1.
	val1:: self at: i1.
	val2:: self at: i2.
	out:: first - 1.  "will be pre-incremented"

	"select 'lower' half of the elements based on comparator"
	[(i1 <= middle) and: [i2 <= last]] whileTrue:
		[(aBlock value: val1 value: val2)
			ifTrue: [dst at: (out:: out + 1) put: val1.
					val1:: self at: (i1:: i1 + 1)]
			ifFalse: [dst at: (out:: out + 1) put: val2.
					i2:: i2 + 1.
					i2 <= last ifTrue: [val2:: self at: i2]]].

	"copy the remaining elements"
	i1 <= middle
		ifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]
		ifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]
)
mergeSortFrom: first to: last src: src dst: dst by: aBlock = (
	"Private. Split the range to be sorted in half, sort each half, and 
	merge the two half-ranges into dst."

	| middle |
	first = last ifTrue: [^ self].
	middle:: (first + last) // 2.
	self mergeSortFrom: first to: middle src: dst dst: src by: aBlock.
	self mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.
	src mergeFirst: first middle: middle last: last into: dst by: aBlock
)
mergeSortFrom: startIndex to: stopIndex by: aBlock = (
	"Sort the given range of indices using the mergesort algorithm.
	Mergesort is a worst-case O(N log N) sorting algorithm that usually
	does only half as many comparisons as heapsort or quicksort."

	"Details: recursively split the range to be sorted into two halves,
	mergesort each half, then merge the two halves together. An extra 
	copy of the data is used as temporary storage and successive merge 
	phases copy data back and forth between the receiver and this copy.
	The recursion is set up so that the final merge is performed into the
	receiver, resulting in the receiver being completely sorted."

	self size <= 1 ifTrue: [^ self].  "nothing to do"
	startIndex = stopIndex ifTrue: [^ self].
	self assert: [startIndex >= 1 and: [startIndex < stopIndex]]. "bad start index"
	self assert: [stopIndex <= self size]. "bad stop index"
	self
		mergeSortFrom: startIndex
		to: stopIndex 
		src: self clone 
		dst: self 
		by: aBlock
)
reject: aBlock = (
	| result |
	result:: self Array new.
	self do: [:each | (aBlock value: each) ifFalse: [result add: each]].
	^result
)
replaceFrom: start to: stop with: replacement = (
	"This destructively replaces elements from start to stop in the receiver. 
	Answer the receiver itself. Use copyReplaceFrom:to:with: for 
	insertion/deletion which may alter the size of the result."

	replacement size = (stop - start + 1)
		ifFalse: [self error: 'Size of replacement doesnt match'].
	^self replaceFrom: start to: stop with: replacement startingAt: 1
)
replaceFrom: start to: stop with: replacement startingAt: repStart = (
	"This destructively replaces elements from start to stop in the receiver 
	starting at index, repStart, in the sequenceable collection, 
	replacementCollection. Answer the receiver. No range checks are 
	performed."

	| index repOff |
	repOff:: repStart - start.
	index:: start - 1.
	[(index:: index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]
)
select: aBlock = (
	| result |
	result:: self Array new.
	self do: [:each | (aBlock value: each) ifTrue: [result add: each]].
	^result
)
sort: from to: to  using: sortBlock = (

	^self mergeSortFrom: from to: to by: sortBlock
)) : ('as yet unclassified'
with: element = (

	^ {element}
))
class Block = ()
('as yet unclassified'
clone = (

	^ self
)
isBlock = (
	^true
)
repeat = (
	[true] whileTrue: self
)
whileFalse = (
	self whileFalse: []
)
whileTrue = (
	self whileTrue: []
)) : ()
class Boolean = ()
('as yet unclassified'
clone = (

	^ self
)
printString = (
	^self ifTrue: ['true'] ifFalse: ['false']
)) : ()
class Delay computation: c = (
"A Javascript-friendly reimplementation of Delay not relying on reassigning an object's class."|
	computation = c.
	computedValue ::= uniqueObject.
|)
('as yet unclassified'
doesNotUnderstand: aMessage = (
	^aMessage sendTo: (self class ensureIsNoDelay: self)
)
isKindOfDelay = (

	^ true
)) : ('as yet unclassified'
ensureIsNoDelay: object  = (

	^ object isKindOfDelay
		ifTrue: [
			object computedValue == uniqueObject ifTrue: [
				object computedValue: object computation value].
			object computedValue]
		ifFalse: [object]
))
class Error description: d <String> = (|
	private descriptionText = d.
|)
('as yet unclassified'
description = (
	^descriptionText
)
printString = (
	"Classes don't have a name. We could ask for a class mirror and then ask for a name, but do we have access to a mirror module here?"
	^ class printString, ' ',  description
)
signal = (
	"This method is replaced by the bootstrap code with the actual implementation that does essentially 'throw this'."
)) : ('as yet unclassified'
signal: description = (

	(self description: description) signal
))
class False = Boolean ()
() : ()
class Message selector: selector arguments: arguments = (|
	public selector = selector.
	public arguments = arguments.
|)
('as yet unclassified'
printString = (
	^'a Message #', selector
)
sendTo: anObject = (
"Send the receiver to the specified object and return the result. This method is a documentation stub. The actual implementation is supplied by the bootstrap code. It could be described as
	^anObject perform: selector withArguments: arguments
except in Newspeak Object does not havethe #perform: behavior."
)) : ('as yet unclassified'
selector: selector = (

	^ self selector: selector arguments: {}
)
sendTo: object selector: selector arguments: arguments = (

	^ (self selector: selector arguments: arguments)
		sendTo: object
))
class MessageNotUnderstood message: aMessage = Error description: 'MessageNotUnderstood: #', aMessage selector (
"The error signalled by the default implementation of the doesNotUnderstand: method."|
	message = aMessage.
|)
('as yet unclassified'
printString = (
	^description
)) : ()
class MixinHandle = (
"An opaque reference to the mixin of a class. Instances of this class are returned by the #mixin method of a metaclass. The method stores a reference to the underlying mixin (a Javascript object) in a property of the newly created object not visible to Newspeak code."|
|)
('as yet unclassified'
|> aClass = (
	"Magic. This method exists here only for documentation. Bootstrap code replaces it with the actual implementation, which cannot be expressed in Newspeak. The implementation applies the underlying mixin stored in a property of the receiver inaccesible to Newspeak code to the argument and returns the factory of the resulting class."
)) : ()
class Number = ("A fake class of numbers. The actual runtime numbers are Javascript numbers, either primitive values or objects derived from Number.prototype. However, Number.prototype is augmented with the methods defined in this class, so for practical purproses runtime numbers do exhibit the behavior defined here. They also report this class in response to the #class message.")
('as yet unclassified'
@ number = (
	^(self Array new: 2)
		at: 1 put: self;
		at: 2 put:  number;
		yourself
"For the JS implementation, the above Array access must be written as an explicit self send rather than as a here send or a tuple (brace) syntax. This way the Array reference comes from the method inherited from Object rather than from the lexical scope. Lexical scope access doesn't work because runtime numbers are Javascript numbers rather than proper instances of this class. We could make lexical access work by adding an enclosing object array to Number.prototype but it doesn't seem worth the trouble."
)
asInteger = (

	^ self // 1
)
between: min and: max = (

	^ self >= min and: [self <= max]
)
clone = (

	^ self
)
identityHash = (
	^self
)
isNumber = (
	^true
)
max: other = (

	^ self > other
		ifTrue: [self]
		ifFalse: [other]
)
min: other = (

	^ self < other
		ifTrue: [self]
		ifFalse: [other]
)
odd = (
	^self even not
)
positive = (

	^ self >= 0
)
sign = (

	self > 0 ifTrue: [^1].
	self < 0 ifTrue: [^-1].
	^0
)
timesRepeat: aBlock = (
	1 to: self do: [:i | aBlock value]
)) : ()
class String = ()
('as yet unclassified'
asString = (
	^self
)
asSymbol = (

	"We're not really distinguishing strings/symbols. Yet, some existing code relies on this being available. So this should probably go away at some point."
	^ self
)
beginsWith: string = (

	string size > self size ifTrue: [^ false].
	"An efficient implementation wouldn't copy the string.
	We could for example do this.indexOf(string) == 0;"
	^ string = (self copyFrom: 1 to: string size)
)
between: a and: b = (

	^ self >= a and: [self <= b]
)
clone = (

	^ self
)
copyWithSize: newSize = (

	"This differes from the implementation in Array in order to not rely on mutating functions"
	| copyCount result |
	copyCount:: newSize min: self size.
	result:: self copyFrom: 1 to: copyCount.	
	[copyCount < newSize] whileTrue: [
		copyCount:: copyCount + 1.
		result:: result, ' '].
	^ result
)
first = (
	^self at: 1
)
hash = (
	"This implementation is not used; implemented in InfrastructureFunctions for speed to be equivalent to the code below."
	^self size = 0
		ifTrue: [0]
		ifFalse: [(self size * 32 bitXor: (self at: 1)) * 32 bitXor: (self at: self size)]
)
includes: element = (

	self do: [:each | each = element ifTrue: [^ true]].
	^ false
)
isKindOfCharacter = (
	^true
)
isLetter = (

	"Do we want isLetter at all? If yes, then we want it to work for more than English."
	^ (self >= 'a' and: [self <= 'z']) or: [
		self >= 'A' and: [self <= 'Z']]
)
isString = (
	^true
)
last = (
	^self at: self size
)
printString = (

	^ self
)
startsWith: element = (
	element size > self size ifTrue: [ ^ false ].
	^ (self copyFrom: 1 to: element size) = element
)) : ('as yet unclassified'
cr = (
	^self withCharCode: 13 
)
lf = (
	^self withCharCode: 10
)
null = (
	^self withCharCode: 0
)
tab = (
	^self withCharCode: 9
)
withAll: collection = (

	| result |
	result:: ''.
	collection do: [:each | result:: result, each].
	^ result
))
class True = Boolean ()
() : ()) : ()
class Metaclass = (|
|)
() : ()
class UndefinedObject = ()
('as yet unclassified'
ifNil: nullaryBlock = (
	^nullaryBlock value
)
ifNotNil: unaryBlock = (
	^nil
)
isNil = (
	^true
)
notNil = (
	^false
)) : ()) : ()'accessing'
outputTo: stream = (
	writeHelperFunctionsTo: stream.
	writeObjectTo: stream.
	writeUndefinedObjectTo: stream.
	writeMetaclassTo: stream.
	writeClassTo: stream.
	writeCoreClassesTo: stream.
	writeArrayTo: stream.
	writeBlockTo: stream.
	writeBooleanTo: stream.
	writeDelayTo: stream.
	writeErrorTo: stream.
	writeNumberTo: stream.
	writeMessageTo: stream.
	writeMessageNotUnderstoodTo: stream.
	writeMixinHandleTo: stream.
	writeStringTo: stream.
)'as yet unclassified'
compileClass: source <String> ^<CompiledMixinMirror> = (
	^compiler compileClassSource: source readStream within: nil.
)
objectClassSource = (
"Bootstrapping the Object class from a real class definition, the way we handle all other classes, is tricky because of its name. Because of that, it's the only one compiled from a plain string rather than from source produced from a class definition."
^'Newsqueak2
''Language''
class Object = ("") (
	''unclassified''
	~= anObject = (^(self = anObject) not)
	~~ anObject = (^(self == anObject) not)
	hash = (^self identityHash)
	ifNil: nullaryBlock = (^self)
	ifNotNil: unaryBlock = (^unaryBlock value: self)
	isBlock = (^false)
	isNil = (^false)
	isNumber = (^false)
	isString = (^false)
	notNil = (^true)
	yourself = (^self)
	value = (^self)
	assert: block = (block value ifFalse: [Error signal])
	assert: block message: message = (block value ifFalse: [Error signal: message])
	FixedLengthString = (^ '''' class)
	Number = (^ 42 class)
	Integer = (^ 42 class)
	Double = (^ 42.23 class)
	isImmutable = (^false)
	isBlockLocalReturnAST = ( ^false )
	isKindOfBag = ("We do not want to specify these methods manually" ^ false)
	isKindOfCollection = ( ^ false)
	isKindOfCombinatorialParser = ( ^ false)
	isKindOfCharacter = ( ^false )
	isKindOfDelay = (^false)
)'
)
sourceFromClass: aClass = (
	| stream |
	stream:: (String new: 1000) writeStream.
	aClass printClassOn: stream.
	^stream contents
)
writeArrayTo: stream = (
	stream nextPutAll: 'var newspeakArrayFactory = coreClassesModule["#Array"]();'; cr.
	stream nextPutAll: 'exportForNodeJS("newspeakArrayFactory", newspeakArrayFactory);'; cr.
	stream nextPutAll: 'copyNewNewspeakMethods(newspeakArrayFactory.runtimeClass, Array.prototype);'; cr.
	stream nextPutAll: 'copyMetaclassMethods({
	"#new": function () { return new Array(); },
	"#new:": function (n) {
		var result = new Array(n);
		for(var i = 0; i < n; i++) {
			result[i] = newspeakUndefinedObject;
		}
		return result;
	}}, newspeakArrayFactory);'; cr; cr.
)
writeBlockTo: stream = (
	stream
		nextPutAll: 'var newspeakBlockFactory = coreClassesModule["#Block"]();'; cr;
		nextPutAll: 'exportForNodeJS("newspeakBlockFactory", newspeakBlockFactory);'; cr;
		nextPutAll: 'copyNewNewspeakMethods(newspeakBlockFactory.runtimeClass, Function.prototype);'; cr;
		nextPutAll: 'copyNewNewspeakMethods(newspeakBlockFactory.runtimeClass, blockPrototype);'; cr; cr.
)
writeBooleanTo: stream = (
	stream
		nextPutAll: 'var newspeakBooleanFactory = coreClassesModule["#Boolean"]();'; cr;
		nextPutAll: 'exportForNodeJS("newspeakBooleanFactory", newspeakBooleanFactory);'; cr;
		nextPutAll: 'copyNewNewspeakMethods(newspeakBooleanFactory.runtimeClass, Boolean.prototype);'; cr; cr.
)
writeClassTo: stream = (
	stream
		nextPutAll: 'var newspeakClassFactory = '.
	compiler outputTopLevelClass: classClass to: stream.
	stream nextPutAll: ';'; cr.
	stream nextPutAll: 'exportForNodeJS("newspeakClassFactory", newspeakClassFactory);'; cr.
	"We must copy methods such as basicNew to the bootstrapped class"
	stream nextPutAll: 'copyNewProperties(newspeakClassRC, newspeakClassFactory.runtimeClass);'; cr; cr.
	stream
		nextPutAll: 'newspeakClassRC = newspeakClassFactory.runtimeClass;'; cr;
		nextPutAll:'fixPrototypesOfFactory(newspeakObjectFactory);';cr;
		nextPutAll:'fixPrototypesOfFactory(newspeakClassFactory);';cr;
		nextPutAll:'fixPrototypesOfFactory(newspeakUndefinedObjectFactory);';cr;
		nextPutAll:'fixPrototypesOfFactory(newspeakMetaclassClassFactory);';cr; cr.
	
)
writeCoreClassesTo: stream = (
	stream nextPutAll: 'var coreClassesFactory = '.
	compiler outputTopLevelClass: coreClassesClass to: stream.
	stream nextPutAll: ';'; cr.
	stream nextPutAll: 'exportForNodeJS("coreClassesFactory", coreClassesFactory);'; cr.
	stream nextPutAll: 'var coreClassesModule = coreClassesFactory["#new"]();'; cr; cr.
)
writeDelayTo: stream = (
	stream
		nextPutAll: 'var delayFactory = coreClassesModule["#Delay"]();'; cr; 
		nextPutAll: 'exportForNodeJS("delayFactory", delayFactory);'; cr;
		cr.
)
writeErrorTo: stream = (
	stream
		nextPutAll: 'var newspeakErrorFactory = coreClassesModule["#Error"]();'; cr;
		nextPutAll: 'exportForNodeJS("newspeakErrorFactory", newspeakErrorFactory);'; cr;
		nextPutAll: 'copyAllNewspeakMethods({"#signal": function () {throw this;}}, newspeakErrorFactory.runtimeClass);'; cr; cr
)
writeFalseTo: stream = (
	stream
		nextPutAll: 'var newspeakFalseFactory = coreClassesModule["#False"]();'; cr;
		nextPutAll: 'exportForNodeJS("newspeakFalseFactory", newspeakFalseFactory);'; cr;
		cr.
)
writeHelperFunctionsTo: stream = (
"copyNewProperties -- copy all properties (own and inherited), provided the property does not already exist in the target. This is currently used to copy primitive methods to the bootstrapped newspeakClassFactory. Existing properties are left alone because this allows us to define them as primitives at an earlier bootstrapping stage."
	stream nextPutAll:
'function copyNewProperties(source, target) {
	for (property in source) {
		if (target[property] == undefined) {
			target[property] = source[property];
		}
	}
}'; cr; cr.

"copyNewNewspeakMethods -- copy all function properties (own and inherited) whose name begins with a #, provided the property does not already exist in the target. This is normally used to copy methods from a runtime class to a function prototype to have the prototype define the same behavior as the class. Existing properties are left alone because this allows us to define them as primitives at an earlier bootstrapping stage."
	stream nextPutAll:
'function copyNewNewspeakMethods(source, target) {
	for (property in source) {
		if (property[0] == "#" && typeof source[property] == "function" && target[property] == undefined) {
			target[property] = source[property];
			makePropertyNotEnumerable(target, property);
		}
	}
}'; cr; cr.
"copyAllNewspeakMethods -- copy all function properties (own and inherited) whose name begins with a #. If the property already exists in the target, overwrite it. This is normally used to copy a set of methods into a runtime metaclass to make the factory return things other than actual instances of the class."
	stream nextPutAll:
'function copyAllNewspeakMethods(source, target) {
	for (property in source) {
		if (property[0] == "#" && typeof source[property] == "function") {
			target[property] = source[property];
		}
	}
}'; cr; cr.
	stream nextPutAll:
'function copyMetaclassMethods(source, factory) {
	copyAllNewspeakMethods(source, Object.getPrototypeOf(factory));
}'; cr; cr.
	stream nextPutAll:
'function exportForNodeJS(name, value) {
	if (javascriptEngineName() == "NodeJS") {
		this[name] = value;
	}
}'; cr; cr.
)
writeMessageNotUnderstoodTo: stream = (
	stream
		nextPutAll: 'var messageNotUnderstoodFactory = coreClassesModule["#MessageNotUnderstood"]();'; cr; 
		nextPutAll: 'exportForNodeJS("messageNotUnderstoodFactory", messageNotUnderstoodFactory);'; cr;
		cr.
)
writeMessageTo: stream = (
	stream
		nextPutAll: 'var messageFactory = coreClassesModule["#Message"]();'; cr;
		nextPutAll: 'exportForNodeJS("messageFactory", messageFactory);'; cr;
		nextPutAll: 'messageFactory.runtimeClass["#sendTo:"] = function (obj) { return sendMessageN.apply(null, [obj, "#" + sendMessage0(this, "#selector")].concat(sendMessage0(this, "#arguments"))); };'; cr; cr.
)
writeMetaclassTo: stream = (
	stream
		nextPutAll: 'var newspeakMetaclassFactory = '.
	compiler outputTopLevelClass: metaclassClass to: stream.
	stream nextPutAll: ';'; cr.
	stream nextPutAll: 'exportForNodeJS("newspeakMetaclassFactory", newspeakMetaclassFactory);'; cr.
	stream
		nextPutAll:
'newspeakMetaclassRC = newspeakMetaclassFactory.runtimeClass;
copyAllNewspeakMethods(
	{"#superclass": function () { return newspeakClassFactory; },
	 "#class": function () { return this.factory; },
	 "#mixin": function () { return this.runtimeClass.mixin.mixinHandle(); }
	}, 
	newspeakMetaclassRC);
var newspeakMetaclassClassRC = Object.getPrototypeOf(newspeakMetaclassFactory);
function MetaclassClassFactory() {
	this.runtimeClass = newspeakMetaclassClassRC;
	this.newspeakMetaobjectType = "MetaclassClassFactory";
	this["#class"] = function () { return newspeakMetaclassFactory; };
}
MetaclassClassFactory.prototype = newspeakMetaclassRC;
var newspeakMetaclassClassFactory = new MetaclassClassFactory();
'.
	stream cr; cr.
)
writeMixinHandleTo: stream = (
	stream
		nextPutAll: 'var mixinHandleFactory = coreClassesModule["#MixinHandle"]();'; cr;
		nextPutAll: 'exportForNodeJS("mixinHandleFactory", mixinHandleFactory);'; cr;
		nextPutAll:
'mixinHandleFactory.runtimeClass["#|>"] = function (factory) {
	var app = invokeMixin(this.underlyingMixin, factory.runtimeClass);
	var enclosingObjectsProperty = "enclosingObjects`" + this.underlyingMixin.metadata.name;
	app[enclosingObjectsProperty] = this.definingClass[enclosingObjectsProperty];
	return app.factory;
}'; cr; cr.
)
writeNumberTo: stream = (
	stream
		nextPutAll: 'var newspeakNumberFactory = coreClassesModule["#Number"]();'; cr;
		nextPutAll: 'exportForNodeJS("newspeakNumberFactory", newspeakNumberFactory);'; cr;
		nextPutAll: 'copyNewNewspeakMethods(newspeakNumberFactory.runtimeClass, Number.prototype);'; cr; cr.
)
writeObjectTo: stream = (
	stream
		nextPutAll: 'var newspeakObjectFactory = '.
	compiler outputTopLevelClass: objectClass to: stream.
	stream nextPutAll: ';'; cr.
	stream nextPutAll: 'exportForNodeJS("newspeakObjectFactory", newspeakObjectFactory);'; cr.
	stream nextPutAll: 'newspeakObjectRC = newspeakObjectFactory.runtimeClass;'; cr; cr.
	"the newspeakUndefinedObject redefinition evaluated at a later time will also set the runtime class' superclass to nil"
)
writeStringTo: stream = (
	stream
		nextPutAll: 'var newspeakStringFactory = coreClassesModule["#String"]();'; cr;
		nextPutAll: 'exportForNodeJS("newspeakStringFactory", newspeakStringFactory);'; cr;
		nextPutAll: 'copyNewNewspeakMethods(newspeakStringFactory.runtimeClass, String.prototype);'; cr;
		nextPutAll: 'copyMetaclassMethods(
			{
				"#new" : function () { return ""; },
				"#withCharCode:" : function (charCode) { return String.fromCharCode(charCode); }
			}, 
			newspeakStringFactory)'; cr; cr.
)
writeTrueTo: stream = (
	stream
		nextPutAll: 'var newspeakTrueFactory = coreClassesModule["#True"]();'; cr;
		nextPutAll: 'exportForNodeJS("newspeakTrueFactory", newspeakTrueFactory);'; cr;
		cr.
)
writeUndefinedObjectTo: stream = (
	stream
		nextPutAll: 'var newspeakUndefinedObjectFactory = '.
	compiler outputTopLevelClass: undefinedObjectClass to: stream.
	stream nextPutAll: ';'; cr.
	stream nextPutAll: 'exportForNodeJS("newspeakUndefinedObjectFactory", newspeakUndefinedObjectFactory);'; cr.
	stream nextPutAll: 'newspeakUndefinedObject = newspeakUndefinedObjectFactory["#new"]();'; cr.
	stream nextPutAll: 'newspeakObjectRC.superclass = newspeakUndefinedObject;'; cr; cr.
)) : ()
class PropertyCallAST = MessageAST (
"Sepcialized node to represent applications of JS properties. In some cases (well, at least one) we need to generate ASTs that call javascript methods directly. These calls need to be translated slightly differently (their names must not be mangled). To distinguish these form normal message sends, we use this node.")
('as yet unclassified'
apply: tool <ASTTool> = (
	^tool propertyCallNode: self
)) : ()
class Scope = (
"A generic scope facility.

The text below describes the intended scheme for handling closures using the Cog VM's closure support. It is not yet implemented.

To support efficient compilation of closures, each scope tracks how many temporary variables need to ''remote''. 

A remote temporary is one that is closed over by a nested closure, and cannot reliably be copied down into the closure upon closure creation.  Any temporary that might be written to after closure creation is necessarily remote.

Remote temps are allocated in an array rather than directly in their activation. All the remote temps in a given scope are alllocated in a single array, the remote temp vector. Each remote temp is uniquely identified by an index into th eremote temp vector.

Closures nested within the scope get a reference to the remote temp vector. They can and read and write a temporary by modifying the vector using the index associated with the temporary.

Typically, the first instruction in the code of a closure or method allocates the remote temp vector (if one is needed). This is supported by a special byte code, pushArray.

Reads and writes to a remote temp take the form of at: i and at: i put: v sends where i is the index of the remote temp and v is the value being written to it.

A temporary variable is considered remote iff:

a. It is written to in a closure nested within its defining method or closure.
b. It is read in in a closure c nested within its defining method or closure, and written to after the end of c.

"| 
  superScope 
  bindings =  Dictionary new.
	public end <Integer>
 |)
('access'
at: aKey put: aValue = (


^self bindings at: aKey put: aValue
)
at: aKey put: aValue ifThere: aBlock = (

    "Associates aValue with aKey and answers aValue if aKey
    was absent. Otherwise answers the value of aBlock."
    | wasAbsent |
    self assert: [aKey isSymbol] 
	message:['Attempt to ok up non-symbol ',aKey printString, ' in scope'].
    wasAbsent:: false.
    bindings at: aKey ifAbsent: [bindings at: aKey put: aValue. wasAbsent:: true].
    ^ wasAbsent
        ifTrue: [aValue]
        ifFalse: [aBlock value]
)
at: key = (

	"Answers the value associated with aKey in this or one the super scopes or fails if aKey is absent"
	^self at: key ifAbsent: [self error: 'Key ', key, ' not found!']
)
at: key ifAbsent: blk = (

    "Answers the value associated with aKey in this or one of the superScopes or the value of aBlock if aKey is absent."

	"Optimization note: This is written using [nil] blocks to avoid passing 
		non-clean blocks dynamically down the scope structure."

	| val <T> |
	(val:: self bindings at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	self superScope isNil
		ifTrue: [ ^blk value ].
	(val:: self superScope at: key ifAbsent: [ nil ]) notNil
		ifTrue: [ ^val ].
	^blk value
)
clear = (


self bindings keys do:[:k | self bindings removeKey: k].
)
includesIndex: key = (
"should this search the superscope?"
    ^ self bindings includesKey: key
)
includesIndexLocally: key <NameType > ^ <Boolean> = (


^self bindings includesKey: key.
)
removeKey: key = (


self bindings removeKey: key
)
removeKey: key ifAbsent: blk = (


self bindings removeKey: key ifAbsent: blk
)
within: scope = (
    "Creates and initializes a new (sub)scope within scope."
      self superScope: scope.
  )'as yet unclassified'
depth ^ <Integer> = (
	superScope ifNil:[^0].
	^superScope depth + 1.
)) : ()
class SemanticMethod decl: d <MethodAST> = SemanticNode onAST: d (
"Semantic info for a method declaration. Things like the frame size"|
frameSize <Integer>
|)
() : ()
class SemanticNode onAST:  ast = (
"Represents semantic information about a construct."|
tree = ast.
|)
() : ()
class SemanticVarDecl decl: d <VarDeclAST> = SymbolTableEntry for: d (
"Semantic info for a variable: slot, local or parameter."|
  offset <Integer>
  remote ::= false.
  remoteVector <SemanticVarDecl>
|)
('as yet unclassified'
isTemporaryAST ^ <Boolean> = (
	^data isTemporaryAST
)
setIndex: i <Integer> InVector: v <VarDeclAST> = (
	assert: remote message: 'Var Decl is not remote'.
	remoteVector:: v.
	offset:: i.
)
variableClass ^ <Class> = (
	^data variableClass
)) : ()
class SlotMirror named: name source: source isMutable: isMutable = (|
	public name = name.
	public source = source.
	public isMutable = isMutable.
|)
() : ()
class SymbolTableEntry for: datum = (| 
  sym  
  data = datum first.  
  depth = datum last.  
|)
('as yet unclassified'
isMethodNode = (^self data  isMethodNode)'testing'
isMessagePatternNode = (^self data  isMessagePatternNode)
isVarDeclNode = (^self data isVarDeclNode)) : ()'as yet unclassified'
assert: block <[^Boolean]> = (
	block value ifFalse: [error: 'assertion failed']
)
fullyQualifiedNameToSimple: fullName <String> = (
	| parts |
	
	parts:: splitFullyQualifiedName: fullName.
	^parts last asSymbol
)
fullyQualifySimpleName: simpleName <Symbol> with: fullyQualifiedPackage <Symbol> = (
	^(fullyQualifiedPackage asString, syntheticNameSeparator, simpleName) asSymbol
)
mixinNameOfClassNamed: className <String> ^<Symbol> = (
	| simpleNames <Collection[String]> rawNames <Collection[String]> |
	rawNames:: splitFullyQualifiedName: className. 
	rawNames size =1 ifTrue: [^className].
	simpleNames:: rawNames select: [:n <String>  | 
					n size == 0 or: [ n first isLetter ]].
				"this was isDigit--either add isDigit to core string, or perhaps use between:and:" 
	assert: [simpleNames size >= 2].
	^(simpleNames inject: '' into: [:sn1 <String>  :sn2 <String> | sn1, syntheticNameSeparator, sn2]) asSymbol
)
mixinSlotNameFor: nestedName <String> = (
	| mixinName <String> |
	mixinName:: mixinNameOfClassNamed: nestedName.
	^mixinName, syntheticNameSeparator, 'slot'
)
split: aString at: aCharacter = (
	| parts start |
	parts:: OrderedCollection new.
	start:: 1.
	1 to: aString size do:
		[:index |
		(aString at: index) = aCharacter ifTrue:
			[parts add: (aString copyFrom: start to: index - 1).
			start:: index + 1]].
	parts add: (aString copyFrom: start to: aString size).
	^parts
)
splitFullyQualifiedName: fqn = (

	"Make sure we pass only the first character, so that the code works in image and on JS"
	^ split: fqn at: syntheticNameSeparator first
)
syntheticNameSeparator ^<String> = (
	^'`'
)) : ()