Newspeak3
'AliensForJavascript'
class AliensForJavascriptTesting usingPlatform: platform testing: aliens testFramework: utf = (
(*
   Copyright 2012 SAP AG.
   
   Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
*)|
	private TestContext = utf TestContext.
	private MessageNotUnderstood = platform exceptions MessageNotUnderstood.
	private aliens = aliens.

	private Expat = aliens Expat.
	private NaiveExpat = aliens NaiveExpat.
	private JavascriptEvaluator = aliens JavascriptEvaluator.
	
	private Map = platform collections MutableHashedMap.
|)
(
class AlienTests = TestContext (|
|)
('as yet unclassified'
alienFor: javascriptSource = (

	|javascriptObject |

	javascriptObject:: aliens JavascriptEvaluator eval: '(', javascriptSource, ')'.
	^ aliens Alien onJavascriptObject: javascriptObject.
)
expatIdempotency = (
	(*expat(Expat(x)) = Expat(x)*)
	| x expatOfX |
	x = Object new.
	expatOfX = Expat ExpatBuilder onNewspeakObject:x.
	assert:[(Expat ExpatBuilder onNewspeakObject: expatOfX) == expatOfX]
)
expatOfAlien = (
	(*expat(Alien(x)) = x*)
	assert:[
		JavascriptEvaluator eval: '
		function() {
		   var x = {}
		   return Expat["#ExpatBuilder]()[#onNewspeakObject:](x) === x
		}
		']
)
testAccessFunctionObject = (

	(*Javascript can reify methods/functions without the need for mirrors. What if we want to access a Javascript program that relies on this?*)
	
	| alien |
	alien:: alienFor:'{
		f : function() {return 21;},
		g : function(h) {return 2 * h();}}'.
	assert: [42 = (alien g: {[alien f]})].
	assert: [ | x |
		x:: 2.
		84 = (alien g: {[x * alien f]})]
)
testBinaryMethods = (

	| alien |
	alien:: alienFor: '{a: 3, b: 4}'.
	assert: [alien a + alien b = 7]
)
testCallMethods = (

	| alien |
	
	alien:: alienFor: '{f : function(){return 42;}}'.
	assert: [alien f = 42].
	
	alien:: alienFor: '{f : function(x, y){return x + y;}}'.
	assert: [(alien f: {3. 4}) = 7].
	
	alien:: alienFor: 'new function() {this.x = 42; this.f = function() {return this.x;}}'.
	assert: [alien f = 42]
)
testCannotWriteNonexistentProperty = (

	| alien |
	alien:: alienFor: '{name: ''e.t.''}'.
	should: [alien location: 'earth'] signal: MessageNotUnderstood
)
testNameManglingClashes = (

	(*How are we going to treat these kind of name clashes?
	We can't simply replace ':' with '_' and '_' with '__', as properties might also contain '::'*)
	| alien |
	alien:: alienFor: '{
		"slot"  : 1,
		"slot:" : 2,
		"slot_" : 3}'.
	assert: [false]
)
testReadProperty = (

	| alien |
	alien:: alienFor: '{name: ''e.t.''}'.
	assert: [alien name = 'e.t.']
)
testWrappingArguments = (

	| alien |
	alien:: alienFor: '{
		f : function(x, y){return x + y;},
		a: 3,
		b: 4,
		c: 7}'.
	assert: [(alien f: {alien a. alien b}) = alien c]
)
testWriteProperty = (

	(*Shouldn't we also check the actual JS-object using llm?*)
	| alien |
	alien:: alienFor: '{name: ''e.t.'', location: ''mars''}'.
	alien location: 'earth'.
	assert: [alien location = 'earth']
)) : ('as yet unclassified'
TEST_CONTEXT = (
	
))
class ExpatTests = TestContext (|
	private cachedExpat
	private newspeakObject = TestedClass new.
|)
(
class TestedClass = (
(*An instances of this class becomes the expat for the tests*)|
		string = 'xyz'.
		number ::= 42.
		(*Cannot be called 'boolean' because that appears to be some reserved world*)
		bool = true.
		array = {1. 'x'. Inner new}.
|)
(
class Inner = (|
	foo = 123.
|)
('as yet unclassified'
alsoWill: x be: y translated: z = (

	^ x + y + z
)) : ()
class OtherInner factory: x = (|
	x = x.
|)
() : ()'as yet unclassified'
callFooOn: object = (

	^ object foo
)
callFooWithInnerOn: object = (

	^ object foo: Inner new
)
createAnInstanceOfAndReturnFoo: klass = (

	^ klass new foo
)
foo = (

	^ 23
)
plus5: x = (
	^ x + 5
)
valuePlus6: block = (
	^ block value + 6
)
will: x be: y translated: z = (

	^ x + y + z
)
withAndWithoutColon = (

	^ 2
)
withAndWithoutColon: x = (

	^ x
)) : ()'as yet unclassified'
eval: javscriptSource = (

	^ JavascriptEvaluator
		evalFunction: 
			'function(expat) {
				return ', javscriptSource, '
			}'
		with: {expat}

)
expat = (

	nil = cachedExpat ifTrue: [
		cachedExpat:: Expat onNewspeakObject: newspeakObject].
	^ cachedExpat
)
testAccessNestedClass = (

	(*Must use x()['y'] syntax, as rhino can't handle x().y*)
	assert:: eval: 'expat.Inner()["new_"]()["foo"]() == 123'.
	assert:: eval: 'expat.OtherInner()["factory"](83)["x"]() == 83'
)
testAccessNewspeakMethodsOfJavascriptPrimitiveTypes = (

	(*We currently do not create expats on Javascript's primitive types. This results in Newspeak's methods not being exposed on such returned objects. So this is expected to fail.*)
	assert:: eval: 'expat.array().size()'.
	assert:: eval: 'expat.bool().not()'.
	assert:: eval: 'expat.number().neg()'.
	assert:: eval: 'expat.string().size()'.
)
testCallMethod = (

	assert:: eval: 'expat.foo() == 23'
)
testCallMethodWithArguments = (

	assert:: eval: 'expat.plus5(10) == 15'
)
testConvertArrays = (

	assert:: eval: 'expat.array()[0] == 1'.
	assert:: eval: 'expat.array()[1] == "x"'.
	assert:: eval: 'expat.array()[2].foo() == 123'.
)
testConvertBasicTypes = (

	assert:: eval: 'expat.string() == "xyz"'.
	assert:: eval: 'expat.number() == 42'.
	assert:: eval: 'expat.bool() == true'.
)
testDuplicateNames = (

	assert:: eval: 'expat.withAndWithoutColon() == 2'.
	assert:: eval: 'expat.withAndWithoutColon_(5) == 5'
)
testFunctionsCanActAsBlocks = (

	assert:: eval: 'expat.valuePlus6(function () {return 20;}) == 26'
)
testNameTranslation = (

	aliens requestedNameMapping at: #'AliensForJavascriptTesting`ExpatTests`TestedClass' put: (
		Map new
			at: 'will:be:translated:' put: 'translatedSelector';
			yourself).
	aliens requestedNameMapping at: #'AliensForJavascriptTesting`ExpatTests`TestedClass`Inner' put: (
		Map new
			at: 'alsoWill:be:translated:' put: 'otherTranslatedSelector';
			yourself).
	assert:: eval: 'expat.translatedSelector(1, 2, 3) == 6'.
	(*Must use x()['y'] syntax, as rhino can't handle x().y*)
	assert:: eval: 'expat.Inner()["new_"]()["otherTranslatedSelector"](3, 4, 5) == 12'
)
testPassExpatsAsParameters = (

	assert:: eval: 'expat.createAnInstanceOfAndReturnFoo(expat.Inner()) == 123'.
)
testPassObjectCallMethodOnIt = (

	assert:: eval: 'expat.callFooOn({foo: function() {return 24}}) == 24'
)
testPassObjectCallMethodWithArgumentsOnIt = (

	assert:: eval: 'expat.callFooWithInnerOn({foo: function(inner) {return inner.foo()}}) == 123'
	
)
testReadSlot = (

	assert:: eval: 'expat.number() == 42'
)
testWriteSlot = (

	eval: 'expat.set_number(23)'.
	assert: newspeakObject number = 23.
)) : ('as yet unclassified'
TEST_CONTEXT = (
	
))
class NaiveExpatTests = TestContext (|
	cachedExpat
	newspeakObject = TestedClass new.
|)
(
class TestedClass = (
(*Describe the class in this comment.*)|
	slot1 = 1.
	slot2 = 2.
	string = 'xyz'.
	number = 42.
	bool = true.
|)
(
class Inner = (
(*Describe the class in this comment.*)|
	onetwothree = 123.
|)
() : ()'as yet unclassified'
callFooWithInnerOn: object = (

	^ object foo: Inner new
)
createAnInstanceOfAndReturnOneTwoThree: klass = (

	^ klass new onetwothree
)
valuePlus6: block = (
	^ block value + 6
)) : ()'as yet unclassified'
eval: javscriptSource = (

	^ JavascriptEvaluator
		evalFunction: 
			'function(expat) {
				return ', javscriptSource, '
			}'
		with: { expat }

)
expat = (

	nil = cachedExpat ifTrue: [
		cachedExpat:: NaiveExpat onNewspeakObject: newspeakObject].
	^ cachedExpat
)
testConvertBasicTypes = (

	assert:: eval: 'expat.invokeOn("string", []) == "xyz"'.
	assert:: eval: 'expat.invokeOn("number", []) == 42'.
	assert:: eval: 'expat.invokeOn("bool",[]) == true'.
)
testFunctionsCanActAsBlocks = (
	(*assert:: eval: 'expat.valuePlus6(function () {return 20;}) == 26'*)
	assert:: eval: 'expat.invokeOn(
					"valuePlus6_",
					[function () {return 20;}]) == 26'
)
testPassExpatsAsParameters = (
	(*assert:: eval: 'expat.createAnInstanceOfAndReturnFoo(expat.Inner()) == 123'.*)
	assert:: eval: 'expat.invokeOn(
					"createAnInstanceOfAndReturnOneTwoThree_",
					[expat.invokeOn("Inner",[])]) == 123'.
)
testPassObjectToNaiveExpatCallMethodWithArgumentsOnIt = (
	(*assert:: eval: 'expat.callFooWithInnerOn({foo: function(inner) {return inner.foo()}}) == 123'*)
	assert:: eval: 'expat.invokeOn(
					"callFooWithInnerOn_", 
					[{ foo: function(inner) { 
						return inner.invokeOn("onetwothree", []) }}]) == 123'
)
testReadSlot = (
	assert:: eval: 'expat.invokeOn("slot1", []) == 1'
)
testWriteSlot = (
	eval: 'expat.invokeOn(
					"set_slot2",
					[ 23 ])
		'.
	assert: newspeakObject slot2 = 23.
)) : ('as yet unclassified'
TEST_CONTEXT = (
	
))
class TestingInfrastructure = TestContext (|

|)
() : ()) : ()