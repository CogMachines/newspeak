Newspeak3
'VmMirror-Squeak'
class SqueakVmMirror usingPlatform: platform = (
"Copyright 2008 Cadence Design Systems, Inc.
Copyright 2012 Cadence Design Systems, Inc.
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0
"|
	SqNoFields = 2r0000.
	SqFixedPointerFields = 2r001.
	SqIndexablePointerFields = 2r0010.
	SqFixedAndIndexablePointerFields = 2r0011.
	SqIndexableAndWeakIndexablePointerFields = 2r0100.
	SqIndexableWordFields = 2r0110.
	SqIndexableByteFields = 2r1000.
	SqHashWidth = 12.
	SqCciWidth = 5.
	SqFmtWidth = 4.
	SqSizeWidth = 6.
	SqHtWidth = 2.
	SqSizeMaskLow = 2r111111.
	SqIntegerTagWidth = 1.
	SqMaxFieldsShifted = 4.

	protected IdentityDictionary = platform blackMarket IdentityDictionary.
	protected Behavior = platform blackMarket Behavior.
	protected MethodDictionary = platform blackMarket MethodDictionary.
	protected CompiledMethod = platform blackMarket CompiledMethod.
	protected Transcript = platform blackMarket Transcript.
	protected UnhandledError = platform blackMarket UnhandledError.

	"Hack to workaround bug in NS2 compiler"
	SqueakVmMirror = self.

	private assert = platform blackMarket Assert new.

	objectUtil = ObjectMirrorHelper withObjectPrimitives: platform blackMarket SqueakObjectPrimitives.
	methodUtil = MethodMirrorHelper withObjectPrimitives: platform blackMarket SqueakObjectPrimitives.
	classUtil = ClassMirrorHelper withClassPrimitives: platform blackMarket SqueakClassPrimitives.
	Dictionary = platform blackMarket Dictionary.
	SequenceableCollection = platform blackMarket SequenceableCollection.
|)
(
class ClassMirrorHelper withClassPrimitives: cprims = (|
	protected classPrimitives <SqueakClassPrimitives> = cprims.
	protected mockClasses = IdentityDictionary new.
|)
('as yet unclassified'
allInstanceVariableNamesOf: cls <Object> = (
"Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at http://www.squeak.org/SqueakLicense/"

	| superclass |
	superclass:: superclassOf: cls.
	^superclass == nil
		ifTrue: [instanceVariableNamesOf: cls]
		ifFalse: [(allInstanceVariableNamesOf: superclass), (instanceVariableNamesOf: cls)]
)
consider: cls ifBehavior: whenBehavior ifMetaclass: whenMetaclass ifClass: whenClass ifUnknown: whenUnknown = (
	| victimSize |
	victimSize:: instanceSizeOf: (objectUtil classOf: cls).
	victimSize == 5 ifTrue: [^whenBehavior value].
	victimSize == 8 ifTrue: [^whenMetaclass value].
	victimSize >= 14 ifTrue: [^whenClass value].
	^whenUnknown value
)
findInstanceVariableNamesOf: victim <Class> ^<Array[String]> = (
	| names |
	names::
		consider: victim
		ifBehavior: [^nil]
		ifMetaclass: ["objectUtil namedSlotOf: victim at: 6" victim instVarNames]
		ifClass: ["objectUtil namedSlotOf: victim at: 6" victim instVarNames]
		ifUnknown: ["^nil" victim isBehavior ifTrue: [victim instVarNames] ifFalse: [^nil]].
	^Array streamContents: [ :s |
		objectUtil indexedSlotIndicesOf: names do: [ :i |
			s nextPut: (objectUtil asString: (objectUtil indexedSlotOf: names at: i))]]
)
formatOf: cls <Object> = (^objectUtil namedSlotOf: cls at: 3)
indexOfInstanceVariableNamed: varName <String> of: cls ifAbsent: action = (
	^(allInstanceVariableNamesOf: cls) indexOf: varName ifAbsent: [action value]
)
instanceSizeOf: cls <Object> = (
"Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at http://www.squeak.org/SqueakLicense/"

	| format |
	format:: formatOf: cls.
	^(format >> 10 bitAnd: 16rC0) + (format >> 1 bitAnd: 16r3F) - 1
)
instanceSpecOf: cls <Object> = (
"Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at http://www.squeak.org/SqueakLicense/"

	| format |
	format:: formatOf: cls.
	^(format >> 7) bitAnd: 16rF
)
instanceVariableNamesOf: cls <Object> = (
"Licensed under the Squeak License (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at http://www.squeak.org/SqueakLicense/"

	| instSize superSize superclass names |
	superclass:: superclassOf: cls.
	instSize:: instanceSizeOf: cls.
	superSize::
		superclass == nil
			ifTrue: [0]
			ifFalse: [instanceSizeOf: superclass].
	instSize = superSize ifTrue: [^{}].
	names:: findInstanceVariableNamesOf: cls.
	names = nil ifFalse: [^names collect: [ :n | n asString]].
	^(superSize + 1 to: instSize) collect: [:i | 'inst' , i printString]
)
isBytes: cls <Object> = (
	| instanceSpec |
	instanceSpec:: instanceSpecOf: cls.
	^instanceSpec >= 8 and: [instanceSpec < 12]
)
isCompiledMethod: cls <Object> = (
	| instanceSpec |
	instanceSpec:: instanceSpecOf: cls.
	^instanceSpec >= 12
)
isPointers: cls <Object> = (
	| instanceSpec |
	instanceSpec:: instanceSpecOf: cls.
	^instanceSpec < 6
)
isVariable: cls <Object> = (
	| instanceSpec |
	instanceSpec:: instanceSpecOf: cls.
	^instanceSpec >= 2
)
methodDictionaryOf: cls <Object>^ <MethodDictionary> = (^objectUtil namedSlotOf: cls at: 2)
mockClassForHeaderWord: headerWord <Integer> ^<Class> = (
	^mockClasses at: headerWord ifAbsent:
		[ | cls |
		cls:: MockBehavior oldWithFormat: headerWord.
		mockClasses at: headerWord put: cls.
		cls]
)
nameOf: victim <Class> ^<String> = (

	^consider: victim
		ifBehavior: ['a subclass of: ', (nameOf: (objectUtil classOf: victim))]
		ifMetaclass: [ | thisClass |
			thisClass:: objectUtil namedSlotOf: victim at: 8.
			nil == thisClass
				ifTrue: ['a Metaclass']
				ifFalse: [(nameOf: thisClass), ' class']]
		ifClass: [ | victimName |
			victimName:: objectUtil namedSlotOf: victim at: 9.
			nil == victimName
				ifTrue: [nameOf: (superclassOf: victim)]
				ifFalse: [victimName]]
		ifUnknown: [victim name].
)
superclassOf: cls <Object> = (^objectUtil namedSlotOf: cls at: 1)) : ()
class MethodMirrorHelper withObjectPrimitives: oprims = ObjectMirrorHelper withObjectPrimitives: oprims ()
('as yet unclassified'
compiledMethodHeader: literalCount = (
	^literalCount << 9
)
indexedSlotIndicesOf: victim <CompiledMethod> do: action <BlockContext[Integer]> = (
	victim initialPC to: victim size do: [ :i | action value: i]
)
namedSlotIndicesOf: victim <CompiledMethod> do: action <BlockContext[Integer]> = (
	1 to: victim numLiterals + 1 do: [ :i | action value: i]
)
namedSlotOf: victim <CompiledMethod> at: index <Integer> ^<Object> = (
	"Equivalent to victim objectAt: index.
	This makes CompiledMethod look more like a regular object."
	^victim objectAt: index
)
namedSlotOf: victim <CompiledMethod> at: index <Integer> put: anObject <Object> ^<Object> = (
	"Equivalent to victim objectAt: index put: anObject.
	This makes CompiledMethod look more like a regular object."
	assert true: [index ~= 1 or: [anObject class == 1 class]].
"	Transcript cr; show: 'Setting a literal/header on a compiled method'."
	^victim objectAt: index put: anObject
)) : ()
class MockBehavior withFormat: fmt = (
"Describe the class in this comment."|
	superclass = Object.
	methodDict
	format = fmt.
	mixinSlot
	enclosingObjectSlot
|)
() : ('as yet unclassified'
oldWithFormat: fmt = (
	| cls |
	cls:: Behavior new.
	cls setFormat: fmt.
	cls methodDict: nil.
	^cls
))
class ObjectMirror on: victim = (
"Describe the class in this comment."|
	protected reflectee = victim.
|)
('as yet unclassified'
= other = (
	^self class == other class and:
		[reflectee == other reflectee]
)
evaluate: expression <String> ifError: onError <[String]> = (
	#BOGUS yourself. "Questionable if this is the right place to have evaluate."
	^reflectOn: (reflecteeClass language compiler
		evaluate: expression
		for: reflectee
		logged: true)
)
hasIndexedSlots = (
	^classUtil isVariable: reflecteeClass
)
hash = (
	^self class hash bitXor: (objectUtil identityHashOf: reflectee)
)
indexedSlotAt: index = (
	^reflectOn: (objectUtil indexedSlotOf: reflectee at: index)
)
indexedSlotAt: index put: newValue <ObjectMirror> = (
	objectUtil indexedSlotOf: reflectee at: index put: newValue reflectee
)
namedSlotNames ^<SequenceableCollection[String]> = (
	^classUtil allInstanceVariableNamesOf: reflecteeClass
)
printOn: stream = (
	stream
		nextPutAll: 'ObjectMirror:';
		nextPutAll: (reflecteePrintStringLimitedTo: 1024)
)
reflecteeBasicSize = (
	^objectUtil indexedSlotsOf: reflectee
)
reflecteeClass = (
	^objectUtil classOf: reflectee
)
reflecteeIsFalse = (
	^reflectee == false
)
reflecteeIsNil = (
	^reflectee == nil
)
reflecteeIsTrue = (
	^reflectee == true
)
reflecteePerform: selector <Symbol> = (
	^ reflectOn: (reflectee perform: selector)
)
reflecteePerform: selector <Symbol> with: args <Array> = (
	^ reflectOn: (reflectee perform: selector withArguments: args)
)
reflecteePerformDirect: selector <Symbol> = (
"This method should only be called if the reflectee is a value. In the future this may be enforced. The idea is that a mirror library that runs in a inter-process/distributed setting can only communicate its results as mirrors unless they are values"
	^ reflectee perform: selector
)
reflecteePrintOn: stream = (
	stream nextPutAll:
		([String streamContents: [:s | reflectee printOn: s]]
			on: UnhandledError do: [(objectUtil printStringFor: reflectee)])
)
reflecteePrintOn: stream <WriteStrean> limitedTo: limit <Integer> = (
	stream nextPutAll:
		([String streamContents: [:s | reflectee printOn: s] limitedTo: limit]
			on: UnhandledError
			do: [(objectUtil printStringFor: reflectee)])
)
reflecteePrintString = (
	^String streamContents: [:s | reflecteePrintOn: s]
)
reflecteePrintStringLimitedTo: limit = (
	| prntStr |
	prntStr:: String
 streamContents: [:s | reflecteePrintOn: s
 limitedTo: limit + 3].
	^prntStr size > limit
		ifTrue: [(prntStr copyFrom: 1 to: limit - 3), '...']
		ifFalse: [prntStr]
)
slotNamed: slotName ifAbsent: onAbsent = (
	| index |
	index:: objectUtil namedSlotOf: reflectee indexOf: slotName ifAbsent:
		[onAbsent value].
	^reflectOn: (objectUtil namedSlotOf: reflectee at: index)
)
slotNamed: slotName put: objectMirror ifAbsent: onAbsent = (
	| index |
	index:: objectUtil namedSlotOf: reflectee indexOf: slotName ifAbsent:
		[onAbsent value].
	objectUtil namedSlotOf: reflectee at: index put: objectMirror reflectee
)
withReflecteeDo: action <[Object]> = (
	^action value: reflectee
)) : ()
class ObjectMirrorHelper withObjectPrimitives: oprims = (|
	objectPrimitives <SqueakObjectPrimitives> = oprims.
	primitiveGetClass = oprims class compiledMethodAt: #primitiveGetClass.
	primitiveIdentityHash = oprims class compiledMethodAt: #primitiveIdentityHash.
	protected switchTable = {
		#visitRegularObject:. "0: no fields"
		#visitRegularObject:. "1: fixed pointer fields"
		#visitRegularObject:. "2: indexable pointer fields"
		#visitRegularObject:. "3: both fixed and indexable pointer fields"
		#visitRegularObject:. "4: both fixed and indexable pointer fields (pointer fields are weak)"
		#visitUnused:. "5: unused"
		#visitIndexableWordObject:. "6: indexable word fields"
		#visitUnused:. "7: unused"
		#visitIndexableByteObject:. "8: indexable byte fields"
		#visitUnused:. "9: unused"
		#visitUnused:. "10: unused"
		#visitUnused:. "11: unused"
		#visitCompiledMethod:. "12: compiled method"
	}.
|)
('as yet unclassified'
asString: victim <Object> = (
	^String streamContents: [ :s |
		indexedSlotIndicesOf: victim do: [ :i | s nextPut: (indexedSlotOf: victim at: i) asCharacter]]
)
changeClassOf: victim <Object> to: newClass <Class> ^<self> = (
	"| victimSpec instSpec |
	victimSpec:: ((headerWordsOf: victim) at: 1) >> 8 bitAnd: 16rF.
	instSpec:: ((classUtil formatOf: newClass) >> 7) bitAnd: 16rF.
	victimSpec > 8 ifTrue: [victimSpec:: victimSpec bitAnd: 2r1100].
	assert true: [instSpec = victimSpec]."
	objectPrimitives changeClassOf: victim to: newClass isVariable: (classUtil isVariable: newClass)
)
classOf: victim <Object> ^<Object> = (
	^objectPrimitives receiver: victim withArguments: {} apply: primitiveGetClass
)
headerWord: instanceVariableCount <Integer> format: format <Integer> ^ <Integer> = (
	| fixedSize <Integer> headerWord <Integer> |
	fixedSize:: instanceVariableCount negative
		ifTrue: [ 1 ]
		ifFalse: [ instanceVariableCount + 1 ]. "One extra for header word"
	headerWord:: fixedSize >> SqSizeWidth.
	assert true: [headerWord < SqMaxFieldsShifted].
	headerWord:: headerWord << SqCciWidth. "Ignoring compact classes"
	headerWord:: (headerWord << SqFmtWidth) bitOr: format.
	headerWord:: (headerWord << SqSizeWidth) bitOr: (fixedSize bitAnd: SqSizeMaskLow).
	headerWord:: headerWord << SqHtWidth.
	^headerWord >> SqIntegerTagWidth
)
headerWordsOf: victim <Object> = (
	^objectPrimitives primitiveGetHeaderWordsOf: victim
)
identityHashOf: victim <Object> = (
	^objectPrimitives receiver: victim withArguments: {} apply: primitiveIdentityHash
)
indexedSlotIndicesOf: victim <Object> do: action <BlockContext[Integer]> = (
	1 to: (indexedSlotsOf: victim) do: [ :i | action value: i]
)
indexedSlotOf: victim <Object> at: index <Integer> ^<Object> = (
	"Equivalent to victim basicAt: index"
	^objectPrimitives indexedSlotOf: victim at: index
)
indexedSlotOf: victim <Object> at: index <Integer> put: anObject <Object> ^<Object> = (
	"Equivalent to victim basicAt: index put: anObject"
	^objectPrimitives indexedSlotOf: victim at: index put: anObject
)
indexedSlotsOf: victim <Object> ^<Integer> = (
	"Answer the number of indexed slots in an object, equivalent to victim basicSize."
	^objectPrimitives indexedSlotsOf: victim
)
namedSlotIndicesOf: victim <Object> do: action <BlockContext[Integer]> = (
	1 to: (classUtil instanceSizeOf: (classOf: victim)) do: [ :i | action value: i]
)
namedSlotOf: obj <Object> at: index <Integer> test: oldValue <Object> andSet: newValue <BlockContext> = (
	oldValue == (namedSlotOf: obj at: index)
		ifTrue: [namedSlotOf: obj at: index put: newValue value. ^true].
	^false
)
namedSlotOf: victim <Object> at: index <Integer> ^<Object> = (
	"Equivalent to victim instVarAt: index"
	^objectPrimitives namedSlotOf: victim at: index
)
namedSlotOf: victim <Object> at: index <Integer> put: anObject <Object> ^<Object> = (
	"Equivalent to victim instVarAt: index put: anObject"
	^objectPrimitives namedSlotOf: victim at: index put: anObject
)
namedSlotOf: victim <Object> indexOf: nm <String> ifAbsent: absentAction = (
	| index |
	index:: (classUtil allInstanceVariableNamesOf: (classOf: victim)) indexOf: nm.
	^index = 0
		ifTrue: [absentAction value]
		ifFalse: [index]
)
objectFormat: instanceVariableCount <Integer> variable: isVariable <Boolean> bytes: isBytes <Boolean> pointers: isPointers <Boolean> weak: isWeak <Boolean> ^<Object> = (
	assert true: (isBytes not or: [isVariable]). "Squeak only supports byte-sized fields in the variable section."
	^isWeak
		ifTrue: [
			"Squeak only supports one kind of weak objects"
			assert true: isVariable.
			assert true: isBytes not.
			assert true: isPointers.
			SqIndexableAndWeakIndexablePointerFields]
		ifFalse: [
			isPointers
				ifTrue: [
					assert true: isBytes not.
					isVariable
						ifTrue: [
							instanceVariableCount >0
								ifTrue: [SqFixedAndIndexablePointerFields]
								ifFalse: [SqIndexablePointerFields]]
						ifFalse: [
							instanceVariableCount > 0
								ifTrue: [SqFixedPointerFields]
								ifFalse: [SqNoFields]]
					]
				ifFalse: [
					assert true: instanceVariableCount negative.
					assert true: isVariable.
					isBytes
						ifTrue: [SqIndexableByteFields]
						ifFalse: [SqIndexableWordFields]]
			]

)
printStringFor: victim <Object> ^<String> = (
	| victimClass |
	nil == victim ifTrue: [^'nil'].
	victimClass:: classOf: victim.
	victimClass == #class class ifTrue: [^victim printString].
	victimClass == 1 class ifTrue: [^victim printString].
	^'an instance of ', (classUtil nameOf: victimClass)
)
slotNamed: slotName of: victim = (
	| cls i |
	cls:: classOf: victim.
	i:: classUtil indexOfInstanceVariableNamed: slotName of: cls ifAbsent: [^error].
	^namedSlotOf: victim at: i
)
slotNamed: slotName of: victim put: newValue = (
	| cls i |
	cls:: classOf: victim.
	i:: classUtil indexOfInstanceVariableNamed: slotName of: cls ifAbsent: [^error].
	^namedSlotOf: victim at: i put: newValue
)
switchOn: object <Object> using: visitor <FormatVisitor> = (
	^visitor perform: (switchTable at: (classUtil instanceSpecOf: object class) + 1) with: object
)) : ()'as yet unclassified'
allocateCompiledMethod: literalCount byteCount: byteCount = (
	^CompiledMethod
		newMethod: byteCount
		header: (methodUtil compiledMethodHeader: literalCount)
)
allocateObjectOfFixedSize: instanceVariableCount <Integer> variableSize: variableSize <Integer> bytes: isBytes <Boolean> pointers: isPointers <Boolean> weak: isWeak <Boolean> ^<Object> = (
	"Allocate an object.
	The allocated object will have the following properties:
	* fixed fields if instanceVariableCount is not negative.
	* variable fields if variableSize is not negative.
	* byte-sized variable fields if isBytes is true, word sized otherwise.
	* all fields are pointers if isPointers is true.
	* the variable section is weak pointers if isWeak is true."
	| format headerWord cls |
	format:: objectUtil objectFormat: instanceVariableCount variable: variableSize negative not bytes: isBytes pointers: isPointers weak: isWeak.
	headerWord:: objectUtil headerWord: instanceVariableCount format: format.
	cls:: classUtil mockClassForHeaderWord: headerWord.
	^variableSize negative
		ifTrue: [cls tryPrimitive: 70 withArgs: {}]
		ifFalse: [cls tryPrimitive: 71 withArgs: {variableSize}]
)
reflectOn: victim = (
	^ObjectMirror on: victim
)) : ('as yet unclassified'
classFormat: nInstVars <Integer> variable: isVar <Boolean> words: isWords <Boolean> pointers: isPointers <Boolean> weak: isWeak <Boolean> ^ <Integer> = (
	"This method was derived from ClassBuilder>>format:variable:words:pointers:weak:.

	Compute the format for the given instance specification.
	nInstVars - the number of named inst vars (e.g. Point's x,y => nInstVars = 2).
	isVar  true if indexable inst vars.
	isWords  true for bit objects not organized as bytes (Float would you believe)
	isPointers  true for pointer objects (except CompiledMethod) false otherwise
	isWeak, true if indexable, named weak collection"
	| cClass instSpec sizeHiBits fmt |

	#instSizeChange yourself.
	"NOTE: This code supports the backward-compatible extension to 8 bits of instSize.
	For now the format word is...
		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>
	But when the Squeak image format is revised, it should become...
		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"

	sizeHiBits:: (nInstVars+1) // 64.
	cClass:: 0.  "for now"
	instSpec:: isWeak
		ifTrue:[4]
		ifFalse:[isPointers
				ifTrue: [isVar
						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]
						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]
				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].
	fmt:: sizeHiBits.
	fmt:: (fmt bitShift: 5) + cClass.
	fmt:: (fmt bitShift: 4) + instSpec.
	fmt:: (fmt bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"
	fmt:: (fmt bitShift: 1). "This shift plus integer bit lets wordSize work like byteSize"
	^fmt
))