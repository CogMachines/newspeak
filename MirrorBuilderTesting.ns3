Newspeak3
'Mirrors'
class MirrorBuilderTesting usingPlatform: p minitest: m = (|
private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
private ClassMirror = p mirrors ClassMirror.
private ObjectMirror = p mirrors ObjectMirror.
private MessageNotUnderstood = p kernel MessageNotUnderstood.
private TestContext = m TestContext.
|) (
public class ClassDeclarationBuilderTests = TestContext () (
'as yet unclassified'
assert: instance isInstanceOf: expectedClass = (
	| actualClass = (ObjectMirror reflecting: instance) getClass reflectee. |
	assert: actualClass equals: expectedClass.
)
classFromSource: src <String> ^<Class> = (
	^(ClassDeclarationBuilder fromSource: src) install applyToObject reflectee
)
public testClassDeclAddMethod = (
	(* add a new method *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	|
	testBuilder:: ClassDeclarationBuilder reflecting: newClass mixin.
	testBuilder instanceSide methods addFromSource: 'public foo: x = (^x * x)'.
	testMirror:: testBuilder install.
	klass:: testMirror reflectee apply: Object.
      assert: (klass new foo: 3) equals: 9. 
)
public testClassDeclAddNestedClass = (
	(* add a new nested class decl *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	|
	testBuilder:: ClassDeclarationBuilder reflecting: newClass mixin.
	testBuilder instanceSide nestedClasses addFromSource: 'public class Nested = ()(''cat'' public foo = (^91))'.
	testMirror:: testBuilder install.
	klass:: testMirror reflectee apply: Object.
	assert: klass new Nested new foo equals: 91.
)
public testClassDeclChangeHeader = (
	(* add a new slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	testBuilder:: ClassDeclarationBuilder reflecting: newClass mixin.
	testBuilder headerFromSource: 'class EmptyClass = ( | public newSlot ::= 91. | )'.
	testMirror:: testBuilder install.
	klass:: testMirror reflectee apply: Object.
	instance:: klass new.
	assert: instance newSlot equals: 91.
	instance newSlot: 101.
	assert: instance newSlot equals: 101.	
)
public testClassDeclCopyNested = (
	(* The bug here seems to be the copy doesn't get its qualified name patched. *)
	| 
	enclosingBuilder <ClassDeclarationBuilder>
	origBuilder
	origMirror
	origMixin
	copyBuilder
	copySource
	copyMixin
	|
	enclosingBuilder:: ClassDeclarationBuilder fromSource: 'class Enclosing = ()()'.
	
	origBuilder:: enclosingBuilder instanceSide nestedClasses addFromSource: 'class TheOriginal = ()()'.
	origMirror:: origBuilder install.
	origMixin:: origMirror reflectee.
	assert: origMixin simpleName equals: 'TheOriginal'.
	assert: origMixin accessModifier equals: #protected.

	copyBuilder:: ClassDeclarationBuilder fromSource: origMirror source.
	copyBuilder header name: 'TheCopy'.
	copySource:: copyBuilder source.
	copyBuilder:: enclosingBuilder instanceSide nestedClasses addFromSource: copySource.
	enclosingBuilder install.
	copyMixin:: copyBuilder reflectee.
	
	assert: copyMixin simpleName equals: 'TheCopy'.
	assert: copyMixin accessModifier equals: #protected.
)
public testClassDeclCopyTopLevel = (
	| 
	origBuilder
	origMirror
	origMixin
	copyBuilder
	copyMixin
	|
	origBuilder:: ClassDeclarationBuilder fromSource: 'class TheOriginal = ()()'.
	origMirror:: origBuilder install.
	origMixin:: origMirror reflectee.
	assert: origMixin simpleName equals: 'TheOriginal'.
	assert: origMixin accessModifier equals: #public.
	
	copyBuilder:: ClassDeclarationBuilder fromSource: origMirror source.
	copyBuilder header name: 'TheCopy'.
	copyMixin:: copyBuilder install reflectee.
	assert: copyMixin simpleName equals: 'TheCopy'.
	assert: copyMixin accessModifier equals: #public.
)
public testClassDeclModifySlot = (
	(* modify the declaration of an existing slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	klass:: classFromSource: 'class TestClassDeclModifySlot = ( | x ::= 117.  y = 0. z  | )()'.
	testBuilder:: ClassDeclarationBuilder reflecting: klass mixin.
	testBuilder headerFromSource: 'class TestClassDeclModifySlot = ( | public x ::= 120. y = 0.  z | )'.
	testMirror:: testBuilder install.
	assert: [testMirror instanceSide slots includesMirrorNamed: #x].
	assert: [testMirror instanceSide slots includesMirrorNamed: #y].
	assert: [testMirror instanceSide slots includesMirrorNamed: #z].
	instance:: klass new.
	assert: instance x equals: 120.
	instance x: 101.
	assert: instance x equals: 101.	
)
public testClassDeclRemoveMethod = (
	(* remove an existing method *)
	| 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	myKlass <Class>
	|	
	myKlass:: classFromSource: 'class TestClassDeclRemoveMethod = ()(
		''unclassified''
		foo = (^91)
	      bar = (^42)
	)'.
	testBuilder::  ClassDeclarationBuilder reflecting: myKlass mixin. 
	testBuilder instanceSide methods removeMirrorNamed: 'foo'.
	testMirror:: testBuilder install.
	deny: [testMirror instanceSide methods includesMirrorNamed: #foo].
)
public testClassDeclRemoveNestedClass = (
	(* remove an existing nested class *)
	| builder <ClassMirrorBuilder> outerClass <Class> |
	
	outerClass:: classFromSource: 'class TestClassDeclRemoveNestedClass = ()(
		class Nested = ()()
	)'.
	builder:: ClassDeclarationBuilder reflecting: outerClass mixin. 
	builder instanceSide nestedClasses removeMirrorNamed: #Nested.
	builder install. (* remove *)
	should: [outerClass new Nested] signal: MessageNotUnderstood.
	assert:[
		((ClassMirror reflecting: outerClass) mixin nestedClasses 
			findMirrorNamed: #Nested) = nil
		].(* verify *)
)
public testClassDeclRemoveNonExistantMethod = (
	(* remove a non-existing method. The effect should be to do nothing, so our only goal here is to run without error *)
	| 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	myKlass <Class>
	|	
	myKlass:: classFromSource: 'class TestClassDeclRemoveMethod = ()(
		''unclassified''
		foo = (^91)
	      bar = (^42)
	)'.
	testBuilder:: ClassDeclarationBuilder reflecting: myKlass mixin. 
	testBuilder instanceSide methods removeMirrorNamed: 'baz'.
)
public testClassDeclRemoveNonExistantNestedClass = (
	(* remove a non-existing nested class. The effect should be to do nothing, so our only goal here is to run without error *)
	| builder <ClassMirrorBuilder>  outerClass <Class> |
	
	outerClass:: classFromSource: 'class TestClassDeclRemoveNonExistantNestedClass = ()()'.
	builder:: ClassDeclarationBuilder reflecting: outerClass mixin. 
	builder instanceSide nestedClasses removeMirrorNamed: #Nested.
)
public testClassDeclRemoveSlot = (
	(* remove an existing slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	klass:: classFromSource: 'class TestClassDeclRemoveSlot = ( | x ::= 117.  y = 0. z  | )()'.
	testBuilder:: ClassDeclarationBuilder reflecting: klass mixin.
	testBuilder headerFromSource: 'class TestClassDeclRemoveSlot = ( | x ::= 117. y = 0.  | )'.
	testMirror:: testBuilder install.
	deny: [testMirror instanceSide slots includesMirrorNamed: #z].
	assert: [testMirror instanceSide slots includesMirrorNamed: #y].
	assert: [testMirror instanceSide slots includesMirrorNamed: #x].
)
public testClassDeclRenameNested = (
	| 
	mixin <InstanceMixin> 
	enclosingBuilder <ClassDeclarationBuilder>
	builder
	builder2
	|
	enclosingBuilder:: ClassDeclarationBuilder fromSource: 'class Enclosing = ()()'.
	builder:: enclosingBuilder instanceSide nestedClasses addFromSource: 'class OldName = ()()'.
	mixin:: builder install reflectee.
	assert: mixin simpleName equals: 'OldName'.
	builder2:: ClassDeclarationBuilder reflecting: mixin.
	builder2 header name: 'NewName'.
	builder2 install.
	assert: mixin simpleName equals: 'NewName'.
)
public testClassDeclRenameNestedPrivate = (
	| 
	mixin <InstanceMixin> 
	enclosingBuilder <ClassDeclarationBuilder>
	builder
	builder2
	|
	enclosingBuilder:: ClassDeclarationBuilder fromSource: 'class Enclosing = ()()'.
	builder:: enclosingBuilder instanceSide nestedClasses addFromSource: 'private class OldName = ()()'.
	mixin:: builder install reflectee.
	assert: mixin simpleName equals: 'OldName'.
	builder2:: ClassDeclarationBuilder reflecting: mixin.
	builder2 header name: 'NewName'.
	builder2 install.
	assert: mixin simpleName equals: 'NewName'.
	assert: mixin accessModifier equals: #private.
)
public testClassDeclRenameTopLevel = (
	| 
	mixin <InstanceMixin> 
	builder <ClassDeclarationBuilder>
	builder2
	|
	builder:: ClassDeclarationBuilder fromSource: 'class OldName = ()()'.
	mixin:: builder install reflectee.
	assert: mixin name equals: 'OldName'.
	builder2:: ClassDeclarationBuilder reflecting: mixin.
	builder2 header name: 'NewName'.
	builder2 install.
	assert: mixin name equals: 'NewName'.
)
public testClassDeclReplaceMethod = (
	(* replace an existing method *)
	| 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	myKlass <Class>
	|	
	myKlass:: classFromSource: 'class TestClassDeclReplaceMethod = ()(
		''unclassified''
		public foo = (^91)
	      bar = (^42)
	)'.
	testBuilder::  ClassDeclarationBuilder reflecting: myKlass mixin. 
	testBuilder instanceSide methods addFromSource: 'public foo = (^254 + 1)'.
	testMirror:: testBuilder install.
	assert: myKlass new foo equals: 255.
)
public testClassDeclReplaceNestedClass = (
	(* replace an existing nested class *)
| builder <ClassMirrorBuilder>  outerClass <Class> nestedKlass <Class> instance <OuterClass> nestedInstance <OuterClass Nested> |
	
	outerClass:: classFromSource: 'class TestClassDeclReplaceNestedClass = ()(
		public class Nested = ()()
	
	)'.
	instance:: outerClass new.
	nestedKlass:: instance Nested.
	nestedInstance:: nestedKlass new.
	builder::  ClassDeclarationBuilder reflecting: outerClass mixin. 
	builder instanceSide nestedClasses addFromSource:
'public class Nested = (| public a = 0.  public b ::= 1. public c |)(''cat'' public foo = (^27))'.
	builder install. (* replace *)
	
	assert: instance Nested new a equals: 0.
	assert: instance Nested new b equals: 1.
	assert: instance Nested new c equals: nil.
	assert: instance Nested new foo equals: 27.
		
	assert: nestedKlass new a equals: 0.
	assert: nestedKlass new b equals: 1.
	assert: nestedKlass new c equals: nil.
	assert: nestedKlass new foo equals: 27.
	
	assert: nestedInstance a equals: nil.
	assert: nestedInstance b equals: nil.
	assert: nestedInstance c equals: nil.
	assert: nestedInstance foo equals: 27.
	
	assert: nestedKlass equals: instance Nested.
	assert: nestedInstance isInstanceOf: nestedKlass.

	assert: outerClass new Nested new a equals: 0.
	assert: outerClass new Nested new b equals: 1.
	assert: outerClass new Nested new c equals: nil.
	assert: outerClass new Nested new foo equals: 27.
)
public testClassDeclReplaceSlot = (
	(* replace an existing slot *)
	| 
	klass <Class> 
	testBuilder <ClassDeclarationBuilder> 
	testMirror <ClassDeclarationMirror> 
	instance <Object>
	|
	klass:: classFromSource: 'class TestClassDeclReplaceSlot = ( | x ::= 117.  y = 0. z  | )()'.
	testBuilder:: ClassDeclarationBuilder reflecting: klass mixin.
	testBuilder headerFromSource: 'class TestClassDeclReplaceSlot = ( | public a ::= 120. y = 0.  z | )'.
	testMirror:: testBuilder install.
	deny:[testMirror instanceSide slots includesMirrorNamed: #x].
	assert:[testMirror instanceSide slots includesMirrorNamed: #y].
	assert:[testMirror instanceSide slots includesMirrorNamed: #z].
	assert:[testMirror instanceSide slots includesMirrorNamed: #a].
	instance:: klass new.
	assert: instance a equals: 120.
	instance a: 101.
	assert: instance a equals: 101.
)
public testConflictingMethodOverFactory = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted foo = ()()'.
	should: [builder classSide methods addFromSource: 'foo = ()'] signal: Error.
)
public testConflictingMethodOverNestedClass = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()(
		class foo = ()()
	)'.
	should: [builder instanceSide methods addFromSource: 'foo = ()'] signal: Error.
)
public testConflictingMethodOverSlot = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = (| foo bar = 1. |)()'.
	should: [builder instanceSide methods addFromSource: 'foo = ()'] signal: Error.
	should: [builder instanceSide methods addFromSource: 'foo: x = ()'] signal: Error.
	should: [builder instanceSide methods addFromSource: 'bar = ()'] signal: Error.
	builder instanceSide methods addFromSource: 'bar: x = ()'.
)
public testConflictingNestedClassOverMethod = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = (| foo |)()'.
	should: [builder instanceSide nestedClasses addFromSource: 'class foo = ()()'] signal: Error.
)
public testConflictingSlotOverMethod = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()(
		''cat'' foo = ()
	)'.
	should: [builder headerFromSource: 'Conflicted = (| foo |)'] signal: Error.
)
public testConflictingSlotOverNestedClass = (
	| builder |
	builder:: ClassDeclarationBuilder fromSource: 'class Conflicted = ()(
		class foo = ()()
	)'.
	should: [builder headerFromSource: 'Conflicted = (| foo |)'] signal: Error.
)
public testIncrementalScopeBuilding = (
	(* add a new method *)
	| 
	builder <ClassDeclarationBuilder> 
	klass <Class>
	ooter
	inner
	r
	|
	builder:: ClassDeclarationBuilder fromSource:
'class Outer = ( | public outerSlot = 1. | )(
	public class Inner = ( | public innerSlot = 3. | )(
		public class InnerInner = ()()
		''cat'' public innerMethod = (^4)
	)
	public class Sibling = ()()
	''cat'' public outerMethod = (^2)
)'.
	klass:: builder install reflectee apply: Object.
	ooter:: klass new.
	inner:: ooter Inner new.

	(* Incremental eval *)
	r:: (ObjectMirror reflecting: inner) 
		evaluate: '{outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner}'
		ifCompilerError: [ compileTimeFail ] ifError: [ runtimeFail ].
	assert: r reflectee equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.
	
	(* Incremental method *)
	(builder instanceSide nestedClasses findMirrorNamed: #Inner) instanceSide methods addFromSource: 'public testMethod = (^{outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner})'.
	builder install.
	assert: inner testMethod equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.
	
	(* Incremental header *)
	(builder instanceSide nestedClasses findMirrorNamed: #Inner) headerFromSource: 'public class Inner = ( | public innerSlot = 33. public testSlot = {outer Outer. outerSlot. outerMethod. outer Inner. innerSlot. innerMethod. Inner. Sibling. InnerInner}. |)'.
	builder install.
	inner:: ooter Inner new.
	assert: inner testSlot equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner. ooter Sibling. inner InnerInner.}.
	
	(* Incremental nested class *)
	builder instanceSide nestedClasses addFromSource: 'public class Inner2 = ( | public innerSlot = 333. | )(
		public class InnerInner = ()()
		''cat'' public innerMethod = (^444)
		public testMethod = (^{outer Outer. outerSlot. outerMethod. outer Inner2. innerSlot. innerMethod. Inner2. Sibling. InnerInner})
	)'.
	builder install.
	inner:: ooter Inner2 new.
	assert: inner testMethod equals: {ooter. ooter outerSlot. ooter outerMethod. inner. inner innerSlot. inner innerMethod. ooter Inner2. ooter Sibling. inner InnerInner.}.
)
'private'
emptyClassSource ^ <String> = (
	^'class EmptyClass = ()()'
)
newClass ^ <Class> = (
	^classFromSource: emptyClassSource
)
) : (
'test markers'
TEST_CONTEXT = ()
)
) : (
)
