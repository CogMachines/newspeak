Newspeak3
'NS2V8'
class Newspeak2V8Compilation usingPlatform: platform
 parsing: parsing
 generation: generation
 mirrors: mirrors = NewspeakCompilation
 usingPlatform: platform
 asts: parsing ASTModule ((* This module provides a Newspeak-to-Javascript cross-compiler. It is a descendent of Newspeak2Javascript which takes care to generate code that is easier for V8 to optimize and which is easier to maintain because of a simpler bootstrapping story and strategy for including bits that need to be written directly in Javascript. The output is not V8-specific and should run in any Javascript implementation that supports apply(), call() and bind().

The current compilation scheme does not address access control, async sends, reflection or reified activation records. Also, like all Newspeak implementations as of this writing, it does not provide generalized mixin application.

At runtime, a Newspeak object O is represented as a Javascript object J with properties that correspond directly to the Newspeak slots. The prototype of J is a runtime-class JRC, whose properties correspond to the instance methods of O's class, including any necessary synthetic methods. The prototype of JRC is another runtime class object corresponding to the superclass of O's class, and so on up to Object. The prototype of the runtime class of Object is ImplementationBase, which is hand-written and contains stub implementations to end the upward recursion in basicNew and the instance initializers.

JRC includes synthetic slots that refer to its runtime mixin, its enclosing object chain, and its metaclass or non-metaclass counterpart.

The main output of the compiler is an object containing all of the runtime mixins corresponding to the top-level class declarations. A runtime mixin has properties containing the definitions of its Newspeak and synthetic methods and its nested mixins. It also has a function that takes a runtime superclass and produces a runtime class that represents the application of the mixin. This function produces either a runtime class or a runtime metaclass, not the pair.

One synthetic method deserves particular attention: basicNew(). The prototype of basicNew is the runtime class. The body of basicNew calls the basicNew of the superclass using call(), then initializes properties corresponding to each Newspeak slot to nil.

All mixin applications share the same Newspeak and synthetic functions, except basicNew.

[PERFORMANCE NOTE] It is important that objects have all their slots initialized up front, rather than lazily. This ensures that all instances of the same Newspeak class go through the same transitions in the same order so V8 will give them all the same "hidden class" (what Self called a map).

[PERFORMANCE NOTE] It is important that an object's methods are defined in a prototype, rather than in the constructor call. If they were defined in the constructor, they would be different objects with different contexts.

[PERFORMANCE NOTE] The current structure where the functions for methods are defined in other deeply nested functions may produce functions that perform slower than if they had been defined at the top level. This is because of a need to give them contexts, even if they never access their free variables. This used to be an issue in V8, but it was fixed under pressure from dart2js (who wanted to nest all of their code at least one level to avoid polluting the global scope). It may still be the case in other Javascript engines.

Object creation follows the same pattern as the Squeak and Dart implementations: basicNew is followed by running a synthetic instance initializer.

Mixin application is implemented by a hand-written method on VMMirror. First a pair of runtime class and runtime metaclass are produced by applying the runtime mixin and runtime metamixin to the runtime class of the superclass and the runtime class of Class, respectively. Then an instance of Metaclass is created to represent the Newspeak metaclass, and an instance of the metaclass is created to represent the Newspeak class. Newspeak objects never directly interact with runtime classes or runtime mixins; the objects answered by #class are the Newspeak class or metaclass.

Self sends and ordinary sends map to Javascript method invocation. Outer sends map to an invocation on an entry in the enclosing objects array at the correct depth. Implicit receiver sends are resolved either as the self sends or outer sends at compile-time. Super sends are implemented as call() applied to the corresponding property of the runtime superclass.

Newspeak selectors are mangled into legal Javascript identifiers. Unary selectors map directly. Keyword selectors have each colon replaced with dollar. For binary selectors, they are the concatenation of a mapping for each of the special characters. For instance +- would map to $plus$minus.

[PERFORMANCE NOTE] It is important that we use legal identifiers for our property names. The earlier NS2JS did not mangle selectors and instead used square bracket notation to access properties. For example, foo at: 1 put: 2 would become foo["#at:put:"](1,2) rather than foo.at$put$(1,2). V8 eagerly transitions objects like these to dictionary mode, which means they do not have fast property access. This is the most important difference between NS2JS and NS2V8.

Non-local return is implemented using exceptions. The body of a method containing an NLR is wrapped in a try-catch block. At the beginning, an object is created to represent the current activation. When there is a non-local return, the return value is assigned to a property of this object and the object is thrown. The catch clause checks if the object thrown corresponds to its NLR object, and if so extracts the value and does a Javascript (local) return. Otherwise the object is re-thrown.

Newspeak closures map to Javascript functions. Accesses to self do *not* map directly to "this". Rather the receiver must be captured in a local at the beginning of a method, and access must be through this local to get proper lexical scope.

[UNIMPLEMENTED] This representation is not suitable for closure mirrors as there is no way in Javascript to get at the closure's free variables. To support closure mirrors, we would have create objects for each closure that took free variables and the enclosing context as arguments and stored them as slots that reflection could later access. dart2js follows this approach (but I believe this is to ensure they cannot be called with the wrong arity).

To implement #doesNotUnderstand:, for every message sent the compiler emits a DNU catcher that creates a Message object from the arguments and forwards to #doesNotUnderstand:. At bootstrap, these handlers are all installed into ImplementationBase.

[PERFORMANCE NOTE] It is important that these prototypes are all installed up-front, rather than the subset needed at each mixin application, to ensure the prototype chain is stable during the program's execution. Installing these catchers later would trigger deoptimizations.

The basic types (number, array, block, boolean, string) are represented directly as their Javascript counterparts. Where the Javascript behavior differs from the Newspeak behavior, we monkey patch the Javascript prototypes.

[ENGINEERING NOTE] These patches are all defined in classes of KernelForV8, using the js intrinsic described below. Unlike NS2JS, there is no need to look through several places and bootstrapping phases to find where such behavior is defined. Adding or modifying behavior for the basic types is as easier as adding or changing methods in these classes.

[PERFORMANCE NOTE] It is important that these patches are labelled for strict mode to avoid automatic boxing.

[ENGINEERING NOTE] We simply label the whole program for script mode, but if our output got wrapped in or otherwise mixed with other scripts, it wouldn't run in script mode.

[ENGINEERING NOTE] dart2js does not use this technique because they want to interoperate with other Javascript code. Instead they use a technique called interceptors, and can avoid the cost in the common cast through fancy type inference and inlining that make runtime modification very difficult. Newspeak doesn't want to go there and is content to monkey patch.

[ENGINEERING NOTE] Like dart2js, we cave on the semantics of integers by directly representing our numbers as Javascript numbers, which are doubles.

Nil is not respresented as Javascript's null. We use of a singleton instance of the Newspeak class UndefinedObject.

Bootstrapping: the compiled Javascript starts by hand-initializing the classes of Kernel to deal with the circular references. Then a namespace is populated with the applications of each of the top-level mixins to Object. This namespace is passed to the factory of RuntimeForV8, and the returned object is passed the VMMirror. This causes the platform object to be created and initialized. As part of this process, the DNU catchers and basic type monkey patches are installed. The application configuration is then passed the namespace, and the returned app object is sent #main:args: with the platform.  (Newspeak2Dart follows the same pattern, though without DNU catcher or basic type patches.)

[ENGINEERING NOTE] This is *way* simpler than whatever multi-phase thing NS2JS is doing.

The js intrinsic: When compiling the platform sources, we evaluate sends to "js" at compile-time against a factory for Javascript ASTs (an instance of JavascriptGeneration`Factory). For instance,

at: index = (
  ^js propertyOf: (js ident: 'this') at: index - 1
)

translates to

function at$(index) { return this[index - 1]; }

Note that arguments in messages to "js" can be arbitrary expressions (index - 1), which will be compiled like any other ordinary expression, allowing one to write implementations partially in the target language and partially in ordinary Newspeak in the same method.

This scheme allows the implementations of primitives to be written in the methods they are implementing and without special language support like pragmas, externs or native clauses, which I think is pretty cool :)


[UNIMPLEMENTED] Object-based access control might be implemented by having a pair of Javascript objects for each Newspeak object, one for the public parts and one for the private parts. Will this be a 2x overhead? Greater because of forwarding between the halves? Less if allocation isn't the dominating factor?

[UNIMPLEMENTED] Async sends

[UNIMPLEMENTED] Introspection: The compiler needs to emit more information in the runtime mixins so mirrors could enumerate the methods, slots and nested classes.

[UNIMPLEMENTED] Reflective modification

[UNIMPLEMENTED] Reified activation records


Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
Copyright 2012 Google Inc.
Copyright 2013 Ryan Macnak
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
      asts = parsing ASTModule.
	Collection = platform collections Collection.
	Dictionary = platform collections Dictionary.
	IdentityDictionary = platform collections IdentityDictionary.
	OrderedCollection = platform collections OrderedCollection.
	SortedList = platform collections SortedList.
	Set = platform collections Set.
	ReadStream = platform streams CharacterReadStream.
	WriteStream = platform streams CharacterReadWriteStream.

	MutableString = platform kernel MutableString.
	
	Parser = parsing Parser.
	
	javascriptGeneration = generation.
	JavascriptWriter = javascriptGeneration Writer.
	js = javascriptGeneration factory.

	names = NameMangler new.

	ASTTool = asts ASTTool.
      ASTCopier = asts ASTCopier.
      AST = asts AST.
	AssignmentAST = asts AssignmentAST.
	BlockAST = asts BlockAST.
	CascadedSendAST = asts CascadedSendAST.
	CodeBodyAST = asts CodeBodyAST.
	MessageAST = asts MessageAST.
      MessagePatternAST = asts MessagePatternAST.
	MethodAST = asts MethodAST.
	NormalSendAST = asts NormalSendAST.
	NumberAST = asts NumberAST.
	ReturnStatAST = asts ReturnStatAST.
      SendAST = asts SendAST.
	SymbolAST = asts SymbolAST.
	TupleAST = asts TupleAST.
      VarDeclAST = asts VarDeclAST.
	VariableAST = asts VariableAST.

	parser = Parser new.
	
	cachedCompilations = Dictionary new.
|)
(
class CachedCompilation = (|
	source <String>
	enableIntrinsics <Boolean>
	ir <ClassDeclarationIR>
	sentSelectors <Set[Symbol]>
|)
() : ()
class ClassDeclarationIR = (|
	public name
	public headerSource
	public instanceSide = MixinIR for: self isMeta: false.
	public classSide = MixinIR for: self isMeta: true.
	public depth
|)
('as yet unclassified'
basicNew = (
	^js functionOf: {} body: (js block: (
		{
		js call: (js ident: 'superBasicNew.call') with: {js ident: 'this'}.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'hashCode')) toBe: (js literal: 0).
		},
		(instanceSide slots collect: [:s | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: s name))) toBe: (js ident: 'nil')])
	))
)
basicNewMeta = (
	^js functionOf: {} body: (js block: (
		{
		js call: (js ident: 'superBasicNew.call') with: {js ident: 'this'}.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'hashCode')) toBe: (js literal: 0).
		}
	))
)
classMethodsMetadata = (
	^js array: (classSide methods collect:
		[:method | js new: (js ident: 'MM') with: {
			js literal: method name.
			js literal: method isSynthetic.
			method src ifNil: [js ident: 'null'] ifNotNil: [:src | js literal: src]
		}])
)
copyMethods: methods = (
	| stmts = OrderedCollection new. |
	methods do: [:m | 
		| assignProtected |
		assignProtected::
			(js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleProtected: m name)))
				toBe: (js propertyOf: (js ident: '$') at: (js literal: (names manglePublic: m name)))).

		m isPublic ifTrue: [
			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name)))
					toBe: assignProtected).
		].
		m isProtected ifTrue: [
			stmts add: assignProtected.
			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name)))
					toBe: (dnuCatcherFor: (names manglePublic: m name))).
		].
		m name = #doesNotUnderstand: ifTrue: [
			stmts add: (js assign: (js propertyOf: (js ident: 'this') at: (js literal: names privateDnu))
					toBe: (js propertyOf: (js ident: '$') at: (js literal: (names manglePublic: m name)))).
		].
	].
	^stmts
)
dnuCatcherFor: publicMangling = (
	^js call: (js ident: 'dnuCatcher') with: {js literal: publicMangling}
)
invoke = (				
	^js functionOf: {js ident: 'runtimeSuperclass'. js ident: 'enclosingObjects'} body: (js block: {
		js function: 'constructRuntimeClass' of: {js ident: 'superBasicNew'} body: (js block: (
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime class for ', name).
			},
			(copyMethods: instanceSide methods),
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: 'enclosingObjects`',name)))
				toBe: (js ident: 'enclosingObjects').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: 'super`',name)))
				toBe: (js ident: 'runtimeSuperclass').
			(* This first assignment causes devtools to use the class's name as the short name for its instances. *)
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: name)) toBe: basicNew.
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'basicNew')) toBe: (js propertyOf: (js ident: 'this') at: (js literal: name)).
			js verbatim: 'this.basicNew.prototype = this'.
			js verbatim: 'this.meta = null'.
			js verbatim: 'this.newspeakClass = null'.
			}
		)).
		js verbatim: 'constructRuntimeClass.prototype = runtimeSuperclass'.
		js verbatim: 'return new constructRuntimeClass(runtimeSuperclass.basicNew)'.
	})
)
invokeMeta = (
	^js functionOf: {js ident: 'runtimeSuperclass'. js ident: 'enclosingObjects'.} body: (js block: {
		js function: 'constructRuntimeClass' of: {js ident: 'superBasicNew'} body: (js block: (
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime meta class for ', name).
			},
			(copyMethods: classSide methods),
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: 'enclosingObjects`',name)))
				toBe: (js ident: 'enclosingObjects').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: 'super`',name)))
				toBe: (js ident: 'runtimeSuperclass').	
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'basicNew')) toBe: basicNewMeta.
			js verbatim: 'this.basicNew.prototype = this'.
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nonMeta')) toBe: (js ident: 'null').
			js verbatim: 'this.newspeakClass = null'.
			}
		)).
		js verbatim: 'constructRuntimeClass.prototype = runtimeSuperclass'.
		js verbatim: 'return new constructRuntimeClass(runtimeSuperclass.basicNew)'.
	})
)
makeMixin: rm = (
	^js call: (js propertyOf: (js ident: 'Mixin') at: (js literal: 'fromRuntimeMixin')) with: {rm}
)
methodsMetadata = (
	^js array: (instanceSide methods collect:
		[:method | js new: (js ident: 'MM') with: {
			js literal: method name.
			js literal: method isSynthetic.
			method src ifNil: [js ident: 'null'] ifNotNil: [:src | js literal: src]
		}])
)
nestedClassesMetadata = (
	^js array: (instanceSide nestedClasses collect: [:nc | js literal: nc name])
)
public printOn: stm = (
	stm nextPutAll: 'ClassDeclarationIR:'.
	stm nextPutAll: name.
)
runtimeMetamixin = (
	^js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'meta')) toBe: (
	js new: (js functionOf: {} body: (js block: (
		{
		js var: '$' value: (js ident: 'this').
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime meta mixin for ', name).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'slots')) toBe: (js array: {}).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'methods')) toBe: classMethodsMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nestedClasses')) toBe: (js array: {}).
		},
		(classSide methods collect: [:m | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name))) toBe: m function]),
		{
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'invoke')) toBe: invokeMeta.
		}
	))) with: {})
)
public runtimeMixin = (
	^js new: (js functionOf: {} body: (js block: (
		{
		js var: '$' value: (js ident: 'this').
		js var: '$', depth printString value: (js ident: 'this').
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime mixin for ', name).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'name')) toBe: (js literal: name).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'header')) toBe: (js literal: headerSource).
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'slots')) toBe: slotsMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'methods')) toBe: methodsMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nestedClasses')) toBe: nestedClassesMetadata.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'applications')) toBe: (js array: {}).
		},
		(instanceSide methods collect: [:m | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: m name))) toBe: m function]),
		(instanceSide nestedClasses collect: [:ncd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: ncd name))) toBe: ncd runtimeMixin]),
		(instanceSide nestedClasses collect: [:ncd | 
			js assign: (js propertyOf: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: ncd name))) at: (js literal: 'enclosingMixin')) toBe: (js ident: 'this')]),
		{
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'invoke')) toBe: invoke.
		runtimeMetamixin.
		js assign: (js propertyOf: (js propertyOf: (js ident: 'this') at: (js literal: 'meta')) at: (js literal: 'nonMeta')) toBe: (js ident: 'this').
		}
	))) with: {}
)
slotsMetadata = (
	^js array: (instanceSide slots collect:
		[:slot | js new: (js ident: 'SM') with: {
			js literal: slot name.
			js literal: slot isMutable.
			js literal: slot isSynthetic
	}]).
)) : ()
public class Compiler = super Compiler ((* A work-in-progress Compiler reimplementation, with Javascript AST as the output. This makes automated testing easier and provides control over formatting (for example, placing every expression on its own line to allow for precise breakpoint placement in substandard JS debugger implementations). *)|
	scopeStack ::= OrderedCollection new.
	input
	sentSelectors ::= Set new.

	rewriter = Rewriter new.	
	translator = Translator new.
	currentDepth
	currentMixinUID
	jsWriter = JavascriptWriter new.
	supportDoesNotUnderstand ::= true.
	inlineOperators ::= true.
	enableIntrinsics ::= true.
|)
(
class Rewriter = super Rewriter (|
	protected inlinableOperators <Dictionary[String, String]> = Dictionary new.
	protected inlinableNumericOperators <Dictionary[String, String]> = Dictionary new.
|inlinableOperators
		at: #+ put: '+';
		at: #- put: '-';
		at: #* put: '*';
		at: #/ put: '/';
		at: #'==' put: '==='.
	inlinableNumericOperators	
		at: #'<' put: '<';
		at: #'<=' put: '<=';
		at: #'>' put: '>';
		at: #'>=' put: '>=')
(
class InlinedOperatorAST = NormalSendAST ((* When the inlineOperators mode is on, message sends with certain selectors are replaced with this node. Javascript code generated for those nodes uses native Javascript operators instead of real message sends. The selector of the message of this AST is not a real Newspeak selector but rather the Javascript operator such as &&. *)|
|)
('as yet unclassified'
public apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinedOperatorNode: self
)) : ()
class SchedulerAST = AST ()
('as yet unclassified'
public apply: visitor <ASTVisitor> = (
	^visitor schedulerNode: self
)) : ()'as yet unclassified'
__isInlinableAsExpressionConditional: node <NormalSendAST> ^ <Boolean> = (
	((conditionalSelectors includes: node msg sel) and: [valueExpected]) ifFalse: [^false].
	node msg args do:
		[:each <AST> |
		((isRemovableBlock: each withArgs: 0)
			and: [each body statements size = 1
			and: [each body statements first isReturnStatNode not]])
				ifFalse: [^false]].
	^true
)
canInlineSeqexps ^<Boolean> = (
	^false
)
currentScope = (
	^super currentScope
)
inline: node as: sendClass selector: selector rewriteArgsAs: argRewriteBlock = (
	| receiver message |
	receiver:: applyForValueTo: node recv.
	message:: MessageAST new
		send: selector
		with: (node msg args collect: argRewriteBlock).
	^sendClass new
		to: receiver send: message;
		start: node start;
		end: node end
)
isInlinableBooleanOperator: node <NormalSendAST> = (
	| selector |
	selector:: node msg sel.
	^(selector = 'or:' or: [selector = 'and:'])
		and: [node msg args size = 1
		and: [node msg args first isBlockNode
		and: [node msg args first body statements size = 1]]]
)
isInlinableNumericOperator: node <NormalSendAST> = (
	| args |
	args:: node msg args.
	args size = 1 ifFalse: [^false].
	(inlinableNumericOperators includesKey: node msg sel) ifFalse: [^false].
	(node recv isLiteralNode and: [node recv val isNumber]) ifTrue: [^true].
	(args first isLiteralNode and: [args first val isNumber]) ifTrue: [^true].
	^false
)
isInlinableOperator: node <NormalSendAST> = (
	^(inlinableOperators includesKey: node msg sel)
		and: [node msg args size = 1]
)
processEventualSend: node <NormalSendAST> = (
	| scheduler receiver selector arguments |
	scheduler:: SchedulerAST new.
		
	receiver:: node recv apply: self.
	selector:: (SymbolAST new val: node msg sel) apply: self.
	arguments:: (TupleAST new elements: node msg arguments) apply: self.

	^(OrdinarySendAST
		to: scheduler
		send: ((MessageAST new
			send: #eventualSendTo:selector:arguments: 
			with: {receiver. selector. arguments})
				copyPositionFrom: node msg))
		copyPositionFrom: node
)
setterBlockArgName = (
	^ ('setter_arg') asSymbol
)'node traversal'
public normalSendNode: node <NormalSendAST> ^ <AST> = (

	(inlineOperators and: [isInlinableNumericOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableNumericOperators at: node msg sel)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableOperators at: node msg sel)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableBooleanOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (node msg sel = 'and:' ifTrue: ['&&'] ifFalse: ['||']) (* BOGUS *)
			rewriteArgsAs: [:each <BlockAST> | applyForValueTo: each body statements first]].
	
	^super normalSendNode: node
)
public propertyCallNode: node <PropertyCallAST> ^ <PropertyCallAST> = (
	| args |
	assert: [node isMessageNode].
	args:: OrderedCollection new.
	node args do: [:each | args add: (applyForValueTo: each)].
	^PropertyCallAST new
		send: node sel with: args;
		start: node start;
		end: node end
)
public setterSendNode: node <SetterSendAST> ^ <AST> = (
(* Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send. *)
	| binding block blockArg blockParam blockScope send rewrittenSetterSend |
	binding:: currentScope at: node msg sel ifAbsent: [MessageAST new].
	binding isVarDeclNode ifTrue:
		(* This is an assignment to a temporary; no special handling is needed
		as the value of the expression is the value being assigned. *)
		[^processLocalAccess: node msg of: binding].
	valueExpected ifFalse:
		(* The parent ignores the expression value; use a plain cheap here message send. *)
		[^processImplicitReceiverSend: node].

	(* The value is used by the parent; rewrite the whole thing as
		setter:: expr  =>  [:a | setter: a. a] value: expr *)
	(* a -- ok to use a constant name as long as it cannot collide with a user's name *)
	blockArg:: NormalSendAST new
		to: implicitReceiverNode
		send: (MessageAST new send: setterBlockArgName with: {}).
	blockParam:: ParameterAST name: setterBlockArgName type: nil.
	(* setter: a *)
	send:: NormalSendAST new to: node recv send:
		(MessageAST new sel: node msg sel; args: {blockArg};
		start: node msg start; end: node msg end; yourself);
		start: node  start; end: node  end.
	(* [:a | setter: a. a] *)
	block:: BlockAST new body:
		(CodeBodyAST new
			parameters: {blockParam}
			temporaries: {}
			statements: {
				send.
				blockArg
			};			
			start: node start; end: node end);
			start: node start; end: node end.
	blockScope:: Scope new.
	blockScope
		superScope: currentScope;
		at: setterBlockArgName put: (LocalEntry forDeclaration: blockParam atDepth: nil).
	scopeMap at: block put: blockScope.
	scopeMap at: block body put: blockScope.
	(* [:a | setter: a. a] value: expr *)
	rewrittenSetterSend::
		NormalSendAST new
			to: block
			send: (MessageAST new
				sel: #value:;
				args: {node msg args first};
				start: node msg start; end: node msg end);
				start: node  start; end: node  end.
	^applyForValueTo: rewrittenSetterSend
)) : ()
class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = super ScopeBuilder nestedIn: initialScope atLevel: initialDepth ()
('as yet unclassified'
public propertyCallNode: aNode <PropertyCallAST> = (
	self messageNode: aNode
)) : ('as yet unclassified'
public new ^<Instance> = (
	^self nestedIn: Scope new atLevel: 0
))
class Translator = ASTTool ((* Visits nodes of an NS AST to produce a Javascript AST. The usual translation unit is a method. Translation is initiated by sending the translateMethodNode: message. The argument is the method to translate, the returned value is the translation. *)|
	scopeStack
	public currentSelector
	protected containsNonLocalReturn <Boolean> (* Set to false at the beginning of translating a method. The code that emits a non-local return sets this to true. The top-level code checks the value to see whether to emit a try-catch wrapper for an NLR. *)

|)
('as yet unclassified'
addCascadedSend: node to: statements = (
	node isCascadedSendNode ifTrue:
		[addCascadedSend: node prevSend to: statements].
	statements add:
		(js call: (js propertyOf: (js ident: 'cascadeReceiver') at: (publicMessage: node msg))
			with: (node msg args collect: [:each | each apply: self]) asArray). 
)
public beginNewTranslationCycle = (
	scopeStack:: OrderedCollection new.
	containsNonLocalReturn:: false.
)
nlrName = (
	^'NLR'
)
nlrValuePropertyName = (
	^'value'
)
processIntrinsic: msg <MessageAST> = (
	^js perform: msg sel 
		withArguments: (msg args collect: [:arg | processIntrinsicArg: arg]) asArray.
)
processIntrinsicArg: arg <AST> = (
	arg isTupleNode ifTrue: [^(arg elements collect: [:el | processIntrinsicArg: el]) asArray].
	arg isLiteralNode ifTrue: [^arg val].
	^arg apply: self
)
processLexicalSend: message to: jsReceiver binding: binding = (
	
	(binding notNil and: [binding ast accessModifier = #private]) ifTrue: [
		(* Do early binding. *)
		|
		definingMixinDepth = binding depth - 1.
		definingMixin = js ident: '$', definingMixinDepth printString.
		targetMethod = js propertyOf: definingMixin at: (publicMessage: message).
		|
		^js call: (js propertyOf: targetMethod at: (js literal: 'call'))
			with: {jsReceiver}, (message args collect: [:each | each apply: self]) asArray
	].
	
	^js 
		call: (js propertyOf: jsReceiver at: (protectedMessage: message))
		with: (message args collect: [:each | each apply: self]) asArray
)
processOuterReceiverAtDepth: depth <Integer> = (
	| slotName |
	depth = 0 ifTrue: [^js ident: 'self'].
	slotName:: names mangleSynthetic: 'enclosingObjects`', currentMixinUID.
	^js propertyOf: (js propertyOf: (js ident: 'self') at: (js literal: slotName))
		at: (js literal: depth - 1) (* Adjust for self not being in the enclosing objects array. *)
)
protectedMessage: node = (
	sentSelectors add: node sel.
	^js literal: (names mangleProtected: node sel)
)
publicMessage: node = (
	sentSelectors add: node sel.
	^js literal: (names manglePublic: node sel)
)
selfName = (
	^'self'
)
wrapBodyForNlrHandling: body <Block> = (
	| nlrVarNode nlrParamName nlrParamNode |
	nlrVarNode:: js ident: nlrName.
	nlrParamName:: nlrName, '_exception'.
	nlrParamNode:: js ident: nlrParamName.
	^js block: {
		js var: selfName value: (js ident: 'this').
		js var: nlrName value: (js new: (js ident: 'Object') with: {}).
		js try: body catch: nlrParamName with:
			(js block: {
				js if: (js operator: '===' with: nlrVarNode and: nlrParamNode)
					then: (js return: (js propertyOf: nlrParamNode at: (js literal: nlrValuePropertyName)))
					else: (js throw: nlrParamNode)
			})
	}
)
wrapBodyNoNlrHandling: body <Block> = (
	^js block: {js var: selfName value: (js ident: 'this')}, body statements
)'node traversal'
public blockLocalReturnNode: node <BlockLocalReturnAST> = (
	^js return: (node expr apply: self)
)
public blockNode: node <BlockAST> = (
(* Commented out code creates a special object that may be examined by ClosureMirrors.
*)
       ^(* js new: (js ident: #JsBlock) with: { *)
		js functionOf: (node parameters collect: [:each | each apply: self]) asArray
			body: (node body apply: self).
		(* freeNameLiteralOf: node.
		astFunctionForBlock: node. 
		js literal:  (sourceForNode: node). 
		js literal: parsedLanguage
		} *)
)
public boolNode: node <BoolAST> = (
	^js literal: node val
)
public cascadedSendNode: node <CascadedSendAST> = (
	| statements |
	statements:: OrderedCollection new.
	addCascadedSend: node to: statements.
	statements at: statements size put: (js return: statements last).
	^js call: (js functionOf: {'cascadeReceiver'} body: (js block: statements))
		with: {node recv apply: self}
)
public charNode: node <CharAST> = (
	(* Javascript has no characters, only strings. *)
	^js literal: node val asString
)
public codeBodyNode: node <CodeBodyAST> = (
	| locals statements |
	locals:: node temporaries collect: [:each | each apply: self].
	statements:: node statements collect: [:each | each apply: self].
	^js block: (locals asArray, statements) asArray
)
public conditionalNode: node <ConditionalAST> = (
	^inlinableConditionalNode: node
)
public contextNode: node <ContextAST> = (
	Error signal: 'NS2V8 does not support thisContext'.
)
public enclosingObjectNode: node <EnclosingObjectAST> = (
	^processOuterReceiverAtDepth: node depth
)
public explicitOuterReceiverNode: node <ExplicitOuterReceiverAST> = (
	^processOuterReceiverAtDepth: node depth
)
public implicitReceiverSendNode: node <ImplicitReceiverSendAST> = (
	| receiver = processOuterReceiverAtDepth: node depth. |
	^processLexicalSend: node msg to: receiver binding: node binding
)
public inlinableAsExpressionConditionalNode: node <InlinableConditionalAST> = (
	| truePath falsePath condition |
	
	condition:: (node recv apply: self).
	
	node msg sel = 'ifTrue:' ifTrue:
		[truePath:: (node msg args at: 1) body statements first apply: self.
		falsePath:: js ident: 'nil'].
	node msg sel = 'ifFalse:' ifTrue:
		[truePath:: js ident: 'nil'.
		falsePath:: (node msg args at: 1) body statements first apply: self].
	node msg sel = 'ifTrue:ifFalse:' ifTrue:
		[truePath:: (node msg args at: 1) body statements first apply: self.
		falsePath:: (node msg args at: 2) body statements first apply: self].
	node msg sel = 'ifFalse:ifTrue:' ifTrue:
		[truePath:: (node msg args at: 2) body statements first apply: self.
		falsePath:: (node msg args at: 1) body statements first apply: self].
	
	^js ternaryIf: condition then: truePath else: falsePath
)
public inlinableConditionalNode: node <InlinableConditionalAST> = (
	| inverseCondition hasElseClause condition |
	inverseCondition:: node ifTrue not.
	hasElseClause:: node else isNil not.
	condition:: node condition apply: self.
	^js if: (inverseCondition ifTrue: [js prefixOperator: '!' on: condition] ifFalse: [condition])
		then: (node then apply: self)
		else: (hasElseClause ifTrue: [node else apply: self] ifFalse: [nil])
)
public inlinedOperatorNode: node <InlinedOperatorAST> = (
	(* We are not modeling JS operator precedence, so just parenthesize everything. *)
	^js operator: node msg sel
		with: (node recv apply: self)
		and: (node msg args first apply: self)
)
public localReadNode: node <LocalReadAST> = (
	^js ident: (names mangleLocal: node name)
)
public localWriteNode: node <LocalWriteAST> = (
	^js assign: (js ident: (names mangleLocal: node name)) toBe: (node value apply: self)
)
public loopNode: node <LoopAST> = (

	(* prologue; while(cond==whileTrue) {body}; *)

	|
	prologue = node prologue apply: self.
	cond = node condition apply: self.
	body = node body ifNil: [js block: {}] ifNotNil: [:it | it apply: self].
	
	(* Split the condition is it isn't a single expression *)
	condExpression ::= cond statements last.
	condPrologue = cond statements asOrderedCollection removeLast; yourself.
	|
	
	node isWhileTrue ifFalse: [
		condExpression:: js prefixOperator: '!' on: condExpression].
	
	(* Flatten prologue so its declarations are in scope for the loop *)
	
	^js block: 
		prologue statements,
		condPrologue, {
		js 
			for: (js verbatim: '')
			while: condExpression
			step: (js verbatim: '')
			do: (js block: body statements, condPrologue)}
)
public messageNode: node = (
	halt.
	sentSelectors add: node sel.
	^js literal: (names mangleSelector: node sel)
)
public messagePatternNode: node <MessagePatternAST> ^<List[String]> = (
	currentSelector:: node selector.
	^node parameters collect: [:each | each apply: self]
)
public methodLocalReturnNode: node <MethodLocalReturnAST> = (
	^blockLocalReturnNode: node
)
public methodNode: node <MethodAST> ^<Node> = (
	| translatedBody |
	translatedBody:: node body apply: self.
	^js functionOf: (node pattern apply: self) asArray
		body: (containsNonLocalReturn
			ifTrue: [wrapBodyForNlrHandling: translatedBody]
			ifFalse: [wrapBodyNoNlrHandling: translatedBody]).
)
public nilNode: node = (
	^js ident: 'nil'
)
public nonLocalReturnNode: node <NonlocalReturnAST> = (
	^returnStatNode: node
)
public numberNode: node <NumberAST> = (
	^js literal: node val
)
public ordinarySendNode: node <OrdinarySendAST> = (
	enableIntrinsics ifTrue: [
		node recv isImplicitReceiverSendNode ifTrue: [
			node recv msg sel = 'js' ifTrue: [^processIntrinsic: node msg]]].

	^js 
		call: (js propertyOf: (node recv apply: self) at: (publicMessage: node msg))
		with: (node msg args collect: [:each | each apply: self]) asArray
)
public outerSendNode: node <OuterSendAST> = (
	| receiver = processOuterReceiverAtDepth: node depth. |
	^processLexicalSend: node msg to: receiver binding: node binding
)
public parameterDeclNode: node <ParameterAST> = (
	^names mangleLocal: node name
)
public propertyCallNode: node <PropertyCallAST> = (
	^js literal: (names mangleSelector: node sel)
)
public receiverNode: node <ReceiverNode> = (
	^js ident: selfName
)
public returnStatNode: node <ReturnAST> = (
	containsNonLocalReturn:: true.
	^js block: {
		js assign: (js propertyOf: (js ident: nlrName) at: (js literal: nlrValuePropertyName)) toBe: (node expr apply: self).
		js throw: (js ident: nlrName)
	}
)
public schedulerNode: node <SchedulerAST> = (
	^js ident: 'theScheduler'
)
public selfSendNode: node <SelfSendAST> = (
	| receiver = js ident: selfName. |
	^processLexicalSend: node msg to: receiver binding: node binding
)
public stringNode: node <StringAST> = (
	^js literal: node val
)
public superSendNode: node <SuperSendAST> = (
	| superSlotName args |
	superSlotName:: names mangleSlot: 'super`', currentMixinUID.
	args:: OrderedCollection new.
	args add: (js ident: 'self').
	node msg args do: [:each | args add: (each apply: self)].
	^js call:
			(js propertyOf:
				(js propertyOf: (
					js propertyOf: (js ident: 'self')
						at: (js literal: superSlotName))
					at: (protectedMessage: node msg))
				at: (js literal: 'call')) with: args
)
public symbolNode: node <SymbolAST> = (
	assert: [node isSymbolNode].
	^js literal: node val
)
public temporaryDeclNode: node <ParameterAST> ^<String> = (
	^js var: (names mangleLocal: node name)
		value: (js ident: 'nil')
)
public tupleNode: node <TupleAST> = (
	^js array: (node elements collect: [:ea | ea apply: self])
)
public varDeclNode: node <VarDeclNode> = (
	(* Produce the corresponding local decl. *)
	^js var: (names mangleLocal: node name)
)) : ()'as yet unclassified'
accessorForNestedClassNamed: simpleName <String> in: mixinName  <String> superCall: superAccessor <Node> ^ <String> = (
(* Build  a method that will lazily create a nested class 'simpleName' with superclass defined by 'superAccessor' via mixin application, and cache it.  Maybe replace null slot with self-replacing function that computes class and stores in its closure? *)

	| nestedName <String> nestedSlotName <String> nestedSlotNode <Node> enclosingObjectsName <String> |
	nestedName:: names mangleSynthetic: mixinName, '`', simpleName.
	nestedSlotName:: names mangleSlot: mixinName, '`', simpleName.
	nestedSlotNode:: js propertyOf: (js ident: 'this') at: (js literal: nestedSlotName).	
	enclosingObjectsName:: names mangleSynthetic: 'enclosingObjects`', mixinName.
	^js functionOf: {} body: (js block: {
		js if: (js operator: '===' with: (js ident: 'nil') and: nestedSlotNode)
			then: (js block: {
				js var: 'self' value: (js ident: 'this').
				js var: 'superclass' value: superAccessor.
				js var: 'enclosingObjects' value: 
					(js call: (js propertyOf: (js array: {js ident: 'this'}) at: (js literal: 'concat'))
						with: {js propertyOf: (js ident: 'this') at: (js literal: enclosingObjectsName)}).
				js var: 'mixin' value: (js propertyOf: (js ident: '$') at: (js literal: nestedName)).
				js assign: nestedSlotNode toBe: 
					(js call: (js propertyOf: (js ident: 'vmmirror') at: (js literal: '$applyMixin$toSuperclass$withEnclosingObjects$'))
						with: {(js ident: 'mixin'). js ident: 'superclass'. js ident: 'enclosingObjects'}).
			}).
		js return: nestedSlotNode.
		})
)
accessorForSuperclass: superclassCall <AST> inScope: s <Scope> ^<Node> = (
	| send scopeBuilder |
	rewriter pushScope: s.
	send:: superclassCall apply: rewriter.
	rewriter popScope.
	
	translator beginNewTranslationCycle.
	^send apply: translator
)
checkForDuplicateNames: aNode = (

	| namesWithDuplicates names duplicateNames |
	
	namesWithDuplicates:: OrderedCollection new.
	aNode instanceSide categories do: [:cat |
		cat methods do: [:each | namesWithDuplicates add: each selector]].
	
	aNode hdr slots do: [:each |
		namesWithDuplicates add: each name.
		each isMutable ifTrue: [namesWithDuplicates add: each name, ':']].
	
	namesWithDuplicates
		addAll: (aNode instanceSide nestedClasses collect: [:each | each name]).

	names:: Set new.
	duplicateNames:: Set new.
	namesWithDuplicates do: [:each | | present |
		present:: true.
		names include: each ifNew: [present:: false].
		present ifTrue: [duplicateNames add: each]].
	
	duplicateNames isEmpty ifFalse: [ | message |
		message:: String streamContents: [:s |
			s
				nextPutAll: 'Class ';
				nextPutAll: aNode name;
				nextPutAll: '" has multiple definitions for '.
			duplicateNames
				do: [:each | s nextPutAll: each asString]
				separatedBy: [ s nextPutAll: ','].
			s nextPutAll: '.'.].
		assert: false message: message].

)
classNode: aNode <ClassDeclarationAST> ^ <ClassDeclarationIR> = (
	| ir <ClassDeclarationIR> priorMixinUID <String> |
	aNode name = #Newspeak2V8Compilation ifTrue: [
		#BOGUS. (* The flaw in the js intrinsic scheme. *)
		enableIntrinsics: false].
	checkForDuplicateNames: aNode.
	ir:: computeMixinFrom: aNode hdr.
	priorMixinUID:: currentMixinUID.
	currentMixinUID:: ir name.
	currentDepth:: currentDepth + 1.
	processInstanceSideOf: aNode ofMixin: ir instanceSide.
	generateSlotAccessorsFor:  ir instanceSide. 
	(* must be called after nested classes are processed, so all synthetic slots have been added *)
	processClassSideOf: aNode ofMixin: ir classSide.
	currentDepth::currentDepth - 1.
	currentMixinUID:: priorMixinUID.
	^ir
)
compileClassSource: source <ReadStream> within: enclosing <MixinMirror> ^<CompiledMixinMirror> = (
	| tree <AST> mixinRep <MixinRep> |
	tree:: parser classDefinition parse: source.
	setInput: source.
	setScopeFor: tree in: enclosing.
	(*sentSelectors:: Set new.*)
	mixinRep:: classNode: tree.
	scopeMap:: Dictionary new.
	^enclosing isNil ifTrue:[mixinRep] ifFalse:[{enclosing. mixinRep}].
)
public compileExpressionSource: stm <ReadStream> inMixin: enclosing <MixinMirror> ^<MethodIR> = (
	|
	body <CodeBodyAST>
	method <MethodAST>
	result <LowLevelMethodMirror>
	|
	
	(* Parse as a code body *)
	body:: parser doItExpression parse: stm.
	input:: stm.

	(* Ensure last statement is a return statement *)
	body statements isEmpty ifFalse:
		[body statements last isReturnStatNode ifFalse:
			[| last |
			last:: body statements removeLast.
			body statements add: (ReturnStatAST new 
				expr: last; start: last start; end: last end)]].

	(* Put into a method *)
	method:: MethodAST new
		pattern: (MessagePatternAST new selector: #DoIt parameters: {});
		body: body;
		accessModifier: #public.
	
	(* Build scope *)
	setScopeFor: method in: enclosing.
	currentMixinUID: enclosing declaration name.
	
	(* Rewrite and compile *)
 	result:: methodNode: method.
	scopeMap:: Dictionary new.
	^result
)
compileMethodSource: source <ReadStream> within: enclosing <MixinMirror> ^<MethodMirror> = (
	| tree <AST> jsTree |
	tree:: parser methodDecl parse: source.
	setInput: source.
	setScopeFor: tree in: enclosing.
	currentMixinUID: enclosing declaration name.
	jsTree:: methodNode: tree.
	scopeMap:: Dictionary new.
	^jsTree
)
compileNestedClasses: nestedClasses <Collection[ClassDeclarationAST]> within: mixinIR <MixinIR> = (
	
	nestedClasses do:
		[ :nc <ClassDeclarationAST> |  
			| nSlotName <String> nSlot <InstanceVariableMirror> |
		nSlotName:: mixinIR declaration name, '`', nc name.
		nSlot:: SlotIR named: nSlotName mutable: true accessModifier: #public (* questionable*).
		nSlot isSynthetic: true.
		mixinIR slots add: nSlot.
		mixinIR nestedClasses add: (classNode: (nestedMixinWrapperFor: nc in: mixinIR)). (* make 'mixin' (a Smalltalk subclass of ProtoObject) for nested class *)
		createNestedClassAccessorFrom: nc within: mixinIR
		].
)
compileNestedClassesOf: aNode <SideAST> within: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	(* where do we check that nested classes do not conflict with each other, or with methods or slots? *)
	^compileNestedClasses: aNode nestedClasses within: mixinMirror
)
computeMethod: aNode <MethodAST> inScope: s <Scope> = (
	|  scopeBuilder <ScopeBuilder>  |
	scopeBuilder:: ScopeBuilder nestedIn: s atLevel: currentDepth.
	aNode apply: scopeBuilder.
	(* need to build scope for method before visiting it *)
	^methodNode: aNode.
)
computeMixinFrom: aNode <ClassHeaderAST> ^ <ClassDeclarationIR> = (
	| 
	ir = ClassDeclarationIR new.
	|
	
	ir name: aNode name.
	aNode slots do: [:s |
		ir instanceSide slots add:
			(SlotIR 
				named: s name
				mutable: s isMutable
				accessModifier: s accessModifier)].
	ir headerSource: (input contents copyFrom: aNode start to: aNode end).
	ir depth: currentDepth.
	(* ir factorySelector: aNode constructor selector. *)
	^ir
)
createNestedClassAccessorFrom: classDecl <ClassDeclarationAST> within: mixinMirror <LowLevelMixinMirror> = (
(* Create an accessor method for the nested class represented by the incoming class tree.
This accessor will lazily generate the nested class when its enclosing instance is first asked for it. *)

	| n <String>  accessorString <String> methodAST hdr <ClassHeaderAST> accessor <MethdMirror>  |
	hdr:: classDecl hdr.
	n:: hdr name. 
	methodAST:: 
		accessorForNestedClassNamed: n 
		in:  mixinMirror name 
		superCall: (accessorForSuperclass: hdr superclassCall inScope:  (scopeMap at: classDecl instanceSide)).
	accessor:: MethodIR 
		named: classDecl name
		accessModifier: classDecl accessModifier
		function: methodAST
		source: nil.
	accessor isSynthetic: true.
	mixinMirror methods add: accessor.
)
currentScope ^<Scope> = (
	^scopeStack last
)
public dnuHandlers = (
	(* We used to generate a separate function for each selector. Now we are recycling the same code for each selector and using the JS magic 'arguments' to handle the variable number of arguments in an attempt to reduce the amount of code the must be compiled at start-up (recall DNU handlers must be installed up front). *)
	|
	mangledSelectors = js array: (sentSelectors collect: [:sel | js literal: (names manglePublic: sel)]).
	catcher = js call: (js ident: 'dnuCatcher') with: {js ident: 'sel'}.
	|
	^js function: 'installDnuHandlersOn' of: {js ident: 'p'} body: (js block: {
		js call: (js propertyOf: mangledSelectors at: (js literal: 'forEach'))
		with: {js functionOf: {'sel'} body: (js block: {
			js assign: (js propertyOf: (js ident: 'p') at: (js operator: '+' with: (js literal: '_') and: (js ident: 'sel'))) toBe: catcher.
			js assign: (js propertyOf: (js ident: 'p') at: (js ident: 'sel')) toBe: catcher
		})}
	}).
	(* function() {  this.dnu(kernel.Message().selector$arguments$(selector, arguments) )  } *)
)
generateSlotAccessorsFor: mixinIR <MixinIR>  = (
(* We need getter FUNCTIONS so we can call them uniformly with arguments (albeit empty ones) *)
	mixinIR slots do: [:slotIR  | 
		| getter <MethodMirror> getterJS <Node> setter <MethodMirror> setterJS <Node> slotName <String> fieldName |
		slotName:: slotIR name.
		fieldName:: names mangleSlot: slotName.
		
		
		getterJS:: js functionOf: {} body: (js block: {
			js return: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))
			}).
		getter:: MethodIR
			named: slotName
			accessModifier: slotIR accessModifier
			function: getterJS
			source: nil.
		getter isSynthetic: true.			
		mixinIR methods add: getter.
		
		setterJS:: js functionOf: {'v'} body: (js block: {
			(js assign: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))
				toBe: (js ident: 'v')).
			js return: (js ident: 'this')
			}).
		setter:: MethodIR 
			named: (setterSelectorFor: slotIR)
			accessModifier: slotIR accessModifier
			function: setterJS
			source: nil.
		setter isSynthetic: true.	
		mixinIR methods add: setter.
		]	
)
hereNode ^<VariableAST> = (
	(* Generates an AST representing the implicit receiver. We use a string so that we can represent a name that is not a legal identier *)
	
	^VariableAST new name: #'@here'; start: 0; end: 0.
)
hereSendFrom: arg <VarDeclAST> ^<MessageNode> = (
	^NormalSendAST new
		to: hereNode
		send: (MessageAST new 
			send: arg name
			with: {};
			start: arg start; end: arg end); 
		start: arg start; end: arg end
)
initializerFor: aNode <ClassHeaderAST> ^ <MethodAST> = (
| 
stmts  <Collection[StatementAST]>
start <Integer>  
end <Integer> 
initHdr <MessagePatternAST>
body <CodeBodyAST> 
copier <ASTCopier> 
params <List[VarDeclAST]>
|

	start:: aNode superConstructorCall start.
	end:: aNode superConstructorCall end.
	copier:: ASTCopier new.
	params:: aNode constructor parameters collect: 
		[:formal | formal apply: copier].
	initHdr:: MessagePatternAST new
		selector: #'instance`initializer' parameters: params;
		start: start; end: end.
		
	(* set up scope with constructor parameters *)
 	stmts:: OrderedCollection new.
	
	stmts add: (superConstructorCallFor: aNode).
	
	(aNode slots reject: [:ea | ea initializer isNil]) 
		do: [:slot <SlotDefAST> | | aMsg <MessageAST> |
	aMsg:: MessageAST new send: (setterSelectorFor: slot)
					   with:  {slot initializer apply: copier} ;
					   start: slot  start; end: slot end.
	stmts add: (NormalSendAST new msg: aMsg; 
                          recv: (selfNode start: aMsg start; end: aMsg end);
                          start: aMsg start; end: aMsg end).			
	].

 stmts addAll: (aNode initExprs collect:[:ie | ie apply: copier]).
 body:: CodeBodyAST new temporaries: OrderedCollection new
                                       statements: stmts; 
                                       start: start; end: end.
 ^MethodAST new pattern: initHdr
                            body: body
                            accessModifier: #public; 
                            start: start; end: end.
)
language = (
	^#NewspeakLanguage2
)
methodNode: aNode <MethodAST> ^ <MethodMirror> = (
	| tree <AST> jsTree |
	tree:: aNode apply: rewriter.  (* rewrite ast *)
	translator beginNewTranslationCycle.
	jsTree:: tree apply: translator.	 (* final pass: visit rewritten ast *)
	(* pop scope? *)
	^MethodIR
		named: translator currentSelector
		accessModifier: aNode accessModifier
		function: jsTree
		source: ([sourceForNode: aNode] on: Error do: [nil])
)
nestScope: s <Scope> = (
	(* Hook up a new lexically nested scope, and push onto the scope stack *)
	s setSuperScope: currentScope.
	pushScope: s
)
nestedMixinWrapperFor: nested <ClassDeclarationAST> in: outerClass <MixinMirror>  ^ <ClassDeclarationAST> = (
(* Wrap a class declaration to make it look like a nested mixin within outerClass should. This includes making the name be the fully qualified name, and hiding the superclass. *)

	| wrapper <ClassDeclarationAST> |
	wrapper:: nested clone.
	wrapper hdr: nested hdr clone.
	wrapper hdr name: (fullyQualifySimpleName: nested name with: outerClass name).
	^wrapper
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
processClassSideOf: aNode <ClassAST> ofMixin: mixinMirror <LowLevelMixinMirror> = (
	(* | primaryFactory <MethodMirror> factoryAST <MethodAST> | *)
	processFactoryFor: aNode in: mixinMirror.
	processSide: aNode classSide ofMixin: mixinMirror. (* compile class methods *)
)
processFactoryFor: aNode <ClassAST> in: mixinIR <MixinIR> = (
	| accessor <MethdMirror> argNames ast |
	argNames:: (aNode hdr constructor parameters collect: [:each | names mangleLocal: each name]) asArray.
	ast:: js functionOf: argNames body: (js block: {
		js return:
			(js call: (js ident: '(new this.nonMeta.basicNew()).$instance$initializer') (* cheat! *)
				with: (argNames collect: [:each | js ident: each]))
		}).
	accessor:: MethodIR 
		named: aNode hdr constructor selector
		accessModifier: #public
		function: ast
		source: nil.
	accessor isSynthetic: true.
	accessor isFactory: true.
	mixinIR methods add: accessor.
)
processInitializerFor: aNode <ClassAST> in: mixinIR <MixinIR> = (
	processMethod: (superConstructorMethodFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinIR. 
	(*makeCreateSlotsFor: aNode hdr within: mixinIR.*)
	processMethod: (initializerFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinIR.
)
processInstanceSideOf: aNode <ClassAST> ofMixin: mixinIR <MixinIR> ^ <Collection[MixinRep]> = (
	processInitializerFor: aNode in: mixinIR.
	processSide: aNode instanceSide ofMixin: mixinIR. (* compile instance methods *)
	compileNestedClassesOf: aNode instanceSide within: mixinIR. (* gather nested classes *)
)
processMethod: aNode <MethodAST> inScope: s <Scope> in: mixinIR <MixinIR> = (
	|  method <MethodMirror> |
	method:: computeMethod: aNode inScope: s.
	method isSynthetic: true.
	mixinIR methods add: method.
)
processSide: side <SideAST> ofMixin: mixinIR <MixinIR> = (
	side categories do: [:cat |
		cat methods do: [:m | 
			mixinIR methods add: (methodNode: m)]].
)
pushScope: scope <Scope> = (
	scopeStack addLast: scope
)
selfNode ^ <VariableAST> = (
	(* generate a an AST representing self; used for implicit self sends *)
	^VariableAST new name: #self; start: 0; end: 0
)
setInput: source <ReadStream> = (
	source position: 1.
	input: source. (* save the input *)
)
setScopeFor: node <AST> in: enclosing <MixinMirror | nil> = (
	| scopeBuilder |
	pushScope: Scope new.
	enclosing isNil ifFalse: [nestScope:: ScopeBuilder new buildScopeFor: enclosing].
	currentDepth:: currentScope depth.
	scopeBuilder:: ScopeBuilder nestedIn: currentScope atLevel: currentDepth.
	node apply: scopeBuilder
)
setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	^((slot isMutableSlot ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), slot name, ':') asSymbol.
)
sourceForNode: node <AST> ^ <String> = (
	| savedPos <Integer> pos <Integer> len <Integer> s <String> |
	^input contents copyFrom: node start to: node end
)
superConstructorCallFor: aNode <ClassHeaderAST> ^<NormalSendAST> = (
	
	(* create call to super constructor method *)
	|
	var  <VariableAST> 
	send <NormalSendAST>
	start <Integer> 
	end <Integer>  
	superMsg <MessageAST>
	args <List[VariableAST]> 
	|

	start:: aNode superConstructorCall start.
	end:: aNode superConstructorCall end.
	var:: VariableAST new name: #self; start: start; end: end.
	args:: aNode constructor parameters collect:
		[:p <VarDeclAST> | hereSendFrom: p].
	superMsg:: MessageAST new 
		send: (superConstructorNameFor: aNode) with: args; 
		start: start; end: end.
	send:: NormalSendAST new to: var send: superMsg; start: start; end: end.	
	^send
)
superConstructorMethodFor:  aNode <ClassHeaderAST> ^ <MethodAST> = (
| 
start <Integer> 
end <Integer>
stmts <List[StmtAST]> 
var  <VariableAST> 
initHdr <MessagePatternAST>
superMsg <MessageAST> 
send <NormalSendAST>
body  <CodeBodyAST>
copier <ASTCopier>
params <List[VarDeclAST]>
args <List>
|

	start:: aNode superConstructorCall start.
	end::  aNode  superConstructorCall end.
	copier:: ASTCopier new.
	params:: aNode constructor parameters collect:[:formal | formal apply: copier].
	initHdr:: MessagePatternAST new selector: (superConstructorNameFor: aNode) parameters: params;
				start: start; end: end. 
	(* set up scope with constructor parameters *)
	(* create call to superclass initializer *)
	stmts:: OrderedCollection new. 
	var:: VariableAST new name: #super; start: start; end: end.
	args:: aNode superConstructorCall args collect:[:actual | actual apply: copier].
	superMsg::  PropertyCallAST new send: 'instance`initializer' with: args; 
				start: start; end: end. 
	(* only copy actual args *)
	(* send these as a tuple? to super instance initializer? *)
	send:: NormalSendAST new to: var send: superMsg; start: start; end: end. 
	stmts addFirst: send.
	body:: CodeBodyAST new temporaries: OrderedCollection new
                                       	statements: stmts;
                                      	start: start; end: end.
	^MethodAST new pattern: initHdr
                            body: body
                            accessModifier: #protected;
                            start: start; end: end	
)
superConstructorNameFor: aNode <ClassHeaderAST> ^ <Symbol> = (
	^'superInit`', aNode name
)'lexical export'
scopeMap = (
	^super scopeMap
)) : ()
class MethodIR named: n accessModifier: am function: f source: s = (|
	public name = n.
	public function = f.
	public src = s.
	public isSynthetic ::= false.
	public isFactory ::= false.
	public accessModifier = am.
|assert: [(n includes: $$) not].
	am isNil ifTrue: [halt])
('as yet unclassified'
public isPrivate = (
	^#private = accessModifier
)
public isProtected = (
	^#protected = accessModifier
)
public isPublic = (
	^#public = accessModifier
)
public printOn: stm = (
	stm nextPutAll: 'MethodIR:'.
	stm nextPutAll: name.
)) : ()
class MixinIR for: d isMeta: m = (|
	public declaration = d.
	public isMeta = m.
	public slots = OrderedCollection new.
	public methods = OrderedCollection new.
	public nestedClasses = OrderedCollection new.
|)
('as yet unclassified'
public name = (
	^declaration name
)) : ()
class NameMangler = (|
	private specialCharacterManglings = Dictionary new.
|specialCharacterManglings
		at: $+ put: '$plus';
		at: $- put: '$minus';
		at: $* put: '$times';
		at: $/ put: '$over';
		at: $\ put: '$back';
		at: $< put: '$less';
		at: $> put: '$greater';
		at: $~ put: '$tilde';
		at: $= put: '$equal';
		at: $@ put: '$at';
		at: $% put: '$percent';
		at: $| put: '$pipe';
		at: $& put: '$amp';
		at: $? put: '$question';
		at: $! put: '$bang';
		at: $, put: '$comma')
('as yet unclassified'
protected _mangleSelector: selector <String> ^ <String> = (
	(* Convert a Newspeak selector into a JS identifer. *)

	(* Binary *)
	('+-*/\<>~=@%|&?!,' includes: selector first) ifTrue: [
		^(selector inject: '$' into: [:accum :next | 
			accum, (specialCharacterManglings at: next)]) asSymbol].

	^((('$', selector)
		replaceAll: $: with: $$) (* Keyword *)
		replaceAll: $` with: $$) (* Qualified *)
		replaceAll: $. with: $$ (* limit temp *)
)
public mangleLocal: selector <String> ^ <String> = (
	^_mangleSelector: selector
)
public mangleProtected: selector = (
	^'_', (_mangleSelector: selector)
)
public manglePublic: selector = (
	^_mangleSelector: selector
)
public mangleSlot: selector <String> ^ <String> = (
	^(_mangleSelector: selector), '$slot'
)
public mangleSynthetic: selector = (
	^_mangleSelector: selector
)
public privateDnu = (
	^'dnu'
)) : ()
class ProgramBuilder = (|
private compiler = Compiler new.
private mixins <List[ClassDeclarationIR]> = OrderedCollection new.
private sentSelectors = Set new.
private runtimeConfiguration <ClassDeclarationIR>
private applicationConfiguration <ClassDeclarationIR>
private resources <List[Node]> = OrderedCollection new.
|)
('as yet unclassified'
public addImageResource: relativeUrl under: name = (
	| r i |
	i:: js verbatim: 
	'vmmirror.kernel.$Future().$computing$(
		function(){return vmmirror.platform.$aliens().$yourself()._$alienate$(
			function(){ var i = new Image(); i.src ="', relativeUrl,'"; return i;}() );})'.
	r:: js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: name)))
				toBe: (js functionOf: {} body: (js block: {js return: i})).
	resources add: r.
)
public addStringResource: string under: name = (
	| r |
	r:: js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: name)))
				toBe: (js functionOf: {} body: (js block: {js return: (js literal: string)})).
	resources add: r.
)
public applicationSources: sources <List[String]> = (
	| results |
	results:: sources collect: [:source | compileSource: source enableIntrinsics: false].
	applicationConfiguration: results first.
)
compileSource: source <String> enableIntrinsics: flag <Boolean> ^<ClassDeclarationIR> = (
	| compilation |
	compilation:: cachedCompilations
		at: {source. flag}
		ifAbsentPut:
			[ | newCompliation = CachedCompilation new. |
			newCompliation source: source.
			newCompliation enableIntrinsics: flag.
			compiler enableIntrinsics: flag.
			compiler sentSelectors: Set new.
			newCompliation ir: (compiler compileClassSource: source readStream within: nil).
			newCompliation sentSelectors: compiler sentSelectors].
	mixins add: compilation ir.
	sentSelectors addAll: compilation sentSelectors.
	^compilation ir
)
private main = (
	^js verbatim: 
'var runtime = ns.$',runtimeConfiguration name,'().$packageUsing$(ns);
vmmirror.platform = runtime.$using$(vmmirror);
var app = ns.$',applicationConfiguration name,'().$packageUsing$(ns);
app.$main$args$(vmmirror.platform, [])'
)
private namespace = (
	^js var: 'ns' value: (js new: (js functionOf: {} body: (js block: (
		(mixins asArray collect: [:cd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: cd name))) 
				toBe: (js call: (js propertyOf: (js ident: 'vmmirror') at: (js literal: 'applyTopLevelMixin')) 
						with: {js propertyOf: (js ident: 'mixins') at: (js literal: (names manglePublic: cd name))})]),
		(mixins asArray collect: [:cd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: cd name)))
				toBe: (js functionOf: {} body: (js block: {js return: 
					(js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: cd name)))}))]),
		resources asArray
	))) with: {})
)
public outputTo: stream = (
	JavascriptWriter new generateSourceFor: script on: stream
)
private runtimeMixinNamespace = (
	^js new: (js functionOf: {} body: (js block: (
		mixins collect: [:cd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names manglePublic: cd name))) toBe: cd runtimeMixin]
	))) with: {}
)
public runtimeSources: sources <List[String]> = (
	| results |
	results:: sources collect: [:source | compileSource: source enableIntrinsics: true].
	runtimeConfiguration: results first.
)
private script = (
	compiler sentSelectors: sentSelectors.
	^js script: 
		{js literal: 'use strict'.
		js var: 'nil' value: (js literal: 'patch me with nil').
		js var: 'theGlobalObject' value: (js ident: 'this').
		js verbatim: 'function SM(n,m,s){this.name=n; this.isMutable=m; this.isSynthetic=s; }'.
		js verbatim: 'function MM(n,sy,src){this.name=n; this.isSynthetic=sy; this.source=src; }'.
		js verbatim: 'function dnuCatcher(s){ return function() {
return this.dnu(vmmirror.kernel.$Message().$selector$arguments$(s, Array.prototype.slice.call(arguments)));
} }'.
		js var: 'mixins' value: runtimeMixinNamespace.
		vmmirror.
		namespace.
		compiler dnuHandlers.
		main}
)
private vmmirror = (
	^js verbatim: 
'
var vmmirror = new function(){
	
	this.ImplementationBase$slot = new function(){
		this.debug = "ImplementationBase";
		this.$runtimeClass$slot = new function(){
			this.debug = "Runtime class for ImplementationBase";
			this.basicNew = function(){};
			this.$instance$initializer = function(){};
			this._$instance$initializer = function(){};
			this.toString = function(){ return this.$printString(); }
		};
	};
	this.$ImplementationBase = function(){return this.ImplementationBase$slot;};
	this.$Array = function(){return Array;};
	this.$String = function(){return String;};
	this.$printString = function(){return "VMMirrorForV8"};
	
	this.createKernel = function(){
		
		var enclosingObjects = ["patch me with kernel", "patch me with nil"];
		var enclosingObjects2 = ["patch me with nil"];
		
		var Object$runtimeClass = mixins.$KernelForV8.$KernelForV8$Object.invoke(this.$ImplementationBase().$runtimeClass$slot, enclosingObjects);
		var Class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Class.invoke(Object$runtimeClass, enclosingObjects);
		var Metaclass$runtimeClass = mixins.$KernelForV8.$KernelForV8$Metaclass.invoke(Object$runtimeClass, enclosingObjects);
		var Mixin$runtimeClass = mixins.$KernelForV8.$KernelForV8$Mixin.invoke(Object$runtimeClass, enclosingObjects);
		var UndefinedObject$runtimeClass = mixins.$KernelForV8.$KernelForV8$UndefinedObject.invoke(Object$runtimeClass, enclosingObjects);
		var Kernel$runtimeClass = mixins.$KernelForV8.invoke(Object$runtimeClass, enclosingObjects2);
		
		var Object$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Object.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Class$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Class.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Metaclass$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Metaclass.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Mixin$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$Mixin.meta.invoke(Class$runtimeClass, enclosingObjects);
		var UndefinedObject$class$runtimeClass = mixins.$KernelForV8.$KernelForV8$UndefinedObject.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Kernel$class$runtimeClass = mixins.$KernelForV8.meta.invoke(Class$runtimeClass, enclosingObjects2);
		
		Object$runtimeClass.meta = Object$class$runtimeClass;
		Class$runtimeClass.meta = Class$class$runtimeClass;
		Metaclass$runtimeClass.meta = Metaclass$class$runtimeClass;
		Mixin$runtimeClass.meta = Mixin$class$runtimeClass;
		UndefinedObject$runtimeClass.meta = UndefinedObject$class$runtimeClass;
		Kernel$runtimeClass.meta = Kernel$class$runtimeClass;
		
		Object$class$runtimeClass.nonMeta = Object$runtimeClass;
		Class$class$runtimeClass.nonMeta = Class$runtimeClass;
		Metaclass$class$runtimeClass.nonMeta = Metaclass$runtimeClass;
		Mixin$class$runtimeClass.nonMeta = Mixin$runtimeClass;
		UndefinedObject$class$runtimeClass.nonMeta = UndefinedObject$runtimeClass;
		Kernel$class$runtimeClass.nonMeta = Kernel$runtimeClass;
		
		nil = new UndefinedObject$runtimeClass.basicNew();
		
		var Object = new Object$class$runtimeClass.basicNew();
		var Class = new Class$class$runtimeClass.basicNew();
		var Metaclass = new Metaclass$class$runtimeClass.basicNew();
		var Mixin = new Mixin$class$runtimeClass.basicNew();
		var UndefinedObject = new UndefinedObject$class$runtimeClass.basicNew();
		var Kernel = new Kernel$class$runtimeClass.basicNew();
		
		var Object$class = new Metaclass$runtimeClass.basicNew();
		var Class$class = new Metaclass$runtimeClass.basicNew();
		var Metaclass$class = new Metaclass$runtimeClass.basicNew();
		var Mixin$class = new Metaclass$runtimeClass.basicNew();
		var UndefinedObject$class = new Metaclass$runtimeClass.basicNew();
		var Kernel$class = new Metaclass$runtimeClass.basicNew();
		
		Object$class$runtimeClass.newspeakClass = Object$class;
		Class$class$runtimeClass.newspeakClass = Class$class;
		Metaclass$class$runtimeClass.newspeakClass = Metaclass$class;
		Mixin$class$runtimeClass.newspeakClass = Mixin$class;
		UndefinedObject$class$runtimeClass.newspeakClass = UndefinedObject$class;
		Kernel$class$runtimeClass.newspeakClass = Kernel$class;
		
		Object$runtimeClass.newspeakClass = Object;
		Class$runtimeClass.newspeakClass = Class;
		Metaclass$runtimeClass.newspeakClass = Metaclass;
		Mixin$runtimeClass.newspeakClass = Mixin;
		UndefinedObject$runtimeClass.newspeakClass = UndefinedObject;
		Kernel$runtimeClass.newspeakClass = Kernel;
		
		var kernel = Kernel.$usingVmMirror$(this);
		
		//superclass$slot
		Object.$superclass$slot = nil;
		Class.$superclass$slot = Object;
		Metaclass.$superclass$slot = Object;
		Mixin.$superclass$slot = Object;
		UndefinedObject.$superclass$slot = Object;
		Kernel.$superclass$slot = Object;
		
		Object$class.$superclass$slot = Class;
		Class$class.$superclass$slot = Class;
		Metaclass$class.$superclass$slot = Class;
		Mixin$class.$superclass$slot = Class;
		UndefinedObject$class.$superclass$slot = Class;
		Kernel$class.$superclass$slot = Class;
		
		//mixin$slot
		Object.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Object);
		Class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Class);
		Metaclass.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Metaclass);
		Mixin.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Mixin);
		UndefinedObject.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$UndefinedObject);
		Kernel.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8);

		Object$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Object.meta);
		Class$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Class.meta);
		Metaclass$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Metaclass.meta);
		Mixin$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$Mixin.meta);
		UndefinedObject$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.$KernelForV8$UndefinedObject.meta);
		Kernel$class.$mixin$slot = Mixin.$fromRuntimeMixin$(mixins.$KernelForV8.meta);
		
		//enclosingObject$slot
		Object.$enclosingObject$slot = kernel;
		Class.$enclosingObject$slot = kernel;
		Metaclass.$enclosingObject$slot = kernel;
		Mixin.$enclosingObject$slot = kernel;
		UndefinedObject.$enclosingObject$slot = kernel;
		Kernel.$enclosingObject$slot = nil;
		
		Object$class.$enclosingObject$slot = kernel;
		Class$class.$enclosingObject$slot = kernel;
		Metaclass$class.$enclosingObject$slot = kernel;
		Mixin$class.$enclosingObject$slot = kernel;
		UndefinedObject$class.$enclosingObject$slot = kernel;
		Kernel$class.$enclosingObject$slot = nil;
		
		enclosingObjects[0] = kernel;
		enclosingObjects[1] = nil;
		enclosingObjects2[0] = nil;
		
		//name$slot
		Object.$name$slot = "Object";
		Class.$name$slot = "Class";
		Metaclass.$name$slot = "Metaclass";
		Mixin.$name$slot = "Mixin";
		Kernel.$name$slot = "Kernel";
		
		Object$class.$name$slot = "Object class";
		Class$class.$name$slot = "Class class";
		Metaclass$class.$name$slot = "Metaclass class";
		Mixin$class.$name$slot = "Mixin class";
		Kernel$class.$name$slot = "Kernel class";
		
		//runtimeClass
		Object.runtimeClass = Object$runtimeClass;
		Class.runtimeClass = Class$runtimeClass;
		Metaclass.runtimeClass = Metaclass$runtimeClass;
		Mixin.runtimeClass = Mixin$runtimeClass;
		Kernel.runtimeClass = Kernel$runtimeClass;
		
		Object$class.runtimeClass = Metaclass$runtimeClass;
		Class$class.runtimeClass = Metaclass$runtimeClass;
		Metaclass$class.runtimeClass = Metaclass$runtimeClass;
		Mixin$class.runtimeClass = Metaclass$runtimeClass;
		Kernel$class.runtimeClass = Metaclass$runtimeClass;
		
		//thisClass$slot
		Object$class.$thisClass$slot = Object;
		Class$class.$thisClass$slot = Class;
		Metaclass$class.$thisClass$slot = Metaclass;
		Mixin$class.$thisClass$slot = Mixin;
		Kernel$class.$thisClass$slot = Kernel;
		
		kernel.$KernelForV8$Object$slot = Object;
		kernel.$KernelForV8$Class$slot = Class;
		kernel.$KernelForV8$Metaclass$slot = Metaclass;
		kernel.$KernelForV8$Mixin$slot = Mixin;
		
		return kernel;
	};
	this.kernel = this.createKernel();
	
	this.applyTopLevelMixin = function(runtimeMixin){
		return this.$applyMixin$toSuperclass$withEnclosingObjects$(runtimeMixin, this.kernel._$Object(), [nil]);
	};
	
	this.$applyMixin$toSuperclass$withEnclosingObjects$ = function(runtimeMixin, newspeakSuperclass, enclosingObjects){
		
		var Class = this.kernel.$Class();
		var Metaclass = this.kernel.$Metaclass();
		var Mixin = this.kernel.$Mixin();
		
		var runtimeSuperclass = newspeakSuperclass.runtimeClass;
		var runtimeClass = runtimeMixin.invoke(runtimeSuperclass, enclosingObjects);
		var runtimeMetaclass = runtimeMixin.meta.invoke(Class.runtimeClass, enclosingObjects);
		runtimeClass.meta = runtimeMetaclass;
		runtimeMetaclass.nonMeta = runtimeClass;
		
		var newspeakMetaclass = Metaclass.$new();
		var newspeakClass = new runtimeMetaclass.basicNew();
		
		runtimeClass.newspeakClass = newspeakClass;
		runtimeMetaclass.newspeakClass = newspeakMetaclass;//Class;
		
		newspeakMetaclass.$superclass$slot = Class;
		newspeakMetaclass.$mixin$slot = Mixin.$fromRuntimeMixin$(runtimeMixin.meta);
		newspeakMetaclass.$enclosingObject$slot = enclosingObjects[0];
		newspeakMetaclass.$enclosingObjects$slot = enclosingObjects;
		newspeakMetaclass.$name$slot = runtimeMixin.name + " class";
		newspeakMetaclass.$thisClass$slot = newspeakClass;
		newspeakMetaclass.runtimeClass = runtimeMetaclass;
		
		newspeakClass.$superclass$slot = newspeakSuperclass;
		newspeakClass.$mixin$slot = Mixin.$fromRuntimeMixin$(runtimeMixin);
		newspeakClass.$enclosingObject$slot = enclosingObjects[0];
		newspeakClass.$enclosingObjects$slot = enclosingObjects;
		newspeakClass.$name$slot = runtimeMixin.name;
		newspeakClass.runtimeClass = runtimeClass;

		runtimeMixin.applications.push(runtimeClass);
		return newspeakClass;
	};
	
	var specialCharacters = new Object();
	specialCharacters["plus"] = "+";
	specialCharacters["minus"] = "-";
	specialCharacters["times"] = "*";
	specialCharacters["over"] = "/";
	specialCharacters["back"] = "\\";
	specialCharacters["less"] = "<";
	specialCharacters["greater"] = ">";
	specialCharacters["tilde"] = "~";
	specialCharacters["equal"] = "=";
	specialCharacters["at"] = "@";
	specialCharacters["percent"] = "%";
	specialCharacters["pipe"] = "|";
	specialCharacters["amp"] = "&";
	specialCharacters["question"] = "?";
	specialCharacters["bang"] = "!";
	specialCharacters["comma"] = ",";
	
	this.$unmangleSelector$ = function(s) {
		if(s[0] != "$") return "<jsSelector:"+s+">";
		if(s[s.length-1] == "$")
			// Keyword
			return s.substring(1).replace(/\$/g,":");
		if(s[1] == "$")
			// Binary
			return s.substring(2).split("$").map(function(x) {return specialCharacters[x];}).join("");
		// Unary / qualified
	   	return s.substring(1).replace(/\$/g,"`");
	};
	
	this.$mangleSelector$ = function(s) {
		return "$" + s.replace(/\:/g,"$").replace(/\`/g,"$");
	};
};
'
)) : ()
class PropertyCallAST = MessageAST ((* Sepcialized node to represent applications of JS properties. In some cases (well, at least one) we need to generate ASTs that call javascript methods directly. These calls need to be translated slightly differently (their names must not be mangled). To distinguish these form normal message sends, we use this node. *))
('as yet unclassified'
apply: tool <ASTTool> = (
	^tool propertyCallNode: self
)) : ()
class SlotIR named: n mutable: m accessModifier: am = (|
	public name = n.
	public isMutable = m.
	public accessModifier = am.
	public isSynthetic ::= false.
|)
('as yet unclassified'
public isMutableSlot = (
	(* polymorphic with the AST *)
	^isMutable
)
public printOn: stm = (
	stm nextPutAll: 'SlotIR:'.
	stm nextPutAll: name.
)) : ()'as yet unclassified'
LocalEntry = (
	^super LocalEntry
)
Scope = (
	^super Scope
)
assert: block <[Boolean]> = (
      super assert: block message: 'assertion failed'.
	(* block value ifFalse: [error: 'assertion failed'] *)
)
fullyQualifiedNameToSimple: fullName <String> = (
	| parts |
	
	parts:: splitFullyQualifiedName: fullName.
	^parts last asSymbol
)
fullyQualifySimpleName: simpleName <Symbol> with: fullyQualifiedPackage <Symbol> = (
	^(fullyQualifiedPackage asString, syntheticNameSeparator, simpleName) asSymbol
)
mixinNameOfClassNamed: className <String> ^ <Symbol> = (
	| simpleNames <Collection[String]> rawNames <Collection[String]> |
	rawNames:: splitFullyQualifiedName: className. 
	rawNames size =1 ifTrue: [^className].
	simpleNames:: rawNames select: [:n <String>  | 
					n size == 0 or: [ n first isLetter ]].
				(* this was isDigit--either add isDigit to core string, or perhaps use between:and: *) 
	assert: [simpleNames size >= 2].
	^(simpleNames inject: '' into: [:sn1 <String>  :sn2 <String> | sn1, syntheticNameSeparator, sn2]) asSymbol
)
mixinSlotNameFor: nestedName <String> = (
	| mixinName <String> |
	mixinName:: mixinNameOfClassNamed: nestedName.
	^mixinName
)
split: aString at: aCharacter = (
	| parts start |
	parts:: OrderedCollection new.
	start:: 1.
	1 to: aString size do:
		[:index |
		(aString at: index) = aCharacter ifTrue:
			[parts add: (aString copyFrom: start to: index - 1).
			start:: index + 1]].
	parts add: (aString copyFrom: start to: aString size).
	^parts
)
splitFullyQualifiedName: fqn = (

	(* Make sure we pass only the first character, so that the code works in image and on JS *)
	^ split: fqn at: syntheticNameSeparator first
)
syntheticNameSeparator ^<String> = (
	^'`'
)) : ()