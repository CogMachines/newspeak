Newspeak3
'NS2V8'
class Newspeak2V8Compilation usingPlatform: platform
 parsing: parsing
 generation: generation
 mirrors: mirrors = NewspeakCompilation
 usingPlatform: platform
 asts: parsing ASTModule (
(* NS2V8 is a fork of NS2JS with attention on avoiding performance traps on V8.

Selectors are mangled to legal JavaScript identifiers to avoid V8 eagerly transitioning objects to dictionary mode. Because more characters are allowable in its identifiers, this is cleaner for JavaScript than Dart. Colons become dollars, binary selectors are mapped by a table, and synthetics start with a dollar. (We don't yet fully live up to that last part.)

Bootstrapping is much more similar to NS2Dart, where there is only one version of the code for the Kernel classes which is hand-initialized, rather than phases as in NS2JS.

NS2V8 treats messages sends in the runtime modules to 'js' as intrinsics, evalutating them at compile time. This allows the logic of primitive behavior to defined where is it need, an improvement over the vmmirror intrinsic in NS2Dart which required the logic to be specified in a compiler class.

Unlike NS2JS, the output conforms to strict mode.

NS2V8 only supports the DNU stubs ('big prototype in the sky') implementation of doesNotUnderstand. It installs all DNU stubs up front, rather than at each mixin application.

TODO: ensure we do all of the inlining done by NS2Dart

TODO: add a testing strategy for the compiler test suite


Copyright 2008 Cadence Design Systems, Inc.
Copyright 2009-2010 Gilad Bracha.
Copyright 2012 SAP AG.
Copyright 2012 Google Inc.
Copyright 2013 Ryan Macnak
   
Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0 *)|
      asts = parsing ASTModule.
	Collection = platform collections Collection.
	Dictionary = platform collections Dictionary.
	IdentityDictionary = platform collections IdentityDictionary.
	OrderedCollection = platform collections OrderedCollection.
	SortedList = platform collections SortedList.
	Set = platform collections Set.
	ReadStream = platform streams CharacterReadStream.
	WriteStream = platform streams CharacterReadWriteStream.

	MutableString = platform kernel MutableString.
	
	Parser = parsing Parser.
	
	javascriptGeneration = generation.
	JavascriptWriter = javascriptGeneration Writer.
	js = javascriptGeneration factory.

	names = NameMangler new.

	ASTTool = asts ASTTool.
      ASTCopier = asts ASTCopier.
      SuperFalseVisitor = asts FalseVisitor.
      AST = asts AST.
	AssignmentAST = asts AssignmentAST.
	BlockAST = asts BlockAST.
	CascadedSendAST = asts CascadedSendAST.
	CodeBodyAST = asts CodeBodyAST.
	MessageAST = asts MessageAST.
      MessagePatternAST = asts MessagePatternAST.
	MethodAST = asts MethodAST.
	NormalSendAST = asts NormalSendAST.
	NumberAST = asts NumberAST.
	ReturnStatAST = asts ReturnStatAST.
      SendAST = asts SendAST.
	SymbolAST = asts SymbolAST.
	TupleAST = asts TupleAST.
      VarDeclAST = asts VarDeclAST.
	VariableAST = asts VariableAST.

	parser = Parser new.
	
	(* Caching *)
	lastRuntimeSources
	lastRuntimeReps
|)
(
class ClassDeclarationIR = (|
	name
	instanceSide = MixinIR for: self isMeta: false.
	classSide = MixinIR for: self isMeta: true.
|)
('as yet unclassified'
basicNew = (
	^js functionOf: {} body: (js block: (
		{
		js call: (js ident: 'superBasicNew.call') with: {js ident: 'this'}.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'An instance of ', name).
		},
		(instanceSide slots collect: [:s | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: s name))) toBe: (js ident: 'nil')])
	))
)
basicNewMeta = (
	^js functionOf: {} body: (js block: (
		{
		js call: (js ident: 'superBasicNew.call') with: {js ident: 'this'}.
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'An instance of ', name, ' class').
		}
	))
)
invoke = (
	^js functionOf: {js ident: 'runtimeSuperclass'. js ident: 'enclosingObjects'} body: (js block: {
		js function: 'constructRuntimeClass' of: {js ident: 'superBasicNew'} body: (js block: (
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime class for ', name).
			},
			(instanceSide methods collect: [:m | 
				js assign: (js propertyOf: (js ident: 'this') at: (js literal: m name))
					toBe: (js propertyOf: (js ident: '$') at: (js literal: m name)) ]),
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSelector: 'enclosingObjects`',name)))
				toBe: (js ident: 'enclosingObjects').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSelector: 'super`',name)))
				toBe: (js ident: 'runtimeSuperclass').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'basicNew')) toBe: basicNew.
			js verbatim: 'this.basicNew.prototype = this'.
			js verbatim: 'this.meta = null'.
			js verbatim: 'this.newspeakClass = null'.
			}
		)).
		js verbatim: 'constructRuntimeClass.prototype = runtimeSuperclass'.
		js verbatim: 'return new constructRuntimeClass(runtimeSuperclass.basicNew)'.
	})
)
invokeMeta = (
	^js functionOf: {js ident: 'runtimeSuperclass'. js ident: 'enclosingObjects'.} body: (js block: {
		js function: 'constructRuntimeClass' of: {js ident: 'superBasicNew'} body: (js block: (
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime meta class for ', name).
			},
			(classSide methods collect: [:m | 
				js assign: (js propertyOf: (js ident: 'this') at: (js literal: m name))
					toBe: (js propertyOf: (js ident: '$') at: (js literal: m name)) ]),
			{
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSelector: 'enclosingObjects`',name)))
				toBe: (js ident: 'enclosingObjects').
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSelector: 'super`',name)))
				toBe: (js ident: 'runtimeSuperclass').	
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'basicNew')) toBe: basicNewMeta.
			js verbatim: 'this.basicNew.prototype = this'.
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'nonMeta')) toBe: (js ident: 'null').
			js verbatim: 'this.newspeakClass = null'.
			}
		)).
		js verbatim: 'constructRuntimeClass.prototype = runtimeSuperclass'.
		js verbatim: 'return new constructRuntimeClass(runtimeSuperclass.basicNew)'.
	})
)
makeMixin: rm = (
	^js call: (js propertyOf: (js ident: 'Mixin') at: (js literal: 'fromRuntimeMixin')) with: {rm}
)
printOn: stm = (
	stm nextPutAll: 'ClassDeclarationIR:'.
	stm nextPutAll: name.
)
runtimeMetamixin = (
	^js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'meta')) toBe: (
	js new: (js functionOf: {} body: (js block: (
		{
		js var: '$' value: (js ident: 'this').
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime meta mixin for ', name).
		},
		(classSide methods collect: [:m | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: m name)) toBe: m function]),
		{
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'invoke')) toBe: invokeMeta.
		}
	))) with: {})
)
runtimeMixin = (
	^js new: (js functionOf: {} body: (js block: (
		{
		js var: '$' value: (js ident: 'this').
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'debug')) toBe: (js literal: 'Runtime mixin for ', name).
		},
		(instanceSide methods collect: [:m | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: m name)) toBe: m function]),
		(instanceSide nestedClasses collect: [:ncd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSelector: ncd name))) toBe: ncd runtimeMixin]),
		{
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: 'invoke')) toBe: invoke.
		runtimeMetamixin.
		}
	))) with: {}
)) : ()
class Compiler = super Compiler (
(* A work-in-progress Compiler reimplementation, with Javascript AST as the output. This makes automated testing easier and provides control over formatting (for example, placing every expression on its own line to allow for precise breakpoint placement in substandard JS debugger implementations). *)|
	scopeStack ::= OrderedCollection new.
	input
	sentSelectors ::= Set new.

	rewriter = Rewriter new.	
	translator = Translator new.
	currentDepth
	currentMixinUID
	jsTree
	jsWriter = JavascriptWriter new.
	supportDoesNotUnderstand ::= true.
	inlineOperators ::= true.
	enableIntrinsics ::= true.
|)
(
class Rewriter = super Rewriter (|
	protected inlinableOperators <Dictionary[String, String]> = Dictionary new.
	protected inlinableNumericOperators <Dictionary[String, String]> = Dictionary new.
|inlinableOperators
		at: #+ put: '+';
		at: #- put: '-';
		at: #* put: '*';
		at: #/ put: '/';
		at: #'==' put: '==='.
	inlinableNumericOperators	
		at: #'<' put: '<';
		at: #'<=' put: '<=';
		at: #'>' put: '>';
		at: #'>=' put: '>=')
(
class InlinedOperatorAST = NormalSendAST (
(* When the inlineOperators mode is on, message sends with certain selectors are replaced with this node. Javascript code generated for those nodes uses native Javascript operators instead of real message sends. The selector of the message of this AST is not a real Newspeak selector but rather the Javascript operator such as &&. *)|
|)
('as yet unclassified'
apply: aTool <ASTTool> ^ <Self> = (
	^aTool inlinedOperatorNode: self
)) : ()'as yet unclassified'
__isInlinableAsExpressionConditional: node <NormalSendAST> ^ <Boolean> = (
	((conditionalSelectors includes: node msg sel) and: [valueExpected]) ifFalse: [^false].
	node msg args do:
		[:each <AST> |
		((isRemovableBlock: each withArgs: 0)
			and: [each body statements size = 1
			and: [each body statements first isReturnStatNode not]])
				ifFalse: [^false]].
	^true
)
canInlineSeqexps ^<Boolean> = (
	^false
)
currentScope = (
	^super currentScope
)
depthOfExplicit: binding = (
	| depth |
	#BOGUS. (* Should be the same as depthOfImplicit: *)
	depth:: outer Compiler currentDepth - binding depth - 1.
	assert: [depth >= 0] message: 'Invalid enclosing object index'.
	^depth
)
depthOfImplicit: binding = (
	| depth |
	#BOGUS. (* Should be the same as depthOfExplicit: *)
	depth:: outer Compiler currentDepth - binding depth.
	assert: [depth >= 0] message: 'Invalid enclosing object index'.
	^depth
)
inline: node as: sendClass selector: selector rewriteArgsAs: argRewriteBlock = (
	| receiver message |
	receiver:: applyForValueTo: node recv.
	message:: MessageAST new
		send: selector
		with: (node msg args collect: argRewriteBlock).
	^sendClass new
		to: receiver send: message;
		start: node start;
		end: node end
)
isInlinableBooleanOperator: node <NormalSendAST> = (
	| selector |
	selector:: node msg sel.
	^(selector = 'or:' or: [selector = 'and:'])
		and: [node msg args size = 1
		and: [node msg args first isBlockNode
		and: [node msg args first body statements size = 1]]]
)
isInlinableNumericOperator: node <NormalSendAST> = (
	| args |
	args:: node msg args.
	args size = 1 ifFalse: [^false].
	(inlinableNumericOperators includesKey: node msg sel) ifFalse: [^false].
	(node recv isLiteralNode and: [node recv val isNumber]) ifTrue: [^true].
	(args first isLiteralNode and: [args first val isNumber]) ifTrue: [^true].
	^false
)
isInlinableOperator: node <NormalSendAST> = (
	^(inlinableOperators includesKey: node msg sel)
		and: [node msg args size = 1]
)
normalSendNode: node <NormalSendAST> ^ <AST> = (

	(inlineOperators and: [isInlinableNumericOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableNumericOperators at: node msg sel)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (inlinableOperators at: node msg sel)
			rewriteArgsAs: [:each | applyForValueTo: each]].
	(inlineOperators and: [isInlinableBooleanOperator: node]) ifTrue:
		[^inline: node as: InlinedOperatorAST
			selector: (node msg sel = 'and:' ifTrue: ['&&'] ifFalse: ['||']) (* BOGUS *)
			rewriteArgsAs: [:each <BlockAST> | applyForValueTo: each body statements first]].
	
	^super normalSendNode: node
)
propertyCallNode: node <PropertyCallAST> ^ <PropertyCallAST> = (
	| args |
	assert: [node isMessageNode].
	args:: OrderedCollection new.
	node args do: [:each | args add: (applyForValueTo: each)].
	^PropertyCallAST new
		send: node sel with: args;
		start: node start;
		end: node end
)
setterBlockArgName = (
	^ ('setter_arg') asSymbol
)
setterSendNode: node <SetterSendAST> ^ <AST> = (
(* Rewrite a double-colon setter send. The value of the entire expression should be the value of the argument of the send, NOT the value returned by the setter method. This general case is somewhat inefficient, but in most cases the value of the expression is ignored by the parent so we can use a cheaper regular message send. *)
	| binding block blockArg blockParam blockScope send rewrittenSetterSend |
	binding:: currentScope at: node msg sel ifAbsent: [MessageAST new].
	binding isVarDeclNode ifTrue:
		(* This is an assignment to a temporary; no special handling is needed
		as the value of the expression is the value being assigned. *)
		[^processLocalAccess: node msg of: binding].
	valueExpected ifFalse:
		(* The parent ignores the expression value; use a plain cheap here message send. *)
		[^processImplicitReceiverSend: node].

	(* The value is used by the parent; rewrite the whole thing as
		setter:: expr  =>  [:a | setter: a. a] value: expr *)
	(* a -- ok to use a constant name as long as it cannot collide with a user's name *)
	blockArg:: NormalSendAST new
		to: implicitReceiverNode
		send: (MessageAST new send: setterBlockArgName with: {}).
	blockParam:: ParameterAST name: setterBlockArgName type: nil.
	(* setter: a *)
	send:: NormalSendAST new to: node recv send:
		(MessageAST new sel: node msg sel; args: {blockArg};
		start: node msg start; end: node msg end; yourself);
		start: node  start; end: node  end.
	(* [:a | setter: a. a] *)
	block:: BlockAST new body:
		(CodeBodyAST new
			parameters: {blockParam}
			temporaries: {}
			statements: {
				send.
				blockArg
			};			
			start: node start; end: node end);
			start: node start; end: node end.
	blockScope:: Scope new.
	blockScope
		superScope: currentScope;
		at: setterBlockArgName put: (SlotEntry forDeclaration: blockParam atDepth: nil).
	scopeMap at: block put: blockScope.
	scopeMap at: block body put: blockScope.
	(* [:a | setter: a. a] value: expr *)
	rewrittenSetterSend::
		NormalSendAST new
			to: block
			send: (MessageAST new
				sel: #value:;
				args: {node msg args first};
				start: node msg start; end: node msg end);
				start: node  start; end: node  end.
	^applyForValueTo: rewrittenSetterSend
)) : ()
class ScopeBuilder nestedIn: initialScope <Scope> atLevel: initialDepth <Integer> = super ScopeBuilder nestedIn: initialScope atLevel: initialDepth ()
('as yet unclassified'
propertyCallNode: aNode <PropertyCallAST> = (
	self messageNode: aNode
)) : ('as yet unclassified'
new ^<Instance> = (
	^self nestedIn: Scope new atLevel: 0
))
class Translator = ASTTool (
(* Visits nodes of an NS AST to produce a Javascript AST. The usual translation unit is a method. Translation is initiated by sending the translateMethodNode: message. The argument is the method to translate, the returned value is the translation. *)|
	scopeStack
	currentSelector
	protected containsNonLocalReturn <Boolean> (* Set to false at the beginning of translating a method. The code that emits a non-local return sets this to true. The top-level code checks the value to see whether to emit a try-catch wrapper for an NLR. *)

|)
(
class ASTDescriber = ASTTool (
(* Convert an AST into JS code that constructs an identical AST.

We need to ensure we cover all relevant ASTs (for now, blocks and their contents) and that we capture start and end info (here and in the JS code we call).

We cover rewritten nodes like assignments out of an abundance of caution. *))
('as yet unclassified'
arrayNode: aNode <ArrayAST> = (
halt. 
 ^'ast.arr(', (convertList: aNode elements), ')'.	
)
assignmentNode: aNode  <AssignmentAST> = (
halt.
	^'ast.assign(', (aNode var apply: self), ', ', (aNode expr apply: self), ')'
)
binaryTypeOpNode: aNode <BinaryTypeOpAST>  = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js ident: 'binaryType')) with: {js literal: aNode operator asString. aNode lOperand apply: self. aNode rOperand apply: self}(*
	^'ast.binaryType(', aNode operator asString printString, ', ', (aNode lOperand apply: self), ', ',  (aNode rOperand apply: self),  ')'
*))
blockNode: aNode  <BlockAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'block')) with: {aNode body apply: self}(*
	^'ast.block(', (aNode body apply: self),  ')' *)
)
cascadedSendNode: aNode  <CascadedSendAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'cascade')) with: {aNode prevSend apply: self. aNode msg apply: self}(*
	^'ast.cascade(', (aNode prevSend apply: self), ', ', (aNode msg apply: self), ')' *)
)
charNode: aNode  <CharacterAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'character')) with: {js literal: aNode val asString}(*
	^'ast.character(""', aNode val asString,  '"")' *)
)
codeBodyNode: aNode  <CodeBodyAST> = (
	| ps ts ss |
	ps:: convertList: aNode parameters.
	ts:: convertList: aNode temporaries.
	ss:: convertList: aNode statements.
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'codeBody')) with: {ps. ts. ss}(*	
	^'ast.codeBody(', ps, ', ', ts, ', ', ss, ')' *)
)
genericInvocationNode: aNode = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'genericInvoke')) with: {aNode generic apply: self. convertList: aNode arguments}(*
 ^'ast.genericInvoke(', (aNode generic apply: self), ', ', (convertList: aNode arguments), ')' *)
)
messageNode: aNode  <MessageAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'message')) with: {js literal: aNode sel. convertList: aNode args}(*
	^'ast.message(', aNode sel asString printString, ',', (convertList: aNode args), ')' *)
)
normalSendNode: aNode  <NormalSendAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'send')) with: {aNode recv apply: self. aNode msg apply: self}(*

	^'ast.send(', (aNode recv apply: self), ', ', (aNode msg apply: self), ')' *)
)
numberNode: aNode  <NumberAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'num')) with: {js literal: aNode val}(*
	^'ast.num(', aNode val printString,  ')' *)
)
returnStatNode: aNode  <ReturnStatAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'ret')) with: {aNode expr apply: self}(*
	^'ast.ret(', (aNode expr apply: self), ')' *)
)
setterSendNode: aNode  <SetterSendAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'setter')) with: {aNode recv apply: self. aNode msg apply: self}(*
	^'ast.setter(', (aNode recv apply: self), ', ', (aNode msg apply: self), ')' *)
)
slotDefNode: aNode <SlotDefAST> = (
	| init <String>  |	
	
	init:: aNode initializer ifNil:[js literal: nil] ifNotNil: [: i | i apply: self].	
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'slotDef')) with: {aNode slotDecl apply: self. init. js literal: aNode isMutable. js literal: aNode accessModifier}(*
	init:: aNode initializer ifNil:['null'] ifNotNil: [: i | i apply: self].
	^'ast. slotDef(', (aNode slotDecl apply: self), ', ', init, ', ', aNode isMutable printString, ', ', aNode accessModifier asString printString,  ')' *)
)
stringNode: aNode  <StringAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'str')) with: {js literal: aNode val}(*
	^'ast.str(""', aNode val,  '"")' *)
)
symbolNode: aNode  <SymbolAST> = (
	^stringNode: aNode
)
tupleNode: aNode <TupleAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'tuple')) with: {convertList: aNode elements}(*
 ^'ast.tuple(', (convertList: aNode elements), ')'. *)	
)
typeIdNode: aNode  <TypeIdAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'typeId')) with: {js literal: aNode name}(*
	^'ast.typeId(', aNode name asString printString,  ')' *)
)
unaryTypeOpNode: aNode <UnaryTypeOpAST>  = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'unaryType')) with: {js literal: aNode operator asString. aNode operand apply: self}(*
	^'ast.unaryType(', aNode operator printString, ', ', (aNode operand apply: self),  ')' *)
)
varDeclNode: aNode  <VarDeclAST> = (
	| typ <String> |
		
	typ:: aNode type ifNil:[js ident: 'null'] ifNotNil: [: t | t apply: self].	
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'vdecl')) with: {js literal: aNode name. typ}(*
	typ:: aNode type ifNil:['null'] ifNotNil:[: t | aNode type apply: self].
	^'ast.vdecl(', aNode name asString printString, ', ', typ, ')' *)
)
variableNode: aNode  <VariableAST> = (
	^js call: (js propertyOf: (js ident: 'ast') at: (js literal: 'variable')) with: {js literal: aNode name}(*
	^'ast.variable(', aNode name asString printString,  ')' *)
)'private'
convertList: l = (
 | elements |

	elements:: l collect:[:e | e apply: self].
	^js array: elements
(*
	elements:: ''.
	l do:[:e | elements:: elements, (e apply: self)] separatedBy:[elements:: elements, ', '].	
	^'[', elements, ']' *)
)) : ()
class FreeVariableDetector for: codeBody <CodeBodyAST> = (
(* Discover all free names in the code body. Note that names may be free in a nested closure but not free in the overall  code body.

The motivation for detecting the free names is that a Newspeak closure must provide reflective access to its free variables, but a Javascript closure does not.
Therefore, the compiler needs to collect this information and build a representation that will be accessible at run time.

In practice, free names fall into two categories: true messages to enclosing objects, and variable accesses in the surrounding scope. Conceptually, these are all message sends, but they are treated very differently during compilation.

The second category is primarily what we want to detect. Message sends can be directed at the enclosing object (starting with self) and looked up via standard lookup rules. *)|
freeVariables <Set[Symbol]> = Set new.
boundVariableStack = OrderedCollection new add: Set new; yourself.
|codeBody apply: self)
('as yet unclassified'
assignmentNode: node = (
	node expr apply: self.
	node var apply: self.
)
blockLocalReturnNode: node  = (
	node expr apply: self
)
blockNode: node <BlockAST> = (
	pushScope: node body.
	node body apply: self.
	popScope.
)
boolNode: node = (
	
)
cascadedSendNode: node <CascadedSendAST> = (
	node prevSend apply: self.
	node msg apply: self.
)
charNode: node <CharAST> = (
	
)
codeBodyNode: node <CodeBodyAST> = (
	pushScope: node.
	(* who takes care of slot initializers? they have already been rewritten *)
	node statements do: [:each <StatementAST>  | each apply: self].
	popScope.
)
explicitOuterReceiverNode: node <ExplicitOuterReceiverAST> = (
	
)
freeNames = (
	^freeVariables asMutableArrayList
)
hereName = (
	^#'_here'
)
implicitSendNode: node = (
	| b <AST> aMsg <MessageAST> |
	aMsg:: node msg.
	aMsg apply: self.  
	b:: currentScope at: aMsg sel ifAbsent: [MessageAST new].
	b isMessagePatternNode ifTrue:
		[(* this is a message send for a lexically defined method *)
		^processImplicitOuterSend: aMsg atDepth: b depth].
	b isVarDeclNode
		ifTrue: [freeVariables add: aMsg sel].(* a real variable in scope *)
)
inlinableAsExpressionConditionalNode: node = (
	normalSendNode: node	
)
inlinableConditionalNode: node = (
	normalSendNode: node
)
isHereNode: aNode <AST> ^ <Boolean> = (
	aNode isVariableNode ifFalse: [^false].
	^aNode name = hereName
)
isPseudoVariableNode: aNode <VariableAST> ^ <Boolean> = (
	^aNode name = #self
		or: [aNode name = #super
		or: [aNode name = #outer
		or: [aNode name = #thisContext]]]
)
keywordPatternNode: node <KeywordPatternAST> = (
)
literalPatternNode: aNode <LiteralPatternAST> = (
)
messageNode: node <MessageAST> = (	
	node args do: [:each | each apply: self].
)
mixinClassNode: node = (
	
)
nilNode: node = (
	
)
normalSendNode: node <NormalSendAST> = (
	
	(* temp reads and writes are here sends *)
	(isHereNode: node recv) ifTrue: [^self processHereSend: node msg].	
		(* this is post-rewriter. Do we ever need the above? *)
	node recv apply: self.
	node msg apply: self.
)
numberNode: node <NumberAST> = (
	
)
parameterDeclNode: node = (
	
)
parameterNode: node = (
	processName: node name	
)
receiverNode: node = (
	(* freeVariables add: #self *)
)
returnStatNode: node <ReturnStatAST> = (
	node expr apply: self
)
setterSendNode: node <SetterSendAST> = (
 	normalSendNode: node.
)
stringNode: node <StringAST> = (
	
)
superSendNode: node = (
	node msg apply: self.
	(* freeVariables add: #self *)
)
symbolNode: node <SymbolAST> = (
	
)
temporaryDeclNode: node = (
	
)
temporaryNode: node = (
	processName: node name	(* what if it is synthetic/ *)
)
tupleNode: node <TupleAST> = (
	node elements do: [:each | each apply: self]
)
varDeclNode: node = (
	
)
variableNode: node = (
	processName: node name	
)
wildcardPatternNode: aNode <WildcardPatternAST> = (
)'private'
currentScope = (
	^boundVariableStack last.
)
popScope ^ <Set[Symbol]> = (
	^boundVariableStack removeLast.
)
processHereSend: aMsg <MessageAST> = (
	| b <AST> | (* is this ever called, given we are post rewriter? *)
	aMsg apply: self.  
	b:: currentScope at: aMsg sel ifAbsent: [MessageAST new].
	b isMessagePatternNode ifTrue:
		[(* this is a message send for a lexically defined method *)
		^processImplicitOuterSend: aMsg atDepth: b depth].
	b isVarDeclNode
		ifTrue: [processName: aMsg sel].(* a real variable in scope *)
)
processImplicitOuterSend: aMsg <MessageAST> atDepth: depth <Integer> = (
	(* stub. At some point, we may want to produce a mapping of free names to the lexical depth they come from to make things easier and more efficient for the closure mirror *)
)
processName: n <Symbol> = (
	boundVariableStack detect:[: s | s includes: n] ifNone:[freeVariables add: n].
	
)
pushScope: s <CodeBodyAST> = (
	| bvs <Set[Symbol]> |
	bvs:: Set new.
	currentScope do:[:v <Symbol> | bvs add: v].
	s parameters do:[: p | bvs add: p name].
	s temporaries do:[: t | bvs add: t name].
	boundVariableStack add: bvs
)) : ()'AST visiting'
ifNode: node <IfAST> = (
	^js if: (node cond apply: self)
		then: (node then apply: self)
		else: (node else ifNotNil: [:else | else apply: self])
)
messagePatternNode: node <MessagePatternAST> ^<List[String]> = (
	currentSelector:: node selector.
	^node parameters collect: [:each | each apply: self]
)
methodNode: node <MethodAST> ^<Node> = (
	| translatedBody |
	translatedBody:: node body apply: self.
	^js functionOf: (node pattern apply: self) asArray
		body: (containsNonLocalReturn
			ifTrue: [wrapBodyForNlrHandling: translatedBody]
			ifFalse: [wrapBodyNoNlrHandling: translatedBody]).
)'accessing'
translateMethodNode: node <MethodAST> ^<Node> = (
	| translation |
	beginNewTranslationCycle.
	pushScope: (scopeMap at: node).
	currentScope at: (syntheticNameSeparator, 'currentMethod') asSymbol put: (SemanticMethod decl: node).
	translation:: node apply: self.
	popScope.
	^translation.
)'as yet unclassified'
addCascadedSend: node to: statements = (
	node isCascadedSendNode ifTrue:
		[addCascadedSend: node prevSend to: statements].
	statements add:
		(js call: (js propertyOf: (js ident: 'cascadeReceiver') at: (js literal: (names mangleSelector: node msg sel)))
			with: (node msg args collect: [:each | each apply: self]) asArray). 
)
assignmentNode: node = (
	halt.
	^js assign: (node var apply: self) toBe: (node expr apply: self)
)
astForBlock: node <BlockAST> ^ <Node> = (
	| tree <BlockAST> body <CodeBodyAST> params |
	
	params:: node parameters collect:[:p | VariableAST new name: p name].
	(params size = 1and:[params first name = rewriter setterBlockArgName])
		ifTrue:[^js verbatim:'{}'].
		(* A gross hack to avoid blocks that are produced by rewriting setter sends, as these do not have parseable block source *)
	(* parse the source to obtain unrewritten AST *)
	tree:: parser block parse: (ReadStream  on: (sourceForNode: node)).
	tree isCodeBodyNode ifTrue:[body:: tree] ifFalse:[body:: tree body].
	body parameters: params.
	(* make sure we get a code body, and update any parameters *)
	(* The above is only needed for sugar that hides the actual closure *)
	^(body apply: ASTDescriber new)
)
astFunctionForBlock: node <BlockAST> ^ <Node> = (
	| body |
	body:: astForBlock: node.
	^js functionOf: {} body: (js block:{
		js var: (js ident: 'ast') value: (js call: (js ident: 'populateAST') with: {}).
		js return: (astForBlock: node).
		}).
)
beginNewTranslationCycle = (
	scopeStack:: OrderedCollection new.
	containsNonLocalReturn:: false.
)
blockLocalReturnNode: node <BlockLocalReturnAST> = (
(*	(node expr isNormalSendNode and: [isInlinableConditionalNode: node expr]) ifTrue:
		""Optimize the common special case of returning the value of an ifTrue:ifFalse: message send.
		The clauses already have the necessary local returns of the last expression of each clause
		inserted by the rewriter.""
		[^js if: (node expr recv apply: self)
			then: (node expr msg args first body apply: self)
			else: ((node expr msg args at: 2) body apply: self)]. *)
	^js return: (node expr apply: self)
)
blockNode: node <BlockAST> = (
(* Commented out code creates a special object that may be examined by ClosureMirrors.
*)
       ^(* js new: (js ident: #JsBlock) with: { *)
		js functionOf: (node parameters collect: [:each | each apply: self]) asArray
			body: (node body apply: self).
		(* freeNameLiteralOf: node.
		astFunctionForBlock: node. 
		js literal:  (sourceForNode: node). 
		js literal: parsedLanguage
		} *)
)
boolNode: node <BoolAST> = (
	^js literal: node val
)
cascadedSendNode: node <CascadedSendAST> = (
	| statements |
	statements:: OrderedCollection new.
	addCascadedSend: node to: statements.
	statements at: statements size put: (js return: statements last).
	^js call: (js functionOf: {'cascadeReceiver'} body: (js block: statements))
		with: {node recv apply: self}
)
charNode: node <CharAST> = (
	(* Javascript has no characters, only strings. *)
	^js literal: node val asString
)
codeBodyNode: node <CodeBodyAST> = (
	| locals statements |
	locals:: node temporaries collect: [:each | each apply: self].
	statements:: node statements collect: [:each | each apply: self].
	^js block: (locals asArray, statements) asArray
)
conditionalNode: node <ConditionalAST> = (
	^inlinableConditionalNode: node
)
enclosingObjectNode: node <EnclosingObjectAST> = (
	^processOuterReceiverAtDepth: node depth
)
explicitOuterReceiverNode: node <ExplicitOuterReceiverAST> = (
	^processOuterReceiverAtDepth: node depth
)
freeNamesOf: block  <BlockAST> ^ <Set[Symbol]> = (
	^(FreeVariableDetector for: block body) freeNames
)
implicitReceiverSendNode: node <ImplicitReceiverSendAST> = (
	^processSend: node msg to: (processOuterReceiverAtDepth: node depth) with: node msg args
)
implicitSendNode: node <ImplicitRcvrSendNode> = (
	halt.
	^processSend: node msg to: (processOuterReceiverAtDepth: node depth) with: node msg args
)
inlinableAsExpressionConditionalNode: node <InlinableConditionalAST> = (
	| truePath falsePath condition |
	
	condition:: (node recv apply: self).
	
	node msg sel = 'ifTrue:' ifTrue:
		[truePath:: (node msg args at: 1) body statements first apply: self.
		falsePath:: js ident: 'nil'].
	node msg sel = 'ifFalse:' ifTrue:
		[truePath:: js ident: 'nil'.
		falsePath:: (node msg args at: 1) body statements first apply: self].
	node msg sel = 'ifTrue:ifFalse:' ifTrue:
		[truePath:: (node msg args at: 1) body statements first apply: self.
		falsePath:: (node msg args at: 2) body statements first apply: self].
	node msg sel = 'ifFalse:ifTrue:' ifTrue:
		[truePath:: (node msg args at: 2) body statements first apply: self.
		falsePath:: (node msg args at: 1) body statements first apply: self].
	
	^js ternaryIf: condition then: truePath else: falsePath
)
inlinableConditionalNode: node <InlinableConditionalAST> = (
	| inverseCondition hasElseClause condition |
	inverseCondition:: node ifTrue not.
	hasElseClause:: node else isNil not.
	condition:: node condition apply: self.
	^js if: (inverseCondition ifTrue: [js prefixOperator: '!' on: condition] ifFalse: [condition])
		then: (node then apply: self)
		else: (hasElseClause ifTrue: [node else apply: self] ifFalse: [nil])
)
inlinedOperatorNode: node <InlinedOperatorAST> = (
	(* We are not modeling JS operator precedence, so just parenthesize everything. *)
	^js operator: node msg sel
		with: (node recv apply: self)
		and: (node msg args first apply: self)
)
localReadNode: node <LocalReadAST> = (
	^js ident: (names mangleLocal: node name)
)
localWriteNode: node <LocalWriteAST> = (
	^js assign: (js ident: (names mangleLocal: node name)) toBe: (node value apply: self)
)
loopNode: node <LoopAST> = (

	(* prologue; while(cond==whileTrue) {body}; *)

	|
	prologue = node prologue apply: self.
	cond = node condition apply: self.
	body = node body ifNil: [js block: {}] ifNotNil: [:it | it apply: self].
	
	(* Split the condition is it isn't a single expression *)
	condExpression ::= cond statements last.
	condPrologue = cond statements asOrderedCollection removeLast; yourself.
	|
	
	node isWhileTrue ifFalse: [
		condExpression:: js prefixOperator: '!' on: condExpression].
	
	(* Flatten prologue so its declarations are in scope for the loop *)
	
	^js block: 
		prologue statements,
		condPrologue, {
		js 
			for: (js verbatim: '')
			while: condExpression
			step: (js verbatim: '')
			do: (js block: body statements, condPrologue)}
)
messageNode: node = (
	sentSelectors add: node sel.
	^js literal: (names mangleSelector: node sel)
)
methodLocalReturnNode: node <MethodLocalReturnAST> = (
	^blockLocalReturnNode: node
)
nilNode: node = (
	^js ident: 'nil'
)
nlrName = (
	^'NLR'
)
nlrValuePropertyName = (
	^'value'
)
nonLocalReturnNode: node <NonlocalReturnAST> = (
	^returnStatNode: node
)
numberNode: node <NumberAST> = (
	assert: [node isNumberNode].
	^js literal: node val
)
ordinarySendNode: node <OrdinarySendAST> = (
	enableIntrinsics ifTrue: [
		node recv isImplicitReceiverSendNode ifTrue: [
			node recv msg sel = 'js' ifTrue: [^processIntrinsic: node msg]]].

	^processSend: node msg to: (node recv apply: self) with: node msg args
)
parameterDeclNode: node <ParameterAST> = (
	^names mangleLocal: node name
)
processIntrinsic: msg <MessageAST> = (
	^js perform: msg sel 
		withArguments: (msg args collect: [:arg | processIntrinsicArg: arg]) asArray.
)
processIntrinsicArg: arg <AST> = (
	arg isTupleNode ifTrue: [^(arg elements collect: [:el | processIntrinsicArg: el]) asArray].
	arg isLiteralNode ifTrue: [^arg val].
	^arg apply: self
)
processOuterReceiverAtDepth: depth <Integer> = (
	| slotName |
	depth = 0 ifTrue: [^js ident: 'self'].
	slotName:: names mangleSelector: 'enclosingObjects`', currentMixinUID.
	^js propertyOf: (js propertyOf: (js ident: 'self') at: (js literal: slotName))
		at: (js literal: depth - 1) (* Adjust for self not being in the enclosing objects array. *)
)
processSend: message to: receiver with: args = (
	^js 
		call: (js propertyOf: receiver at: (message apply: self))
		with: (args collect: [:each | each apply: self]) asArray
)
propertyCallNode: node <PropertyCallAST> = (
	^js literal: (names mangleSelector: node sel)
)
receiverNode: node <ReceiverNode> = (
	(* assert: [ node apply: rewriter ReceiverVisitor new] message: 'ReceiverNode expected'. *)
	#BOGUS yourself.
	^js ident: selfName
)
returnStatNode: node <ReturnAST> = (
	containsNonLocalReturn:: true.
	^js block: {
		js assign: (js propertyOf: (js ident: nlrName) at: (js literal: nlrValuePropertyName)) toBe: (node expr apply: self).
		js throw: (js ident: nlrName)
	}
)
selfName = (
	^'self'
)
stringNode: node <StringAST> = (
	^js literal: node val
)
superSendNode: node <SuperSendAST> = (
	| superSlotName args |
	superSlotName:: names mangleSelector: 'super`', currentMixinUID.
	args:: OrderedCollection new.
	args add: (js ident: 'self').
	node msg args do: [:each | args add: (each apply: self)].
	^js call:
			(js propertyOf:
				(js propertyOf: (
					js propertyOf: (js ident: 'self')
						at: (js literal: superSlotName))
					at: (node msg apply: self))
				at: (js literal: 'call'))
		with: args asArray
)
symbolNode: node <SymbolAST> = (
	assert: [node isSymbolNode].
	^js literal: node val
)
temporaryDeclNode: node <ParameterAST> ^<String> = (
	^js var: (names mangleLocal: node name)
		value: (js ident: 'nil')
)
tupleNode: node <TupleAST> = (
	^js array: (node elements collect: [:ea | ea apply: self])
)
varDeclNode: node <VarDeclNode> = (
	(* Produce the corresponding local decl. *)
	^js var: (names mangleLocal: node name)
)
variableNode: node <VariableAST> = (
	halt.
	^js ident: (names mangleLocal: node name)
)
wrapBodyForNlrHandling: body <Block> = (
	| nlrVarNode nlrParamName nlrParamNode |
	nlrVarNode:: js ident: nlrName.
	nlrParamName:: nlrName, '_exception'.
	nlrParamNode:: js ident: nlrParamName.
	^js block: {
		js var: selfName value: (js ident: 'this').
		js var: nlrName value: (js new: (js ident: 'Object') with: {}).
		js try: body catch: nlrParamName with:
			(js block: {
				js if: (js operator: '==' with: nlrVarNode and: nlrParamNode)
					then: (js return: (js propertyOf: nlrParamNode at: (js literal: nlrValuePropertyName)))
					else: (js throw: nlrParamNode)
			})
	}
)
wrapBodyNoNlrHandling: body <Block> = (
	^js block: {js var: selfName value: (js ident: 'this')}, body statements
)'private'
freeNameLiteralOf: block <BlockAST> ^ <Node> = (
	| freeNames <List[Symbol]> vals |
	freeNames:: freeNamesOf: block.
	vals:: freeNames collect:[:n <Symbol> | slotForFreeName: n].
	^js objectLiteralSlotNames: freeNames values: vals
)
slotForFreeName: n <Symbol> ^ <Node> = (
	^js functionOf: {} body: (js return: (js ident: (names mangleLocal:  n)))
)) : ()'as yet unclassified'
accessorForNestedClassNamed: simpleName <String> in: mixinName  <String> superCall: superAccessor <Node> ^ <String> = (
(* Build  a method that will lazily create a nested class 'simpleName' with superclass defined by 'superAccessor' via mixin application, and cache it.  Maybe replace null slot with self-replacing function that computes class and stores in its closure? *)

	| nestedName <String> nestedSlotName <String> nestedSlotNode <Node> enclosingObjectsName <String> |
	nestedName:: names mangleSelector: mixinName, '`', simpleName.
	nestedSlotName:: names mangleSlot: mixinName, '`', simpleName.
	nestedSlotNode:: js propertyOf: (js ident: 'this') at: (js literal: nestedSlotName).	
	enclosingObjectsName:: names mangleSelector: 'enclosingObjects`', mixinName.
	^js functionOf: {} body: (js block: {
		js if: (js operator: '===' with: (js ident: 'nil') and: nestedSlotNode)
			then: (js block: {
				js var: 'self' value: (js ident: 'this').
				js var: 'superclass' value: superAccessor.
				js var: 'enclosingObjects' value: 
					(js call: (js propertyOf: (js array: {js ident: 'this'}) at: (js literal: 'concat'))
						with: {js propertyOf: (js ident: 'this') at: (js literal: enclosingObjectsName)}).
				js var: 'mixin' value: (js propertyOf: (js ident: 'this') at: (js literal: nestedName)).
				js assign: nestedSlotNode toBe: 
					(js call: (js propertyOf: (js ident: 'vmmirror') at: (js literal: 'applyMixin$toSuperclass$withEnclosingObjects$'))
						with: {(js ident: 'mixin'). js ident: 'superclass'. js ident: 'enclosingObjects'}).
			}).
		js return: nestedSlotNode.
		})
)
accessorForSuperclass: superclassCall <AST> inScope: s <Scope> ^<Node> = (
	| send scopeBuilder |
	rewriter pushScope: s.
	send:: superclassCall apply: rewriter.
	rewriter popScope.
	
	translator beginNewTranslationCycle.
	^send apply: translator
)
addMetadataFor: mixin <ClassMixinMirror> to: object <ObjectLiteral> = (

	| metadataSlots | 

	#BOGUS yourself. (* this is not the whole thing *)

	metadataSlots:: OrderedCollection withAll: {
		(* MKL: We should change this to fullyQualifiedName *)
		'name'.
			js literal: mixin name. 
		'simpleName'.
			js literal: (fullyQualifiedNameToSimple: mixin name).
		'isMeta'.
			js literal: mixin isMeta. 
		'language'.
			js literal: parsedLanguage. 
		'methods'.
			js array: ((mixin methods mirrors reject: [:each | each isSynthetic])
					collect: [:each |
							js objectLiteral: {
								'language'. js literal: parsedLanguage. 
								'name'. js literal: each name.
								'source'. js literal: (each src ifNil: [emptyMethodForSelector: each name])}])}.

	mixin isMeta
		ifTrue: [metadataSlots addAll: {
			'slots'. js array: {}}]
		ifFalse: [metadataSlots addAll: {
		(* We could store the header only and refrain from storing the source of single slots explicitly. Reconstructing the slots from the source requires the Newspeak parser to be working though, which itself relies on class/slot mirrors being functional to a certain extent. Thus we store the sources of single slots, so that we can at least report the names of slots. Nothing more is required by the parser. *)
			'header'. js literal: mixin header.
			'slots'. js array: (mixin slots collect: [:each |
				js objectLiteral: {
					'language'. js literal: parsedLanguage. 
					'name'. js literal: each name.
					'source'. js literal: each source.
					'isMutable'. js literal: each isMutable}])},
			(useDnuCatcher
				ifTrue: [{'sentSelectors'. js array: (sentSelectors asArray collect: [:each | js literal: each])}]
				ifFalse: [{}])].
	
	object addSlot: 'metadata' value: (js objectLiteral: metadataSlots).
)
addMethodsOf: mirror <LowLevelMixinMirror> to: object <ObjectLiteral> = (
	mirror methods do:
		[:method <MethodMirror> |
		| nameMustBeQuoted properName |
		(*nameMustBeQuoted:: method isSynthetic not or: [method isAccessor or: [method isFactory]].
		properName:: nameMustBeQuoted
			ifTrue: ['''#', method name, '''']
			ifFalse: [method name].*)
		object addSlot: (names mangleSelector: properName) value: method method]
)
addMixinHandleAccessorTo: object = (

	| mixinAccessor |
	(* We used to generate a single mixin accessor method in newspeakClassRC. We changed to generating a method per mixin, so that mixin handles can also be accessed when only the mixin object is available. *)
	mixinAccessor:: js
		functionOf: {}
		body: (js block: {
			js return: (js call: (js ident: 'mixinHandleFor') with: {js ident: 'this'})}).

	object
		addSlot: 'mixinHandle'
		value: mixinAccessor
)
addNestedClassesFor: mixin <MixinRep> to: object <ObjectLiteral> = (
	| nestedMixins |
	nestedMixins:: js objectLiteral.
	mixin last do:
		[:rep <MixinRep> |
		nestedMixins
			addSlot: (names mangleSelector: rep first name)
			value: (translateMixinRep: rep)].
	object addSlot: 'nestedMixins' value: nestedMixins.
)
addNestedMixinsFromNamespaceFor: mixin <MixinRep> to: object <ObjectLiteral> = (
	| nestedMixins |
	nestedMixins:: js objectLiteral.
	mixin last do:
		[:rep <MixinRep> |
		nestedMixins
			addSlot: rep first name
			value: (js
				propertyOf: (js ident: mixinNamespace)
				at: (js literal: rep first name))].
	object addSlot: 'nestedMixins' value: nestedMixins.
)
beginNewCompileCycle = (
	scopeStack:: OrderedCollection new.
)
checkForDuplicateNames: aNode = (

	| namesWithDuplicates names duplicateNames |
	
	namesWithDuplicates:: OrderedCollection new.
	aNode instanceSide categories do: [:cat |
		cat methods do: [:each | namesWithDuplicates add: each selector]].
	
	aNode hdr slots do: [:each |
		namesWithDuplicates add: each name.
		each isMutable ifTrue: [namesWithDuplicates add: each name, ':']].
	
	namesWithDuplicates
		addAll: (aNode instanceSide nestedClasses collect: [:each | each name]).

	names:: Set new.
	duplicateNames:: Set new.
	namesWithDuplicates do: [:each | | present |
		present:: true.
		names include: each ifNew: [present:: false].
		present ifTrue: [duplicateNames add: each]].
	
	duplicateNames isEmpty ifFalse: [ | message |
		message:: String streamContents: [:s |
			s
				nextPutAll: 'Class ';
				nextPutAll: aNode name;
				nextPutAll: '" has multiple definitions for '.
			duplicateNames
				do: [:each | s nextPutAll: each asString]
				separatedBy: [ s nextPutAll: ','].
			s nextPutAll: '.'.].
		assert: false message: message].

)
classNode: aNode <ClassDeclarationAST> ^ <ClassDeclarationIR> = (
	| ir <ClassDeclarationIR> priorMixinUID <String> |
	checkForDuplicateNames: aNode.
	ir:: computeMixinFrom: aNode hdr.
	priorMixinUID:: currentMixinUID.
	currentMixinUID:: ir name.
	currentDepth:: currentDepth + 1.
	processInstanceSideOf: aNode ofMixin: ir instanceSide.
	generateSlotAccessorsFor:  ir instanceSide. 
	(* must be called after nested classes are processed, so all synthetic slots have been added *)
	processClassSideOf: aNode ofMixin: ir classSide.
	currentDepth::currentDepth - 1.
	currentMixinUID:: priorMixinUID.
	^ir
)
compileClassSource: source <ReadStream> within: enclosing <MixinMirror> ^<CompiledMixinMirror> = (
	| tree <AST> mixinRep <MixinRep> |
	tree:: parser classDefinition parse: source.
	setInput: source.
	setScopeFor: tree in: enclosing.
	(*sentSelectors:: Set new.*)
	mixinRep:: classNode: tree.
	scopeMap:: Dictionary new.
	^enclosing isNil ifTrue:[mixinRep] ifFalse:[{enclosing. mixinRep}].
)
compileMethodSource: source <ReadStream> within: enclosing <MixinMirror> ^<MethodMirror> = (
	| tree <AST> |
	tree:: parser methodDecl parse: source.
	setInput: source.
	setScopeFor: tree in: enclosing.
	jsTree:: translateMethodNode: tree.
	scopeMap:: Dictionary new.
	^jsTree
)
compileNestedClasses: nestedClasses <Collection[ClassDeclarationAST]> within: mixinIR <MixinIR> = (
	
	nestedClasses do:
		[ :nc <ClassDeclarationAST> |  
			| nSlotName <String> nSlot <InstanceVariableMirror> |
		nSlotName:: mixinIR declaration name, '`', nc name.
		nSlot:: SlotIR named: nSlotName mutable: true.
		nSlot isSynthetic: true.
		mixinIR slots add: nSlot.
		mixinIR nestedClasses add: (classNode: (nestedMixinWrapperFor: nc in: mixinIR)). (* make 'mixin' (a Smalltalk subclass of ProtoObject) for nested class *)
		createNestedClassAccessorFrom: nc within: mixinIR
		].
)
compileNestedClassesOf: aNode <SideAST> within: mixinMirror <LowLevelMixinMirror> ^ <Collection[MixinRep]> = (
	(* where do we check that nested classes do not conflict with each other, or with methods or slots? *)
	^compileNestedClasses: aNode nestedClasses within: mixinMirror
)
compileWithFullInfoTopLevelClassSource: source <ReadStream> = (
	| tree rep mixinAst ast output |
	tree:: parser classDefinition parse: source.
	setInput: source.
	setScopeFor: tree in: nil.
	(*sentSelectors:: Set new.*)
	rep:: classNode: tree.
	mixinAst:: translateMixinRep: rep. 
	ast:: js
		propertyOf: (js
			call: (js ident: 'makeTopLevelClass')
			with: {mixinAst})
		at: (js literal: 'factory').
	output:: WriteStream on: (MutableString new: 100).
	jsWriter generateSourceFor: ast on: output.
	^{	output contents.
		jsWriter nsIntervals.
		jsWriter jsIntervals.
		tree.
		ast
	}
)
computeMethod: aNode <MethodAST> inScope: s <Scope> = (
	|  scopeBuilder <ScopeBuilder>  |
	scopeBuilder:: ScopeBuilder nestedIn: s atLevel: currentDepth.
	aNode apply: scopeBuilder.
	(* need to build scope for method before visiting it *)
	^methodNode: aNode.
)
computeMixinFrom: aNode <ClassHeaderAST> ^ <ClassDeclarationIR> = (
	| 
	ir = ClassDeclarationIR new.
	|
	
	ir name: aNode name.
	aNode slots do: [:s |
		ir instanceSide slots add: (SlotIR named: s name mutable: s isMutable)].
	(* ir headerSource: (input contents copyFrom: aNode start to: aNode end).
	ir factorySelector: aNode constructor selector. *)
	^ir
)
createNestedClassAccessorFrom: classDecl <ClassDeclarationAST> within: mixinMirror <LowLevelMixinMirror> = (
(* Create an accessor method for the nested class represented by the incoming class tree.
This accessor will lazily generate the nested class when its enclosing instance is first asked for it. *)

	| n <String>  accessorString <String> methodSrc <String>  hdr <ClassHeaderAST> accessor <MethdMirror>  |
	hdr:: classDecl hdr.
	n:: hdr name. 
	methodSrc:: 
		accessorForNestedClassNamed: n 
		in:  mixinMirror name 
		superCall: (accessorForSuperclass: hdr superclassCall inScope:  (scopeMap at: classDecl instanceSide)).
	accessor:: MethodIR named: (names mangleSelector: classDecl name) asSymbol.
	accessor function: methodSrc.
	accessor isSynthetic: true.
	mixinMirror methods add: accessor.
)
createSlotsFor: aNode <ClassHeaderAST> ^ <String> = (
	| assignments |
	assignments:: aNode  slots collect:
		[:slot <SlotDefAST> |
		js assign: (js propertyOf: (js ident: 'this') at: (js literal: slot name))
			toBe: (js ident: 'nil')].
 	^js functionOf: {}
		body: (js block: (assignments asArray, {js return: (js ident: 'this')}))
)
currentScope ^<Scope> = (
	^scopeStack last
)
emptyMethodForSelector: selector = (

	| result counter |
	result:: ''.
	counter:: 1.
	(* Could use some generic substring-replacement mechanism.
	Should not construct a new string on every iteration. *)
	selector do: [:each | | next |
		next:: each = $:
			ifTrue: [': x', counter asString]
			ifFalse: [each asString].
		result:: result, next.].
	^ result, ' = ("generated")'
)
generateSlotAccessorsFor: mixinIR <MixinIR>  = (
(* We need getter FUNCTIONS so we can call them uniformly with arguments (albeit empty ones) *)
	mixinIR slots do: [:slotIR  | 
		| getter <MethodMirror> getterJS <Node> setter <MethodMirror> setterJS <Node> slotName <String> fieldName |
		slotName:: slotIR name.
		fieldName:: names mangleSlot: slotName.
		
		getter:: MethodIR named: (names mangleSelector: slotName).
		getterJS:: js functionOf: {} body: (js block: {
			js return: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))
			}).
		getter function: getterJS.
		getter isSynthetic: true.			
		mixinIR methods add: getter.
		
		setter:: MethodIR named: (names mangleSelector: (setterSelectorFor: slotIR)).
		setterJS:: js functionOf: {'v'} body: (js block: {
			(js assign: (js propertyOf: (js ident: 'this') at: (js literal: fieldName))
				toBe: (js ident: 'v')).
			js return: (js ident: 'this')
			}).
		setter function: setterJS.
		setter isSynthetic: true.	
		mixinIR methods add: setter.
		]	
)
hereNode ^<VariableAST> = (
	(* Generates an AST representing the implicit receiver. We use a string so that we can represent a name that is not a legal identier *)
	
	^VariableAST new name: #'@here'; start: 0; end: 0.
)
hereSendFrom: arg <VarDeclAST> ^<MessageNode> = (
	^NormalSendAST new
		to: hereNode
		send: (MessageAST new 
			send: arg name
			with: {};
			start: arg start; end: arg end); 
		start: arg start; end: arg end
)
initializerFor: aNode <ClassHeaderAST> ^ <MethodAST> = (
| 
stmts  <Collection[StatementAST]>
start <Integer>  
end <Integer> 
initHdr <MessagePatternAST>
body <CodeBodyAST> 
copier <ASTCopier> 
params <List[VarDeclAST]>
|

	start:: aNode superConstructorCall start.
	end:: aNode superConstructorCall end.
	copier:: ASTCopier new.
	params:: aNode constructor parameters collect: 
		[:formal | formal apply: copier].
	initHdr:: MessagePatternAST new
		selector: #instanceInitializer parameters: params;
		start: start; end: end.
		
	(* set up scope with constructor parameters *)
 	stmts:: OrderedCollection new.
	
	stmts add: (superConstructorCallFor: aNode).
	
	(aNode slots reject: [:ea | ea initializer isNil]) 
		do: [:slot <SlotDefAST> | | aMsg <MessageAST> |
	aMsg:: MessageAST new send: (names mangleSelector: (setterSelectorFor: slot)) 
					   with:  {slot initializer apply: copier} ;
					   start: slot  start; end: slot end.
	stmts add: (NormalSendAST new msg: aMsg; 
                          recv: (selfNode start: aMsg start; end: aMsg end);
                          start: aMsg start; end: aMsg end).			
	].

 stmts addAll: (aNode initExprs collect:[:ie | ie apply: copier]).
 body:: CodeBodyAST new temporaries: OrderedCollection new
                                       statements: stmts; 
                                       start: start; end: end.
 ^MethodAST new pattern: initHdr
                            body: body
                            accessModifier: #public; 
                            start: start; end: end.
)
language = (
	^#NewspeakLanguage2
)
makeCreateSlotsFor: hdr <ClassHeaderAST>  within: mixinMirror <LowLevelMixinMirror> ^ <MethodAST> = (
(* Create the method that initializes the slots defined by the class declaration to nil *)
	| accessor <MethdMirror>  |
	accessor:: MethodMirror named: #createSlots.
	accessor method: (createSlotsFor: hdr).
	accessor isSynthetic: true.
	mixinMirror methods addMirror: accessor.
)
methodNode: aNode <MethodAST> ^ <MethodMirror> = (
	| tree <AST> jsTree |
	tree:: aNode apply: rewriter.  (* rewrite ast *)
	translator beginNewTranslationCycle.
	jsTree:: tree apply: translator.	 (* final pass: visit rewritten ast *)
	(* pop scope? *)
	^((MethodIR named: (names mangleSelector: translator currentSelector))
		function: jsTree)
			src: (sourceForNode: aNode)
)
mixinNamespace = (

	^ 'globalMixinNamespace'
)
nestScope: scope <Scope> = (
	(* Hook up a new lexically nested scope, and push onto the scope stack *)
	scope superScope: currentScope.
	pushScope: scope
)
nestedMixinWrapperFor: nested <ClassDeclarationAST> in: outerClass <MixinMirror>  ^ <ClassDeclarationAST> = (
(* Wrap a class declaration to make it look like a nested mixin within outerClass should. This includes making the name be the fully qualified name, and hiding the superclass. *)

	| wrapper <ClassDeclarationAST> |
	wrapper:: nested clone.
	wrapper hdr: nested hdr clone.
	wrapper hdr name: (fullyQualifySimpleName: nested name with: outerClass name).
	^wrapper
)
outputClass: mixinRep <MixinRep> toNamespace: namespace <FilePattern> = (

	| ast simpleName |
	
	simpleName:: (fullyQualifiedNameToSimple: mixinRep first name).
	
	mixinRep last do: [:each |
		outputClass: each toNamespace: namespace / simpleName].
	
	ast:: js script: {js
		assign: (js propertyOf: (js ident: mixinNamespace) at: (js literal: mixinRep first name))
		toBe: (translateMixinRepWithNestedMixinsFromNamespace: mixinRep)}.
	
	(namespace / (simpleName, '.js')) stream: [:stream |
		jsWriter generateSourceFor: ast on: stream].
	
)
outputCreationOfClass: mixinRep <MixinRep> to: stream<[:WriteStream]> = (

	| ast |
	ast:: js
		propertyOf: (js
			call: (js ident: 'makeTopLevelClass')
			with: {js propertyOf: (js ident: mixinNamespace) at: (js literal: mixinRep first name)})
		at: (js literal: 'factory').

	jsWriter generateSourceFor: ast on: stream
)
outputInfrastructureCodeTo: stream = (

	InfrastructureFunctions new outputTo: stream.
	Phase1Platform new outputTo: stream.
)
outputTopLevelClass: rep <MixinRep> to: stream <WriteStream> = (
	| mixinAst ast |
	mixinAst:: translateMixinRep: rep. 
	ast:: js
		propertyOf: (js
			call: (js ident: 'makeTopLevelClass')
			with: {mixinAst})
		at: (js literal: 'factory').
		
	jsWriter generateSourceFor: ast on: stream.
)
popScope ^<Scope> = (
	^scopeStack removeLast
)
processClassSideOf: aNode <ClassAST> ofMixin: mixinMirror <LowLevelMixinMirror> = (
	(* | primaryFactory <MethodMirror> factoryAST <MethodAST> | *)
	processFactoryFor: aNode in: mixinMirror.
	processSide: aNode classSide ofMixin: mixinMirror. (* compile class methods *)
)
processFactoryFor: aNode <ClassAST> in: mixinIR <MixinIR> = (
	| accessor <MethdMirror> argNames ast |
	accessor:: MethodIR named: (names mangleSelector: aNode hdr constructor selector).
	argNames:: (aNode hdr constructor parameters collect: [:each | names mangleLocal: each name]) asArray.
	ast:: js functionOf: argNames body: (js block: {
		js return:
			(js call: (js ident: '(new this.nonMeta.basicNew()).instanceInitializer') (* cheat! *)
				with: (argNames collect: [:each | js ident: each]))
		}).
	accessor function: ast.
	mixinIR methods add: accessor.
)
processInitializerFor: aNode <ClassAST> in: mixinIR <MixinIR> = (
	processMethod: (superConstructorMethodFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinIR. 
	(*makeCreateSlotsFor: aNode hdr within: mixinIR.*)
	processMethod: (initializerFor: aNode hdr) inScope:  (scopeMap at: aNode instanceSide) in: mixinIR.
)
processInstanceSideOf: aNode <ClassAST> ofMixin: mixinIR <MixinIR> ^ <Collection[MixinRep]> = (
	processInitializerFor: aNode in: mixinIR.
	processSide: aNode instanceSide ofMixin: mixinIR. (* compile instance methods *)
	compileNestedClassesOf: aNode instanceSide within: mixinIR. (* gather nested classes *)
)
processMethod: aNode <MethodAST> inScope: s <Scope> in: mixinIR <MixinIR> = (
	|  method <MethodMirror> |
	method:: computeMethod: aNode inScope: s.
	method isSynthetic: true.
	mixinIR methods add: method.
)
processSide: side <SideAST> ofMixin: mixinIR <MixinIR> = (
	side categories do: [:cat |
		cat methods do: [:m | 
			mixinIR methods add: (methodNode: m)]].
)
pushScope: scope <Scope> = (
	scopeStack addLast: scope
)
selfNode ^ <VariableAST> = (
	(* generate a an AST representing self; used for implicit self sends *)
	^VariableAST new name: #self; start: 0; end: 0
)
setInput: source <ReadStream> = (
	source position: 1.
	input: source. (* save the input *)
)
setScopeFor: node <AST> in: enclosing <MixinMirror | nil> = (
	| scopeBuilder |
	pushScope: Scope new.
	enclosing notNil ifTrue: [nestScope:: ScopeBuilder new buildScopeFor: enclosing].
	currentDepth:: currentScope depth - 1.
	scopeBuilder:: ScopeBuilder nestedIn: currentScope atLevel: currentDepth.
	node apply: scopeBuilder
)
setterSelectorFor: slot <SlotDefAST | InstanceVariableMirror> ^<Symbol> = (
	^((slot isMutableSlot ifTrue: [ '' ] ifFalse: [ 'setOnce`' ]), slot name, ':') asSymbol.
)
slotNameForNestedClassNamed: ncn <String> within: outerName <String> ^ <String> = (
	^mixinSlotNameFor:
		(fullyQualifySimpleName: ncn with: outerName). 
)
sourceForNode: node <AST> ^ <String> = (
	| savedPos <Integer> pos <Integer> len <Integer> s <String> |
	(* ^String withAll: (input copyFrom: node start to: node end *)
	savedPos:: input position.
	len: (node end - node start) + 1.
	s:: MutableString new: len.
	input position: node start -1.
	1 to: len do:
		[:index |
		s at: index put: input next].	
	input position: savedPos.
	^s
)
superConstructorCallFor: aNode <ClassHeaderAST> ^<NormalSendAST> = (
	
	(* create call to super constructor method *)
	|
	var  <VariableAST> 
	send <NormalSendAST>
	start <Integer> 
	end <Integer>  
	superMsg <MessageAST>
	args <List[VariableAST]> 
	|

	start:: aNode superConstructorCall start.
	end:: aNode superConstructorCall end.
	var:: VariableAST new name: #self; start: start; end: end.
	args:: aNode constructor parameters collect:
		[:p <VarDeclAST> | hereSendFrom: p].
	superMsg:: MessageAST new 
		send: (superConstructorNameFor: aNode) with: args; 
		start: start; end: end.
	send:: NormalSendAST new to: var send: superMsg; start: start; end: end.	
	^send
)
superConstructorMethodFor:  aNode <ClassHeaderAST> ^ <MethodAST> = (
| 
start <Integer> 
end <Integer>
stmts <List[StmtAST]> 
var  <VariableAST> 
initHdr <MessagePatternAST>
superMsg <MessageAST> 
send <NormalSendAST>
body  <CodeBodyAST>
copier <ASTCopier>
params <List[VarDeclAST]>
args <List>
|

	start:: aNode superConstructorCall start.
	end::  aNode  superConstructorCall end.
	copier:: ASTCopier new.
	params:: aNode constructor parameters collect:[:formal | formal apply: copier].
	initHdr:: MessagePatternAST new selector: (superConstructorNameFor: aNode) parameters: params;
				start: start; end: end. 
	(* set up scope with constructor parameters *)
	(* create call to superclass initializer *)
	stmts:: OrderedCollection new. 
	var:: VariableAST new name: #super; start: start; end: end.
	args:: aNode superConstructorCall args collect:[:actual | actual apply: copier].
	superMsg::  PropertyCallAST new send: 'instanceInitializer' with: args; 
				start: start; end: end. 
	(* only copy actual args *)
	(* send these as a tuple? to super instance initializer? *)
	send:: NormalSendAST new to: var send: superMsg; start: start; end: end. 
	stmts addFirst: send.
	body:: CodeBodyAST new temporaries: OrderedCollection new
                                       	statements: stmts;
                                      	start: start; end: end.
	^MethodAST new pattern: initHdr
                            body: body
                            accessModifier: #private;
                            start: start; end: end	
)
superConstructorNameFor: aNode <ClassHeaderAST> ^ <Symbol> = (
	^'superInit`', aNode name
)
translateMethodNode: method <MethodAST> = (
	| tree <AST> |
	tree:: method apply: rewriter.
	translator beginNewTranslationCycle.
	^tree apply: translator.
)
translateMixinRep: mixin <MixinRep> = (
	| mirror <LowLevelMixinMirror> object |
	mirror:: mixin first lowLevelMirror.
	object:: js objectLiteral.
	mirror isMeta ifFalse: [
		| classMixinObject |
		classMixinObject:: js objectLiteral.
		addMetadataFor: mirror classMixin to: classMixinObject.
		addMixinHandleAccessorTo: classMixinObject.
		addMethodsOf: mirror classMixin to: classMixinObject.
		object addSlot: 'classMixin' value: classMixinObject.
		addNestedClassesFor: mixin to: object.
		addMetadataFor: mixin first to: object].
	addMixinHandleAccessorTo: object.
	addMethodsOf: mirror to: object.
	^object
)
translateMixinRepWithNestedMixinsFromNamespace: mixin <MixinRep> = (
	| mirror <LowLevelMixinMirror> object |
	mirror:: mixin first lowLevelMirror.
	object:: js objectLiteral.
	mirror isMeta ifFalse: [
		| classMixinObject |
		classMixinObject:: js objectLiteral.
		addMetadataFor: mirror classMixin to: classMixinObject.
		addMixinHandleAccessorTo: classMixinObject.
		addMethodsOf: mirror classMixin to: classMixinObject.
		object addSlot: 'classMixin' value: classMixinObject.
		addNestedMixinsFromNamespaceFor: mixin to: object.
		addMetadataFor: mixin first to: object].
	addMixinHandleAccessorTo: object.
	addMethodsOf: mirror to: object.
	^object
)
writeJascriptAST: node <Node> ^<String> = (
	| writer |
	writer:: JavascriptWriter on: '' writeStream.
	writer generateSourceFor: node.
	^writer contents
)'lexical export'
scopeMap = (
	^super scopeMap
)) : ()
class Infrastructure withAppSources: appSources withRuntimeSources: runtimeSources outputTo: stream = (|
	compiler = Compiler new.
	applicationMixins = compileModules: appSources enableIntrinsics: false.
	runtimeMixins = compileModules: runtimeSources enableIntrinsics: true.
|JavascriptWriter new generateSourceFor: script on: stream)
('as yet unclassified'
appDefnName = (
	 ^applicationMixins first name
)
compileModules: modules <List[String]> enableIntrinsics: flag <Boolean> ^<List[ClassDeclarationIR]> = (
	(* Strictly speaking, these are module definitions not module (instances). *)
	
	| results |
	(flag and: [modules = lastRuntimeSources]) ifTrue: [^lastRuntimeReps].
	
	compiler enableIntrinsics: flag.
	results:: modules collect: [:module <String> |
		compiler compileClassSource: module readStream within: nil].
	
	flag ifTrue: [lastRuntimeReps:: results. lastRuntimeSources:: modules].
	^results
)
dnuHandlers = (
	^js function: 'installDnuHandlersOn' of: {js ident: 'p'} body: (js block: (
	compiler sentSelectors collect: [:selector | 
		| args = ((1 to: selector numArgs) collect: [:i | js ident: 'a',i printString]). |
		js assign: (js propertyOf: (js ident: 'p') at: (js literal: (names mangleSelector: selector))) toBe:
		(js functionOf: args body: (js block: {
			js return: (js call: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSelector: #doesNotUnderstand:)))
			 with: {js call: (js verbatim: 'vmmirror.kernel.Message().selector$arguments$') 
				with: {js literal: (names mangleSelector: selector). js array: args} })
		}))
	]))
	
	(* sel (a1,a2){  this.dnu(kernel.Message().selector$arguments$('sel', [a1, a2]) )  } *)
)
main = (
	^js verbatim: 
'var runtime = ns.',runtimeDefnName,'().packageUsing$(ns);
var platform = runtime.using$(vmmirror);
var app = ns.',appDefnName,'().packageUsing$(ns);
app.main$args$(platform, [])'
)
namespace = (
	^js var: 'ns' value: (js new: (js functionOf: {} body: (js block: (
		(applicationMixins, runtimeMixins collect: [:cd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: cd name))) 
				toBe: (js call: (js propertyOf: (js ident: 'vmmirror') at: (js literal: 'applyTopLevelMixin')) 
						with: {js propertyOf: (js ident: 'mixins') at: (js literal: (names mangleSelector: cd name))})]),
		(applicationMixins, runtimeMixins collect: [:cd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSelector: cd name)))
				toBe: (js functionOf: {} body: (js block: {js return: 
					(js propertyOf: (js ident: 'this') at: (js literal: (names mangleSlot: cd name)))}))])
	))) with: {})
)
runtimeDefnName = (
	 ^runtimeMixins first name
)
runtimeMixinNamespace = (
	^js new: (js functionOf: {} body: (js block: (
		applicationMixins, runtimeMixins collect: [:cd | 
			js assign: (js propertyOf: (js ident: 'this') at: (js literal: (names mangleSelector: cd name))) toBe: cd runtimeMixin]
	))) with: {}
)
script = (
	^js script: 
		{js literal: 'use strict'.
		js var: 'nil' value: (js literal: 'patch me with nil').
		js var: 'mixins' value: runtimeMixinNamespace.
		vmmirror.
		namespace.
		dnuHandlers.
		main}
)
source = (
	^JavascriptWriter new generateSourceFor: script
)
vmmirror = (
	^js verbatim: 
'
var vmmirror = new function(){
	
	this.ImplementationBase$slot = new function(){
		this.debug = "ImplementationBase";
		this.runtimeClass$slot = new function(){
			this.debug = "Runtime class for ImplementationBase";
			this.basicNew = function(){};
			this.instanceInitializer = function(){};
		};
	};
	this.ImplementationBase = function(){return this.ImplementationBase$slot;};
	this.Array = function(){return Array;};
	this.String = function(){return String;};	
	
	this.createKernel = function(){
		
		var enclosingObjects = ["patch me with kernel", "patch me with nil"];
		var enclosingObjects2 = ["patch me with nil"];
		
		var Object$runtimeClass = mixins.KernelForV8.KernelForV8$Object.invoke(this.ImplementationBase().runtimeClass$slot, enclosingObjects);
		var Class$runtimeClass = mixins.KernelForV8.KernelForV8$Class.invoke(Object$runtimeClass, enclosingObjects);
		var Metaclass$runtimeClass = mixins.KernelForV8.KernelForV8$Metaclass.invoke(Object$runtimeClass, enclosingObjects);
		var Mixin$runtimeClass = mixins.KernelForV8.KernelForV8$Mixin.invoke(Object$runtimeClass, enclosingObjects);
		var UndefinedObject$runtimeClass = mixins.KernelForV8.KernelForV8$UndefinedObject.invoke(Object$runtimeClass, enclosingObjects);
		var Kernel$runtimeClass = mixins.KernelForV8.invoke(Object$runtimeClass, enclosingObjects2);
		
		var Object$class$runtimeClass = mixins.KernelForV8.KernelForV8$Object.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Class$class$runtimeClass = mixins.KernelForV8.KernelForV8$Class.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Metaclass$class$runtimeClass = mixins.KernelForV8.KernelForV8$Metaclass.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Mixin$class$runtimeClass = mixins.KernelForV8.KernelForV8$Mixin.meta.invoke(Class$runtimeClass, enclosingObjects);
		var UndefinedObject$class$runtimeClass = mixins.KernelForV8.KernelForV8$UndefinedObject.meta.invoke(Class$runtimeClass, enclosingObjects);
		var Kernel$class$runtimeClass = mixins.KernelForV8.meta.invoke(Class$runtimeClass, enclosingObjects2);
		
		Object$runtimeClass.meta = Object$class$runtimeClass;
		Class$runtimeClass.meta = Class$class$runtimeClass;
		Metaclass$runtimeClass.meta = Metaclass$class$runtimeClass;
		Mixin$runtimeClass.meta = Mixin$class$runtimeClass;
		UndefinedObject$runtimeClass.meta = UndefinedObject$class$runtimeClass;
		Kernel$runtimeClass.meta = Kernel$class$runtimeClass;
		
		Object$class$runtimeClass.nonMeta = Object$runtimeClass;
		Class$class$runtimeClass.nonMeta = Class$runtimeClass;
		Metaclass$class$runtimeClass.nonMeta = Metaclass$runtimeClass;
		Mixin$class$runtimeClass.nonMeta = Mixin$runtimeClass;
		UndefinedObject$class$runtimeClass.nonMeta = UndefinedObject$runtimeClass;
		Kernel$class$runtimeClass.nonMeta = Kernel$runtimeClass;
		
		nil = new UndefinedObject$runtimeClass.basicNew();
		
		var Object = new Object$class$runtimeClass.basicNew();
		var Class = new Class$class$runtimeClass.basicNew();
		var Metaclass = new Metaclass$class$runtimeClass.basicNew();
		var Mixin = new Mixin$class$runtimeClass.basicNew();
		var UndefinedObject = new UndefinedObject$class$runtimeClass.basicNew();
		var Kernel = new Kernel$class$runtimeClass.basicNew();
		
		var Object$class = new Metaclass$runtimeClass.basicNew();
		var Class$class = new Metaclass$runtimeClass.basicNew();
		var Metaclass$class = new Metaclass$runtimeClass.basicNew();
		var Mixin$class = new Metaclass$runtimeClass.basicNew();
		var UndefinedObject$class = new Metaclass$runtimeClass.basicNew();
		var Kernel$class = new Metaclass$runtimeClass.basicNew();
		
		Object$class$runtimeClass.newspeakClass = Object$class;
		Class$class$runtimeClass.newspeakClass = Class$class;
		Metaclass$class$runtimeClass.newspeakClass = Metaclass$class;
		Mixin$class$runtimeClass.newspeakClass = Mixin$class;
		UndefinedObject$class$runtimeClass.newspeakClass = UndefinedObject$class;
		Kernel$class$runtimeClass.newspeakClass = Kernel$class;
		
		Object$runtimeClass.newspeakClass = Object;
		Class$runtimeClass.newspeakClass = Class;
		Metaclass$runtimeClass.newspeakClass = Metaclass;
		Mixin$runtimeClass.newspeakClass = Mixin;
		UndefinedObject$runtimeClass.newspeakClass = UndefinedObject;
		Kernel$runtimeClass.newspeakClass = Kernel;
		
		var kernel = Kernel.usingVmMirror$(this);
		
		//superclass$slot
		Object.superclass$slot = this.ImplementationBase(); //or null?
		Class.superclass$slot = Object;
		Metaclass.superclass$slot = Object;
		Mixin.superclass$slot = Object;
		UndefinedObject.superclass$slot = Object;
		Kernel.superclass$slot = Object;
		
		Object$class.superclass$slot = Class;
		Class$class.superclass$slot = Class;
		Metaclass$class.superclass$slot = Class;
		Mixin$class.superclass$slot = Class;
		UndefinedObject$class.superclass$slot = Class;
		Kernel$class.superclass$slot = Class;
		
		//mixin$slot
		
		//enclosingObject$slot
		Object.enclosingObject$slot = kernel;
		Class.enclosingObject$slot = kernel;
		Metaclass.enclosingObject$slot = kernel;
		Mixin.enclosingObject$slot = kernel;
		UndefinedObject.enclosingObject$slot = kernel;
		Kernel.enclosingObject$slot = nil;
		
		Object$class.enclosingObject$slot = kernel;
		Class$class.enclosingObject$slot = kernel;
		Metaclass$class.enclosingObject$slot = kernel;
		Mixin$class.enclosingObject$slot = kernel;
		UndefinedObject$class.enclosingObject$slot = kernel;
		Kernel$class.$enclosingObject$slot = nil;
		
		enclosingObjects[0] = kernel;
		enclosingObjects[1] = nil;
		enclosingObjects2[0] = nil;
		
		//name$slot
		
		//runtimeClass$slot
		Object.runtimeClass$slot = Object$runtimeClass;
		Class.runtimeClass$slot = Class$runtimeClass;
		Metaclass.runtimeClass$slot = Metaclass$runtimeClass;
		Mixin.runtimeClass$slot = Mixin$runtimeClass;
		Kernel.runtimeClass$slot = Kernel$runtimeClass;
		
		Object$class.runtimeClass$slot = Metaclass$runtimeClass;
		Class$class.runtimeClass$slot = Metaclass$runtimeClass;
		Metaclass$class.runtimeClass$slot = Metaclass$runtimeClass;
		Mixin$class.runtimeClass$slot = Metaclass$runtimeClass;
		Kernel$class.runtimeClass$slot = Metaclass$runtimeClass;
		
		//thisClass$slot
		Object$class.thisClass$slot = Object;
		Class$class.thisClass$slot = Class;
		Metaclass$class.thisClass$slot = Metaclass;
		Mixin$class.thisClass$slot = Mixin;
		Kernel$class.thisClass$slot = Kernel;
		
		kernel.KernelForV8$Object$slot = Object;
		kernel.KernelForV8$Class$slot = Class;
		kernel.KernelForV8$Metaclass$slot = Metaclass;
		kernel.KernelForV8$Mixin$slot = Mixin;
		
		return kernel;
	};
	this.kernel = this.createKernel();
	
	this.applyTopLevelMixin = function(runtimeMixin){
		return this.applyMixin$toSuperclass$withEnclosingObjects$(runtimeMixin, this.kernel.$Object(), [nil]);
	};
	
	this.applyMixin$toSuperclass$withEnclosingObjects$ = function(runtimeMixin, newspeakSuperclass, enclosingObjects){
		
		var Class = this.kernel.Class();
		var Metaclass = this.kernel.Metaclass();
		
		var runtimeSuperclass = newspeakSuperclass.runtimeClass$slot;
		var runtimeClass = runtimeMixin.invoke(runtimeSuperclass, enclosingObjects);
		var runtimeMetaclass = runtimeMixin.meta.invoke(Class.runtimeClass$slot, enclosingObjects);
		runtimeClass.meta = runtimeMetaclass;
		runtimeMetaclass.nonMeta = runtimeClass;
		
		var newspeakMetaclass = Metaclass.$new();
		var newspeakClass = new runtimeMetaclass.basicNew();
		
		runtimeClass.newspeakClass = newspeakClass;
		runtimeMetaclass.newspeakClass = newspeakClass;
		
		newspeakMetaclass.superclass$slot = Class;
		newspeakMetaclass.mixin$slot = "implement reified mixins";
		newspeakMetaclass.enclosingObject$slot = enclosingObjects[0];
		newspeakMetaclass.name$slot = null;
		newspeakMetaclass.thisClass$slot = newspeakClass;
		newspeakMetaclass.runtimeClass$slot = runtimeMetaclass;
		
		newspeakClass.superclass$slot = newspeakSuperclass;
		newspeakClass.runtimeMixin$slot = runtimeMixin;
		newspeakClass.enclosingObject$slot = enclosingObjects[0];
		newspeakClass.name$slot = "implement class names";
		newspeakClass.runtimeClass$slot = runtimeClass;
		
		return newspeakClass;
	};
};
'
)) : ()
class MethodIR named: n = (|
	name = n.
	function
	src
	isSynthetic ::= false.
|)
('as yet unclassified'
printOn: stm = (
	stm nextPutAll: 'MethodIR:'.
	stm nextPutAll: name.
)) : ()
class MixinIR for: d isMeta: m = (|
	declaration = d.
	isMeta = m.
	slots = OrderedCollection new.
	methods = OrderedCollection new.
	nestedClasses = OrderedCollection new.
|)
('as yet unclassified'
name = (
	^declaration name
)) : ()
class NameMangler = (|
	private specialCharacterManglings = Dictionary new.
	private reservedWordManglings = Dictionary new.
|specialCharacterManglings
		at: $+ put: '$plus';
		at: $- put: '$minus';
		at: $* put: '$times';
		at: $/ put: '$over';
		at: $\ put: '$back';
		at: $< put: '$less';
		at: $> put: '$greater';
		at: $~ put: '$tilde';
		at: $= put: '$equal';
		at: $@ put: '$at';
		at: $% put: '$percent';
		at: $| put: '$pipe';
		at: $& put: '$amp';
		at: $? put: '$question';
		at: $! put: '$bang';
		at: $, put: '$comma'.
		
	reservedWordManglings
		at: 'Object' put: '$Object'.
		
	class reservedWords do: 
		[:word | reservedWordManglings at: word put: '$', word])
('as yet unclassified'
mangleLocal: selector <String> ^ <String> = (
	^'local$',(mangleSelector: selector)
)
mangleSelector: selector <String> ^ <String> = (
	(* Convert a Newspeak selector into a JS identifer. *)

	('+-*/\<>~=@%|&?!,' includes: selector first) ifTrue: [
		^(selector inject: '' into: [:accum :next | 
			accum, (specialCharacterManglings at: next)]) asSymbol].

	(reservedWordManglings includesKey: selector)
		ifTrue: [^reservedWordManglings at: selector].

	^(selector asString copy replaceAll: $: with: $$) replaceAll: $` with: $$; replaceAll: $. with: $_
)
mangleSlot: selector <String> ^ <String> = (
	^(mangleSelector: selector), '$slot'
)) : ('as yet unclassified'
reservedWords ^ <Collection[String]> = (
	(* This tuple is extracted to a class-side method so that NameManager's definition of Array doesn't interfere with the Array used for tuple literals. *)
	^ {'abstract' . 'boolean' . 'break' . 'byte' . 'case' . 'catch' . 'char' . 'class' . 'const' . 'continue' . 'debugger' . 'default' . 'delete' . 'do' . 'double' . 'else' . 'enum' . 'export' . 'extends' . 'final' . 'finally' . 'float' . 'for' . 'function' . 'goto' . 'if' . 'implements' . 'import' . 'in' . 'instanceof' . 'int' . 'interface' . 'long' . 'native' . 'new' . 'package' . 'privated' . 'protected' . 'public' . 'return' . 'short' . 'static' . 'super' . 'switch' . 'synchronized' . 'this' . 'throw' . 'throws' . 'transient' . 'try' . 'typeof' . 'var' . 'void' . 'volatile' . 'while' . 'with'}
))
class PropertyCallAST = MessageAST (
(* Sepcialized node to represent applications of JS properties. In some cases (well, at least one) we need to generate ASTs that call javascript methods directly. These calls need to be translated slightly differently (their names must not be mangled). To distinguish these form normal message sends, we use this node. *))
('as yet unclassified'
apply: tool <ASTTool> = (
	^tool propertyCallNode: self
)) : ()
class SlotIR named: n mutable: m = (|
	name = n.
	isMutable = m.
	isSynthetic ::= false.
|)
('as yet unclassified'
isMutableSlot = (
	(* polymorphic with the AST *)
	^isMutable
)
printOn: stm = (
	stm nextPutAll: 'SlotIR:'.
	stm nextPutAll: name.
)) : ()'as yet unclassified'
Scope = (
	^super Scope
)
SlotEntry = (
	^super SlotEntry
)
assert: block <[Boolean]> = (
      super assert: block message: 'assertion failed'.
	(* block value ifFalse: [error: 'assertion failed'] *)
)
fullyQualifiedNameToSimple: fullName <String> = (
	| parts |
	
	parts:: splitFullyQualifiedName: fullName.
	^parts last asSymbol
)
fullyQualifySimpleName: simpleName <Symbol> with: fullyQualifiedPackage <Symbol> = (
	^(fullyQualifiedPackage asString, syntheticNameSeparator, simpleName) asSymbol
)
mixinNameOfClassNamed: className <String> ^ <Symbol> = (
	| simpleNames <Collection[String]> rawNames <Collection[String]> |
	rawNames:: splitFullyQualifiedName: className. 
	rawNames size =1 ifTrue: [^className].
	simpleNames:: rawNames select: [:n <String>  | 
					n size == 0 or: [ n first isLetter ]].
				(* this was isDigit--either add isDigit to core string, or perhaps use between:and: *) 
	assert: [simpleNames size >= 2].
	^(simpleNames inject: '' into: [:sn1 <String>  :sn2 <String> | sn1, syntheticNameSeparator, sn2]) asSymbol
)
mixinSlotNameFor: nestedName <String> = (
	| mixinName <String> |
	mixinName:: mixinNameOfClassNamed: nestedName.
	^mixinName
)
split: aString at: aCharacter = (
	| parts start |
	parts:: OrderedCollection new.
	start:: 1.
	1 to: aString size do:
		[:index |
		(aString at: index) = aCharacter ifTrue:
			[parts add: (aString copyFrom: start to: index - 1).
			start:: index + 1]].
	parts add: (aString copyFrom: start to: aString size).
	^parts
)
splitFullyQualifiedName: fqn = (

	(* Make sure we pass only the first character, so that the code works in image and on JS *)
	^ split: fqn at: syntheticNameSeparator first
)
syntheticNameSeparator ^<String> = (
	^'`'
)
testWith: sources = (
	^(Infrastructure withAppSources: {} withRuntimeSources: sources outputTo: nil) inspect
)) : ()