Newspeak3
'NSFiles-Unix'
class UnixFiles usingPlatform: p <NsPlatform> = NewspeakObject (
"This code was derived by converting the Strongtalk Unix file classes to Newspeak, which is why the Sun Microsystems copyright and BSD license below applies.

Copyright (c) 1995-2006 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
Copyright 2009 Stephen Rees
Copyright 2010 Ryan Macnak and other contributors.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, 
 this  list of conditions and the following disclaimer.

* Redistribution in binary form must reproduce the above copyright notice, 
this list of conditions and the following disclaimer in the documentation and/o other materials provided with the distribution.

Neither the name of Sun Microsystems or the names of contributors may 
be used to endorse or promote products derived from this software without 
specific prior written permission.

>>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS 
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGE.>>"|

private FileDescriptor = p files FileDescriptor.
private FilePattern = p files FilePattern.
private FilePath = p files FilePath.

private outerStatBuffer = p blackMarket NSFiles StatBuffer.

private Alien = p aliens Alien.

private ExternalUnixFilePattern = ExternalObject mixinApply: UnixFilePattern.
private ExternalStreamableUnixFilePattern = ExternalStreamableObject mixinApply: ExternalUnixFilePattern.
private ExternalUnixFilePath = FilePath mixinApply: ExternalStreamableUnixFilePattern.

|)
(
class ExternalObject = (
"A dummy class for mixin"|
|)
() : ()
class ExternalStreamableObject = ExternalObject (
"A dummy class for mixin"|
|)
() : ()
class UnixFileDescriptor = FileDescriptor (| ioCount <ExternalProxy>
            "Used to hold the count of bytes read/written, & other temporary results, for speed"
         |)
('accessing'
blockSize ^<Int> = (

    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer:: StatBuffer newC.

    [^((Alien lookup: '__fxstat' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: statBuffer version
		with: self handle
		with: statBuffer address
	) asSignedLong  == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]
	] ensure: [ statBuffer free]
)
getBufferSize ^<Int> = (

    ^self blockSize * 8
)
size ^<Int> = (

    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer:: outerStatBuffer newC.
    [^((Alien lookup: '__fxstat' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: statBuffer version
		with: self handle asSignedLong
		with: statBuffer address
	) asSignedLong == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]
		
	] ensure: [statBuffer free]
)'as yet unclassified'
StatBuffer = (
	^outerStatBuffer
)
libcName = (
	^'libc.so.6'
)'control'
flushIfFail: errf <[ExternalError]>
 = (

    | result <ExternalProxy> |
    "%todo: uncomment"
    "result := {<kernel ExternalProxy FlushFileBuffers async>
        handle: self handle }."
    result isNull
        ifTrue: [ errf value: 'I/O Error flushing file information' ].
)
openIfFail: err <[ExternalError]>
 = (
    super openIfFail: err.
  " self ioCount malloc: Platform wordSize. "
)
severExternalConnections
 = (
    | result <ExternalProxy> |
    
    super severExternalConnections.
    self ioCount free.
	((Alien lookup: 'close' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: self handle
	) asSignedLong == -1
        ifTrue: [ self error: 'Error closing file handle' ].
)'i/o'
read: handle buffer: buffer count: count
 = (
	^((Alien lookup: 'read' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: handle
		with: buffer address
		with: count
	) asSignedLong
)
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int> = (

    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count:: 0 ]
        ifFalse: [result:: self read: self handle
                        				buffer: self buffer
                        				count: self bufferSize.
                     result == -1
                     	ifTrue: [|msg|
                     				msg:: self errorText: 'Error filling buffer: '.
                     				errf value: msg]
                     	ifFalse: [count:: result ]].
    self setPosition: self position + count.
    ^count
)
write: nBytes <Int> at: pos <Int> ifFail: errf <[ExternalError]>
 = (
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].

	count:: ((Alien lookup: 'write' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: self handle
		with: self buffer address
		with: nBytes) asSignedLong.
		
    	self setPosition: self position + count
)'initialization'
mode: m <Symbol>
 = (
    super mode: m.
    self initializeIOCount.
)'private'
SEEK_SET
 = (

	^0
)
errno
 = (

	"^{{primitiveGetLastError}}"
)
errorText: message
 = (

	^message , self errno printString
)
initializeIOCount
 = (
   " ioCount:: ExternalProxy new.
    ioCount malloc: 4."
	ioCount:: Alien newC: 4.
)
lseek: handle position: p <Int> whence: whence <Int>
 = (
    "%todo: support large integer positions for extremely large files"

	^((Alien lookup: 'lseek' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: handle
		with: p
		with: whence)
)
postCopy
 = (
    super postCopy.
    self initializeIOCount.
)
setExternalPosition: p <Int>
 = (
    "%todo: support large integer positions for extremely large files"
    | result |
    result:: self lseek: self handle
    					position: p
           				whence: self SEEK_SET.    "FILE_BEGIN"
    result == -1
    	ifTrue: [self error: (self errorText: 'Could not position file descriptor: ')]
)) : ('as yet unclassified'
for: obj <EOBJ> mode: m <Symbol>  ^ <Instance> = (

	"Create a new instance, but don't open yet"

	^self new externalObject: obj; mode: m
))
class UnixFilePath = ExternalUnixFilePath (|
|)
('accessing'
type ^<Str> = (

    "The file type (on most platforms this is the part after the $. at the end)"

    | indices <SeqCltn[Int]> |
    indices:: self name indicesOfSubCollection: '.'.
    indices isEmpty
        ifTrue: [ ^'' ].
    ^self name
            copyFrom: indices last + 1
            to: self name size
)'as yet unclassified'
O_CREAT
 = (

	^8r100
)
O_RDONLY
 = (

	^0
)
O_RDWR
 = (

	^2
)
O_TRUNC
 = (

	^8r1000
)
O_WRONLY
 = (

	^1
)
S_IFDIR
 = (

	^8r40000
)
S_IRGRP
 = (

	^8r400
)
S_IROTH
 = (

	^8r40
)
S_IRUSR
 = (

	^8r4000
)
S_IWGRP
 = (

	^8r200
)
S_IWOTH
 = (

	^8r20
)
S_IWUSR
 = (

	^8r2000
)
S_IXGRP
 = (

	^8r100
)
S_IXOTH
 = (

	^8r10
)
S_IXUSR
 = (

	^8r1000
)
StatBuffer
 = (

    ^outerStatBuffer
)
createValueFor: mode <Symbol>  ^<ExternalData> = (


    mode = #read
        ifTrue: [ ^3        "OPEN_EXISTING" ].
    mode = #write
        ifTrue: [ ^2        "CREATE_ALWAYS" ].
    mode = #readWrite
        ifTrue: [ ^4        "OPEN_ALWAYS" ].
    self shouldNotHappen
)
deleteDirectoryIfFail: blk <[Symbol]>
 = (

    | name <CString> |
    name:: Alien newCString: self name.
    [((Alien lookup: 'rmdir' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: name address
	) asSignedLong == -1 ifTrue: [ blk value: #ErrorDeletingDirectory ]
    ] ensure: [ name free ]
)
deleteFileIfFail: blk <[Symbol]>
 = (

    | name <CString> |
    name:: Alien newCString: self name.
    [((Alien lookup: 'unlink' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: name address
	) asSignedLong == -1 ifTrue: [ blk value: #ErrorDeletingFile ]
    ] ensure: [ name free ]
)
fileAttributesFor: mode <Symbol>  ^<ExternalData> = (

    
    mode = #read
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0800        "FILE_FLAG_SEQUENTIAL_SCAN"
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    (mode = #write)
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0000
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    (mode = #readWrite)
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0000    
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    self shouldNotHappen.
)
fileDescriptorClass ^<FileDescriptor class> = (

"%TODO delegate to Platform"
    ^UnixFileDescriptor
)
getegid = (
	^((Alien lookup: 'getegid' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
	) asUnsignedLong
)
geteuid = (
	^((Alien lookup: 'geteuid' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
	) asUnsignedLong
)
lastModified = (
	#TODO yourself.
	
	error: 'Not yet implemented'
)
modeFor: mode <Symbol> ^<SmallInt> = (


    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^(self O_WRONLY bitOr: self O_CREAT) bitOr: self O_TRUNC ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ].
    self error: 'Unrecognised mode: ' , mode
)
modeProxyFor: mode <Symbol> ^<SmallInt> = (


    mode = #read
        ifTrue: [ ^0 ].
    mode = #write
        ifTrue: [ ^1 ].
    mode = #readWrite
        ifTrue: [ ^2 ]
)
open: dname <ExternalProxy> mode: dmode <SmallInt> ^ <ExternalProxy> = (

  	^(Alien lookup: 'open' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: dname
		with: dmode
		with: "permissions" 8r644 "used to be 777"
)
sharingValueFor: mode <Symbol> ^<ExternalData> = (


    mode = #read
        ifTrue: [ ^1    "FILE_SHARE_WRITE" ].
    "in all other cases"
    ^0 "no sharing"
)
size = (
	#TODO yourself.
	
	error: 'Not yet implemented'
)
stat: testBlock ifFail: failBlock
 = (

    | statBuffer <StatBuffer> 
    	status <ExternalProxy>
    	name <CString> |
	
    statBuffer:: StatBuffer newC.
    name:: Alien newCString: self name.
    [
	((Alien lookup: '__xstat' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: statBuffer version
		with: name address
		with: statBuffer address
	) asSignedLong == -1 
		ifTrue: [ failBlock value ]
		ifFalse: [ ^testBlock value: statBuffer ]
		
	] ensure: [ statBuffer free. name free]
)
statFailed
 = (

	| errno|
	errno:: self lastError.
	self error: 'could not stat file: ', errno printString
)'control'
createDirectoryIfFail: fail <[Symbol]>
 = (

    | name <CString> |
    name:: Alien newCString: self name.
    [((Alien lookup: 'mkdir' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: name address
		with: 8r777
	) asSignedLong == -1 ifTrue: [ fail value: #CannotCreatFile ]
    ] ensure: [ name free ]
)'copying-moving'
copyAs: newPath <FilePath> ifFail: fail <[ExternalError]>
 = (

    | source target	|
	source:: self readStream.
	target:: newPath writeStream.
	[[source atEnd]	 whileFalse: [
		target nextPut: source next]]
			ensure: [source close.
							target close]
)
moveAs: newPath <FilePath> ifFail: fail <[ExternalError]> = (

    | csrc <CString> cdest <CString> |
    csrc:: Alien newCString: self name.
    cdest:: Alien newCString: newPath name.
    [((Alien lookup: 'rename' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: csrc address
		with: cdest address
	) asSignedLong == -1 ifTrue: [ fail value: 'Error moving file.' asSymbol ]
    ] ensure:
        [   csrc free.
            cdest free  ]
)'restricted'
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X> = (


    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname:: "self nameProxy." Alien newCString: self name.

    [ dmode:: self modeFor: mode.
    	proxy:: self open: dname address
    						mode: dmode]
    		ensure: [ dname free ].

    ^proxy asSignedLong == -1
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]
)'restricted-double dispatching'
deletePathIfFail: blk <[Symbol]>
 = (

    self exists
        ifFalse: [  blk value: #NoSuchFileOrDirectory.
                        ^self       ].
    self isDirectory
        ifTrue: [ self deleteDirectoryIfFail: blk ]
        ifFalse: [ self deleteFileIfFail: blk ]
)'testing'
exists ^<Boolean> = (

	| name result |
	name:: Alien newCString: self pattern.
	[result:: (Alien lookup: 'open' inLibrary: libcName)
		primFFICallResult: (Alien new: 4)
		with: name address
		with: 0
		with: 0.
	result asSignedLong > 0 ifTrue: [
		(Alien lookup: 'close' inLibrary: libcName)
			primFFICallResult: nil
			with: result].
	^result asSignedLong > 0
	] ensure: [name free]
)
isDirectory ^<Boolean> = (

    ^self stat: [:stat|
		(stat mode bitAnd: self S_IFDIR) == self S_IFDIR
	] ifFail: [ self statFailed ]
)
isReadOnly ^<Boolean> = (


    ^self isWriteable not
)
isSyntaxValid ^<Boolean> = (


    "Extend inherited version to ensure no wildcard characters"
    ^super isSyntaxValid and: [ self unimplemented ]
)
isWriteable
 = (

    ^self stat: [:stat| 
    		(stat uid == self geteuid
		and: [(stat mode bitAnd: self S_IWUSR) == self S_IWUSR])
    		or: [(stat gid == self getegid
		and: [(stat mode bitAnd: self S_IWGRP) == self S_IWGRP])
    		or: [(stat mode bitAnd: self S_IWOTH) == self S_IWOTH]]]
    	ifFail: [ self statFailed ]
)) : ('as yet unclassified'
currentDirectory: file <FilePath> = (

    	| result <Alien> name <Alien> chdir <Alien> |
    	chdir:: Alien lookup: 'chdir' inLibrary: 'libc.so.6'.
    	result:: Alien new: 4.
    	name:: Alien newCString: file name asString.
    	[chdir
    		primFFICallResult: result
    		with: name pointer.
    	result asSignedLong = 0
		ifFalse: [self error: 'Unable to cd to directory ', file name]
	] ensure: [name free]
		
)'instance creation'
currentDirectory ^<FilePath> = (

	|cd func res| 
	[cd:: Alien newC: 500.
	func:: Alien lookup: #getcwd inLibrary: 'libc.so.6'.
	res:: func primFFICallResult: (Alien new: 4)
		with: cd address
		with: 500.
	^self new pattern: cd strcpy] ensure: [cd free]
))
class UnixFilePattern = FilePattern (|
|)
('accessing'
extensions ^<FilePattern> = (


    ^self , (FilePattern for: '*')
)'as yet unclassified'
glob: glob pathsDo: blk = (
	| pathArray |
	pathArray:: "self glPathv." Alien forPointer: (glob unsignedLongAt: vectorOffset).
	0 to: ("self glPathc" glob signedLongAt: 1)  - 1 do: [:index|
		 |cstring|
		cstring:: Alien forPointer: (pathArray unsignedLongAt: index*4+1).
    		blk value: cstring strcpy
	]
)
libcName = (
	^'libc.so.6'
)
vectorOffset = (
	^5
)'iterating'
elementsDo: blk <[FilePattern]>
 = (

	| s <CharacterReadStream> |

	pattern first = $/ ifTrue: [
		blk value: (FilePattern for: '/')].
	
	s:: self pattern readStream.

	[ s atEnd ]
		whileFalse:
			[   | next <Str> |
				next:: s upTo: $/.
				next isEmpty
					ifFalse: [ blk value: (FilePattern for: next)] ]
)
pathsDo: blk <[FilePath]>
 = (

	self terminalPathsDo: blk
    "| els <SeqCltn[FilePattern]> i <Int> |
    els := self elements.
    i := self firstWildElementOf: els
                ifFail: [ ^self shouldNotHappen ].
    i = els size
        ifTrue: [ self terminalPathsDo: blk ]
        ifFalse: [  | rest <FilePattern> |
                        i + 1 = els size
                            ifTrue: [ rest := els last ]
                            ifFalse: [ rest := FilePattern forAll: (els copyFrom: i + 1 to: els size) ].
                        (FilePattern forAll: (els copyFrom: 1 to: i))
                            pathsDo:
                                [ :fp <FilePath> |
                                    fp isDirectory
                                        ifTrue: [ (fp, rest) pathsDo: blk ]     ]
                     ]"
)'private'
firstWildElementOf: els <SeqCltn[FilePattern]> ifFail: fail <[^X def]> ^<Int | X> = (


    1 to: els size do:
        [ :i <Int> |
            (els at: i) isPath
                ifFalse: [ ^i ]
        ].
    ^fail value
)
lastError = (

	"^{{primitiveGetLastError}}"
)
patternExtending: pat <FilePattern> ^<Str> = (


    ^pat pattern last = $/
        ifTrue: [ pat pattern, self pattern ]
        ifFalse: [ pat pattern,'/', self pattern ]
)
terminalPathsDo: blk <[FilePath]>
 = (

    | glob pathArray strings patternString |
   glob:: "GlobT new allocate." Alien newC: 36.
   patternString:: Alien newCString: self pattern.

	(Alien lookup: 'glob' inLibrary: libcName)
		primFFICallResult: nil
		with: patternString address
		with: "flags" 0
		with: "ignore" 0
		with: glob address.

	[glob: glob pathsDo: [:pathString| blk value: (FilePath for: pathString)]]
		ensure: [
			glob free.
			patternString free.]
)'testing'
isAbsolute ^<Boolean> = (


    ^self pattern first == $/
)) : ('as yet unclassified'
multipleMatchWildcardCharacter ^ <Character> = (
	^$*
)
pathSeparatorCharacter ^ <Character> = (
	^'/'
)
singleMatchWildcardCharacter ^ <Character> = (
	^$?
)'instance creation'
for: pat <Str>  ^<FilePattern> = (

    self assert: [ self validPattern: pat ].
    ^self new pattern: pat
)'restricted'
patternHasWildcards: pat <Str> ^<Boolean> = (


    ^(pat includes: multipleMatchWildcardCharacter)
        or: [ pat includes: singleMatchWildcardCharacter ]
)'testing'
validPattern: pat <Str> ^<Boolean> = (


    "Make sure this is a valid syntactic pattern (should be valid even if no *s)"
    self unimplemented
))) : ()