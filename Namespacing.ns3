Newspeak3
'HopscotchIDE'
class Namespacing usingPlatform: p = ((* Unlike most languages, Newspeak has no global namespace. The IDE, however, as an extra-linguistic tool does provide a namespace. This namespace is stateless and only contains Values, typically top-level classes or other namespaces. It is used by an application definition in its #packageUsing: to collect the pieces of a program or by a test configuration in #packageTestsUsing:. 

Gilad notes on 12/18/13:

We need to decide on the semantics of these things.  Here is a proposal:

Namespaces nest and act like scopes. In a given namespace, one can access the elements defined in it, and those of its parents. A name in a namespace shadows (not overrides! these are not classes) the same name in its parents. 

The IDE maintains a current namespace that all operations are relative to. Creating a top level class adds a new one to the current namespace, but editing a class looks the class up whereever it is in the parent chain, and edits that version. One should warn if a new class shadows an existing one, and allow to clone a class from one namespace to another.

The namespace presenter shows a namespaces local entries and a collapsed entry for its parent. Expanding parents recursively gives you a flat view of the scope. Elements that shadow or are shadowed should be marked. Perhaps a complete view of the scope with shadoowed elements removed is useful too. 
*)|
	private IdentityDictionary = p collections IdentityDictionary.
	
	public Newspeak = FilteredSystemDictionary filtering: p squeak Smalltalk globals.
	
	(* This doesn't belong here. Should generalize deployment/testing/benchmarking per compiler. *)
	public manifestForSqueak = Manifest forNamespace: Newspeak.
|)
(
class AlternateWorkspace = (|
	source ::= ''.
	bindings = IdentityDictionary new.
|)
('as yet unclassified'
doesNotUnderstand: message = (
	| sel |
	sel:: message selector.
	(sel isKeyword and: [sel numArgs = 1]) ifTrue:
		[sel:: (sel copyFrom: 1 to: sel size -1) asSymbol.
		^bindings at: sel put: message arguments first].
	^bindings at: sel ifAbsent:
		[Smalltalk at: sel ifAbsent: [^super doesNotUnderstand: message]]
)
isWorkspace = (
	^true
)) : ()
class FilteredSystemDictionary filtering: d = (|
systemDictionary = d.
|)
('as yet unclassified'
at: key = (
	^self at: key ifAbsent: [Error signal: 'Key not found'] 
)
at: key ifAbsent: onAbsent = (
	| candidate |
	candidate:: systemDictionary at: key ifAbsent: [^onAbsent value].
	(predicate: candidate) ifTrue: [^candidate].
	^onAbsent value
)
public at: key <Symbol> put: value <Value> ^<Value> = (
	assert: [key isSymbol and: [key isUnary]] message: 'Invalid key'.
	^systemDictionary at: key put: value
)
protected doesNotUnderstand: message <Message> = (
	^self
		at: message selector
		ifAbsent: [super doesNotUnderstand: message].
)
includesKey: symbol <Symbol> ^<Boolean> = (
	^systemDictionary includesKey: symbol
)
public isNamespace = (
	^true
)
public keys = (
	^(systemDictionary select: [:key | predicate: key]) keys
)
predicate: candidate = (
	candidate isForm ifTrue: [^true].
	candidate isString ifTrue: [^true].
	([candidate isNamespace] ifError: [false]) ifTrue: [^true].
	([candidate isWorkspace] ifError: [false]) ifTrue: [^true].
	candidate isBehavior ifFalse: [^false].
	candidate language isNewspeakLanguage3 ifFalse: [^false].
	^candidate enclosingObjectSlot isNil
)) : ()
class Manifest forNamespace: ns = (| private _namespace = ns. |)
('as yet unclassified'
protected doesNotUnderstand: message <Message> = (
	^_namespace 
		at: message selector
		ifAbsent: [super doesNotUnderstand: message]
)) : ()
class Namespace backedBy: dict = ((* A mapping between unary selectors and Values. *)|
private _dictionary = dict.
|)
('as yet unclassified'
public at: symbol <Symbol> ^<Value> = (
	^_dictionary at: symbol
)
public at: symbol <Symbol> put: value <Value> ^<Value> = (
	assert: [symbol isSymbol and: [symbol isUnary]] message: 'Invalid key'.
	^_dictionary at: symbol put: value
)
includesKey: symbol <Symbol> ^<Boolean> = (
	^_dictionary includesKey: symbol
)
public isNamespace = (
	^true
)
public keys = (
	^_dictionary keys
)
public keysAndValuesDo: binaryBlock <[:Symbol :Value]> = (
	_dictionary keysAndValuesDo: binaryBlock
)
public removeKey: name <Symbol> ^<Value> = (
	^_dictionary removeKey: name
)) : ('as yet unclassified'
new = (
	^self backedBy: IdentityDictionary new
))) : ()