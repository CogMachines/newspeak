Newspeak3
'HopscotchIDE'
class Namespacing usingPlatform: p = ((* Unlike most languages, Newspeak has no global namespace. The IDE, however, as an extra-linguistic tool does provide a namespace. This namespace is stateless and only contains Values, typically top-level classes or other namespaces. It is used by an application definition in its #packageUsing: to collect the pieces of a program or by a test configuration in #packageTestsUsing:. 

Gilad notes on 12/18/13:

We need to decide on the semantics of these things.  Here is a proposal:

Namespaces nest and act like scopes. In a given namespace, one can access the elements defined in it, and those of its parents. A name in a namespace shadows (not overrides! these are not classes) the same name in its parents. 

The IDE maintains a current namespace that all operations are relative to. Creating a top level class adds a new one to the current namespace, but editing a class looks the class up whereever it is in the parent chain, and edits that version. One should warn if a new class shadows an existing one, and allow to clone a class from one namespace to another.

The namespace presenter shows a namespaces local entries and a collapsed entry for its parent. Expanding parents recursively gives you a flat view of the scope. Elements that shadow or are shadowed should be marked. Perhaps a complete view of the scope with shadoowed elements removed is useful too. 
*)|
	private IdentityDictionary = p collections IdentityDictionary.
	private IdentitySet = p collections IdentitySet.
	
	private PackageInfo = p blackMarket PackageInfo.
	private SystemOrganization = p blackMarket SystemOrganization.
	private Smalltalk = p blackMarket Smalltalk.
	
	public Newspeak = createRoot2.
|)
(
class Namespace backedBy: dict = ((* A mapping between unary selectors and Values. *)|
private _dictionary = dict.
|)
('as yet unclassified'
public at: symbol <Symbol> ^<Value> = (
	^_dictionary at: symbol
)
public at: symbol <Symbol> put: value <Value> ^<Value> = (
	assert: [symbol isSymbol and: [symbol isUnary]] message: 'Invalid key'.
	^_dictionary at: symbol put: value
)
protected doesNotUnderstand: message <Message> = (
	^_dictionary 
		at: message selector
		ifAbsent: [thisContext home sender out. message selector out. 
			^message sendTo: (Smalltalk at: #BlackMarket) new
			(*super doesNotUnderstand: message*)]
)
includesKey: symbol <Symbol> ^<Boolean> = (
	^_dictionary includesKey: symbol
)
public isNamespace = (
	^true
)
public keys = (
	^_dictionary keys
)
public keysAndValuesDo: binaryBlock <[:Symbol :Value]> = (
	_dictionary keysAndValuesDo: binaryBlock
)
public removeKey: name <Symbol> ^<Value> = (
	^_dictionary removeKey: name
)) : ('as yet unclassified'
new = (
	^self backedBy: IdentityDictionary new
))'as yet unclassified'
createRoot = (
	| ns = Namespace new. |
	
	PackageInfo allPackages do: [:package |
		| pkgNS = Namespace new. hasAny ::= false. |
		
		package systemCategories do: [:cat |
		(SystemOrganization listAtCategoryNamed: cat) do: [ :className |
			| klass = Smalltalk at: className. |
			klass language isNewspeakLanguage3
				ifTrue: [pkgNS at: klass simpleName put: klass. hasAny: true].
		]].
		hasAny ifTrue: [ns at: package packageName asSymbol put: pkgNS].
	].

	ns at: #AASomeStringResource put: 'The quick brown fox'.
	^ns
)
createRoot2 = (
	| backing ns |
	backing:: Smalltalk at: #Newspeak ifAbsentPut:
		[ | d = IdentityDictionary new. |
		Smalltalk do: [:ea | 
			(ea isBehavior and: [ea language isNewspeakLanguage3])
				ifTrue: [d at: ea simpleName put: ea]].
		d].
	ns:: Namespace backedBy: backing.
	^ns
)) : ()