Newspeak3
'HopscotchIDE'
class Newspeak3Browsing usingPlatform: p ide: ide = (
(*
Class browsing for NS3 using new mirrors.

It would be nice to additionally support:
	
	editing a class header to a different name makes a copy a la the classic browser
	pull a nested class up as a sibling of its parent
	push a nested class down into one of its siblings
	
	auto-initialization of new slots in existing instances
	(but if it depends on a factory argument, what can we do?)
	
	senders/implementors restricted to the same module?
*)|
	private ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	private Color = p hopscotch Color.
	private Duct = p ducts Duct.
	private EditableLinePresenter =p hopscotch fragments EditableLinePresenter.
	private HopscotchImages = p hopscotch HopscotchImages.
	private MixinBuilder = p mirrors MixinBuilder.
	private OrderedCollection = p collections OrderedCollection.
	private Set = p collections Set.
	private Subject = p hopscotch core Subject.

	private cachedPlatform = p.

	private AssortedMethodsPresenter = ide browsing AssortedMethodsPresenter.
	private AssortedMethodsSubject = ide browsing AssortedMethodsSubject.
	private ClassCommentPresenter = ide browsingMisc ClassCommentPresenter.
	private CodeEditorFragment = ide tools CodeEditorFragment.
	private DefinitionListPresenter = ide tools DefinitionListPresenter.
	private DefinitionTemplate = ide tools DefinitionTemplate.
	private DeletedClassSubject = ide browsingMisc DeletedClassSubject.
	private DeploymentInstructionsPresenter = ide browsingMisc DeploymentInstructionsPresenter.
	private EditableNSClassNamePresenter = ide browsing EditableNSClassNamePresenter.
	private ExpandableMethodPresenter = ide browsing ExpandableMethodPresenter.
	private ProgrammingPresenter = ide tools ProgrammingPresenter.
	private SelectorSubject = ide browsing SelectorSubject.
	private SuperduperMethodSubject = ide browsing MethodSubject.
	private SuperClassSubject = ide browsing ClassSubject.
	private SuperMethodSubject = ide browsing MethodSubject.
	private SuperMethodInheritanceSubject = ide browsingST MethodInheritanceSubject.

	private languageUiDescriptionRegistry = ide languageUiDescriptionRegistry.
	private minitestUI = ide minitestUI.
	private minitest = ide minitest.

	private Smalltalk = p blackMarket Smalltalk.
	private PackageOrganizer = p blackMarket PackageOrganizer.
	private SystemOrganization = p blackMarket SystemOrganization.
	private MessageNotUnderstood = p blackMarket MessageNotUnderstood.
	private Language = p blackMarket Language.
	private Deployment = p blackMarket Deployment.
	private blackMarket = p blackMarket.
	
	NS3Colorizer = Language newspeak3 browserColorizer.
|)
(
class ClassHeaderPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* WIP. A presenter for the class header. The goal is to separate the display of the header into a distinct presnter that acts more like a method presenter on the initializer, so it can be used in contexts like debugging or references.

Toward this end, several other yhings need to happen. 

1) We need a way to reliably identify initializer methods via the mirror API.  Since initializers are composed of multiple methods, we will need a way of identifying the pieces andthere status as well. 

(2)  It is best if the compiler cooperates by inserting suitable metadata (say via the properties of the compield method).

(3) We probably will need to fix bugs that arise when this presenter is not embedded in a class presenter.


*)|
	slotsSubject 
	slotsPresenterX 
	classNamePresenter 
	summaryOrEditor
	initiallyOpen <Boolean> ::= false.
|)
('as yet unclassified'
acceptClassDefinition: editor = (
	(* This class's definition has been changed in the definition editor. *)

	^majorUpdate:
		[[subject acceptClassDefinition: editor textBeingAccepted] 
			on: Error
			do: [:ex | editor showMessage: ex description. false]]
)
classDefinitionEditor = (
	| editor |
^
	column: {
		mediumBlank.
		editor:: CodeEditorFragment new
			text: subject classMirror header source;
			colorizerBlock: [ :text | subject colorizeSource: text];
			acceptResponse: 
				[(acceptClassDefinition: editor)
					ifTrue: [editor defaultAcceptResponse]].
		}
)
classSummaryDefinition = (
^
	column: {
		mediumBlank.
		preambleLine.
		mediumBlank.
		ClassCommentPresenter onSubject: subject.
		mediumBlank.
		row: {
			label: 'Slots' asText allBold.
			largeBlank.
			addButtonWithAction: [slotsPresenter addNewItemTemplate].
			}.
		mediumBlank.
		slotsPresenter:: subject slotsSubject presenter.
		mediumBlank.
		initializerDefinition.
		}
)
definition ^ <Fragment> = (
	^headingDefinition (* classDefinitionEditor *)
)
definitionSummaryAndEditorPanel = (
	^summaryOrEditor:: summary: classSummaryDefinition editor: classDefinitionEditor
)
headingDefinition = (
^
	(row: {
		elastic:
			(expanded: definitionSummaryAndEditorPanel
	collapsed:  methodHeading).
		smallBlank
	}) 
		color: majorHeadingColor
)
initializerDefinition = (
	| editor fragment success |
	
(*	^nothing
*)	
	editor:: CodeEditorFragment new
		text: subject initExprs;
		colorizerBlock: [ :text | NS2BrowserColorizer new
			parseText: text asString
			fromClass: subject classMirror
			usingSelector: #initExprs];
		acceptResponse: [[
			success:: true.
			subject initExprs: editor textBeingAccepted]
				ifError: [:err |
					success:: false.
					editor showMessage: err].
			success ifTrue: [
				editor defaultAcceptResponse.
				fragment refresh]].
	
	^fragment:: column: {
		holder: [ |additionalText|
			additionalText:: subject hasInitExprs ifTrue: [''] ifFalse:[' (empty)'].
			heading: (row: {
				label: 'Initializer ' asText allBold.
				label: additionalText.
				})
			details: editor.]	
		}
)
methodHeading ^ <Fragment> = (
inspectionHolder:: holder: [nothing].
headingAfterLeftHolder:: holder: [nothing].
^row: {
	(link: [showClassName 
			ifTrue: [subject classAndSelectorString] 
			ifFalse: [subject selector]]
		action: [substance userToggle]
		dragSubject: subject
		withImage: HopscotchImages default hsExpandImage) color: actionLinkColor.
	mediumBlank.
	deferred: [overrideIcon].
	blank: 2.
	deferred: 
		[subject isSubclassResponsibility 
			ifTrue: 
				[image: HopscotchImages default tinySubclassResponsibilityImage]
			ifFalse: [nothing]].
	smallBlank.
	deferred: 
		[sendersOfSubjectPresenter].
	showClassLink ifTrue: [largeBlank].
	showClassLink ifTrue:
		[(link: 'class' action: [browseClass: subject implementingClass]) tinyFont].
	headingAfterLeftHolder.
	filler.
	MethodCategoryPresenter onSubject: subject.
	largeBlank.
	inspectionHolder.
	smallBlank.
	itemReferencesMenuButtonWithAction: [goToMessages].
	smallBlank.
	dropDownMenu: [methodActionsMenu].
	}
)
preambleLine = (
	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)

	| preamble equalIndex prefix suffix |
	preamble:: subject model header preamble.
	equalIndex:: preamble indexOf: $=.
	equalIndex = 0
		ifTrue:
			[prefix:: preamble withBlanksTrimmed.
			suffix:: '']
		ifFalse:
			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1)
				withBlanksTrimmed.
			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)
				withBlanksTrimmed].
	^suffix isEmpty 
		ifTrue: 
			[label: prefix]
		ifFalse:
			[row: {
				label: prefix, ' = '.
				link: suffix action: [respondToBrowseSuperclass]
				}]
)
showHeaderEditor = (
	summaryOrEditor expand.
)
slotsPresenter = (
^slotsPresenterX
)
slotsPresenter: aPresenter = (
(* Users of this expect that we answer the presenter rather than the receiver. *)

slotsPresenterX:: aPresenter.
^aPresenter
)
summary: summary editor: editor = (
	^initiallyOpen 
		ifTrue:[
				more: [summary] label: 'show definition'
				less: [editor] label: 'show summary'.
			] 
		ifFalse:[
				less: [summary] label: 'show definition'
				more: [editor] label: 'show summary'.			
			]
)) : ()
class ClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* Presents a Newspeak class, as a full view that includes slots, nested classes, methods, etc. The subject is an NSClassSubject. *)|
	slotsSubject
	slotsPresenterX
	classNamePresenter
	descriptionOrSourceSwitchHolder
	descriptionOrSourceSwitcherHolder
	descriptionOrSourceHolder
	summaryOrEditor
|)
('accessing'
extraInformationMetapresenter = (
	| enclosingClasses |
	enclosingClasses:: subject enclosingClasses.
	^enclosingClasses isEmpty
		ifTrue: [nothing]
		ifFalse:
			[ | labelStream |
			labelStream:: (String new: 50) writeStream.
			enclosingClasses do:
				[:each |
				labelStream
					nextPutAll: ' in ';
					nextPutAll: each name].
			(label: labelStream contents) color: (Color gray: 0.5)]
)
icon = (
^subject classUiDescription classIcon
)
nestingInformationLine = (
	| enclosingClasses |
	enclosingClasses:: subject enclosingClasses.
	^enclosingClasses isEmpty
		ifTrue: [label: 'top level class']
		ifFalse:
			[ | rowElements |
			rowElements:: OrderedCollection new.

			enclosingClasses do:
				[:each |
				rowElements add: (label: ' in ').
				rowElements add: (linkToBrowseEnclosingClass: each)].
			row: rowElements asArray]
)
preambleLine = (
	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)

	| preamble equalIndex prefix suffix |
	preamble:: subject model header preamble.
	equalIndex:: preamble indexOf: $=.
	equalIndex = 0
		ifTrue:
			[prefix:: preamble withBlanksTrimmed.
			suffix:: '']
		ifFalse:
			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1)
				withBlanksTrimmed.
			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)
				withBlanksTrimmed].
	^suffix isEmpty 
		ifTrue: 
			[label: prefix]
		ifFalse:
			[row: {
				label: prefix, ' = '.
				link: suffix action: [respondToBrowseSuperclass]
				}]
)
slotsPresenter = (
^slotsPresenterX
)
slotsPresenter: aPresenter = (
(* Users of this expect that we answer the presenter rather than the receiver. *)

slotsPresenterX:: aPresenter.
^aPresenter
)'actions'
acceptClassDefinition: editor = (
	(* This class's definition has been changed in the definition editor. *)

	^majorUpdate:
		[[subject acceptClassDefinition: editor textBeingAccepted] 
			on: Error
			do: [:ex | editor showMessage: ex description. false]]
)
classActionsMenu = (

	^menuWithLabelsAndActions: {
		(* 'Open in Squeak Browser' -> 
			[StandardToolSet browse: subject implementationClass selector: nil].
		#separator. *)
		'Save to File' -> [respondToSave].
		#separator.
		'Inspect Mixin' -> [inspect: subject implementationClass].
		'Inspect Mirror' -> [inspect: subject classMirror].
		#separator.
		'Move up' -> [respondToMoveUp].
		'Move down' -> [respondToMoveDown].
		#separator.
		(* 'Convert to NS1' -> [respondToConvertToNS1].
		'Convert to NS3' -> [respondToConvertToNS3]. *)
		'Delete' -> [respondToDelete] }, 
		(subject isTestCase 
			ifTrue:[
				{#separator.
				'Run Tests' -> [respondToRunTests]. 
				#separator }
			] ifFalse:[{#separator}]),
		{'Inspect Presenter' -> [respondToInspectPresenter]}
)
respondToConvertToNS1 = (

	subject 
		convertToNS1IfSuccess: [requestChangeToSTPresentation]
		ifFail: [alert: 'The class has nested classes and cannot be converted.']
)
respondToDelete = (
	| deletedName |
	deletedName:: subject deleteClass.
	requestPresentationChange: 
		(DeletedClassSubject onModel: deletedName) presenter.
)
respondToMoveDown = (
(* Refactoring: move class to a nested class of its enclosing class *)
halt. (* Not yet implemented *)
)
respondToSave = (

	subject implementationClass
		ifNotNil: [:iclass | iclass printClass]
		ifNil: [error: 'no class; is this reasonable?']
)'as yet unclassified'
addOutlineItemsTo: parentItem = (
| selfItem |
selfItem:: (OutlineItem onModel: self)
	text: subject className;
	image: icon.
substance addOutlineItemsTo: selfItem.
parentItem addChild: selfItem
)
browseNSClassReferences: className = (

	sendUp navigatorDo:
		[:shell | shell enterSubject: (ClassReferencesSubject onModel: className)]
)
classDescriptionDefinition = (
	^column: {
		preambleLine.
		mediumBlank.
		ClassCommentPresenter onSubject: subject.
		mediumBlank.
		row: {
			label: 'Slots' asText allBold.
			largeBlank.
			addButtonWithAction: [slotsPresenter addNewItemTemplate].
			}.
		mediumBlank.
		slotsPresenter:: subject slotsSubject presenter.
		mediumBlank.
		initializerDefinition.
		}
)
classSourceDefinition = (
	| editor |
	^column: {	
		editor:: CodeEditorFragment new
			text: subject classMirror header source;
			colorizerBlock: [ :text | subject colorizeSource: text];
			acceptResponse: 
					[(acceptClassDefinition: editor)	
						ifTrue: [editor defaultAcceptResponse]].
	}
)
collapsedHeadingDefinition = (
	(* Second level of the class header block, contained inside #headingDefinition. *)
	^column: {
		smallBlank.
		row:
			{image: icon.
			smallBlank.
			link: subject className asText allBold
				action: [browseClassMirror: subject classMirror].
			filler.
			itemReferencesButtonWithAction:
				[browseNSClassReferences: subject className].
			smallBlank.
			dropDownMenu: [classActionsMenu].
			}.
			smallBlank
		}
)
expandedHeadingDefinition = (
	(* Second level of the class header block, contained inside #headingDefinition. Defines the floating header block including the class name, containing classes, category and package, and the description/source switcher. *)
	^(column: {
		smallBlank.
		classNameAndContainmentDefinition.
		blank: 15.
		descriptionOrSourceSwitcherHolder:: holder: (switcherShowingSource: false).
		(row: {}) width: 1; color: (Color gray: 0.8).
		mediumBlank.
		descriptionOrSourceHolder:: holder: classDescriptionDefinition
	})
)
expandedHeadingDefinitionWithFloatingHeader = (
	(* UNUSED, but saving it for the time being as an experiment. *)
	(* Second level of the class header block, contained inside #headingDefinition. Defines the floating header block including the class name, containing classes, category and package, and the description/source switcher. *)
	^floatingHeader:	
		((column: {
			smallBlank.
			classNameAndContainmentDefinition.
			blank: 15.
			descriptionOrSourceSwitcherHolder::
				holder: (switcherShowingSource: false).	
			(row: {}) width: 1; color: (Color h: 240 s: 0.05 v: 0.8).
		}) color: (Color h: 240 s: 0.05 v: 0.9))
	body:
		(column: {
			smallBlank.
			descriptionOrSourceHolder:: holder: classDescriptionDefinition
		})
)
linkToBrowseEnclosingClass: mirror <ClassDeclarationMirror> = (
	^link: mirror simpleName asText allBold
		action: [enterSubject:: ClassSubject onModel: mirror]
)
parentClassSubjectDo: action = (
^action value: subject
)
requestChangeToSTPresentation = (
| newPresenter |
newPresenter:: STClassPresenter onSubject: 
	(subjectForClass: subject implementationClass).
parent
	replaceChild: self
	with: newPresenter
)
requestPresentationChange: newPresenter = (
	parent
		replaceChild: self
		with: newPresenter
)
respondToBrowseSuperclass = (

	browseClass: subject superclass
)
respondToConvertToNS3 = (
	subject convertToNS3IfSuccess: [ :ns3Class <Class> |
		requestPresentationChange: 
			(NSClassPresenter onSubject: (subjectForClass: ns3Class)) ]
		ifFail: [ alert: 'This class cannot be converted to Newspeak3.' ].
)
respondToMoveUp = (
(* Refactoring: move class to enclosing class of its enclosing class *)
notYetImplemented
)
respondToRename = (

	classNamePresenter enterEditState
)
respondToRunApp = (
	|appDef app|
	appDef:: Smalltalk at: subject model simpleName.
	app:: appDef packageUsing: blackMarket.
	
	[app main: cachedPlatform args: {}] forkNamed: app class name.
	
)
respondToRunTests = (
	enterSubject:: minitestUI TestingInProgressSubject
		onConfiguration: (Smalltalk at: subject model simpleName)
		platform: cachedPlatform
		minitest: minitest
)
showHeaderEditor = (
      switchToSource
)
switchToDescription = (
	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: false).
	descriptionOrSourceHolder content: classDescriptionDefinition.
)
switchToSource = (
	descriptionOrSourceSwitcherHolder content: (switcherShowingSource: true).
	descriptionOrSourceHolder content: classSourceDefinition
)
switcherShowingSource: showingSourceNow <Boolean> = (
	^showingSourceNow
		ifTrue:	
			[row: {
				(link: 'Description' action: [switchToDescription]) smallFont.
				mediumBlank.
				(label: 'Source' asText allBold) smallFont.			
			}]
		ifFalse:	
			[row: {
				(label: 'Description' asText allBold) smallFont.
				mediumBlank.
				(link: 'Source' action: [switchToSource]) smallFont.	
			}]
)'definition'
applicationActionsIfNeeded = (

	^subject isAppDefinition
		ifTrue:
			[row: {
				smallBlank.
				(link: '[deploy]' action: [
					openMenu:: menuWithLabelsAndActions: {
						'as NOF' -> [subject makeNof].
						'as IMAGE (warning: closes this image)' -> [subject makeImage].
						'as Dart' -> [subject makeDart].
						'as JavaScript' -> [subject makeJavaScript].
						(* 'as EXE' -> [subject makeExe]. *)}					
				]) tinyFont.
				smallBlank.
				(link: '[run]' action: [respondToRunApp]) tinyFont.
			}]
		ifFalse: [nothing]
)
classCategoryLink = (

	^(subject classCategoryName
		ifNil: [label: '(uncategorized)']
		ifNotNil:
			[:cat | 
			link: cat action: [browseClassCategory: cat]])
				tinyFont
)
classDefinitionEditor = (
	| 
	editor  
	headerPresenter <InitializerMethodPresenter> = 
	   (InitializerMethodSubject onModel: subject model header primaryFactory)
	       createPresenter.
	|

^	column: {
		smallBlank.
		classNameAndContainmentDefinition.
		mediumBlank.
		(* headerPresenter toggle.
*)
		editor:: CodeEditorFragment new
			text: subject classMirror header source;
			colorizerBlock: [ :text | subject colorizeSource: text];
			acceptResponse: 
				[(acceptClassDefinition: editor)
					ifTrue: [editor defaultAcceptResponse]].
		}
)
classIconAndNameHeading = (
^
	column: {
		smallBlank.
		row:
			{image: icon.
			smallBlank.
			link: subject className asText allBold 
				action: [browseClassMirror: subject classMirror].
			largeBlank.
			itemReferencesButtonWithAction:
				[browseNSClassReferences: subject className].
			}.
		smallBlank
		}
)
classNameAndContainmentDefinition = (
	^row: {
		draggableImage: icon forSubject: subject.
		smallBlank.
		elastic:: column: {
			row: {
				[classNamePresenter:: EditableNSClassNamePresenter onSubject: subject.
					classNamePresenter] value.
				smallBlank.
				linkImage: HopscotchImages default editImage action: [respondToRename].
				smallBlank.
				nestingInformationLine.
				filler.
				(* right hand side begins *)
				testActionsIfNeeded.
				applicationActionsIfNeeded.
				smallBlank.
				itemReferencesButtonWithAction:
					[browseNSClassReferences: subject className].
				smallBlank.
				dropDownMenu: [classActionsMenu].
				}.
			row: {
				(label: 'Category: ') tinyFont.
				classCategoryLink.
				mediumBlank.
				(label: ' Package: ') tinyFont.
				classPackageLink.
				}
			}
		}.
)
classPackageLink = (

	^(subject classPackageName
		ifNil: [label: '(no package)']
		ifNotNil:
			[:packageName | 
			link: packageName action: [browsePackage: packageName]])
				tinyFont
)
classSummaryDefinition = (
^
	column: {
		smallBlank.
		classNameAndContainmentDefinition.
		mediumBlank.
		preambleLine.
		mediumBlank.
		ClassCommentPresenter onSubject: subject.
		mediumBlank.
		row: {
			label: 'Slots' asText allBold.
			largeBlank.
			addButtonWithAction: [slotsPresenter addNewItemTemplate].
			}.
		mediumBlank.
		slotsPresenter:: subject slotsSubject presenter.
		mediumBlank.
		initializerDefinition.
		}
)
definition = (
	| classesPresenter |
^
	column: {
		headingDefinition.
		sectionLabelled: 'Classes' presenting: subject nestedClassesSubject allowSwitch: false.
		sectionLabelled: 'Methods' presenting: subject methodsSubject allowSwitch: true.
		sectionLabelled: 'Class Methods' presenting: subject classMethodsSubject allowSwitch: true.
	}
)
definitionSummaryAndEditorPanel = (
	summaryOrEditor::
		less: [classSummaryDefinition] label: 'show definition'
		more: [classDefinitionEditor] label: 'show summary'.
	^summaryOrEditor
)
headingDefinition = (
	(* Top level of the class header block, the one that provides the expand/collapse button in the top left corner. *)
	^(row: {
		elastic:	
			(expanded: expandedHeadingDefinition
			collapsed: collapsedHeadingDefinition).
		smallBlank
	}) color: (Color h: 240 s: 0.05 v: 0.9)
)
initializerDefinition = (
	| editor fragment success |
	
	^nothing
(*	
	editor:: CodeEditorFragment new
		text: subject initExprs;
		colorizerBlock: [ :text | NS2BrowserColorizer new
			parseText: text asString
			fromClass: subject classMirror
			usingSelector: #initExprs];
		acceptResponse: [[
			success:: true.
			subject initExprs: editor textBeingAccepted]
				ifError: [:err |
					success:: false.
					editor showMessage: err].
			success ifTrue: [
				editor defaultAcceptResponse.
				fragment refresh]].
	
	^fragment:: column: {
		holder: [ |additionalText|
			additionalText:: subject hasInitExprs ifTrue: [''] ifFalse:[' (empty)'].
			heading: (row: {
				label: 'Initializer ' asText allBold.
				label: additionalText.
				})
			details: editor.]	
		} *)
)
testActionsIfNeeded = (
	^subject isMinitestTestConfiguration 
		ifTrue:
			[(link: '[run tests]' action: [respondToRunTests]) tinyFont]
		ifFalse:
			[nothing]
)'private'
sectionLabelled: title <String> presenting: groupSubject <MirrorGroupSubject> = (

	| groupPresenter |
^
	column: {
		minorClassHeadingBlock: (
			row: {
				label: title.
				largeBlank.
				addButtonWithAction: [groupPresenter addNewItemTemplate].
				filler.
				expandButtonWithAction: [groupPresenter expandAll].
				blank: 3.
				collapseButtonWithAction: [groupPresenter collapseAll].
				blank: 3.
				reorderButtonWithAction: [groupPresenter switchSortOrder].
				}
			).
		groupPresenter:: groupSubject presenter.
		}
)
sectionLabelled: title <String> presenting: groupSubject <MirrorGroupSubject> allowSwitch: allowSwitch = (

	| groupPresenter |
^
	column: {
		minorClassHeadingBlock: (
			row: {
				label: title.
				largeBlank.
				addButtonWithAction: [groupPresenter addNewItemTemplate].
				filler.
				expandButtonWithAction: [groupPresenter expandAll].
				blank: 3.
				collapseButtonWithAction: [groupPresenter collapseAll].
				blank: 3.
				allowSwitch 
					ifTrue: [reorderButtonWithAction: [groupPresenter switchSortOrder]]
					ifFalse: [nothing]
				}
			).
		groupPresenter:: groupSubject presenter.
		}
)) : ()
class ClassReferencesPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* The subject is an NSClassReferencesSubject. Displays the list of methods provided by the subject, which are those that seem to reference an NS class. *)|  |)
('as yet unclassified'
definition = (

	| references |
	^column: {
		minorHeadingBlock: (
			row: {
				label: subject className asText allBold.
				label: ' references'.
				filler.
				expandButtonWithAction: [references expandAll].
				blank: 3.
				collapseButtonWithAction: [references collapseAll]
				}
			).
		blank: 10.
		row: {
			blank: 10.
			elastic:
				(references::
				(AssortedMethodsSubject onModel: subject referencesSubjects) presenter).
			}.
		blank: 10
		}
)) : ()
class ClassReferencesSubject onModel: m = Subject onModel: m (
(* The model is the class name. Provides access to methods that are likely to reference the class because they are sending that name as a message. *)| nameSelectorSubject |nameSelectorSubject:: SelectorSubject onModel: className)
('as yet unclassified'
= anotherSubject = (
	^(anotherSubject class = self class)
		and: [anotherSubject model = model]
)
className = (

	^model
)
createPresenter = (

	^ClassReferencesPresenter onSubject: self
)
hash = (
	^model hash
)
referencesSubjects = (

	^nameSelectorSubject senderSubjects
)
title = (
	^className, ' References'
)) : ()
class ClassSubject onModel: m = SuperClassSubject onModel: m (
(* Represents the ''normal'' perspective of looking at an NS class, so that its details such as slots, nested classes, and methods are visible. The model is the mirror on the class. By default presented by NSClassPresenter. *)| commentPresenter nestedClassesPresenter methodsPresenter guessedSuperclass guessedSubclasses |)
('accessing'
classCategoryName ^<Symbol | nil> = (

	^Smalltalk organization categoryOfElement: className
)
classCommentText ^<String> = (
	^model header classComment ifNil: ['']
)
classCommentText: newComment = (

	notYetImplemented.
)
classMethodsSubject = (

	^MethodGroupSubject onModel: classMirror classSide methods
)
classMirror = (
	(* A synonym of #model, for readability. *)

	^model
)
className = (

	^classMirror simpleName
)
classPackageName ^<String | nil> = (
	(* Answer the name of the package the class belongs to. *)

	^[(PackageOrganizer default packageOfClass: implementationClass ifNone: [^nil])
		packageName]
			on: MessageNotUnderstood
			do: [:ex | ex return: nil]
					
)
enclosingClass ^ <NS2ClassStencilMirror> = (
	^classMirror enclosingClass
)
enclosingClasses ^<List[NSClassMirror]> = (
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
	| classes currentClass |
	classes:: OrderedCollection new.
	currentClass:: classMirror enclosingClass.
	[currentClass notNil] whileTrue:
		[classes add: currentClass.
		currentClass:: currentClass enclosingClass].
	^classes
)
enclosingModule ^ <NS2ClassStencilMirror> = (
	| m <NS2ClassStencilMirror> em <NS2ClassStencilMirror> |
	m:: classMirror.
	[m isNil] whileFalse:[em:: m.  m:: m enclosingClassStencil].
	^em
)
implementationClass = (
(* The Smalltalk class behind the scenes. *)
^model reflectee definingClass
)
initExprs = (
	^classMirror initExprs
)
initExprs: newInitExprs = (
	^classMirror initExprs: newInitExprs
)
makeJavaScript = (
	| appDefn jsAppPackager stream |
	
	appDefn:: Smalltalk at: model simpleName.

	jsAppPackager:: (blackMarket NS2JSApplicationPackaging packageUsing: blackMarket)
		main: cachedPlatform args: {}.
	
	stream:: blackMarket FileStream forceNewFileNamed: appDefn name , '.js'.

	[jsAppPackager compileAppDefn: appDefn usingNamespace: Smalltalk to: stream]
		ensure: [stream close].
		
	stream:: blackMarket FileStream forceNewFileNamed: appDefn name , '.html'.
	[stream nextPutAll: '<html><body><script type="text/javascript" src="'.
	stream nextPutAll: appDefn name.
	stream nextPutAll: '.js"> </script></body></html>']
		ensure: [stream close].
)
methodsSubject = (

	^MethodGroupSubject onModel: model instanceSide methods
)
nestedClassesSubject = (

	^NestedClassGroupSubject onModel: model instanceSide nestedClasses
)
slotsSubject = (

	^SlotGroupSubject onModel: classMirror instanceSide slots
)
subclasses = (
(* guessedSubclasses ifNotNil: [ :sc | ^sc].
flag: #BOGUS. 
guessedSubclasses:: model guessSubclassesIfFail: [^NewspeakObject].
^guessedSubclasses *)
	^Object
)
superclassName = (

	^classMirror superclassName
)
title = (
	^className asString
)'actions'
acceptClassDefinition: aString = (

	| builder |
	builder:: ClassDeclarationBuilder reflecting: model reflectee.
	builder headerFromSource: aString.
	builder install.
	^true
)
convertToNS1IfSuccess: successBlock <[]> ifFail: failBlock <[]> = (
canBeConvertedToNS1 ifFalse: [^failBlock value].
classMirror convertToNS1.
^successBlock value
)
convertToNS3IfSuccess: successBlock <[:Class]> ifFail: failBlock <[]> = (
	canBeConvertedToNS3 
		ifFalse: [ ^ failBlock value]
		ifTrue: [ | stream ns3Class | 
			stream:: classAsString readStream.
			deleteClass.
			ns3Class:: Language newspeak3 compiler new compileUnit: stream. 
			^ successBlock valueWithPossibleArgument: ns3Class ] 
)
makeDart = (
	| appDefn dartAppPackager stream flatBlackMarket |
	
	appDefn:: Smalltalk at: model simpleName.

	dartAppPackager:: (blackMarket NS2DartApplicationPackaging packageUsing: blackMarket)
		main: cachedPlatform args: {}.

	flatBlackMarket:: dartAppPackager FlatBlackMarket usingSmalltalk: Smalltalk.
	
	stream:: blackMarket FileStream forceNewFileNamed: appDefn name , '.dart'.

	[dartAppPackager compileAppDefn: appDefn usingNamespace: flatBlackMarket to: stream]
		ensure: [stream close]
)
makeExe = (
	|appDef app|
	Deployment canMakeExe ifFalse: [
		^presenter enterPresenter: DeploymentInstructionsPresenter new.
	].
	
	appDef:: Smalltalk at: model simpleName.
	app:: appDef packageUsing: blackMarket.
	Deployment appToExe: app
)
makeImage = (
	|appDef app|
	appDef:: Smalltalk at: model simpleName.
	app:: appDef packageUsing: blackMarket.
	Deployment makeDeploymentImageFor: app.
)
makeNof = (
	|appDef app|
	appDef:: Smalltalk at: model simpleName.
	app:: appDef packageUsing: blackMarket.
	Deployment appToNof: app.
)'as yet unclassified'
classAsString ^ <String> = (
	^ (String streamContents: [:s | implementationClass printClassOn: s])
)
classLanguage = (
	^Language newspeak3
)
colorizeSource: sourceText <String | Text> ^<Text> = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: model reflectee definingClass
		usingSelector: #classHeader
)
deleteClass = (

	model enclosingClass = nil ifTrue: [
		
		Smalltalk removeKey: model simpleName ifAbsent: [].
		SystemOrganization removeMissingClasses.		

	] ifFalse: [
	
		| builder |
		builder:: ClassDeclarationBuilder reflecting: model enclosingClass reflectee.
		builder instanceSide nestedClasses removeMirrorNamed: model simpleName.
		builder install.
	].

	^ model simpleName
)
isMinitestTestConfiguration = (
	^isTopLevel and: [model classSide canUnderstand: #packageTestsUsing:]
)
isTopLevel = (
	^model enclosingClass == nil
)
methodCount = (

	|instanceCount classCount|
	flag: #BOGUS. 
	instanceCount:: model instanceSide methods size.
	classCount:: model classSide methods size.
	^instanceCount + classCount
	(* ^0 *)
)
superclass = (
	| applications |
	applications:: model instanceSide applications.
	applications 
		detect: [:any <ClassMirror> | ^any superclass mixin reflectee definingClass]
		ifNone: [^Object]
)
totalSubclassCount = (

	(* flag: #BOGUS.
	^(classMirror guessSubclassesIfFail: [Array new]) size *)
	^0
)'private'
createPresenter = (

	^ClassPresenter onSubject: self
)'testing'
canBeConvertedToNS1 = (
^classMirror mixin classes isEmpty
)
canBeConvertedToNS3 = (
	implementationClass language isNewspeakLanguage2 ifFalse: [ ^ false ].
	[ Language newspeak3 parser new classDefinition 
		parse: classAsString readStream. ] on: Error do: [ ^ false ].
	^ true
)
hasInitExprs = (
	^((initExprs select: [:each | each isSeparator]) size = initExprs size) not
)
isAppDefinition = (
	^isTopLevel and: [model classSide canUnderstand: #packageUsing:]
)) : ()
class ExpandableClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* Presents the subject (an NSClassSubject) as a line displaying the class name and expandable into a full-blown class view. *)|  |)
('as yet unclassified'
collapse = (

	substance collapse
)
definition = (

	| toggle |
	toggle::
		collapsed: (NestedClassPresenter onSubject: subject)
		expanded: [ClassPresenter onSubject: subject classSubject].
	toggle onUserToggled: [requestVisibility].
	^toggle
)
expand = (

	substance expand
)) : ()
class InitializerMethodPresenter onSubject: s = ExpandableMethodPresenter onSubject: s (
(* A specialized presenter for instance initializers. These do not show an ordinary method body.
 Instead, they show the class header when expanded. *)|
	_classHeaderDefinition <ClassHeaderPresenter> 
|)
('as yet unclassified'
categoryLink ^ <Fragment> = (
  (* don't display a category at all *)
	^(label: '<instance initializer>') tinyFont
)
classHeaderDefinition ^ <ClassHeaderPresenter> = (
	_classHeaderDefinition isNil ifTrue:[(_classHeaderDefinition:: ClassHeaderPresenter onSubject: subject classSubject) initiallyOpen: true].
	^_classHeaderDefinition
)
methodDetails = (
	^classHeaderDefinition
)) : ()
class InitializerMethodSubject onModel: m <MethodMirror> = MethodSubject onModel: m (
(* WIP: Designed to handle synthetic initailzer methods, including the primary class factory, the instance initailzer and its subparts *)|
_classSubject  <ClassSubject | ClassHeaderSubject>
|)
('as yet unclassified'
changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (
   failureBlock value
)
classSubject ^ <ClassSubject> = (
	_classSubject isNil ifTrue:[_classSubject:: (ClassSubject onModel: model definingMixin declaration)].
	^_classSubject
)
createPresenter ^ <Presenter> = (
	^InitializerMethodPresenter onSubject: self
)
deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (
  (* do nothing for now. Should report an error, or better yet,
   not have the option in the menu *)
)
isAnOverride = (
(* True if one of the superclasses has a method with the same selector. *)
 ^false
)
isAnOverrideIn: classSubj <NSClassSubject | nil> = (
	^false
)
isOverriden = (
(* True if one of the subclasses has a method with the same selector. *)
 ^false
)
isPrivate ^ <Boolean> = (
	^false
)
isValid ^ <Boolean> = (
	^true
)
messages ^ <List[Symbol]> = (
	|  accumulator <Set[Symbol]> = Set new. |

	allInitializers do:[: i |
		i  messages do:[:each | accumulator add: each]].
	^accumulator asMutableArrayList
)
methodCategory ^<String> = (
	^'<synthetic method>'
)
source ^ <String> = (
	^classSubject model header 
)
variableBindingKeys ^ <List[Symbol]> = (
	| accumulator <Set[Symbol]> = Set new. |

	allInitializers do:[: i |
		i  literalsDo:[:each |
			(each isVariableBinding and:[each key notNil]) ifTrue:
			[accumulator add: each key]]].
	^accumulator asMutableArrayList
)'private'
allInitializers ^ <Collection[MethodMirror]> = (
	(* get all the methods that represent instance initializer code.
	A principled way of doing this is needed, so that we don't rely on the
	conventions of the compiler here. Perhaps mirrors should support this?
	*)
	 #BOGUS yourself.
	^{model reflectee} (* need to replace this by the synthetic initializers *)
)) : ()
class MethodGroupPresenter onSubject: s = MirrorGroupPresenter onSubject: s (
(* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)| groupedByCategory::=false. |)
('actions'
switchSortOrder = (

	groupedByCategory: groupedByCategory not.
	refresh
)'as yet unclassified'
addMethodIn: cls proposedSource: src = (
subject model enclosingMixin reflectee == cls ifTrue:
	[| template |
	template:: addNewItemTemplate: src.
	turnOnTemplateEditorMode: src in: template]
)
addNewItemTemplate = (
(* Handle a user's request to create a new method by displaying a new method template. *)
||
addNewItemTemplate: subject methodTemplateText
)
addNewItemTemplate: src = (
	(* Handle a user's request to create a new method by displaying a new method template. *)

	| template |
	template:: DefinitionTemplate new
		caption: 'Adding new method:';
		initialText: src;
		colorizerBlock: [ :text | subject colorizeSource: text];
		acceptResponse:
			[createNewMethodFromTemplate: template];
		cancelResponse:
			[prefixes remove: template].
	prefixes add: template.
	^template
)
compileMethod: source <String> inPresenter: requestor <Presenter> ifCompiledAsSame: successResponse <Block> ifCompiledAsNew: successNewResponse <Block> ifFailed: failureResponse <Block> = (

	majorUpdate:
		[subject
			compileSource: source
			ifSuccess: 
				[:newSelector |
				newSelector = requestor subject selector
					ifTrue: [successResponse value]
					ifFalse: [successNewResponse value].
				content refresh.
				(content detectPresenter: [:some | some subject selector = newSelector]) 
					expand]
			ifFailure: failureResponse]
)
createNewMethodFromTemplate: template <DefinitionTemplate> = (

	subject 
		compileSource: template text
		ifSuccess:
			[:newSelector |
			prefixes remove: template.
			(content detectPresenter: [:some | some subject selector = newSelector]) expand]
		ifFailure:[:message | template editor showMessage: message]
)
deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (

	subject deleteMethodWithSubject: presenter subject.
	successResponse value
)
recategorizeMethodIn: presenter <Presenter> under: newCategoryName <String> ifSuccess: successResponse <Block> ifFailed: failureResponse <Block> = (

	| newName |
	newName:: newCategoryName withBlanksTrimmed.
	newName isEmpty ifTrue: [^failureResponse value].
	presenter subject
		changeCategoryTo: newName asSymbol
		ifSuccess:
			[refresh. (* so the methods are reshuffled according to categories *)
			successResponse value]
		ifFailure: failureResponse
)
repondToEnter: template defaultAction: defaultAction = (
| src index indexType range pos end |
range:: template editor editor selectionInterval.
pos:: range isEmpty ifTrue: [range first] ifFalse: [range last].
src:: (template editor editedText ifNil: [template editor text]) asString.
index:: src asString findString: 'argument' startingAt: pos.
indexType:: src indexOf: $< startingAt: pos.
(index ~= 0 and: [indexType ~= 0]) ifTrue:
	[index:: index min: indexType].
index = 0 ifTrue:
	[index:: indexType].
index = 0 ifTrue:
	[template editor enterKeyResponse: nil.
	index:: src indexOf: Character tab startingAt: pos.
	index ~= 0 ifTrue:
		[template editor editor
			selectFrom: index + 1
			to: index].
	^self].
end:: index = indexType
	ifTrue:
		[index:: index + 1.
		(src indexOf: $> startingAt: pos) - 1]
	ifFalse: ['argument' size + index].
template editor editor
	selectFrom: index
	to: end
)
turnOnTemplateEditorMode: src in: template = (
| indexOfFirstArg |
indexOfFirstArg:: src findString: 'argument1'.
indexOfFirstArg > 0 ifTrue:
	[template editor enterKeyResponse:
		[:defaultAction |
		repondToEnter: template defaultAction: defaultAction].
	template editor editor
		selectFrom: indexOfFirstArg
		to: 'argument1' size + indexOfFirstArg - 1]
)'private'
contentPresenters = (

	| subjects |
	subjects:: groupedByCategory
		ifTrue: [subject sortedCategories]
		ifFalse: [subject elements].
	^subjects collect: 
		[:each | createPresenterForSubject: each]
)) : ()
class MethodGroupSubject onModel: m = MirrorGroupSubject onModel: m (
(* Represents the collection of methods of a Newspeak class. Holds onto the mirror group for the methods. *)|  |)
('actions'
methodTemplateText = (
^
'messageSelector = (
	
)'
)'as yet unclassified'
colorizeSource: sourceText <String | Text> ^<Text> = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: model enclosingMixin declaration reflectee definingClass
		usingSelector: #methodDecl
)
compileSource: aString ifSuccess: successBlock ifFailure: failureBlock = (
	
	[ | builder newMirror |
	builder:: MixinBuilder reflecting: model enclosingMixin reflectee.
	newMirror:: builder methods addFromSource: aString.
	builder declaration install.
	successBlock value: newMirror simpleName]
		on: Error
		do: [:ex | failureBlock value: ex description].
)
createPresenter = (
^MethodGroupPresenter onSubject: self
)
deleteMethodWithSubject: methodSubject = (

	| builder |
	builder:: MixinBuilder reflecting: model enclosingMixin reflectee.
	builder methods removeMirrorNamed: methodSubject selector.
	builder declaration install.
)
elementSubjectClass = (

	^MethodSubject
)
methodSubjectsInCategory: categoryName <Symbol> ^<Collection[MethodSubject]> = (

	| matches |
	matches:: (modelMirrorCollection select: [:each | each category = categoryName]).
	^matches collect: [:mirrorMethod | elementSubjectClass onModel: mirrorMethod].
)
modelMirrorCollection = (
	^super modelMirrorCollection asSortedList: [:a :b | a simpleName < b simpleName]
)
sortedCategories = (
(* Answer a collection of method subjects sorted by their category names found in the class, sorted with initialization first and private categories last. *)

| categories init privateCategories unclassified lineup |
categories:: modelMirrorCollection inject: Set new into: [:s :m | s add: m category. s].
init:: categories select: [:each | 'init*' match: each].
categories:: categories reject: [:each | init includes: each].
privateCategories:: categories select: [:each | 'private*' match: each].
categories:: categories reject: [:each | privateCategories includes: each].
(categories includes: #'as yet unclassified')
	ifTrue:
		[unclassified:: {#'as yet unclassified'}.
		categories remove: #'as yet unclassified']
	ifFalse:
		[unclassified:: {}].
lineup:: OrderedCollection new: categories size.
lineup 
	addAll: unclassified;
	addAll: init asSortedList;
	addAll: categories asSortedList;
	addAll: privateCategories asSortedList.
^lineup 
	inject: OrderedCollection new
	into: 
		[:collection :each |
		collection addAll: (methodSubjectsInCategory: each).
		collection]
)) : ()
class MethodInheritanceSubject onModel: m = SuperMethodInheritanceSubject onModel: m (
(*  *)|  |)
('as yet unclassified'
implementingClass = (

	self halt
)
methodTitle = (

	^model enclosingClassStencil name, '>>', selector
)
selector = (

	^model selector
)) : ()
class MethodSubject onModel: m = SuperduperMethodSubject onModel: m (
(*  *)|  |)
('accessing'
messages = (

	^(model reflectee) messages
)
methodCategory = (
	^methodMirror category
)
methodMirror = (

	^model
)
selector = (

	^model name
)
source = (

	^model source
)
variableBindingKeys  ^ <List[Symbol]> = (

	| result  <List[Symbol]> |
	result:: OrderedCollection new.
	(model reflectee) literalsDo:
		[:each |
		(each isVariableBinding and:[each key notNil]) ifTrue:
			[result add: each key]].
	^result
)'as yet unclassified'
=  other <Object> ^<Boolean> = (

	^self class = other class and: [model = other model]
)
allMethodCategories ^<Collection[Symbol]> = (
(* Answer a collection of all category names used in the implementor class, plus some common names. *)

| names |
names:: super allMethodCategories.
names addAll: (model definingMixin methods collect: [:ea | ea category]).
^names

)
asMethodInheritanceSubject = (
^MethodInheritanceSubject onModel: model
)
changeCategoryTo: newName ifSuccess: successBlock ifFailure: failureBlock = (

	| builder |
	builder:: MixinBuilder reflecting: model definingMixin reflectee.
	(builder methods findMirrorNamed: model simpleName) category: newName.
	builder declaration install.
	#BOGUS. (* Do this non atomicly? *)

	successBlock value
)
className = (

	^model definingMixin name 
)
colorizeMethodSource: sourceText = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: model reflectee methodClass
		usingSelector: #methodDecl
)
compileNewSource: source <String> ifSuccess: successBlock ifNewMethod: newBlock1arg ifFailure: failureBlock = (

	| builder newMirror |
	builder:: MixinBuilder reflecting: model definingMixin reflectee.
	newMirror:: builder methods addFromSource: source.
	builder declaration install.
	newMirror simpleName = model simpleName
		ifTrue: [(* same *) successBlock value]
		ifFalse: [(* new *) newBlock1arg value: newMirror simpleName].
)
compiledMethod = (

	^model reflectee
)
deleteMethodIfSuccess: successBlock ifFailure: failureBlock = (
	| builder |
	builder:: MixinBuilder reflecting: model definingMixin reflectee.
	builder methods removeMirrorNamed: selector.
	builder declaration install.
	successBlock value (* always succeed? *)
)
enclosingClasses ^<List[Mixin]> = (
(* Returns all classes the model is nested in, beginning with the immediately enclosing class and up to the top level. *)
	| classes currentClass |
	classes:: OrderedCollection new.
	currentClass:: methodMirror definingMixin declaration.
	[currentClass notNil] whileTrue:
		[classes add: currentClass reflectee.
		currentClass:: currentClass enclosingClass].
	^classes
)
hash ^<SmallInteger> = (

	^self class hash bitXor: model hash
)
implementingClass = (

	^model reflectee methodClass
)
isAnOverride = (

	^superclass canUnderstand: self selector
)
isAnOverrideIn: classSubject <NSClassSubject | nil> = (

^(classSubject ifNil: [^isAnOverride]) superclass canUnderstand: self selector
)
isOverridden = (

	flag: #BOGUS. 
	^false.
)
isOverriddenIn: classSubject <NSClassSubject | nil> = (
(* (classSubject ifNil: [^isOverridden]) subclasses do: [ :ea |
	(ea mixin methods includesMirrorNamed: selector)
		ifTrue: [^true]]. *)
^false
)
isPrivate ^<Boolean> = (
^methodMirror isPrivate
)
isValid = (

	flag: #BOGUS.
	^true
)
superclass = (
	#BOGUS.
	^Object
)) : ()
class MirrorGroupPresenter onSubject: s = DefinitionListPresenter onSubject: s (
(*  *)| elementPresenterClass |)
('actions'
addNewItemTemplate = (
	(* A subclass must redefine this to show a template for the user to fill out to create a new item in the group. *)

	subclassResponsibility
)'initialize-release'
subject: aMirrorGroupSubject = (

	super subject: aMirrorGroupSubject.
	subject changedChannel => [:whatever | content refresh]
)'private'
contentPresenters = (

	^subject elements collect: 
		[:each | createPresenterForSubject: each]
)
createPresenterForSubject: aSubject = (
	(* Let the subject create its default unless elementPresenterClass is set to specify our preference. *)

	^elementPresenterClass
		ifNil: [aSubject presenter]
		ifNotNil: [:pclass | pclass onSubject: aSubject]
)) : ()
class MirrorGroupSubject onModel: m = Subject onModel: m (
(* An abstract superclass of subjects on mirror groups. Registers to receive update events from the mirror group and broadcasts its own update events through its 'changedChannel' when that happens. The presenter will listen to those and update itself when needed. *)| 
mirrorGroupChangesOutlet
changedChannel::= Duct owner: self.
|self model: m)
('as yet unclassified'
elementSubjectClass = (
	(* Answer the class of the subjects we create on individual elements of our subject group. *)

	subclassResponsibility
)
elements ^<Collection[Subject]> = (
	(* Answer a collection of subjects on individual elements of the group which is our subject. *)

	^modelMirrorCollection collect: [:each | elementSubjectClass onModel: each]
)
modelMirrorCollection ^<Collection[Mirror]> = (

	^(model collect: [:x|x]) asOrderedCollection
)'initialize-release'
model: mirrorGroup = (

	super model: mirrorGroup.
	(* We expect the mirror group changes channel to be weak so we are retaining the outlet and expect that the old one, if any, will get garbage-collected. *)
	
	mirrorGroupChangesOutlet::
		model channelForChanges => [:x | changedChannel send: true].
)) : ()
class NestedClassGroupPresenter onSubject: s = MirrorGroupPresenter onSubject: s (
(* Presents nested classes of an NS class and takes care of their creation and deletion. *)|  |)
('as yet unclassified'
acceptNewClassDefinitionFrom: aTemplate = (

	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[prefixes remove: aTemplate]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
addNewItemTemplate = (

	| template |
	template:: DefinitionTemplate new
		caption: 'Adding new class:';
		initialText: subject classDefinitionHeaderPartTemplate;
		colorizerBlock: [ :text | subject colorizeSource: text];
		acceptResponse:
			[acceptNewClassDefinitionFrom: template];
		cancelResponse:
			[prefixes remove: template].
	prefixes add: template
)) : ()
class NestedClassGroupSubject onModel: m = MirrorGroupSubject onModel: m (
(* Represents the collection of classes nested in a Newspeak class. Holds onto the mirror group for the classes.
*)|  |)
('as yet unclassified'
addClassFromDefinition: aString ifSuccess: successBlock ifFailure: failureBlock = (

	| builder newMirror |
	[builder:: MixinBuilder reflecting: model enclosingMixin reflectee.
	builder nestedClasses addFromSource: aString.
	builder declaration install.] on: Error do: [: e  <Error> | ^failureBlock value: e message].
			
	successBlock value
)
colorizeSource: sourceText <Text | String> ^<Text> = (
	^NS3Colorizer new
		parseText: sourceText asString
		fromClass: model enclosingMixin declaration reflectee definingClass
		usingSelector: (* #classDefinitionTemplate *) #classDeclaration
)
createPresenter = (
^NestedClassGroupPresenter onSubject: self
)
modelMirrorCollection = (
	^super modelMirrorCollection asSortedList: [:a :b | a simpleName < b simpleName]
)'private'
classDefinitionHeaderPartTemplate = (
^
'class ClassNameHere = (
(*Describe the class in this comment.*)
|
	slot1
	slot2
|
) ()'
)
elementSubjectClass = (

	^NestedClassSubject
)) : ()
class NestedClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* Presents an NSClassSubject as link that browses the class. *)|  |)
('as yet unclassified'
definition = (
^
	link: subject classMirror simpleName
	action: [	browseClassMirror: subject classMirror]
)) : ()
class NestedClassSubject onModel: m = Subject onModel: m (
(* Represents a class nested inside another class. The default presenter renders this as a link that enters the class definition when clicked. *)|  |)
('accessing'
classMirror = (

	^model
)'as yet unclassified'
classSubject = (

	^ClassSubject onModel: classMirror
)'private'
createPresenter = (

	^ExpandableClassPresenter onSubject: self
)) : ()
class SlotGroupPresenter onSubject: s = MirrorGroupPresenter onSubject: s (
(* Displays the slots of a Newspeak class and handles their definiting, editing and removal. The subject is an NSSlotGroupSubject. *)|  |)
('as yet unclassified'
acceptNewSlotDefinitionFrom: aTemplate = (

	majorUpdate:
		[subject
			acceptSlotDefinition: aTemplate text
			ifSuccess:
				[prefixes remove: aTemplate]
			ifFailure: 
				[:message |
				error: message]]
)
addNewItemTemplate = (

	sendUp showHeaderEditor
)
defineSlot: definition <String> ifSuccess: successResponse <Block> ifFailure: failureResponse <Block> = (

	majorUpdate:
		[subject
			acceptSlotDefinition: definition
			ifSuccess: successResponse
			ifFailure: failureResponse]
)
deleteSlotInPresenter: presenter <NSSlotPresenter> = (

	|  slotSubject residue |
	slotSubject:: presenter subject.
	residue:: DefinitionResidue new
		caption: 'Deleted slot ', slotSubject slotName;
		definitionText: slotSubject definitionText;
		restoreResponse: [error: 'unimplemented'];
		forgetResponse: [suffixes remove: residue].
	subject deleteSlotSubject: slotSubject.
	suffixes add: residue
)) : ()
class SlotGroupSubject onModel: m = MirrorGroupSubject onModel: m (
(*  *)|  |)
('as yet unclassified'
acceptSlotDefinition: definitionString ifSuccess: successBlock0 ifFailure: failureBlock1 = (

	self unimplemented.  (* Does it make sense to edit slots in isolation? *)
)
colorizeSource: sourceText <Text | String> ^<Text> = (
^NS2BrowserColorizer new
	parseText: sourceText asString
	fromClass: model declaringMixin
	usingSelector: #slotDef
)
createPresenter = (
^SlotGroupPresenter onSubject: self
)
deleteSlotSubject: aSlotSubject = (

	model removeMirrorNamed: aSlotSubject slotName
)
elementSubjectClass = (

	^SlotSubject
)) : ()
class SlotPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* The subject is an NSSlotSubject. Presents the slot as a link expandable into a full definition. *)| editor |)
('as yet unclassified'
goToMessages = (

	| messagesAndActions messageItems classItems |
	messagesAndActions:: OrderedCollection new.
	messagesAndActions 
		add: subject slotName -> [browseSelector: subject slotName];
		add: (subject slotName, ':') -> [browseSelector: subject slotName, ':'].
	(* messageItems:: referencesMenuMessageItems.
	classItems:: referencesMenuClassItems.
	messageItems notEmpty ifTrue:
		[messagesAndActions 
			add: #separator;
			addAll: messageItems].
	classItems notEmpty ifTrue:
		[messagesAndActions 
			add: #separator;
			addAll: classItems]. *)
	openMenuWithLabelsAndActions: messagesAndActions
)'definition'
definition = (
	^row: {
		link: subject slotNameAndInitializerString action: [sendUp showHeaderEditor].
		filler.
		itemReferencesMenuButtonWithAction: [goToMessages].
		}
)'private'
definitionText = (

	^subject slotDefinitionString
)
visibilityIcon = (

	subject slotIsPublic ifTrue: [^'( )'].
	subject slotIsProtected ifTrue: [^'(r)'].
	^'(p)'
)) : ()
class SlotSubject onModel: m = Subject onModel: m (
(*  *)| deleteResponse |)
('accessing'
acceptSlotDefinition: definitionString ifSuccess: successBlock0 ifFailure: failureBlock1 = (

	flag:: #BOGUS. (* do something! *)
	failureBlock1 value: 'Sorry, saving is not implemented yet'
)
definitionText = (

	^slotDefinitionString
)
slotDefinitionString = (

	^slotMirror source copy
)
slotInitializer = (

	^slotMirror initializer
)
slotIsPrivate = (

	^slotMirror isPrivate
)
slotIsProtected = (

	^slotMirror isProtected
)
slotIsPublic = (

	^slotMirror isPublic
)
slotMirror = (
(* A synonym of #model, for readability. *)

^model
)
slotName = (

	^slotMirror name
)
slotNameAndInitializerString ^<String> = (
	(* Answer a string that includes the name of the slot and some information from its initializer. The initializer information does not have to be complete; rather it should be formatted so as to look nice as a single line. *)

	| stream initializer |
	stream:: (String new: 30) writeStream.
	stream nextPutAll: slotMirror name.
	(* initializer:: slotMirror initializer.
	initializer notEmpty ifTrue:
		[stream nextPutAll: ' = ', (shorten: initializer toFirstCROrCharacters: 40)]. *)
	^stream contents
)'colorization'
colorizeSource: sourceText <Text | String> ^<Text> = (
^NS2BrowserColorizer new
	parseText: sourceText asString
	fromClass: model enclosingMixin
	usingSelector: #slotDef
)'private'
createPresenter = (

	^SlotPresenter onSubject: self
)
shorten: aString toFirstCROrCharacters: maxCharacters <Integer> ^<String> = (

	| result truncated |
	result:: aString.
	truncated:: false.
	(result includes: Character cr) ifTrue:
		[result:: (result findTokens: {Character cr}) first.
		truncated:: true].
	result size > maxCharacters ifTrue:
		[result:: result copyFrom: 1 to: maxCharacters.
		truncated:: true].
	^truncated
		ifTrue: [result, '...']
		ifFalse: [result]
)) : ()) : ()