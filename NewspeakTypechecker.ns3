Newspeak3
'Newspeak'
class NewspeakTypechecker usingPlatform: p ide: ide ast: astModule namespace: ns = (
(* A visitor that computes the type of a Newspeak program 

Questions to resolve: is there a set of classes representing types, or do we just interpret the AST nodes
for types as needed.  In some cases we need a semantic type - for example BottomType.

Do we need dedicated error classes? Probably not. All type errors would behave the same except for error strings.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
*)|

(* imports *)
OrderedCollection = p collections OrderedCollection.

TypeIdAST = astModule TypeIdAST.
TupleAST = astModule TupleAST.
GenericApplicationType = astModule GenericApplicationType.
UnaryTypeOpAST = astModule UnaryTypeOpAST.

(* module variables *)

trail = Trail new.
globalScope = ns.
validator = TypeValidator new.
|) (
class NotAValidTerm id: n <Symbol> = (
(* Describe the class in this comment. *)|
|) (
) : (
)
class Trail = (
(* The trail is implemented by this class. A single instance, held in the slot #trail, 
exists at any point in time.

The representation used here is simple. The slot 'dict'
is a dictionary mapping type variables to dictionaries. Every type variable T
that is known to be related to some other type has an entry in 'dict'
(T being the key). The value of this entry is a dictionary D
mapping types to Booleans. Each entry E_sigma in D
corresponds to a type Sigma known to be related to to the type variable T.
If T <= Sigma, then E_sigma value is True.  If T <# Sigma, then E_sigma
value is False. Otherwise, T is unrelated to Sigma.
*)| dict  |) (
'Unclassified'
answer: t1 <ObjectType >isInheritedTypeOf: t2 <ObjectType > ^ <Boolean> = (

    ^((self dict at: t1 ifAbsent:[^false]) at: t2 ifAbsent:[^false]) not
)
answer: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Boolean> = (

    ^(self dict at: t1 ifAbsent:[^false]) at: t2 ifAbsent:[^false]
)
answerTypeVar: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Boolean> = (

(* Buggy!  We need to see if t1 is a subtype or inherited type of its bound.
If it is a subtype, the code below works.
If it is not, it only works provided the bound is monotonic (and what does that entail if the bound
is another type variable?

*)
    ^(self typeVarBoundFor: t1) subtypeOf: t2 assuming: self.
)
assume: t1 <ObjectType >isInheritedTypeOf: t2 <ObjectType > ^ <Self> = (

    | t1Dict <IdentityDictionary[ObjectType, Boolean]>  |

t1Dict:: self dict at: t1
                      ifAbsent:[self dict at: t1 put: IdentityDictionary(*[ObjectType, Boolean]*)  new].
(t1Dict includesIndex: t2) ifFalse:[t1Dict at: t2 put: false]
                                         ifTrue:[self error: 'Trail already contains entry for ', t1 name, ' inherited type of ', t2 name].
)
assume: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Self> = (

    | t1Dict <IdentityDictionary[ObjectType, Boolean]>  |

t1Dict:: self dict at: t1
                      ifAbsent:[self dict at: t1 put: IdentityDictionary(*[ObjectType, Boolean]*)  new].
(t1Dict includesIndex: t2) ifFalse:[t1Dict at: t2 put: true]
                                         ifTrue:[self error: 'Trail already contains entry for ', t1 name, ' subtype of ', t2 name].
)
forget: t1 <ObjectType >isInheritedTypeOf: t2 <ObjectType > ^ <Self> = (

    self forget: t1 isSubtypeOf: t2
)
forget: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Self> = (

    | e1 <IdentityDictionary[ObjectType, Boolean]>  |


(e1:: self dict at: t1 ifAbsent:[^self]) removeKey: t2 ifAbsent:[^self].
e1 isEmpty ifTrue:[self dict removeKey: t1].
)
initialize ^ <Self> = (

    dict:: IdentityDictionary(*[ObjectType, IdentityDictionary[ObjectType, Boolean]]*)  new.
)
typeVarBoundFor: tv <TypeVar > ^ <ObjectType> = (

    | tvDict <IdentityDictionary[ObjectType, Boolean]>  |

(* The entry for a type variable should contain exactly one element, which is the known bound for the type variable.
If no entry exists, we can always assume that the type variable is an Object
(or should we treat this as an inconsistency?).
*)
tvDict:: self dict at: tv ifAbsent:[^DeltaTypeId new setId: #Object; scope: DeltaGlobals].
tvDict associationsDo:[:a <Assoc[ObjectType,IdentityDictionary[ObjectType,Boolean]]> | ^a key].
)
) : (
)
class TypeError = Error () (
) : (
)
class TypeValidator = (
(* A visitor that checks that a type is well formed. *)|

|) (
'as yet unclassified'
public binaryTypeOpNode: node ^ <Boolean> = (
    | operator <Symbol>  operatorOk <Boolean>  |

operatorOk:: operator = #|.
operatorOk ifFalse:[reportError: (InvalidTypeOperatorError operator: operator)].
^operatorOk and:[(node leftOperand apply: self) and:[node rightOperand apply: self]].	
)
blockTypeNode: node ^ <Boolean> = (
	
)
public typeIdASTNode: node ^ <Boolean> = (
	    | r <DeltaAST>  |

(r:: node ref) isError ifTrue: [
	 reportError: r.
	^false].
r isType ifFalse: [
	reportError: (NotATypeError id: node name).
	^false].
^true
)
public typeVariable: node  ^ <Boolean> = (
    ^node declaredBound wellFormed	
)
public unaryTypeOpNode: node ^ <Boolean> = (
    | selector <Symbol>  selectorOk <Boolean>  |

selector:: node selector.
selectorOk:: selector = #class or:[selector = #protocol or:[selector = #instance or:[selector = #def and:[self target isTypeVar]]]].
selectorOk ifFalse:[reportError: (InvalidTypeOperatorError operator: selector)].
^selectorOk and: [node target apply:self].	
)
) : (
)
'as yet unclassified'
public blockNode: node ^ <ObjectType> = (
    | tas <VarOrdCltn[ObjectType]>  |

tas:: OrderedCollection(*[ObjectType]*)  new.
(* must add types of parameters *)
node parameters do:[:p <VarDecl>  | 
										p isIntroducedByRewriter
											ifFalse:[p type wellFormed. tas add: p type].
										].
tas addLast: self body type.
^BlockApplicationType new
        apply: (TypeIdAST new setId: #Fun; scope: globalScope) to: tas.
	)
public cascadedSendNode: node  ^ <ObjectType> = (
	node prevSend type.
	^super type
	)
checkArgsAgainstSignature: sig <MsgSignature> = (
	
)
public codeBodyNode: node ^ <ObjectType> = (

    | lastStatementType <ObjectType>  |

    node temporaries do:[:t <VarDecl>  | validate: t type].

	(* Parameters are not typechecked here. For method bodies, the parameters are
	copied from the signature and are checked there. For block bodies, the parameters
	are checked in Block>>type. The copying hack should go away when the code
	scopes are factored out of the ASTs.*)

    lastStatementType:: TypeIdAST setId: #Nil; scope: globalScope.
    node statements do:[:s <Statement>  | lastStatementType:: s type].
    ^lastStatementType.
)
functionTypeOf: node <NormalSendASTNode> ^ <MsgSignature> = (
	
)
public genericInvocationNode: node ^ <ObjectType> = (
    | myType <GenericApplicationType>  |

(* This will have to change to accomodate generic terms that are not classes  - mixins, or (in the near future) reflective representatives of a types. We also need to verify that the target is a term. For the immediate future, this is sufficient to type generic classes only.
*)

myType:: UnaryTypeOpAST new target:(GenericApplicationType new apply: (TypeIdAST new setId: node target name; scope: globalScope) to: node actuals) selector: #class.
myType wellFormed.
^myType
)
public guaranteedNode: node ^ <Type> = (
(* not supported in the grammar or parser yet *)
  ^node expr type.
)
public messagePatternNode: node ^ <MsgSignature> = (
    ^self filteree type substitute: self substitution
    )
public methodNode: node ^ <MsgSignature>  = (
    node pattern apply: self.
    node body apply: self.
    ^node pattern returnType
    )
public normalSendNode: node <NormalSendASTNode> ^ <ObjectType> = (
    | functionType <MsgSignature>  i <Int>   |

functionType::  functionTypeOf: node.
self checkArityAgainstSignature: functionType 
         ifFail:[((* guaranteed <TypeError> *) functionType) domainSize: node args size].
checkArgsAgainstSignature: functionType.
^functionType range.
)
public numberNode: node = (
	^literal: node
)
ref: node ^ <ObjectType> = (
    node decl isValidTerm ifFalse: [(NotAValidTerm id: node name) signal].
    ^node decl type
    )
public returnStatNode: node ^ <ObjectType> = (
    | returnType <ObjectType>   eType <ObjectType>  |

eType:: node expr type.
returnType:: (* guaranteed <ObjectType>*)  (self scope at: #'.returnVal').
^(eType subtypeOf: returnType assuming: trail)
    ifTrue:[BottomType new]
    ifFalse:[self reportError: (ReturnError new actualName: eType name; declaredName: returnType name)]
    )
public setterSendNode: node ^ <Type> = (
    | etype <ObjectType>  |

etype:: self expr type.
^(etype subtypeOf: node var type assuming: trail)
    ifTrue:[etype]
    ifFalse:[self reportError: (AssignmentError new exprName: etype name; varName: self var name)]
)
public stringNode: node = (
	^literal: node
)
public symbolNode: node = (
	^literal: node
)
public tupleNode: node ^ <ObjectType> = (
    |
sqTarget <TypeId> 
sqActuals <VarOrdCltn[ObjectType]> 
sqActual <ObjectType> 
sqType <GenericTypeApplication>
tupleTarget <TypeId> 
tupleActuals <VarOrdCltn[ObjectType]> 
tupleType <TupleType>
|

sqTarget:: TypeIdAST new setId: #SeqCltn; scope: globalScope; begin: 0 end: 0.
sqActuals:: OrderedCollection(*[ObjectType]*)  new.
tupleActuals:: node value collect:[:e <Literal>  | e type].

tupleActuals isEmpty 
   ifTrue:[tupleActuals add: (TypeIdAST new setId: #DoesNotMatter;
                                                                                         scope: globalScope)
                ].

sqActual:: self buildUnion: tupleActuals asSet asOrderedCollection.

sqActuals add: sqActual.
sqType:: GenericApplicationType new apply: sqTarget to: sqActuals.

tupleTarget:: TypeIdAST new setId: #Tuple; scope: globalScope.
tupleType:: TupleAST new apply: tupleTarget to: tupleActuals.


^ProtocolMerge new type1: sqType type2: tupleType.
)
validate: node = (
	node apply: validator
)
public varDeclNode: node = (
      | result = node type. |
      validate: result.
	^result.
)
'visiting'
literal: node ^ <ObjectType> = (
    ^TypeIdAST setId: self typeName; scope: globalScope
    )
) : (
)
