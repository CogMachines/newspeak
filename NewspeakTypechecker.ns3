Newspeak3
'Newspeak'
class NewspeakTypechecker usingPlatform: p ide: ide ast: astModule mirrors: mirrors namespace: ns = (
(* A visitor that computes the type of a Newspeak program 

Questions to resolve: is there a set of classes representing types, or do we just interpret the AST nodes
for types as needed.  In some cases we need a semantic type - for example BottomType.

Also, we need this typechecker to be incremental. The basic ideas go back as far as the Cecil typechecker, but are properly explained in the context of Scala optimization in the OOPSLA 2016 paper: Parallel Incremental Whole-Program Optimizations for Scala.js.

These principles are:

a. Access to program structure beyond the method currently being typechecked must go through a query API. This API will track any dependencies of the method on types of other program components.

b. These queries are pure functions of immutable data and the program. 

c. We maintain dependencies between (previously) typechecked methods and queries.  We also maintain dependencies between queries and the program parts they describe.

d. Query results are cached, and invalidated if the source code they depend on has changed. This means that we will need to either:
 1. Note when a given change is made and invalidate its dependent queries, or 
 2. Compute a diff when a typecheck starts, and use it to decide which changes have been made, and thus invalidate any dependent 
      queries.

e. Memory required grows linearly with program size, as both the number of methods and the queries about them are proportional to code size. 

f. Time is proportional to the size of the code being typechecked (especially if we note changes as they occur).  Initial typechecks may be slower, as they often require global program information like subtype relations, but this should not be an issue. We can also trade memory for time  by constructing cached subtype queries at type definition time if need be.

For the time being, we ignore generics.

The Type hierarchy consists of:

a. Type, the abstract class at the top of the hierarchy.
b. ObjectType, which is defined by an immutable list of symbols that defines a class as a path of class names starting from a top level class.
c. FunctionType, which is defined by a pair of a list of argument types and a return type.
d. ErrorType, the magical type that is a subtype and supertype of everything and supports all methods.
f. UnionType, defined by a list of types that are acceptable at a given point.

The query hierarchy consists of:

a. Query,  the abstract class at the top of the hierarchy.
b. Subtype(T, S) where T and S are types, which answers whether T <: S.
c. Signature(T, m) where T is a type and m is a selector, which yields the FunctionType of method m in type T, or Error if m is undefined.

We maintain two maps of dependencies:

a. dependentDeclarations. A Map[Query, List[Declaration]] which lists, for each query q, all declarations whose typecheck required q.
b. dependentQueries. A Map[Declaration, List[Query]] which lists, for each declaration d, all queries that d used it its last typecheck.

Declarations can be methods but also class headers.

All this is encapsulated in this module, which eventually needs to be fed into the IDE.  Even in an offline scenario where the typechecker is used as a service, the dependencies need to exist.  Other tools need to maintian the dependencies as code changes.

Do we need dedicated error classes? Probably not. All type errors would behave the same except for error strings.

We need to deal with namespace lookup. For now, we assume a flat namespace of top level classes. Later, we will have to deal with nested namespaces.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
 (c) Google Inc. 2016 - 2017.

Use and distribution of this software is subject to the terms of the attached source license.


*)|

(* imports *)
OrderedCollection = p collections OrderedCollection.
Map = p collections Map.
Set = p collections Set.

TypeIdAST = astModule TypeIdAST.
TupleAST = astModule TupleAST.
GenericApplicationType = astModule GenericApplicationType.
UnaryTypeOpAST = astModule UnaryTypeOpAST.

ClassDeclarationMirror = mirrors ClassDeclarationMirror.

(* module variables *)

namespace = ns.
trail = Trail new.
globalScope = ns.
typeBuilder = TypeBuilder new.
currentClass <Class> (* mirror? *)
currentTopLevelClass <Class>
currentDeclaration <Symbol>
currentReturnType <ObjectType>
errorSet <Set>

errorType <ErrorType> = ErrorType new.
bottom <BottomType> = BottomType new.
dependentDeclarations <Map[Query, Set[Declaration]]> = Map new.
dependentQueries <Map[Declaration, Set[Query]]> = Map new.
cachedTypes <Map[Query, Type]> = Map new.
|) (
class BottomType = Type (
(* The bottom of the type lattice. *)) (
'as yet unclassified'
public subtypeOf: t <Type> ^ <Boolean> = (
	^true
)
) : (
)
class ErrorType = Type (
(* The error type. *)) (
'as yet unclassified'
public subtypeOf: t <Type> ^ <Boolean> = (
	^true
)
) : (
)
class FunctionType domain: d <List[Type]> range: r <Type> = Type (
(* The type of a method. *)|
	public domain <List[Type]> = d.
	public range <Type> = r.
|) (
'as yet unclassified'
public isKindOfFunctionType ^ <Boolean> = (
	^true
)
public subtypeOf: t <Type> ^ <Boolean> = (
  | ft <FunctionType> ftd <List[Type]> |
      t = errorType ifTrue:[^true].
      t isKindOfFunctionType ifFalse:[^false] ifTrue:[ft:: t].

	(range subtypeOf: ft range) ifFalse:[^false].
	ftd:: ft domain.
	domain size = ftd size ifFalse:[^false].
	1 to: domain size do:[: i <Integer> |
		((ftd at: i) subtypeOf: (domain at: i)) ifFalse:[^false]
		].
	^true.
)
) : (
)
class NotAValidTerm id: n <Symbol> = (
(* Describe the class in this comment. *)|
|) (
) : (
)
class ObjectType forPath: ts <List[Symbol]> = Type (
(* The type of an Object. *)|
	public path <List[Symbol]> = ts.
|) (
'as yet unclassified'
public at: selector <Symbol> ^ <FunctionType> = (
  | m <MethodMirror> =  findMethod: selector. signature <MessagePatternAST> |
  signature:: ide parser messagePattern parse: m source. (* parse the message pattern *)
  ^signature apply: typeBuilder (* and build a function type *)
)
findMethod: selector <Symbol> ^ <Mirror> = (
	| actualType <ClassDeclarationMirror> superklass <ClassDeclarationMirror> m <MethodMirror> |
	 actualType:: lookup: path first in: enclosingScope.
	 
	 [actualType != nil] whileTrue:[
		m:: actualType instanceSide methods findMirrorNamed: selector.
		m != nil ifTrue:[^m].
		actualType:: actualType superclass.
		].
       ^errorType
)
public isKindOfObjectType ^ <Boolean> = (
	^true
)
public subtypeOf: t <Type> ^ <Boolean> = (
	| ot <ObjectType>  |
      t = errorType ifTrue:[^true].
      t isKindOfObjectType ifFalse:[^false] ifTrue:[ot:: t].

      path = ot path ifTrue:[^true].
     (supertype subtypeOf: t) ifTrue:[^true].
      ^false
)
supertype ^ <ObjectType> = (
  | actualType <ClassDeclarationMirror> superklass <ClassDeclarationMirror> supertypePath <List[Symbol]> ::= {}. |
  (* TODO: This could be a mixin application *)
  actualType:: lookup: path first in: enclosingScope.
  superklass:: actualType superclass.
  supertypePath add: superklass simpleName.
  ^ObjectType forPath:  supertypePath.
)
) : (
)
class PathFinder = (
(* A visitor on type expression ASTs that computes a path that defines the underlying ObjectType the type expression represents. *)) (
'as yet unclassified'
public binaryTypeOpNode: node <BinaryTypeOpAST> ^ <List[Symbol]> = (
	^{} (* return the empty path, which should be interpreted by the caller as an error type*)
)
public typeIdASTNode: node <TypeIdAST> ^ <List[Symbol]> = (
	^lookupPathForType: node name
)
public unaryTypeOpNode: node <UnaryTypeOpAST> ^ <List[Symbol]> = (
	| operator <Symbol> |
	operator:: node operator.
	(operator = #class or:[operator = #protocol or:[operator = #instance or:[operator = #def and:[self target isTypeVar]]]])
		 ifFalse:[error: 'No unary type operator ', operator at: {node operand concreteEnd + 1. node concreteEnd}].
	^(node operand apply: self) add: node operator
)
) : (
)
class Query = (
(* Abstract class. The root of the query hierrachy. *)) (
) : (
)
class SignatureQuery type: t <Type> selector: m <Symbol> = Query (
(* What is the type of method m of class t? *)|
	type <Type> = t.
	selector <Symbol> = s.
|) (
) : (
)
class SubtypeQuery subtype: s <Type> supertype: t <Type> = Query (
(* Is s <: t ?. *)|
	subtype <Type> = s.
	supertype <Type> = t.
|) (
) : (
)
class Trail = (
(* The trail is implemented by this class. A single instance, held in the slot #trail, 
exists at any point in time.

The representation used here is simple. The slot 'dict'
is a dictionary mapping type variables to dictionaries. Every type variable T
that is known to be related to some other type has an entry in 'dict'
(T being the key). The value of this entry is a dictionary D
mapping types to Booleans. Each entry E_sigma in D
corresponds to a type Sigma known to be related to to the type variable T.
If T <= Sigma, then E_sigma value is True.  If T <# Sigma, then E_sigma
value is False. Otherwise, T is unrelated to Sigma.
*)| 
dict = IdentityDictionary(*[ObjectType, IdentityDictionary[ObjectType, Boolean]]*)  new.
|) (
'Unclassified'
answer: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Boolean> = (

    ^(self dict at: t1 ifAbsent:[^false]) at: t2 ifAbsent:[^false]
)
answerTypeVar: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Boolean> = (

(* Buggy!  We need to see if t1 is a subtype or inherited type of its bound.
If it is a subtype, the code below works.
If it is not, it only works provided the bound is monotonic (and what does that entail if the bound
is another type variable?

*)
    ^(self typeVarBoundFor: t1) subtypeOf: t2 assuming: self.
)
assume: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Self> = (

    | t1Dict <IdentityDictionary[ObjectType, Boolean]>  |

t1Dict:: self dict at: t1
                      ifAbsent:[self dict at: t1 put: IdentityDictionary(*[ObjectType, Boolean]*)  new].
(t1Dict includesIndex: t2) ifFalse:[t1Dict at: t2 put: true]
                                         ifTrue:[self error: 'Trail already contains entry for ', t1 name, ' subtype of ', t2 name].
)
forget: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Self> = (

    | e1 <IdentityDictionary[ObjectType, Boolean]>  |


(e1:: self dict at: t1 ifAbsent:[^self]) removeKey: t2 ifAbsent:[^self].
e1 isEmpty ifTrue:[self dict removeKey: t1].
)
typeVarBoundFor: tv <TypeVar > ^ <ObjectType> = (

    | tvDict <IdentityDictionary[ObjectType, Boolean]>  |

(* The entry for a type variable should contain exactly one element, which is the known bound for the type variable.
If no entry exists, we can always assume that the type variable is an Object
(or should we treat this as an inconsistency?).
*)
tvDict:: self dict at: tv ifAbsent:[^DeltaTypeId new setId: #Object; scope: DeltaGlobals].
tvDict associationsDo:[:a <Assoc[ObjectType,IdentityDictionary[ObjectType,Boolean]]> | ^a key].
)
) : (
)
class Type = (
(* Abstract class, root of the type hierarchy. *)) (
'as yet unclassified'
public subtypeOf: t <Type> ^ <Boolean> = (
	subclassResponsibility
)
) : (
)
class TypeBuilder = (
(* A visitor that creates a Type from an AST representing a type. *)) (
'as yet unclassified'
public binaryTypeOpNode: node <BinaryTypeOpAST> ^ <Type> = (
	| l = node leftOperand apply: self. r = node rightOperand apply: self. |
	operand:: node operand.
	operand = '|' ifTrue:[^UnionType unifying: {l. r}].
	^errorType
)
public messagePatternNode: node <MessagePatternAST> = (
     ^ FunctionType 
		domain:  (node parameters collect:[:p <VarDeclNode> | p type apply: self])
		range: (node returnType apply: self)
)
public typeIdASTNode: node <TypeIdAST> ^ <Type> = (
	^ObjectType forPath: (lookupPathForType: node name)
)
public unaryTypeOpNode: node <UnaryTypeOpAST> ^ <List[Symbol]> = (
	^ObjectType forPath: (node apply: PathFinder new)
)
) : (
)
class TypeError message: s <String> start: p1 end: p2 = Error (|
public message = s.
public start = p1.
public end = p2.
|) (
) : (
)
class UnionType unifying: ts <List[Type]> = Type (
(* The union of th etypes in ts *)|
	elements <List[Type]> = ts.
|) (
) : (
)
'as yet unclassified'
public blockNode: node ^ <ObjectType> = (    | tas <VarOrdCltn[ObjectType]>  |
  tas:: OrderedCollection(*[ObjectType]*)  new.(* must add types of parameters *)
  node parameters do:[:p <VarDecl>  |  tas add:(p apply: self)].
  tas addLast: (node body apply: self). 
  ^BlockApplicationType new apply: (TypeIdAST new setId: #Fun; scope: globalScope) to: tas.	
)
public cascadedSendNode: node  ^ <ObjectType> = (
	node previousSend apply: self.
	^normalSendNode: node
	)
public charNode: node <CharAST> ^ <ObjectType>= (
	^literal: #Character
)
public codeBodyNode: node ^ <ObjectType> = (

    | lastStatementType <ObjectType>  |

    node temporaries do:[:t <VarDecl>  | t apply: self].

	(* Parameters are not typechecked here. For method bodies, the parameters are
	copied from the signature and are checked there. For block bodies, the parameters
	are checked in blockNode. The copying hack should go away when the code
	scopes are factored out of the ASTs.*)

    lastStatementType:: (TypeIdAST setId: #Nil) apply: typeBuilder.
    node statements do:[:s <Statement>  | lastStatementType:: s apply: self].
    ^lastStatementType.
)
currentConflictNamespace = (
	^namespace at: (currentTopLevelClass simpleName, ' conflicts') asSymbol ifAbsent:[nil]
)
error: msg <String> at: location <Pair[Integer]> = (
	errorSet add: (TypeError message: msg start: location first end: location last).
)
functionTypeOf: node <SendASTNode> ^ <MsgSignature> = (
	(* A query *)
	| query <Query> receiverType <Type> cachedType <Type> selector <Symbol> |
	selector:: node message selector.
	receiverType:: node receiver apply: self.
	query:: SignatureQuery type: receiverType selector: selector.
	cachedType:: cachedTypes at: query.
	cachedType = nil ifTrue:[
			cachedType:: receiverType at: selector.
			cachedTypes at: query put: cachedType.
			dependentDeclarations at: query put: Set new.
			].
	(dependentDeclarations at: query) add: currentDeclaration.
	(dependentQueries at: currentDeclaration ifAbsent:[dependentQueries at: currentDeclaration put: Set new]) add: query.
	^cachedType.
)
public genericInvocationNode: node ^ <ObjectType> = (
    | myType <GenericApplicationType>  |

(* This will have to change to accomodate generic terms that are not classes  - mixins, or (in the near future) reflective representatives of a types. We also need to verify that the target is a term. For the immediate future, this is sufficient to type generic classes only.
*)

myType:: UnaryTypeOpAST new target:(GenericApplicationType new apply: (TypeIdAST new setId: node target name; scope: globalScope) to: node actuals) selector: #class.
myType wellFormed.
^myType
)
public guaranteedNode: node ^ <Type> = (
(* not supported in the grammar or parser yet *)
  ^node expr type.
)
lookupPathForType: typeName <Symbol> ^ <List[Symbol]> = (
      | path <List[Symbol]> |

	path:: lookupPathForType: typeName inClass: currentClass.
	path isEmpty
	  ifFalse:[^path]
	  ifTrue:[
		path:: lookupPathForType: typeName inNamespace: currentClass enclosingClass.
	  ].
	
)
lookupPathForType: typeName <Symbol> inClass: klass ^ <List[Symbol]> = (
	lookupPathForType: typeName inClass: currentClass enclosingClass.
)
lookupPathForType: typeName <Symbol> inNamespace: n ^ <List[Symbol]> = (
      | entry |
	entry:: currentConflictNamespace at: typeName. (* what if there isn't a conflict namsespace? *)
	^entry = nil ifTrue:[
		nil =  (namespace at: typeName) ifTrue:[{}] ifFalse:[{typeName}] (* validate that this is a type? *)
		] ifFalse:[
		{currentTopLevelClass name. typeName}
		]
)
public messageNode: node  <MessageAST> ^ <List[ObjectType]>= (
	^node arguments collect:[:e <ExpressionAST> | e apply: self]
)
public messagePatternNode: node ^ <MsgSignature> = (
      ^node apply: typeBuilder
    )
public methodNode: node <MethodAST> ^ <MsgSignature>  = (
   | signature <FunctionType> = node pattern apply: self. |
    currentReturnType:: signature range
    node body apply: self.
    ^currentReturnType
    )
public normalSendNode: node <NormalSendASTNode> ^ <ObjectType> = (
    | functionType <FunctionType> domain <List[ObjectType]>  args <List[ObjectType]>  |

functionType::  functionTypeOf: node.
domain:: functionType domain.
args:: node message apply: self.
domain size != args size ifTrue:[
	error: 'Arity mismatch' at: {node concreteStart. node concreteEnd}
	].
1 to: domain size do:[:i <Integer> | 
	((args at: i) subtypeOf: domain at: i) ifFalse:[
		error: 'Argument is not a subtype of corresponding formal'
		at: {(args at: i) concreteStart. (args at: i) concreteEnd}
		]
	].
^functionType range.
)
public numberNode: node = (
	^literal: #Number
)
public returnStatNode: node ^ <ObjectType> = (
    | returnType <ObjectType>   eType <ObjectType>  |

eType:: node expr apply: self.
^(eType subtypeOf: currentReturnType assuming: trail)
    ifTrue:[BottomType new]
    ifFalse:[error: 'Type of returned expression is not a subtype of declared return type' at: {node concreteStart. node concreteEnd}]
    )
public setterSendNode: node ^ <Type> = (
    | etype <ObjectType>  |

    etype:: node expr apply: self.
    (etype subtypeOf: (node var type apply: self) assuming: trail)
       ifFalse:[error: etype name, ' is not a subtype of ', node var type name at: {node concreteStart. node concreteEnd}].
    ^etype
)
public stringNode: node = (
	^literal: #String
)
public symbolNode: node = (
	^literal: #Symbol
)
public tupleNode: node ^ <ObjectType> = (
    |
sqTarget <TypeId> 
sqActuals <VarOrdCltn[ObjectType]> 
sqActual <ObjectType> 
sqType <GenericTypeApplication>
tupleTarget <TypeId> 
tupleActuals <VarOrdCltn[ObjectType]> 
tupleType <TupleType>
|

sqTarget:: TypeIdAST new setId: #SeqCltn;  start: 0; end: 0.
sqActuals:: OrderedCollection(*[ObjectType]*)  new.
tupleActuals:: node value collect:[:e <Literal>  | e apply: self].

tupleActuals isEmpty 
   ifTrue:[tupleActuals add: (TypeIdAST new setId: #DoesNotMatter)].

sqActual:: UnionType unifying: tupleActuals asSet asOrderedCollection.

sqActuals add: sqActual.
sqType:: GenericApplicationType new apply: sqTarget to: sqActuals.

tupleTarget:: TypeIdAST new setId: #Tuple.
tupleType:: TupleAST new apply: tupleTarget to: tupleActuals.


^ProtocolMerge new type1: sqType type2: tupleType.
)
public typecheckMethod: m <MethodAST> ofClass: c  ^ <Set[TypeError]>= (
     | toplevelCandidate = c. |
	currentClass:: c.
	currentDeclaration:: m selector.
      [toplevelCandidate enclosingClass != nil] whileTrue:[toplevelCandidate:: toplevelCandidate enclosingClass].
      currentTopLevelClass:: toplevelCandidate.
      errorSet:: Set new.
	methodNode: m.
	^errorSet
)
public varDeclNode: node = (
      ^node type apply: typeBuilder. 
)
public variableNode: aNode <VariableAST> ^ <ObjectType> = (
	(* need to deal with #'@here', #self, #super, #outer, temps and formals *)
	| varName <Symbol> = node name. | 
	varName = #'@here' ifTrue:[^processHere: varName].
	varName = #self ifTrue:[^typeOfSelf].
	varName = #super ifTrue:[^typeOfSuper].
	varName = #outer ifTrue:[^typeOfOuter].
	^typeOfLocal: varName
)
'visiting'
literal: typeName <Symbol> ^ <ObjectType> = (
    ^(TypeIdAST setId: typeName) apply: typeBuilder
    )
) : (
)
