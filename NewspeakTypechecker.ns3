Newspeak3
'Newspeak'
class NewspeakTypechecker usingPlatform: p ide: ide ast: astModule namespace: ns = (
(* A visitor that computes the type of a Newspeak program.

Newspeak has no global namespace, but a nominal typechecker needs one. The typechecker takes a namespace as a parameter to its factory.  All types are identified by a fully qualified name that is rooted in a top level class that is stored in this namespace. If a class named C uses a type that conflicts with the top level namespace, then a special conflict namespace #'C conflicts' is added to the top level and is consulted before looking up things at the top level. The typechecker does not look into other nested namespaces.

Fully qualified names are used to define object types (see below). The checker has utilities to convert between classes and object types.

The Type hierarchy consists of:

a. Type, the abstract class at the top of the hierarchy.
b. ObjectType, which is defined by an immutable list of symbols that defines a class as a path of class names starting from a top level class (a fully qualified name).
c. FunctionType, which is defined by a pair of a list of argument types and a return type.
d. ErrorType, the magical type that is a subtype and supertype of everything and supports all methods. There is a special subclass
    of ErrorType, AccessErrorType, for errors involving accessibility violations. We cache singleton instances for both.
e. UnionType, defined by a list of types that are acceptable at a given point.
f. GenericType, defined by an object type representing the generic, and a list of type arguments. For the time being, we largely ignore generics.
g. TypeVariable, defined by a path that starts with its name, and a bound, which is a type.

In addition, there are pseudo types used to represent the types of the lexical scope (the here of here sends) and of outer.

The typechecker is designed to be incremental. The basic ideas go back as far as the Cecil typechecker, but are properly explained in the context of Scala optimization in the OOPSLA 2016 paper: Parallel Incremental Whole-Program Optimizations for Scala.js.

These principles are:

a. Access to program structure beyond the method currently being typechecked must go through a query API. This API will track any dependencies of the method on types of other program components.

b. These queries are pure functions of immutable data and the program. 

c. We maintain dependencies between (previously) typechecked methods and queries.  We also maintain dependencies between queries and the program parts they describe.

d. Query results are cached, and invalidated if the source code they depend on has changed. This means that we will need to either:
 1. Note when a given change is made and invalidate its dependent queries, or 
 2. Compute a diff when a typecheck starts, and use it to decide which changes have been made, and thus invalidate any dependent 
      queries.
  Each kind of query has its results cached separately. Signature query results are stored in cachedTypes. Subtype query results are 
  cached in trail (The term trail originates in algorithms dealing with recursive types, as far back as Algol 68).

e. Memory required grows linearly with program size, as both the number of methods and the queries about them are proportional to code size. 

f. Time is proportional to the size of the code being typechecked (especially if we note changes as they occur).  Initial typechecks may be slower, as they often require global program information like subtype relations, but this should not be an issue. We can also trade memory for time  by constructing cached subtype queries at type definition time if need be.

The query hierarchy consists of:

a. Query,  the abstract class at the top of the hierarchy.
b. Subtype(T, S) where T and S are types, which answers whether T <: S.
c. Signature(T, m) where T is a type and m is a selector, which yields the FunctionType of method m in type T, or Error if m is undefined.

We maintain three maps of dependencies:

a. dependentDeclarations. A Map[Query, Set[Declaration]] which lists, for each query q, all declarations whose typecheck required q.
b. dependentQueries. A Map[Declaration, Set[Query]] which lists, for each declaration d, all queries that refer to d.
c. queriesOfDeclaration. A Map[Declaration, Set[Query]] which lists, for each declaration d, all queries that d used it its last typecheck.

Declarations can be methods but also class headers.

All this is encapsulated in this module, which eventually needs to be fed into the IDE.  Even in an offline scenario where the typechecker is used as a service, the dependencies need to exist.  Other tools need to maintain the dependencies as code changes.

Errors are reported by calling the error:at: method, which produces a TypeError object and adds it to a set that is returned by the typecheck. If the set is empty, typechecking succeeded. The client can then determine how to report the errors, which carry a message and source location information.


 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
 (c) Google Inc. 2016 - 2017.

Use and distribution of this software is subject to the terms of the attached source license.


*)|
(* imports *)
private OrderedCollection = p collections OrderedCollection.
private Map = p collections Dictionary.
private Set = p collections Set.

private TypeIdAST = astModule TypeIdAST.
private TupleAST = astModule TupleAST.
private ParameterizedTypeAST = astModule ParameterizedTypeAST.
private UnaryTypeOpAST = astModule UnaryTypeOpAST.
private BinaryTypeOpAST = astModule BinaryTypeOpAST.
private MessagePatternAST = astModule MessagePatternAST.

private ClassDeclarationMirror = p mirrors ClassDeclarationMirror.
private MixinMirror = p mirrors MixinMirror.

private Scope = p mirrors compiler Scope.

(* module variables *)

parser <NewspeakParsing Parser> = p mirrors compilation parser.
namespace <Map[Symbol, Object]> = ns.
trail <Map[SubtypeQuery, Boolean]> = Map new.
scopeStack <OrderedCollection[Scope]> = OrderedCollection new.
typeBuilder <TypeBuilder>
currentClass <ClassDeclarationMirror> 
currentTopLevelClass <ClassDeclarationMirror>
currentDeclaration <Symbol>
currentReturnType <ObjectType>
errorSet <Set>

errorType <ErrorType> = ErrorType new.
accessErrorType <AccessErrorType> = AccessErrorType new.
bottom <BottomType> = BottomType new.
dependentDeclarations <Map[Query, Set[Declaration]]> = Map new.
queriesOfDeclaration <Map[Declaration, Set[Query]]> = Map new.
dependentQueries <Map[Declaration, Set[Query]]> = Map new.
cachedTypes <Map[Query, Type]> = Map new.
|) (
class AccessErrorType = ErrorType (
(* A special type for access errors. These need to be reported whenever they come up, so they need to be preserved in caches. 
   This, they are distinct from normal type errors.
*)) (
'as yet unclassified'
isKindOfAccessErrorType ^ <Boolean> = (
	^true
)
) : (
)
class BottomType = Type (
(* The bottom of the type lattice. *)) (
'as yet unclassified'
public subtypeOf: t <Type> ^ <Boolean> = (
	^true
)
) : (
)
class ErrorType = Type (
(* The error type. *)) (
'as yet unclassified'
public at: o = (
(* One can ask an error type for the type of any selector, or for the type of the nth argument for any n *)
	^self
)
public domain = (
	^self
)
public isKindOfErrorType ^ <Boolean> = (
	^true
)
public range = (
	^self
)
public subtypeOf: t <Type> ^ <Boolean> = (
	^true
)
) : (
)
class FunctionType domain: d <List[Type]> range: r <Type> = Type (
(* The type of a method. *)|
	public domain <List[Type]> = d.
	public range <Type> = r.
|) (
'as yet unclassified'
public = o   = (
	o isKindOfFunctionType ifFalse:[^false].
	^domain = o domain and:[range = o range]
)
public hash ^ <Integer> = (
	^(domain hash xor: range hash) bitXor: class hash
)
public isKindOfFunctionType ^ <Boolean> = (
	^true
)
public subtypeOf: t <Type> ^ <Boolean> = (
  | ft <FunctionType> ftd <List[Type]> |
      t = errorType ifTrue:[^true].
      t isKindOfFunctionType ifFalse:[^false] ifTrue:[ft:: t].

	(range subtypeOf: ft range) ifFalse:[^false].
	ftd:: ft domain.
	domain size = ftd size ifFalse:[^false].
	1 to: domain size do:[: i <Integer> |
		((ftd at: i) subtypeOf: (domain at: i)) ifFalse:[^false]
		].
	^true.
)
) : (
)
class GenericType generic: g <ObjectType> typeArguments: tas <List[ObjectType]> = ObjectType forPath: g path (
(* A generic (aka parameterized) type such as List[String]. *)|
      generic <ObjectType> = g.
	typeArguments <List[ObjectType]> = tas.
|) (
'as yet unclassified'
public = o   = (
	o isKindOfGenericType ifFalse:[^false].
	^path = o path and:[typeArguments = o typeArguments]
)
public at: selector <Symbol> ^ <FunctionType>  = (
	halt.
)
public hash ^ <Integer> = (
	^(path hash bitXor: class hash) bitXor: typeArguments hash
)
public isKindOfGenericType ^ <Boolean> = (
	^true
)
public isKindOfObjectType ^ <Boolean> = (
	^false
)
public printOn: s = (
	s nextPutAll: class name.
	s nextPutAll: ' generic: '.
	s nextPutAll:  path printString.
	s nextPutAll: ' typeArguments: ['.
	typeArguments do:[: ta <ObjectType> |
		s nextPutAll: ta printString.
		s nextPut: ' '.
		].
	s nextPut: ']'.
)
public subtypeOf: t <Type> ^ <Boolean>  = (
	halt.
)
) : (
)
class HereType for: m <MixinMirror> = PseudoType for: m path: (herePathFor: m) (
(* The type of the lexical scope. *)) (
'as yet unclassified'
public = o   = (
	o isKindOfHereType ifFalse:[^false].
	^mixin = o mixin
)
findMethod: selector <Symbol> ^ <Mirror> = (
	| actualType <MixinMirror>  m <MethodMirror> localType <ObjectType> |
	
	selector = #nil
		ifTrue:[^mirrorForObjectType: (literal: #Nil)]. 
	({#true. #false} includes: selector) 
		ifTrue:[^mirrorForObjectType: (literal: #Boolean)]. (* reserved words *)
	
	localType:: typeOfLocal: selector.
	nil ~= localType 
		ifTrue:[^mirrorForObjectType: localType]. (* formal or temp *)
		
	actualType:: mixin.
	 
	 [nil ~= actualType] whileTrue:[
		m:: actualType methods findMirrorNamed: selector.
		nil ~= m ifTrue:[^m].
		actualType:: actualType enclosingMixin.
		].
       ^nil	
)
public hash ^ <Integer> = (
	^mixin hash bitXor: class hash
)
public isKindOfHereType ^ <Boolean> = (
	^true
)
public isKindOfObjectType ^ <Boolean> = ( 
(* Bogus. If we give it the right path and fix sub/supertype methods as suggested in comments,
    we can get rid of this as well as = and hash*)
	^false
)
selfIdAST  ^ <AST>  = (
	(* should be a type variable; definitely not the here type *)
)
public subtypeOf: t <Type> ^ <Boolean> = (
(* could use equality *)
	assert:[false] message: 'No one should ask a here type if it is a subtype of anything!'
)
supertype ^ <ObjectType> = ( (* Could return Object *)
	assert:[false] message: 'Here types have no supertype, and no one should ask!'
)
) : (
)
class NotAValidTerm id: n <Symbol> = (
(* Describe the class in this comment. *)|
|) (
) : (
)
class ObjectType forPath: ts <List[Symbol]> = Type (
(* The type of an Object. *)|
	public path <List[Symbol]> = ts.
|) (
'as yet unclassified'
public = o ^ <Boolean> = (
	o isKindOfObjectType ifFalse:[^false].
	^path = o path
)
public at: selector <Symbol> ^ <FunctionType> = (
  | m <MethodMirror> =  findMethod: selector. signature <MessagePatternAST> |
  
  nil = m ifTrue:[^errorType].
  m accessModifier ~= #public ifTrue:[^accessErrorType].
  signature:: parser messagePattern parse: m source. (* parse the message pattern *)
  (* deal with substitution of Self, Instance? *)
  ^(signature apply: selfSubstitution) apply: myTypeBuilder (* and build a function type *)
)
findMethod: selector <Symbol> ^ <Mirror> = (
	| actualType <ClassDeclarationMirror> superklass <ClassDeclarationMirror> m <MethodMirror> |
	 actualType:: mirrorForObjectType: self.
	 
	 [actualType ~= nil] whileTrue:[
		m:: actualType instanceSide methods findMirrorNamed: selector. (* should deal with slots and classes too *)
		m != nil ifTrue:[^m].
		actualType:: actualType superclass.
		].
       ^errorType
)
public hash ^ <Integer> = (
	^path hash bitXor: class hash
)
public isKindOfObjectType ^ <Boolean> = (
	^true
)
myTypeBuilder ^ <TypeBuilder> = (
(* really need to cache this somewhere *)
	^TypeBuilder forTypesIn: (mirrorForObjectType: self)
)
public name ^ <String> = (
	^(path inject: '' into:[:s <String> :e <Symbol> | s, e, ' ']) allButLast.
)
public printOn: s = (
	s nextPutAll: class name.
	s nextPutAll: ' forPath: '.
	s nextPutAll:  path printString
)
selfIdAST  ^ <AST> = (
| tree <AST> |
	assert:[path isEmpty not] message: 'Object type must have non-empty path'.
	tree:: TypeIdAST new name: path first.
	(2 to: path size) do:[: i | 
		tree:: UnaryTypeOpAST new 
				operand: tree; 
				operator: (path at: i);
				yourself.
		].
	^tree
)
selfSubstitution ^ <Substitutor> = ( (* we should cache these out the object type *)
	 ^Substitutor forSubstitution: (Map new at: #Self put: selfIdAST)
)
public subtypeOf: t <Type> ^ <Boolean> = (
	| ot <ObjectType>  |
      t = errorType ifTrue:[^true].
      t isKindOfObjectType ifFalse:[^false] ifTrue:[ot:: t].

      path = ot path ifTrue:[^true].
     (supertype subtypeOf: t) ifTrue:[^true].
      ^false
)
supertype ^ <ObjectType> = (
  | 
  actualType <ClassDeclarationMirror> 
  superklass <ClassDeclarationMirror> 
  supertypePath <List[Symbol]> ::= {}. 
  |

  (* TODO: This could be a mixin application - but they have to be named *)
  actualType::  mirrorForObjectType: self.
  superklass:: actualType superclass.
  supertypePath:: pathForMixin:  superklass instanceSide.
  ^ObjectType forPath:  supertypePath.
)
) : (
)
class OuterType for: m <MixinMirror> = PseudoType for: m path: {#@Outer} (
(* The type of outer inside mixin m. *)) (
'as yet unclassified'
public = o   = (
	o isKindOfOuterType ifFalse:[^false].
	^mixin = o mixin
)
public isKindOfOuterType ^ <Boolean> = (
	^true
)
public subtypeOf: t <Type> ^ <Boolean> = (
  ^ self = t
)
supertype ^ <ObjectType> = ( 
	^ObjectType forPath: {#Object}
)
) : (
)
class PathFinder forTypesIn: klass <ClassDeclarationMirror> = (
(* A visitor on type expression ASTs that computes a path that defines the underlying ObjectType the type expression represents. *)| surroundingClass <ClassDeclarationMirror> = klass. |) (
'as yet unclassified'
public binaryTypeOpNode: node <BinaryTypeOpAST> ^ <List[Symbol]> = (
	^{} (* return the empty path, which should be interpreted by the caller as an error type*)
)
public typeIdNode: node <TypeIdAST> ^ <List[Symbol]> = (
	^lookupPathForType: node name inClass: surroundingClass
)
public unaryTypeOpNode: node <UnaryTypeOpAST> ^ <List[Symbol]> = (
	| operator <Symbol> | (* what about qualified types? *)
	operator:: node operator.
	(operator = #class or:[operator = #instance or:[operator = #def and:[self target isTypeVar]]])
		 ifFalse:[error: 'No unary type operator ', operator at: {node operand concreteEnd + 1. node concreteEnd}].
	^(node operand apply: self) add: node operator
)
) : (
)
class PseudoType for: m <MixinMirror> path: p <List[Symbol]> = ObjectType forPath: p (
(* A type for pseudo variables like here and outer. *)|
	public mixin <MixinMirror> = m.
|) (
'as yet unclassified'
public = o   = ( (* BOGUS *)
   mixin = o mixin
)
public hash ^ <Integer> = (
	^mixin hash bitXor: class hash
)
) : (
)
class Query = (
(* Abstract class. The root of the query hierrachy. *)) (
'as yet unclassified'
public invalidate = (
	subclassResponsibility
)
) : (
)
class SignatureQuery type: t <Type> selector: m <Symbol> = Query (
(* What is the type of method m of class t? *)|
	public type <Type> = t.
	public selector <Symbol> = m.
|) (
'as yet unclassified'
public = o   = (
	o isKindOfSignatureQuery ifFalse:[^false].
	^type = o type and:[selector = o selector]
)
public declarations ^ <List[ObjectType]> = (
	^declarationsForSignatureQuery: self
)
public hash ^ <Integer> = (
	^(type hash bitXor: selector hash) bitXor: class hash
)
public invalidate = (
	cachedTypes removeKey: self
)
public isKindOfSignatureQuery ^ <Boolean> = (
	^true
)
) : (
)
class Substitutor forSubstitution: s <Map[Symbol, AST]> = (
(* A visitor that applies a substitution to an AST. *)|
	substitution <Map[Symbol, AST]> = s.
|) (
'as yet unclassified'
public binaryTypeOpNode: node <BinaryTypeOpAST> ^ <BinaryTypeOpAST> = (
	^BinaryTypeOpAST new 
		operator: node operator; 
		leftOperand: (node leftOperand apply: self); 
		rightOperand: (node rightOperand apply: self);
		yourself
)
public genericInvocationNode: node <ParameterizedTypeAST> ^ <ParameterizedTypeAST> =(
	^ParameterizedTypeAST new
		generic: node generic;
		arguments: (node arguments collect:[:ta <AST> | ta apply: self]);
		yourself
)
public messagePatternNode: node <MessagePatternAST> = (
	^MessagePatternAST new
		selector: node selector;
		accessModifier: node accessModifier;
		parameters: (node parameters collect:[: p <AST> | p appy: self]);
		returnType: (node returnType apply: self);
		concreteStart: node concreteStart;
		concreteEnd: node concreteEnd;
		yourself	
)
public typeIdNode: node <TypeIdAST> ^ <AST> = (
	^substitution at: node name ifAbsent:[^node]
)
public unaryTypeOpNode: node <UnaryTypeOpAST> ^ <UnaryTypeOpAST> = (
	^UnaryTypeOpAST new 
		operator: node operator; 
		operand: (node operand apply: self); 
		yourself
)
) : (
)
class SubtypeQuery subtype: s <Type> supertype: t <Type> = Query (
(* Is s <: t ?. *)|
	public subtype <Type> = s.
	public supertype <Type> = t.
|) (
'as yet unclassified'
public = o  = (
	o isKindOfSubtypeQuery ifFalse:[^false].
	^subtype = o subtype and:[supertype = o supertype]
)
public declarations ^ <List[ObjectType]> = (
	^declarationsForSubtypeQuery: self
)
public hash ^ <Integer> = (
	^(subtype hash bitXor: supertype hash) bitXor: class hash
)
public invalidate = (
	trail removeKey: self
)
public isKindOfSubtypeQuery ^ <Boolean> = (
	^true
)
) : (
)
class Type = (
(* Abstract class, root of the type hierarchy. *)) (
'as yet unclassified'
public subtypeOf: t <Type> ^ <Boolean> = (
	subclassResponsibility
)
) : (
)
class TypeBuilder forTypesIn: klass <ClassDeclarationMirror> = (
(* A visitor that creates a Type from an AST representing a type. *)| surroundingClass <ClassDeclarationMirror> = klass. |assert:[klass isMirror] message: '') (
'as yet unclassified'
public binaryTypeOpNode: node <BinaryTypeOpAST> ^ <Type> = (
	| l = node leftOperand apply: self. r = node rightOperand apply: self. operand |
	operand:: node operand.
	operand = '|' ifTrue:[^UnionType unifying: {l. r}].
	^errorType
)
public genericInvocationNode: node <GenericType> = (
	| generic <ObjectType> tas <List[ObjectType]>  |
	
	generic:: node generic apply: self.
	tas:: node arguments collect:[:a <AST> | a apply: self].
	^GenericType generic: generic typeArguments: tas
)
public messagePatternNode: node <MessagePatternAST> ^ <FunctionType> = (
     ^ FunctionType 
		domain:  (node parameters collect:[:p <VarDeclNode> | p type apply: self])
		range: ((returnTypeFor: node) apply: self)
)
public typeIdNode: node <TypeIdAST> ^ <Type> = (
	^ObjectType forPath: (lookupPathForType: node name inClass: surroundingClass)
)
public unaryTypeOpNode: node <UnaryTypeOpAST> ^ <ObjectType> = (
	^ObjectType forPath: (node apply: (PathFinder forTypesIn: surroundingClass))
)
) : (
)
class TypeError message: s <String> start: p1 end: p2 = Error (|
public message = s.
public start = p1.
public end = p2.
|) (
) : (
)
class TypeVariable named: n <Symbol> bound: b <ObjectType> forType: t <ObjectType> = ObjectType forPath: t path, {n} (
(* Type variables, such as Self, Instance or generics. *)|
	bound <ObjectType> = b.
|) (
'as yet unclassified'
public = o ^ <Boolean> = (
	o isKindOfTypeVariable ifFalse:[^false].
	^path = o path	
)
public at: selector <Symbol> ^ <FunctionType>  = (
	^bound at: selector
)
public isKindOfTypeVariable ^ <Boolean>  = (
	^true
)
public name ^ <Symbol> = (
	^path first
)
public subtypeOf: t <Type> ^ <Boolean>  = (
	^bound subtypeOf: t
)
) : (
)
class UnionType unifying: ts <List[Type]> = Type (
(* The union of th etypes in ts *)|
	public elements <List[Type]> = ts.
|) (
'as yet unclassified'
public = o   = (
	o isKindOfUnionType ifFalse:[^false].
	^elements = o elements
)
public hash ^ <Integer> = (
	^elements hash bitXor: class hash
)
public isKindOfUnionType ^ <Boolean> = (
	^true
)
) : (
)
'as yet unclassified'
public blockNode: node ^ <ObjectType> = (    
| tas <VarOrdCltn[ObjectType]> = OrderedCollection(*[ObjectType]*)  new. |
  nestScope: Scope new.
  node parameters do:[:p <VarDecl>  |  tas add:(p apply: self)].
  tas addLast: (node body apply: self). 
  popScope.
  ^BlockApplicationType new apply: (TypeIdAST new setId: #Fun) to: tas.	
)
public cascadedSendNode: node  ^ <ObjectType> = (
	node previousSend apply: self.
	^normalSendNode: node
	)
public charNode: node <CharAST> ^ <ObjectType>= (
	^literal: #Character
)
public codeBodyNode: node ^ <ObjectType> = (

    | lastStatementType <ObjectType>  |

    (* pushScope (if we have a map) or just nest a new one *)
    nestScope: Scope new.
    node temporaries do:[:t <VarDecl>  | t apply: self].

	(* Parameters are not typechecked here. For method bodies, the parameters are
	copied from the signature and are checked there. For block bodies, the parameters
	are checked in blockNode. The copying hack should go away when the code
	scopes are factored out of the ASTs.*)

    lastStatementType:: (TypeIdAST new name: #Nil) apply: typeBuilder.
    node statements do:[:s <Statement>  | lastStatementType:: s apply: self].
    popScope.
    ^lastStatementType.
)
currentConflictNamespace = (
	^namespace at: (currentTopLevelClass simpleName, ' conflicts') asSymbol ifAbsent:[Map new]
)
currentConflictNamespaceHasEntryFor: typeName <Symbol>  = (
	namespace at: (currentTopLevelClass simpleName, ' conflicts') asSymbol ifAbsent:[^false].
	^true
)
currentScope ^ <Scope> = (
	^scopeStack last
)
declarationsForSignatureQuery: q <SubtypeQuery> ^ <List[Declaration]> = ( 
(* what if selector does not define a method *)
	^{(mirrorForObjectType: q type) instanceSide methods findMirrorNamed: q selector}
)
declarationsForSubtypeQuery: q <SubtypeQuery> ^ <List[Declaration]> = (
	^{mirrorForObjectType: q subtype. mirrorForObjectType: q supertype}
)
error: msg <String> at: location <Pair[Integer]> = (
	errorSet add: (TypeError message: msg start: location first end: location last).
)
functionTypeOf: node <SendASTNode> ^ <MsgSignature> = (
	(* A query *)
	| query <Query> receiverType <Type> cachedType <Type> selector <Symbol> |
	selector:: node message selector.
	receiverType:: node receiver apply: self.
	query:: SignatureQuery type: receiverType selector: selector.
	cachedType:: cachedTypes at: query ifAbsent:[
		cachedTypes at: query put: (receiverType at: selector).
		].
	registerDependenciesOfQuery: query.
	cachedType isKindOfAccessErrorType ifTrue:[
		error: selector, ' is defined, but is not publicly accessible' at: {node concreteStart. node concreteEnd}
		] ifFalse:[
		cachedType isKindOfErrorType ifTrue:[
			error: selector, ' is not defined on type ', receiverType name at: {node concreteStart. node concreteEnd}
			].
		].
	^cachedType.
)
public genericInvocationNode: node ^ <ObjectType> = (
    | myType <GenericApplicationType>  |

(* This will have to change to accomodate generic terms that are not classes  - mixins, or (in the near future) reflective representatives of a types. We also need to verify that the target is a term. For the immediate future, this is sufficient to type generic classes only.
*)

myType:: UnaryTypeOpAST new target:(GenericApplicationType new apply: (TypeIdAST new setId: node target name) to: node actuals) selector: #class.
myType wellFormed.
^myType
)
public guaranteedNode: node ^ <Type> = (
(* not supported in the grammar or parser yet *)
  ^node expr type.
)
herePathFor: m <MixinMirror> ^ <List[Symbol]> = (
	^(pathForMixin: m) asOrderedCollection addLast: #'@Here'; yourself
)
public invalidateDeclaration: declaration <Declaration> ^ <Set[Declaration]> = (
(* To be called when declaration has changed.
(a) Wipe clean the set of queries declaration depends on, because they were derived from an old version.
(b) Invalidate all queries that depended on the old declaration and return the declarations that depend on them.
 *)
	removeDependenciesOf:  declaration.
	^invalidateDependenciesOn: declaration.
)
invalidateDependenciesOn: declaration <Declaration> ^ <Set[Declaration]>  = (
(* Will invalidate all queries that depended on the declaration. *)
      | queries <Set[Query]> invalidDeclarations <Set[Declaration]> = Set new. |
      queries:: dependentQueries at: declaration.
	queries do:[:q <Query> | 
		q invalidate.
		invalidDeclarations addAll: (dependentDeclarations at: q)
		].
	^invalidDeclarations
)
lookupPathForType: typeName <Symbol> inClass: klass <ClassDeclarationMirror> ^ <List[Symbol]> = (
      | path <List[Symbol]> |

	path:: pathFor: typeName inClass: klass.
	^path isEmpty
	    ifFalse:[path]
	    ifTrue:[
		  lookupPathForType: typeName inNamespace: klass enclosingClass.
	    ].
	
)
lookupPathForType: typeName <Symbol> inNamespace: n ^ <List[Symbol]> = (

	^(currentConflictNamespaceHasEntryFor: typeName) ifTrue:[
		nil =  (namespace at: typeName) ifTrue:[{}] ifFalse:[{typeName}] (* validate that this is a type? *)
		] ifFalse:[
		{currentTopLevelClass name asSymbol. typeName}
		]
)
lookupType: typeName <Symbol>  = (
| t |
	^(currentConflictNamespace at: typeName) ifAbsent:[
		t:: namespace at: typeName.
		t isNamespace ifFalse:[^t].
            assert: [false] message: 'Inconsistency: object type seeking non-existent entry for itself'
		]	
)
public messageNode: node  <MessageAST> ^ <List[ObjectType]>= (
	^node arguments collect:[:e <ExpressionAST> | e apply: self]
)
public messagePatternNode: node ^ <FunctionType> = (
      ^node apply: typeBuilder
    )
public methodNode: node <MethodAST> ^ <MsgSignature>  = (
   | signature <FunctionType> | 
    pushScope: Scope new.
    signature:: node pattern apply: self.
    currentReturnType:: signature range.
    node body apply: self.
    popScope.
    ^currentReturnType
    )
mirrorForObjectType: o <ObjectType> ^ <ClassDeclarationMirror> = (
	| topName <Symbol> = o path first. mirror <ClassDeclarationMirror> |
	mirror:: ClassDeclarationMirror reflecting: (currentConflictNamespace at: topName ifAbsent:[namespace at: topName]) mixin. 
	2 to: o path size do:[:i <Integer> | | id <Symbol> = o  path at: i. |
		id = #'@Here' ifTrue:[^mirror].
		mirror:: mirror instanceSide nestedClasses findMirrorNamed: id.
		].
	^mirror
)
nestScope: s <Scope> = (
	(* Hook up a new lexically nested scope, and push onto the scope stack *)
	s setSuperScope: currentScope.
	pushScope: s
)
public normalSendNode: node <NormalSendASTNode> ^ <ObjectType> = (
    | functionType <FunctionType> domain <List[ObjectType]>  args <List[ObjectType]>  |

functionType::  functionTypeOf: node.
domain:: functionType domain.
args:: node message apply: self.
1 to: args size do:[:i <Integer> | 
	(type: (args at: i) isSubtypeOf: (domain at: i)) ifFalse:[
		error: 'Argument is not a subtype of corresponding formal'
		at: {(args at: i) concreteStart. (args at: i) concreteEnd}
		]
	].
^functionType range.
)
public numberNode: node = (
	^literal: #Number
)
objectTypeFor: c <ClassDeclarationMirror> ^ <ObjectType> = (
	^ObjectType forPath: (pathForMixin: c instanceSide)
)
pathFor: typeName <Symbol> inClass: klass <ClassDeclarationMirror> ^ <List[Symbol]> = (
      nil = klass ifTrue:[^{}]. (* got to the top level - but must check Self first!*)
	(typeSelector: typeName declaredIn: klass) ifTrue:[
		(* is this a selector of the class we are looking at *)
		^(pathForMixin: klass mixin) add: typeName
		(* if so , the path is the path for this class with the type name appended*)
		].
	^pathFor: typeName inClass: klass enclosingClass.
	(* otherwise, recurse on the enclosing class *)
)
pathForMixin: mixin <MixinMirror> ^ <List[Symbol]> = (
	| enclosingMixin = mixin enclosingMixin. |
	enclosingMixin = nil ifTrue: [^{mixin simpleName}].
	^{pathForMixin: enclosingMixin} add: mixin simpleName
)
popScope ^ <Scope> = (
  ^scopeStack removeLast
)
pushScope: scope <Scope> = (
	scopeStack addLast: scope
)
registerDependenciesOfQuery: q <Query> = (
	(dependentDeclarations at: q ifAbsent:[dependentDeclarations at: q put: Set new]) add: currentDeclaration.
	q declarations do:[: d | (dependentQueries at: d ifAbsent:[dependentQueries at: d put: Set new]) add: q.].
	(queriesOfDeclaration at: currentDeclaration ifAbsent:[queriesOfDeclaration at: currentDeclaration put: Set new]) add: q.	
)
removeDependenciesOf:  declaration = (
(* Wipe clean the set of queries  declaration depends on *)
      
	dependentDeclarations do:[:ds <Set[Declaration]> | ds remove: declaration].
)
public returnStatNode: node ^ <ObjectType> = (
    | returnType <ObjectType>   eType <ObjectType>  |

eType:: node expression apply: self.
^(type: eType isSubtypeOf: currentReturnType)
    ifTrue:[BottomType new]
    ifFalse:[error: 'Type of returned expression is not a subtype of declared return type' at: {node concreteStart. node concreteEnd}]
    )
returnTypeFor: node <MessagePatternAST> ^ <AST> = (
	| returnType <ObjectType> |
	returnType:: node returnType.
	returnType = nil ifTrue:[^ TypeIdAST new name: #Self]. 
	^returnType
)
public setterSendNode: node ^ <Type> = (
    | etype <ObjectType>  |

    etype:: node expr apply: self.
    (etype subtypeOf: (node var type apply: self) assuming: trail)
       ifFalse:[error: etype name, ' is not a subtype of ', node var type name at: {node concreteStart. node concreteEnd}].
    ^etype
)
public stringNode: node = (
	^literal: #String
)
public symbolNode: node = (
	^literal: #Symbol
)
public tupleNode: node ^ <ObjectType> = (
    |
sqTarget <TypeId> 
sqActuals <VarOrdCltn[ObjectType]> 
sqActual <ObjectType> 
sqType <GenericTypeApplication>
tupleTarget <TypeId> 
tupleActuals <VarOrdCltn[ObjectType]> 
tupleType <TupleType>
|

sqTarget:: TypeIdAST new setId: #SeqCltn;  start: 0; end: 0.
sqActuals:: OrderedCollection(*[ObjectType]*)  new.
tupleActuals:: node value collect:[:e <Literal>  | e apply: self].

tupleActuals isEmpty 
   ifTrue:[tupleActuals add: (TypeIdAST new setId: #DoesNotMatter)].

sqActual:: UnionType unifying: tupleActuals asSet asOrderedCollection.

sqActuals add: sqActual.
sqType:: GenericApplicationType new apply: sqTarget to: sqActuals.

tupleTarget:: TypeIdAST new setId: #Tuple.
tupleType:: TupleAST new apply: tupleTarget to: tupleActuals.


^ProtocolMerge new type1: sqType type2: tupleType.
)
type: sub <Type> isSubtypeOf: sup <Type> ^ <Boolean> = (
	| query |
	query:: SubtypeQuery subtype: sub supertype: sup.
	registerDependenciesOfQuery: query.
	^trail at: query ifAbsent:[
		trail at: query put: (sub subtypeOf: sup).		
		].
)
typeOfHere ^ <ObjectType> = (
	^HereType for: currentClass instanceSide
)
typeOfLocal: varName <Symbol> ^ <ObjectType> = (
	 ^currentScope at: varName ifAbsent:[]
)
typeOfOuter ^ <ObjectType> = (
	^OuterType for: currentClass mixin
)
typeOfSelf ^ <ObjectType> = (
      | currentType <ObjectType> = objectTypeFor: currentClass. |
	^TypeVariable named: #Self bound: currentType forType: currentType.
)
typeOfSuper ^ <ObjectType> = (
	^ObjectType forPath: (lookupPathForType: currentClass superclass simpleName inClass: currentClass)
)
typeSelector: typeName <Symbol> declaredIn: klass <ClassDeclarationMirror> ^ <Boolean> = (
	| mixin <MixinMirror> = klass instanceSide. candidate <Mirror> |
	candidate:: mixin nestedClasses findMirrorNamed: typeName.
	nil ~= candidate ifTrue:[^true].
	candidate:: mixin methods findMirrorNamed: typeName. 
	nil ~= candidate ifTrue:[^true].
	candidate:: mixin slots findMirrorNamed: typeName.
	^nil ~= candidate.	
)
public typecheckMethod: m <MethodAST> ofClass: c <Class> ^ <Set[TypeError]>= (
     | toplevelCandidate <ClassDeclarationMirror> = ClassDeclarationMirror reflecting: c mixin. |
	currentClass:: toplevelCandidate.
	typeBuilder:: TypeBuilder forTypesIn: toplevelCandidate.
	currentDeclaration:: m selector.
      [toplevelCandidate enclosingClass ~= nil] whileTrue:[toplevelCandidate:: toplevelCandidate enclosingClass].
      currentTopLevelClass:: toplevelCandidate.
      errorSet:: Set new.
	methodNode: m.
	^errorSet
)
public typecheckMethodSource: src <String> ofClass: c <Class> ^ <Set[TypeError]>= (
     | m <MethodAST> |
	m:: parser methodDecl parseString: src.
	^typecheckMethod: m ofClass: c.
)
public varDeclNode: node = (
      ^currentScope at: node name put: (node type apply: typeBuilder). 
)
public variableNode: node <VariableAST> ^ <ObjectType> = (
	(* need to deal with #'@here', #self, #super, #outer *)
	| varName <Symbol> = node name. | 
	varName = #'@here' ifTrue:[^typeOfHere].
	varName = #self ifTrue:[^typeOfSelf].
	varName = #super ifTrue:[^typeOfSuper].
	varName = #outer ifTrue:[^typeOfOuter].
	^assert: [false] message: varName, ' should never have been treated as a variable node'.
)
'visiting'
literal: typeName <Symbol> ^ <ObjectType> = (
    ^(TypeIdAST new name: typeName) apply: typeBuilder
    )
) : (
)
