Newspeak3
'Newspeak'
class NewspeakTypechecker usingPlatform: p ide: ide ast: astModule namespace: ns = ((* A visitor that computes the type of a Newspeak program Questions to resolve: is there a set of classes representing types, or do we just interpret the AST nodesfor types as needed.  In some cases we need a semantic type - for example BottomType.Also, we need this typechecker to be incremental. The basic ideas go back as far as the Cecil typechecker, but are properly explained in the context of Scala optimization in the OOPSLA 2016 paper: Parallel Incremental Whole-Program Optimizations for Scala.js.These principles are:a. Access to program structure beyond the method currently being typechecked must go through a query API. This API will track any dependencies of the method on types of other program components.b. These queries are pure functions of immutable data and the program. c. We maintain dependencies between (previously) typechecked methods and queries.  We also maintain dependencies between queries and the program parts they describe.d. Query results are cached, and invalidated if the source code they depend on has changed. This means that we will need to either: 1. Note when a given change is made and invalidate its dependent queries, or  2. Compute a diff when a typecheck starts, and use it to decide which changes have been made, and thus invalidate any dependent       queries.e. Memory required grows linearly with program size, as both the number of methods and the queries about them are proportional to code size. f. Time is proportional to the size of the code being typechecked (especially if we note changes as they occur).  Initial typechecks may be slower, as they often require global program information like subtype relations, but this should not be an issue. We can also trade memory for time  by constructing cached subtype queries at type definition time if need be.For the time being, we ignore generics.The Type hierarchy consists of:a. Type, the abstract class at the top of the hierarchy.b. ObjectType, which is defined by an immutable list of symbols that defines a class as a path of class names starting from a top level class.c. FunctionType, which is defined by a pair of a list of argument types and a return type.d. ErrorType, the magical type that is a subtype and supertype of everything and supports all methods.e. BottomType, the bottom of the type lattice.The query hierarchy consists of:a. Query,  the abstract class at the top of the hierarchy.b. Subtype(T, S) where T and S are types, which answers whether T <: S.c. Signature(T, m) where T is a type and m is a selector, which yields the FunctionType of method m in type T, or Error if m is undefined.We maintain two maps of dependencies:a. dependentDeclarations. A Map[Query, List[Declaration]] which lists, for each query q, all declarations whose typecheck required q.b. dependentQueries. A Map[Declaration, List[Query]] which lists, for each declaration d, all queries that d used it its last typecheck.Declarations can be methods but also class headers.All this is encapsulated in this module, which eventually needs to be fed into the IDE.  Even in an offline scenario where the typechecker is used as a service, the dependencies need to exist.  Other toolds need to maintian the dependencies as code changes.Do we need dedicated error classes? Probably not. All type errors would behave the same except for error strings. (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  (c) Google Inc. 2016 - 2017.Use and distribution of this software is subject to the terms of the attached source license.*)|(* imports *)OrderedCollection = p collections OrderedCollection.TypeIdAST = astModule TypeIdAST.TupleAST = astModule TupleAST.GenericApplicationType = astModule GenericApplicationType.UnaryTypeOpAST = astModule UnaryTypeOpAST.(* module variables *)trail = Trail new.globalScope = ns.validator = TypeValidator new.errorType <ErrorType> = ErrorType new.bottom <BottomType> = BottomType new.dependentDeclarations <Map[Query, List[Declaration]]>dependentQueries <Map[Declaration, List[Query]]>|) (
class BottomType = Type (
(* The bottom of the type lattice. *)) (
'as yet unclassified'
public subtypeOf: t <Type> ^ <Boolean> = (
	^true
)
) : (
)
class ErrorType = Type (
(* The error type. *)) (
'as yet unclassified'
public subtypeOf: t <Type> ^ <Boolean> = (
	^true
)
) : (
)
class FunctionType domain: d <List[Type]> range: r <Type> = Type (
(* The type of a method. *)|
	public domain <List[Type]> = d.
	public range <Type> = r.
|) (
'as yet unclassified'
public isKindOfFunctionType ^ <Boolean> = (
	^true
)
public subtypeOf: t <Type> ^ <Boolean> = (
  | ft <FunctionType> ftd <List[Type]> |
      t = errorType ifTrue:[^true].
      t isKindOfFunctionType ifFalse:[^false] ifTrue:[ft:: t].

	(range subtypeOf: ft range) ifFalse:[^false].
	ftd:: ft domain.
	domain size = ftd size ifFalse:[^false].
	1 to: domain size do:[: i <Integer> |
		((ftd at: i) subtypeOf: (domain at: i)) ifFalse:[^false]
		].
	^true.
)
) : (
)
class NotAValidTerm id: n <Symbol> = (
(* Describe the class in this comment. *)|
|) (
) : (
)
class ObjectType forPath: ts <List[Symbol]> = Type (
(* The type of an Object. *)|
	public path <List[Symbol]> = ts.
|) (
'as yet unclassified'
immediateSupertypes ^ <Collection[ObjectType]> = (
	
)
public isKindOfObjectType ^ <Boolean> = (
	^true
)
public subtypeOf: t <Type> ^ <Boolean> = (
	| ot <ObjectType>  |
      t = errorType ifTrue:[^true].
      t isKindOfObjectType ifFalse:[^false] ifTrue:[ot:: t].

      path = ot path ifTrue:[^true].
      immediateSupertypes do:[: st <ObjectType> |
	   (st subtypeOf: t) ifTrue:[^true]
	].
      ^false
)
) : (
)
class Query = (
(* Abstract class. The root of the query hierrachy. *)) (
) : (
)
class SignatureQuery type: t <Type> selector: m <Symbol> = Query (
(* What is the type of method m of class t? *)|
	type <Type> = t.
	selector <Symbol> = s.
|) (
) : (
)
class SubtypeQuery subtype: s <Type> supertype: t <Type> = Query (
(* Is s <: t ?. *)|
	subtype <Type> = s.
	supertype <Type> = t.
|) (
) : (
)
class Trail = (
(* The trail is implemented by this class. A single instance, held in the slot #trail, 
exists at any point in time.

The representation used here is simple. The slot 'dict'
is a dictionary mapping type variables to dictionaries. Every type variable T
that is known to be related to some other type has an entry in 'dict'
(T being the key). The value of this entry is a dictionary D
mapping types to Booleans. Each entry E_sigma in D
corresponds to a type Sigma known to be related to to the type variable T.
If T <= Sigma, then E_sigma value is True.  If T <# Sigma, then E_sigma
value is False. Otherwise, T is unrelated to Sigma.
*)| dict  |) (
'Unclassified'
answer: t1 <ObjectType >isInheritedTypeOf: t2 <ObjectType > ^ <Boolean> = (

    ^((self dict at: t1 ifAbsent:[^false]) at: t2 ifAbsent:[^false]) not
)
answer: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Boolean> = (

    ^(self dict at: t1 ifAbsent:[^false]) at: t2 ifAbsent:[^false]
)
answerTypeVar: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Boolean> = (

(* Buggy!  We need to see if t1 is a subtype or inherited type of its bound.
If it is a subtype, the code below works.
If it is not, it only works provided the bound is monotonic (and what does that entail if the bound
is another type variable?

*)
    ^(self typeVarBoundFor: t1) subtypeOf: t2 assuming: self.
)
assume: t1 <ObjectType >isInheritedTypeOf: t2 <ObjectType > ^ <Self> = (

    | t1Dict <IdentityDictionary[ObjectType, Boolean]>  |

t1Dict:: self dict at: t1
                      ifAbsent:[self dict at: t1 put: IdentityDictionary(*[ObjectType, Boolean]*)  new].
(t1Dict includesIndex: t2) ifFalse:[t1Dict at: t2 put: false]
                                         ifTrue:[self error: 'Trail already contains entry for ', t1 name, ' inherited type of ', t2 name].
)
assume: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Self> = (

    | t1Dict <IdentityDictionary[ObjectType, Boolean]>  |

t1Dict:: self dict at: t1
                      ifAbsent:[self dict at: t1 put: IdentityDictionary(*[ObjectType, Boolean]*)  new].
(t1Dict includesIndex: t2) ifFalse:[t1Dict at: t2 put: true]
                                         ifTrue:[self error: 'Trail already contains entry for ', t1 name, ' subtype of ', t2 name].
)
forget: t1 <ObjectType >isInheritedTypeOf: t2 <ObjectType > ^ <Self> = (

    self forget: t1 isSubtypeOf: t2
)
forget: t1 <ObjectType >isSubtypeOf: t2 <ObjectType > ^ <Self> = (

    | e1 <IdentityDictionary[ObjectType, Boolean]>  |


(e1:: self dict at: t1 ifAbsent:[^self]) removeKey: t2 ifAbsent:[^self].
e1 isEmpty ifTrue:[self dict removeKey: t1].
)
initialize ^ <Self> = (

    dict:: IdentityDictionary(*[ObjectType, IdentityDictionary[ObjectType, Boolean]]*)  new.
)
typeVarBoundFor: tv <TypeVar > ^ <ObjectType> = (

    | tvDict <IdentityDictionary[ObjectType, Boolean]>  |

(* The entry for a type variable should contain exactly one element, which is the known bound for the type variable.
If no entry exists, we can always assume that the type variable is an Object
(or should we treat this as an inconsistency?).
*)
tvDict:: self dict at: tv ifAbsent:[^DeltaTypeId new setId: #Object; scope: DeltaGlobals].
tvDict associationsDo:[:a <Assoc[ObjectType,IdentityDictionary[ObjectType,Boolean]]> | ^a key].
)
) : (
)
class Type = (
(* Abstract class, root of the type hierarchy. *)) (
'as yet unclassified'
public subtypeOf: t <Type> ^ <Boolean> = (
	subclassResponsibility
)
) : (
)
class TypeError = Error () (
) : (
)
class TypeValidator = (
(* A visitor that checks that a type is well formed. *)|

|) (
'as yet unclassified'
public binaryTypeOpNode: node ^ <Boolean> = (
    | operator <Symbol>  operatorOk <Boolean>  |

operatorOk:: operator = #|.
operatorOk ifFalse:[reportError: (InvalidTypeOperatorError operator: operator)].
^operatorOk and:[(node leftOperand apply: self) and:[node rightOperand apply: self]].	
)
blockTypeNode: node ^ <Boolean> = (
	
)
public typeIdASTNode: node ^ <Boolean> = (
	    | r <DeltaAST>  |

(r:: node ref) isError ifTrue: [
	 reportError: r.
	^false].
r isType ifFalse: [
	reportError: (NotATypeError id: node name).
	^false].
^true
)
public typeVariable: node  ^ <Boolean> = (
    ^node declaredBound wellFormed	
)
public unaryTypeOpNode: node ^ <Boolean> = (
    | selector <Symbol>  selectorOk <Boolean>  |

selector:: node selector.
selectorOk:: selector = #class or:[selector = #protocol or:[selector = #instance or:[selector = #def and:[self target isTypeVar]]]].
selectorOk ifFalse:[reportError: (InvalidTypeOperatorError operator: selector)].
^selectorOk and: [node target apply:self].	
)
) : (
)
'as yet unclassified'
public blockNode: node ^ <ObjectType> = (    | tas <VarOrdCltn[ObjectType]>  |tas:: OrderedCollection(*[ObjectType]*)  new.(* must add types of parameters *)node parameters do:[:p <VarDecl>  | p type wellFormed. tas add: p type].(* query: types of parameter*)tas addLast: node body type. (* Typecheck vs type*)^BlockApplicationType new        apply: (TypeIdAST new setId: #Fun; scope: globalScope) to: tas.	)
public cascadedSendNode: node  ^ <ObjectType> = (
	node prevSend type.
	^super type
	)
checkArgsAgainstSignature: sig <MsgSignature> = (
	
)
public codeBodyNode: node ^ <ObjectType> = (

    | lastStatementType <ObjectType>  |

    node temporaries do:[:t <VarDecl>  | validate: t type].

	(* Parameters are not typechecked here. For method bodies, the parameters are
	copied from the signature and are checked there. For block bodies, the parameters
	are checked in Block>>type. The copying hack should go away when the code
	scopes are factored out of the ASTs.*)

    lastStatementType:: TypeIdAST setId: #Nil; scope: globalScope.
    node statements do:[:s <Statement>  | lastStatementType:: s type].
    ^lastStatementType.
)
functionTypeOf: node <NormalSendASTNode> ^ <MsgSignature> = (
	
)
public genericInvocationNode: node ^ <ObjectType> = (
    | myType <GenericApplicationType>  |

(* This will have to change to accomodate generic terms that are not classes  - mixins, or (in the near future) reflective representatives of a types. We also need to verify that the target is a term. For the immediate future, this is sufficient to type generic classes only.
*)

myType:: UnaryTypeOpAST new target:(GenericApplicationType new apply: (TypeIdAST new setId: node target name; scope: globalScope) to: node actuals) selector: #class.
myType wellFormed.
^myType
)
public guaranteedNode: node ^ <Type> = (
(* not supported in the grammar or parser yet *)
  ^node expr type.
)
public messagePatternNode: node ^ <MsgSignature> = (
    ^self filteree type substitute: self substitution
    )
public methodNode: node ^ <MsgSignature>  = (
    node pattern apply: self.
    node body apply: self.
    ^node pattern returnType
    )
public normalSendNode: node <NormalSendASTNode> ^ <ObjectType> = (
    | functionType <MsgSignature>  i <Int>   |

functionType::  functionTypeOf: node.
self checkArityAgainstSignature: functionType 
         ifFail:[((* guaranteed <TypeError> *) functionType) domainSize: node args size].
checkArgsAgainstSignature: functionType.
^functionType range.
)
public numberNode: node = (
	^literal: node
)
ref: node ^ <ObjectType> = (
    node decl isValidTerm ifFalse: [(NotAValidTerm id: node name) signal].
    ^node decl type
    )
public returnStatNode: node ^ <ObjectType> = (
    | returnType <ObjectType>   eType <ObjectType>  |

eType:: node expr type.
returnType:: (* guaranteed <ObjectType>*)  (self scope at: #'.returnVal').
^(eType subtypeOf: returnType assuming: trail)
    ifTrue:[BottomType new]
    ifFalse:[self reportError: (ReturnError new actualName: eType name; declaredName: returnType name)]
    )
public setterSendNode: node ^ <Type> = (
    | etype <ObjectType>  |

etype:: self expr type.
^(etype subtypeOf: node var type assuming: trail)
    ifTrue:[etype]
    ifFalse:[self reportError: (AssignmentError new exprName: etype name; varName: self var name)]
)
public stringNode: node = (
	^literal: node
)
public symbolNode: node = (
	^literal: node
)
public tupleNode: node ^ <ObjectType> = (
    |
sqTarget <TypeId> 
sqActuals <VarOrdCltn[ObjectType]> 
sqActual <ObjectType> 
sqType <GenericTypeApplication>
tupleTarget <TypeId> 
tupleActuals <VarOrdCltn[ObjectType]> 
tupleType <TupleType>
|

sqTarget:: TypeIdAST new setId: #SeqCltn; scope: globalScope; begin: 0 end: 0.
sqActuals:: OrderedCollection(*[ObjectType]*)  new.
tupleActuals:: node value collect:[:e <Literal>  | e type].

tupleActuals isEmpty 
   ifTrue:[tupleActuals add: (TypeIdAST new setId: #DoesNotMatter;
                                                                                         scope: globalScope)
                ].

sqActual:: self buildUnion: tupleActuals asSet asOrderedCollection.

sqActuals add: sqActual.
sqType:: GenericApplicationType new apply: sqTarget to: sqActuals.

tupleTarget:: TypeIdAST new setId: #Tuple; scope: globalScope.
tupleType:: TupleAST new apply: tupleTarget to: tupleActuals.


^ProtocolMerge new type1: sqType type2: tupleType.
)
validate: node = (
	node apply: validator
)
public varDeclNode: node = (
      | result = node type. |
      validate: result.
	^result.
)
'visiting'
literal: node ^ <ObjectType> = (
    ^TypeIdAST setId: self typeName; scope: globalScope
    )
) : (
)
