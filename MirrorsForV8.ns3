Newspeak3
'Mirrors'
class MirrorsForV8 usingPlatform: p vmMirror: vmm = (|
private List = p collections OrderedCollection.
private Mixin = p kernel Mixin.
private CharacterReadStream = p streams CharacterReadStream.
private CharacterWriteStream = p streams CharacterReadWriteStream.
private ImmutableMirrorGroup = (p namespace MirrorGroups usingLib: p) ImmutableMirrorGroup.
private vmmirror = vmm.

private parserLib = Future computing: [p namespace CombinatorialParsing usingPlatform: p].
private grammar = Future computing: [p namespace NewspeakGrammar parserLib: parserLib].
private asts = Future computing: [p namespace NewspeakASTs usingLib: p].
private parsing = Future computing: [p namespace NewspeakParsing usingPlatform: p grammar: grammar asts: asts].
private generation = Future computing: [p namespace JavascriptGeneration usingPlatform: p].
private compilation = Future computing: [p namespace Compilation usingPlatform: p parsing: parsing generation: generation mirrors: nil].
private compiler = Future computing: [compilation Compiler new].
|)
(
class ClassDeclarationBuilder fromIR: ir forExistingMixin: m = (|
private prvtExistingMixin <Mixin> ::= m.
private prvtClassDeclIR <ClassDeclarationIR> ::= ir.

public instanceSide = MixinBuilder forClassDeclaration: self ir: ir instanceSide.
public classSide = MixinBuilder forClassDeclaration: self ir: ir classSide.
|)
('as yet unclassified'
public install ^<ClassDeclarationMirror> = (
	| writer stream src runtimeMixin application |
	assert: [prvtExistingMixin isNil] message: 'Modifying existing code as-yet-unimplemented'.
	writer:: generation Writer new.
	stream:: CharacterWriteStream on: (Array new: 100).
	writer generateSourceFor: prvtClassDeclIR runtimeMixin on: stream.
	src:: String withAll: stream contents.
	src out.
	runtimeMixin:: js call: (js ident: 'eval') with: {src}.
	prvtExistingMixin:: Mixin fromRuntimeMixin: runtimeMixin.
	^ClassDeclarationMirror reflecting: prvtExistingMixin.
)) : ('as yet unclassified'
public fromSource: src <String> ^<ClassDeclarationBuilder> = (
	^self fromUnitSource: 'Newspeak3 ''Uncategorized'' ', src
)
fromUnitSource: src <String> ^<ClassDeclarationBuilder> = (
	^self fromIR: (compiler compileClassSource: (CharacterReadStream on: src) within: nil)
)
public reflecting: mixin <InstanceMixin> ^<ClassDeclarationBuilder> = (
	assert: [mixin isMixin & mixin isMeta not] message: 'Provide an instance-side mixin'.
	^self
		fromMixinRep: (classDeclIRFor: mixin)
		forExistingMixin: mixin
))
class ClassDeclarationMirror reflecting: mixin = (|
	reflectee = mixin.
	instanceSide = MixinMirror reflecting: mixin.
	classSide = MixinMirror reflecting: (Mixin fromRuntimeMixin: (js propertyOf: (js propertyOf: mixin at: (js literal: 'runtimeMixin')) at: (js literal: 'meta'))).
|)
('as yet unclassified'
enclosingClass ^ <ClassDeclarationMirror> = (
	| enclosing <Class> |
	enclosing:: (js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'enclosingMixin')). 
	(js operator: '===' with: enclosing and: (js ident: 'undefined')) ifTrue: [^nil].
	^ClassDeclarationMirror reflecting: (Mixin fromRuntimeMixin: enclosing)
)
name = (
	^reflectee name
)
simpleName = (
	^(name splitBy: '`') last
)) : ()
class ClassMirror reflecting: r = (|
	reflectee = r.
|)
('as yet unclassified'
allSuperclasses ^ <List[ClassMirror]> = (
	| klass <Class> superclasses <List[Class]> |
	superclasses:: List new.
	klass:: superclass.
	[klass isNil] whileFalse:[
		superclasses add: klass.
		klass:: klass superclass.
	].
	^superclasses
)
private computeMirrorGroup: mgAccessor <[:MixinMirror | MirrorGroup]> ^ <List[Mirror]> = (
(* Return a mirror group based on the mixins group and those of all superclasses. The argument mgAccessor extracts a mirror group from any mirror provided to it. *)
	| mg <MirrorGroup>  |
	mg:: List new.
	(allSuperclasses reverse add: self; yourself)
		do:[:klass <ClassMirror> | mg addAll: (mgAccessor value: klass mixin)].
	^ mg	
)
enclosingObject ^<ObjectMirror> = (
	^ObjectMirror reflecting: reflectee enclosingObject
)
methods ^ <MirrorGroup[MethodMirror]> = (
	^computeMirrorGroup: [:r | r methods]
)
mixin ^ <MixinMirror> = (
	^MixinMirror reflecting: reflectee mixin
)
name = (
	^reflectee name
)
nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (
	^computeMirrorGroup: [:r | r nestedClasses]
)
simpleName = (
	^(reflectee name splitBy: '`') last
)
slots ^ <MirrorGroup[SlotMirror]> = (
	^computeMirrorGroup: [:r | r slots].
)
superclass ^ <ClassMirror> = (
	reflectee superclass isNil ifTrue:[^nil].
	^ClassMirror reflecting: reflectee superclass
)) : ()
class MethodBuilder = ()
() : ()
class MethodMirror named: n in: dm source: s = (|
name = n.
definingMixin = dm.
source = s.
|)
() : ()
class MixinBuilder forClassDeclaration: cdb ir: ir <MixinIR> = (|
public declaration <ClassDeclarationBuilder> = cdb.
public isMeta = ir isMeta.
public methods <MutableMethodGroup> = MutableMethodGroup new.
public nestedClasses <MutableNestedClassGroup> = MutableNestedClassGroup new.
|)
() : ()
class MixinMirror reflecting: mixin = (|
	reflectee = mixin.
|)
('as yet unclassified'
public declaration ^<ClassDeclarationMirror> = (
	^ClassDeclarationMirror 
		reflecting: (reflectee isMeta 
			ifFalse: [reflectee]
			ifTrue: [(Mixin fromRuntimeMixin: (js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'nonMeta')))])
)
public isMixinMirror ^<Boolean> = (
	^true
)
public methods ^<MirrorGroup[MethodMirror]> = (
	^((js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'methods'))
		select: [:each | (js propertyOf: each at: (js literal: 'isSynthetic')) not])
		collect: [:each | MethodMirror named: (js propertyOf: each at: (js literal: 'name')) in: self source: (js propertyOf: each at: (js literal: 'source'))].
)
public nestedClasses ^<MirrorGroup[ClassDeclarationMirror]> = (
	^(js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'nestedClasses'))
		collect: [:each | ClassDeclarationMirror reflecting: 
			(Mixin fromRuntimeMixin:
				(js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (vmmirror mangleSelector: each)))].
)
public slots ^<MirrorGroup[SlotDeclarationMirror]> = (
	^((js propertyOf: (js propertyOf: reflectee at: (js literal: 'runtimeMixin')) at: (js literal: 'slots'))
		select: [:each | (js propertyOf: each at: (js literal: 'isSynthetic')) not])
		collect: [:each | SlotMirror named: (js propertyOf: each at: (js literal: 'name'))].
)) : ()
class MutableMethodGroup = MutableMirrorGroup ()
() : ()
class MutableMirrorGroup group: ms within: mb = ImmutableMirrorGroup group: ms (|
public enclosingMixin = mb.
|)
() : ()
class MutableNestedClassGroup = MutableMirrorGroup ()
() : ()
class ObjectMirror reflecting: r = (|
	reflectee = r.
|)
('as yet unclassified'
evaluate: expression <String>
ifCompilerError: compilationErrorHandler <[:Error]> 
ifError: evalErrorHandler <[:Error]> ^<ObjectMirror> = (
	|
	compiler
	ir
	dnuHandlers
	writer
	stream
	src
	func
	result
	|
	[compiler:: compilation Compiler new.
	ir:: compiler
			compileExpressionSource: (CharacterReadStream on: expression)
			inMixin: (getClassIfFail: []) mixin.
	dnuHandlers:: compiler dnuHandlers.
	
	writer:: generation Writer new.
	stream:: CharacterWriteStream on: (Array new: 100).
	writer generateSourceFor: dnuHandlers on: stream.
	src:: String withAll: stream contents.
	func:: js call: (js ident: 'eval') with: {'(',src, ')'}.
	js call: func with: {js verbatim: 'Object.prototype'}.
	
	writer:: generation Writer new.
	stream:: CharacterWriteStream on: (Array new: 100).
	writer generateSourceFor: ir function on: stream.
	src:: String withAll: stream contents.
	src out.
	func:: js call: (js ident: 'eval') with: {src}.
	] on: Error do: [:e | ^compilationErrorHandler value: e].
	[result:: js call: (js propertyOf: func at: (js literal: 'call')) with: {reflectee}.]
		on: Error do: [:e | ^evalErrorHandler value: e].
	^ObjectMirror reflecting: result
)
getClassIfFail: onFail = (
	^ClassMirror reflecting:
		(js propertyOf: reflectee at: (js literal: 'newspeakClass')).
)
getSlot: selector ifFail: failBlock = (
	|
	mangledName = vmmirror mangleSelector: selector, '`slot'.
	raw = js propertyOf: reflectee at: mangledName.
	|
	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [^failBlock value].
	^ObjectMirror reflecting: raw
)
reflecteeIfFail: onFail = (
	^reflectee
)
setSlot: selector to: value ifFail: failBlock = (
	|
	mangledName = vmmirror mangleSelector: selector, '`slot'.
	raw = js propertyOf: reflectee at: mangledName.
	|
	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [^failBlock value].
	js assign: (js propertyOf: reflectee at: mangledName) toBe: value.
)) : ()
class SlotMirror named: n = (|
	name = n.
|)
() : ()'as yet unclassified'
classDeclIRFor: mixin = (
	
)) : ()