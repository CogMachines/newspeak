Newspeak3
'Mirrors'
class MirrorsForV8 usingPlatform: p vmMirror: vmm = (|
private List = p collections OrderedCollection.
private Mixin = p kernel Mixin.
private vmmirror = vmm.

	CharacterReadStream = p streams CharacterReadStream.
	CharacterWriteStream = p streams CharacterReadWriteStream.

	parserLib = Future computing: [p namespace CombinatorialParsing usingPlatform: p].
	grammar = Future computing: [p namespace NewspeakGrammar parserLib: parserLib].
	asts = Future computing: [p namespace NewspeakASTs usingLib: p].
	parsing = Future computing: [p namespace NewspeakParsing usingPlatform: p grammar: grammar asts: asts].
	generation = Future computing: [p namespace JavascriptGeneration usingPlatform: p].
	compilation = Future computing: [p namespace Compilation usingPlatform: p parsing: parsing generation: generation mirrors: nil].
|)
(
class ClassDeclarationMirror reflecting: mixin = (|
	reflectee = mixin.
	instanceSide = MixinMirror reflecting: mixin.
	classSide = MixinMirror reflecting: mixin classMixin.
|)
('as yet unclassified'
enclosingClass ^ <ClassDeclarationMirror> = (
	| enclosing <Class> |
	enclosing:: (js propertyOf: reflectee runtimeMixin at: (js literal: 'enclosingMixin')). 
	(js operator: '===' with: enclosing and: (js ident: 'undefined')) ifTrue: [^nil].
	^ClassDeclarationMirror reflecting: (Mixin fromRuntimeMixin: enclosing)
)
name = (
	^reflectee name
)
simpleName = (
	^(name splitBy: '`') last
)) : ()
class ClassMirror reflecting: r = (|
	reflectee = r.
|)
('as yet unclassified'
allSuperclasses ^ <List[ClassMirror]> = (
	| klass <Class> superclasses <List[Class]> |
	superclasses:: List new.
	klass:: superclass.
	[klass isNil] whileFalse:[
		superclasses add: klass.
		klass:: klass superclass.
	].
	^superclasses
)
private computeMirrorGroup: mgAccessor <[:MixinMirror | MirrorGroup]> ^ <List[Mirror]> = (
(* Return a mirror group based on the mixins group and those of all superclasses. The argument mgAccessor extracts a mirror group from any mirror provided to it. *)
	| mg <MirrorGroup>  |
	mg:: List new.
	(allSuperclasses reverse add: self; yourself)
		do:[:klass <ClassMirror> | mg addAll: (mgAccessor value: klass mixin)].
	^ mg	
)
enclosingObject ^<ObjectMirror> = (
	^ObjectMirror reflecting: reflectee enclosingObject
)
methods ^ <MirrorGroup[MethodMirror]> = (
	^computeMirrorGroup: [:r | r methods]
)
mixin ^ <MixinMirror> = (
	^MixinMirror reflecting: reflectee mixin
)
name = (
	^reflectee name
)
nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (
	^computeMirrorGroup: [:r | r nestedClasses]
)
simpleName = (
	^(reflectee name splitBy: '`') last
)
slots ^ <MirrorGroup[SlotMirror]> = (
	^computeMirrorGroup: [:r | r slots].
)
superclass ^ <ClassMirror> = (
	reflectee superclass isNil ifTrue:[^nil].
	^ClassMirror reflecting: reflectee superclass
)) : ()
class MethodMirror named: n = (|
name = n.
|)
() : ()
class MixinMirror reflecting: mixin = (|
	reflectee = mixin.
|)
('as yet unclassified'
declaration ^ <ClassDeclarationMirror> = (
	^ClassDeclarationMirror 
		reflecting: (reflectee isMeta ifFalse: [reflectee] ifTrue: [reflectee instanceMixin])
)
methods = (
	^(js propertyOf: reflectee runtimeMixin at: (js literal: 'methods'))
		collect: [:each | MethodMirror named: each].
)
nestedClasses = (
	^(js propertyOf: reflectee runtimeMixin at: (js literal: 'nestedClasses'))
		collect: [:each | ClassDeclarationMirror reflecting: 
			(Mixin fromRuntimeMixin:
				(js propertyOf: reflectee runtimeMixin at: (vmmirror mangleSelector: each)))].
)
slots = (
	^(js propertyOf: reflectee runtimeMixin at: (js literal: 'slots'))
		collect: [:each | SlotMirror named: each].
)) : ()
class ObjectMirror reflecting: r = (|
	reflectee = r.
|)
('as yet unclassified'
evaluate: expression <String> ifError: onEvalError = (
	|
	compiler
	ir
	dnuHandlers
	writer
	stream
	src
	func
	result
	|
	compiler:: compilation Compiler new.
	ir:: compiler
			compileExpressionSource: (CharacterReadStream on: expression)
			inMixin: (getClassIfFail: []) mixin declaration.
	dnuHandlers:: compiler dnuHandlers.
	
	writer:: generation Writer new.
	stream:: CharacterWriteStream on: (Array new: 100).
	writer generateSourceFor: dnuHandlers on: stream.
	src:: String withAll: stream contents.
	func:: js call: (js ident: 'eval') with: {'(',src, ')'}.
	js call: func with: {js verbatim: 'Object.prototype'}.
	
	writer:: generation Writer new.
	stream:: CharacterWriteStream on: (Array new: 100).
	writer generateSourceFor: ir function on: stream.
	src:: String withAll: stream contents.
	src out.
	func:: js call: (js ident: 'eval') with: {src}.
	[result:: js call: (js propertyOf: func at: (js literal: 'call')) with: {reflectee}.]
		on: Error do: [:e | ^onEvalError value: e].
	^ObjectMirror reflecting: result
)
getClassIfFail: onFail = (
	^ClassMirror reflecting:
		(js propertyOf: reflectee at: (js literal: 'newspeakClass')).
)
getSlot: selector ifFail: failBlock = (
	|
	mangledName = vmmirror mangleSelector: selector, '`slot'.
	raw = js propertyOf: reflectee at: mangledName.
	|
	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [^failBlock value].
	^ObjectMirror reflecting: raw
)
reflecteeIfFail: onFail = (
	^reflectee
)
setSlot: selector to: value ifFail: failBlock = (
	|
	mangledName = vmmirror mangleSelector: selector, '`slot'.
	raw = js propertyOf: reflectee at: mangledName.
	|
	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [^failBlock value].
	js assign: (js propertyOf: reflectee at: mangledName) toBe: value.
)) : ()
class SlotMirror named: n = (|
	name = n.
|)
() : ()) : ()