Newspeak3
'Mirrors'
 class MirrorsForV8 usingPlatform: p vmMirror: vmm =  (|
private List = p collections OrderedCollection.
private Mixin = p kernel Mixin.
private vmmirror = vmm.












|)
(
class ClassDeclarationMirror reflecting: mixin = (|
	reflectee = mixin.
	instanceSide = MixinMirror reflecting: mixin.
	classSide = MixinMirror reflecting: mixin classMixin.
|)
('as yet unclassified'
enclosingClass ^ <ClassDeclarationMirror> = (
	| enclosing <Class> |
	enclosing:: (js propertyOf: reflectee runtimeMixin at: (js literal: 'enclosingMixin')). 
	(js operator: '===' with: enclosing and: (js ident: 'undefined')) ifTrue: [^nil].
	^ClassDeclarationMirror reflecting: (Mixin fromRuntimeMixin: enclosing)
)
name = (
	^reflectee name
)
simpleName = (
	^(name splitBy: '`') last
)) : ()
class ClassMirror reflecting: r = (|
	reflectee = r.
|)
('as yet unclassified'
allSuperclasses ^ <List[ClassMirror]> = (
	| klass <Class> superclasses <List[Class]> |
	superclasses:: List new.
	klass:: superclass.
	[klass isNil] whileFalse:[
		superclasses add: klass.
		klass:: klass superclass.
	].
	^superclasses
)
private computeMirrorGroup: mgAccessor <[:MixinMirror | MirrorGroup]> ^ <List[Mirror]> = (
(* Return a mirror group based on the mixins group and those of all superclasses. The argument mgAccessor extracts a mirror group from any mirror provided to it. *)
	| mg <MirrorGroup>  |
	mg:: List new.
	(allSuperclasses reverse add: self; yourself)
		do:[:klass <ClassMirror> | mg addAll: (mgAccessor value: klass mixin)].
	^ mg	
)
enclosingObject ^<ObjectMirror> = (
	^ObjectMirror reflecting: reflectee enclosingObject
)
methods ^ <MirrorGroup[MethodMirror]> = (
	^computeMirrorGroup: [:r | r methods]
)
mixin ^ <MixinMirror> = (
	^MixinMirror reflecting: reflectee mixin
)
name = (
	^reflectee name
)
nestedClasses ^ <MirrorGroup[ClassDeclarationMirror]> = (
	^computeMirrorGroup: [:r | r nestedClasses]
)
simpleName = (
	^(reflectee name splitBy: '`') last
)
slots ^ <MirrorGroup[SlotMirror]> = (
	^computeMirrorGroup: [:r | r slots].
)
superclass ^ <ClassMirror> = (
	reflectee superclass isNil ifTrue:[^nil].
	^ClassMirror reflecting: reflectee superclass
)) : ()
class MethodMirror named: n = (|
name = n.
|)
() : ()
class MixinMirror reflecting: mixin = (|
	reflectee = mixin.
|)
('as yet unclassified'
declaration ^ <ClassDeclarationMirror> = (
	^ClassDeclarationMirror 
		reflecting: (reflectee isMeta ifFalse: [reflectee] ifTrue: [reflectee instanceMixin])
)
methods = (
	^(js propertyOf: reflectee runtimeMixin at: (js literal: 'methods'))
		collect: [:each | MethodMirror named: each].
)
nestedClasses = (
	^(js propertyOf: reflectee runtimeMixin at: (js literal: 'nestedClasses'))
		collect: [:each | ClassDeclarationMirror reflecting: 
			(Mixin fromRuntimeMixin:
				(js propertyOf: reflectee runtimeMixin at: (vmmirror mangleSelector: each)))].
)
slots = (
	^(js propertyOf: reflectee runtimeMixin at: (js literal: 'slots'))
		collect: [:each | SlotMirror named: each].
)) : ()
 class ObjectMirror reflecting: r =  (|
	reflectee = r.
|)
('as yet unclassified'
getClassIfFail: onFail = (
	^ClassMirror reflecting:
		(js propertyOf: reflectee at: (js literal: 'newspeakClass')).
)
getSlot: selector ifFail: failBlock = (
	|
	mangledName = vmmirror mangleSelector: selector, '`slot'.
	raw = js propertyOf: reflectee at: mangledName.
	|
	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [^failBlock value].
	^ObjectMirror reflecting: raw
)
reflecteeIfFail: onFail = (
	^reflectee
)
setSlot: selector to: value ifFail: failBlock = (
	|
	mangledName = vmmirror mangleSelector: selector, '`slot'.
	raw = js propertyOf: reflectee at: mangledName.
	|
	(js operator: '===' with: (js ident: 'undefined') and: raw) ifTrue: [^failBlock value].
	js assign: (js propertyOf: reflectee at: mangledName) toBe: value.
)) : ()
class SlotMirror named: n = (|
	name = n.
|)
() : ()) : ()