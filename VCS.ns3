Newspeak3
'StructuredVCS'
class VCS usingPlatform: p vcs: vcs ide: ide = (
"A source control application that supports different VCS backends (git, hg, ...).

Support for new VCSs can be added by providing a custom implementation of AbstractBackend.


Copyright (c) 2010-2011 Matthias Kleine

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ''Software''), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ''AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
"|

"some awkward name, as outer sends can currently not be compiled"
protected importedSourceMirrors = vcs sourceMirrors.

"should an explicit reference to a newspeak specific mirror be here?"
protected ClassSourceMirror = importedSourceMirrors ClassSourceMirror.

private diffing = vcs diffing.

"Collections"
protected Set = p Collections Set.
protected OrderedCollection = p Collections OrderedCollection.
protected Dictionary = p Collections Dictionary.


protected Stream = p Collections Stream.
protected TextStream = p Collections TextStream.

protected ExternalLauncher = p ExternalProcess ExternalLauncher.

protected UUID = p Network UUID.

protected Time = p Kernel Time.
protected Monitor = p Kernel Monitor.

protected Color = p Graphics Color.

protected MultiByteBinaryOrTextStream = p Multilingual MultiByteBinaryOrTextStream.

private CrLfFileStream = p Files CrLfFileStream.

protected HopscotchImages = p Hopscotch HopscotchImages.

protected hopscotch = p hopscotch.
protected Subject = hopscotch core Subject.
protected Presenter = hopscotch core Presenter.
protected RowComposer = hopscotch composers RowComposer.
protected ColumnComposer = hopscotch composers ColumnComposer.
protected BlankFragment = hopscotch fragments BlankFragment.
protected TextEditorFragment = hopscotch fragments TextEditorFragment.
protected SeparatorItem = hopscotch SeparatorItem.
protected Menu = hopscotch Menu.
protected MenuItem = hopscotch MenuItem.
protected EditableLinePresenter = hopscotch fragments EditableLinePresenter.

protected Transcript = p Transcript.

brazil = p brazil.
private Gradient = brazil plumbing Gradient.

private FileDirectory = p Files FileDirectory.

"Nested classes"

protected Differencer = diffing Differencer.
protected WordMerger = diffing WordMerger.

protected SourceControlSubject = vcs ui SourceControlSubject.

Processor = p Processor.

"Other fields"
protected logger = Logger new.
private processes = Set new.
|)
(
class AbstractBackend = ("Abstract superclass for concrete back-ends. Provides shared functionality.

Concrete implementations must provide a subclass of AbstractBackend that implements classes/methods marked as such"|
|)
(
class AbstractLocalRepository onRepositoryId: repositoryId = Repository onRepositoryId: repositoryId (|
protected repositoryDirectory = FileDirectory on: repositoryId.
protected repositoryVersionAccessing = RepositoryVersionAccessing new.
|)
(
class AbstractLocalHistorian named: n version: v = SuperHistorian named: n (|
	version = v.
|)
('accessing'
canMergeWith: otherVersion = (

	^ (version isAncestorOf: otherVersion version) not and: [
			(otherVersion version isAncestorOf: version) not]
)'actions'
cloneAs: clonedHistorianName ifFail: failBlock = (

	^ repository
		newHistorianNamed: clonedHistorianName
		setTo: version
		ifFail: failBlock.
)
forkAs: forkedHistorianName ifFail: failBlock = (

	| forkedHistorian |
	forkedHistorian:: repository newHistorianNamed: forkedHistorianName setTo: version ifFail: failBlock.
	^ forkedHistorian
)
forwardTrackedHistorianIfFail: failBlock = (

	trackedHistorianifPresent: [:trackedHistorian | trackedHistorian setTo: version ifFail: failBlock]
	ifAbsent: [failBlock value: 'No tracked historian available']
	ifError: [
		logger warn: 'Couln''t access historian'.
		failBlock value: 'Failed to access historian']
)
setTo: newVersion ifFail: failBlock = (

	super setTo: newVersion ifFail: failBlock.
	version:: newVersion
)
shareTo: remoteRepository = (

	| newName newHistorian |
	newHistorian:: remoteRepository newHistorianNamed: name setTo: version ifFail: [logger error: 'Could not create a new remote historian'].
	trackedHistorian: newHistorian.
)'subclassResponsibility'
trackedHistorian: otherHistorian = (

	subclassResponsibility
)
trackedHistorianifPresent: presentBlock ifAbsent: absentBlock ifError: errorBlock = (

	subclassResponsibility
))
class AbstractRepositoryVersionAccessing = ()
(
class AbstractRepositoryVersion = Version ("An immutable Version that can be retrieved from the repository using an identifier."|
	internalId
	message
	author
	cachedWithAncestors
|)
('accessing'
hash = (

	^ internalId hash
)
isParentOfImage = (

	^ imageHistorian version = self
)
isRepositoryVersion = (

	^ true
)
parents = (

	^ parentInternalIds collect: [:each | versionAtInternalId: each].
)
withAncestors = (

	nil = cachedWithAncestors ifTrue: [
		cachedWithAncestors:: super withAncestors].
	^ cachedWithAncestors
)'actions'
loadIntoImage = (

	sourceMirrors installMirrorsAsToplevelClasses: mirrors
)'subclassResponsibility'
parentInternalIds = (

	subclassResponsibility
)'testing'
= other = (

	^ other internalId = internalId
))
class AbstractRepositoryVersionStream onStream: s = Stream (|
	stream = s.
|)
('accessing'
atEnd = (

	^ stream atEnd
)
contents = (

	| copied |
	copied:: self class onStream: stream contents readStream.
	^ Array streamContents: [:resultStream |
		[copied atEnd] whileFalse: [
			resultStream nextPut: copied next]].
)'actions'
nextLine = (

	^ String streamContents: [:resultStream | | c |
		c:: stream next.
		[c = nil or: [c = Character cr]] whileFalse: [
			resultStream nextPut: c.
			c:: stream next]]
))'accessing'
Version = (

	"We shouldn't require this. But something appears to be broken with the compiler."
	^ outer AbstractBackend Version
)'subclassResponsibility'
exportVersionId: internalId to: remoteRepository = (

	subclassResponsibility
)
importVersionId: internalId from: remoteRepository = (

	subclassResponsibility
)
versionAtInternalId: internalId = (

	subclassResponsibility
))'accessing'
Stream = (

	"Something is broken with the NS2 compiler. It cannot find Stream otherwise."
	^ outer VCS Stream
)
SuperHistorian = (

	^ super Historian
)
historianNamed: name versionId: versionId = (

	^ Historian named: name version: (versionAtInternalId: versionId)
)
logStream = (

	^ repositoryVersionAccessing logStream
)
remoteRepositoryAt: repositoryId = (

	^ remoteRepositories detect: [:each |
		each repositoryId = repositoryId or: [each name = repositoryId]]
)
versionAtInternalId: internalId = (

	^ repositoryVersionAccessing versionAtInternalId: internalId
)'actions'
exportVersionId: internalId to: remoteRepository = (

	repositoryVersionAccessing exportVersionId: internalId to: remoteRepository
)
importVersionId: internalId from: remoteRepository = (

	^ repositoryVersionAccessing importVersionId: internalId from: remoteRepository
)
refresh = (

	"May be overridden"
)'subclassResponsibility'
RepositoryVersionAccessing = (

	subclassResponsibility
)
create = (

	subclassResponsibility
)
imageHistorian = (

	subclassResponsibility
)
remoteRepositories = (

	subclassResponsibility
))
class AbstractRemoteRepository onLocalRepository: lr onRepositoryId: repositoryId onName: n = Repository onRepositoryId: repositoryId (|
	protected localRepository = lr.
	protected name = n.|)
(
class AbstractRemoteHistorian named: historianName versionId: vId = GeneralHistorian named: historianName ("A historian stored in a remote repository. It knows only it's version's identifier"|
	versionId = vId.
|)
('accessing'
isTracked = (

	^ localRepository historians anySatisfy: [:each |
		each
			trackedHistorianifPresent: [:trackedHistorian | self = trackedHistorian]
			ifAbsent: [false]
			ifError: [
				logger warn: 'Couln''t access historian'.
				false]]
)
version = (

	repository exportVersionId: versionId.
	^ localRepository versionAtInternalId: versionId
)'actions'
createIfFail: failBlock = (

	repository importVersionId: version internalId.
	super createIfFail: failBlock
)
trackAs: localHistorianName = (

	^ localRepository
		newHistorianNamed: localHistorianName
		trackingHistorian: self
		setTo: version
		ifFail: [insertErrorHandlingForTrackingAHistorianWhenALocalHistorianWithTheGivenNameAlreadyExists]
))'accessing'
GeneralHistorian = (

	^ super Historian
)
historianNamed: name versionId: versionId = (

	^ Historian named: name versionId: versionId
)
repository = (

	^ self
)'actions'
exportVersionId: versionId = (

	localRepository importVersionId: versionId from: self
)
importVersionId: versionId = (

	localRepository exportVersionId: versionId to: self
))
class AbstractRepository onRepositoryId: rid = (|
    private repositoryId = rid.
	protected cachedCommand
|)
(
class AbstractCommand = (|
	cachedLauncher
|)
(
class Launcher = (|
cachedExternalLauncher
command

|)
('accessing'
externalLauncher = (

	nil = cachedExternalLauncher ifTrue: [
		cachedExternalLauncher:: ExternalLauncher for: command.
		cachedExternalLauncher
			otherUnixLocations: {'/opt/local/bin'. '/usr/local/bin'};
			otherWindowsLocations: {'c:\cygwin\bin'}].
	^cachedExternalLauncher
)'actions'
noDefaultArgumentsRun: arguments = (

	^ externalLauncher
		runWith: arguments
		ifSuccess: [ :stdout <ReadStream> :stderr <ReadStream> |
			stdout contents]
		ifFailure: [ :stdout <ReadStream> :stderr <ReadStream> |
			halt]
)
run: arguments = (

	^ run: arguments ifFail: [halt]
)
run: arguments ifFail: failBlock= (

	^ run: arguments ifSuccess: [:stdout :stderr | stdout contents] ifFailure: [:stdout :stderr | failBlock value]
)
run: arguments ifSuccess: successBlock ifFailure: failureBlock = (

	^ externalLauncher
		runWith: defaultArguments, arguments
		ifSuccess: [ :stdout <ReadStream> :stderr <ReadStream> |
			successBlock value: stdout value: stderr]
		ifFailure: [ :stdout <ReadStream> :stderr <ReadStream> |
			failureBlock value: stdout value: stderr]
)
runLines: arguments = (

	^ runLines: arguments ifFail: [halt]
)
runLines: arguments ifFail: failBlock = (

	| result|
	result:: OrderedCollection new.
	(run: arguments ifFail: failBlock) linesDo: [:each |
		result add: each].
	^ result
)
runStream: arguments = (

	| resultStream |
	resultStream:: run: arguments ifSuccess: [:stdout :stderr | stdout] ifFailure: [:stdout :stderr | halt].
	^ (MultiByteBinaryOrTextStream with: resultStream contents encoding: 'utf8') reset
))'accessing'
ignoredFilename = (

	^ '.ignore'
)
launcher = (

	cachedLauncher = nil ifTrue: [
		cachedLauncher::  Launcher new
			command: commandLine;
			yourself].
	^ cachedLauncher
)'actions'
writeStream: stream toFileNamed: filename = (

	(CrLfFileStream forceNewFileNamed: (repository repositoryDirectory / filename) pathName)
		ascii;
		nextPutAll: stream contents;
		close.
)'subclassResponsibility'
commandLine = (

	subclassResponsibility
)
defaultArguments = (

	subclassResponsibility
)'testing'
isFilenameIgnored: filename = (

	^ filename = ignoredFilename
))
class AbstractHistorian named: historianName = (|

	public name = historianName.
|)
(
class AbstractHistorianChange onVersion: v = ("Encapsulates the action of committing a new version"|

newVersion = v.
|)
('accessing'
changedMirrors = (

	| filteredZippedMirrors |
	"TODO: Move zippedMirrors + allEqual into intermediate Project/StoreSnapshot abstraction. Check for senders of allEqual:"
	filteredZippedMirrors:: zippedMirrors reject: [:each |
		nil = each first
			or: [Differencer allEqual: each]].
	^ filteredZippedMirrors collect: [:each | each first]
)
deletedOriginalMirrors = (

	| filteredZippedMirrors |
	filteredZippedMirrors:: zippedMirrors select: [:each | nil = each first].
	^ filteredZippedMirrors collect: [:each | each second]
)
historian = (

	^ outer AbstractHistorian historian
)'actions'
commit = (

	subclassResponsibility
)'private'
zippedMirrors = (

	"try zippedMirrorsWith:"
	^ newVersion zipMirrors: {newVersion mirrors. historian version mirrors}.
))'accessing'
hash = (

	^ name hash
)
historian = (

	^ self
)
repository = (

	^ outer AbstractRepository repository
)
versionsIncomingFrom: otherHistorian = (

	^ version versionsIncomingFrom: otherHistorian version
)'actions'
commit: v = (

	"Commits a new version and sets the historian to it. We might want to do this using
	setTo:ifFail: only. We could dispatch on the version to determine whether the version is new and has to be committed."
	| change |
	(v parents includes: self version) ifFalse: [logger error: 'Trying to commit non-child version'].
	change:: HistorianChange onVersion: v.
	change commit
)
loadIntoImage = (

	version loadIntoImage.
	makeCurrentHistorian
)'subclassResponsibility'
HistorianChange = (

	subclassResponsibility
)
createIfFail: failBlock = (

	subclassResponsibility
)
makeCurrentHistorian = (

	subclassResponsibility
)
version = (

	subclassResponsibility
)'testing'
= other = (

	^ repository = other repository and: [name = other name]
)
canForwardTo: otherVersion = (

	^ (version = otherVersion version) not and: [
		version isAncestorOf: otherVersion version]
))'accessing'
command = (

	nil = cachedCommand ifTrue: [
		cachedCommand:: Command new.].
	^ cachedCommand
)
hash = (

	^ self repositoryId hash
)
historianNamed: historianName ifFail: failBlock = (

	^ historians detect: [:each | each name = historianName] ifNone: failBlock
)
repository = (

	^ self
)'actions'
createNewVersion = (

	^ NewVersion new
)
newHistorianNamed: historianName setTo: initialVersion ifFail: failBlock = (

	(historians anySatisfy: [:each | each name = historianName]) ifTrue: [
		^ failBlock value].
	^ (Historian named: historianName version: initialVersion)
		createIfFail: failBlock;
		yourself
)
newHistorianNamed: historianName trackingHistorian: trackedHistorian setTo: initialVersion ifFail: failBlock = (

	| result |
	result:: newHistorianNamed: historianName setTo: initialVersion ifFail: failBlock.
	nil = trackedHistorian ifFalse: [
		result trackedHistorian: trackedHistorian].
	^ result
)'subclassResponsibility'
Historian = (

	subclassResponsibility
)
clone: repositoryLocation = (

	subclassResponsibility
)
historianNamed: name versionId: versionId = (

	"Implemented in abstract subclasses"
	subclassResponsibility
)
historians = (

	subclassResponsibility
)
logStream = (

	subclassResponsibility
)
repositoryType = (

	subclassResponsibility
)'testing'
= other = (

	^ self repositoryId = other repositoryId and: [
		self repositoryType = other repositoryType]
))
class NewVersion = Version (
"A version that has not yet been committed."|
	parents
	mirrors
	message
|)
('accessing'
hash = (

	^ message hash
)'testing'
= other = (

	"TODO: Move zippedMirrors + allEqual into intermediate Project/StoreSnapshot abstraction. Check for senders of allEqual:"
	^ other message = message and: [ | zippedMirrors |
		zippedMirrors:: self zipMirrors: {self mirrors. other mirrors}.
		(zippedMirrors allSatisfy: [:each | Differencer allEqual: each]) and: [
			other parents asSet = parents asSet]]
)
commonAncestorWith: version = (

	parents size = 0 ifTrue: [logger halt: 'no parents set'].
	^ parents inject: version into: [:acc :each | acc commonAncestorWith: each]
))
class Version = ("Common functionality shared by all versions

Subclasses must provide:
- parents
- mirrors
- hash
- =
- commonAncestorWith:

Generic implementations could be provided for hash, =, commonAncestorWith: if needed at some point."|
|)
('accessing'
commonAncestorWith: otherVersion = (

	subclassResponsibility
)
diffsFrom: version = (

	| zippedMirrors |
	zippedMirrors:: zippedMirrorsWith: version.
	^ zippedMirrors collect: [:each |
		Differencer compare: each last to:each first withAncestor: each second]
)
diffsFromFirstParent = (

	^ diffsFrom: parents first
)
diffsTo: version = (

	^ version diffsFrom: self
)
hash = (

	subclassResponsibility
)
mirrors = (

	subclassResponsibility
)
parents = (

	subclassResponsibility
)
versionsIncomingFrom: otherVersion = (

	"The name isn't too descriptive. But withAncestorsNotContainedIn: (works the other way) isn't that good, either"
	"The implementation is slow and can be optimized to traverse ancestors in parallel, should efficiency become a problem."
	^ otherVersion withAncestors copyWithoutAll: self withAncestors asSet
)
withAncestors = (

	"While traversing our ancestors we must keep track of ancestors that we already added to the result. We're using an iterative approach for traversing through the ancestors, as a recursive algorithm was too slow."
	| result position ancestorsAlreadyAdded |

	result:: OrderedCollection new.
	position:: 1.
	ancestorsAlreadyAdded:: Set new.	
	result add: self.

	[position > result size] whileFalse: [ | current |
		current:: result at: position.
		position:: position + 1.
		current parents do: [:each |
			(ancestorsAlreadyAdded includes: each) ifFalse: [
				ancestorsAlreadyAdded add: each.
				result add: each]]].
	^ result		
)
zipMirrors: mirrorCollections = (

	| sortBlock |
	sortBlock:: [:a :b | a filename asString <= b filename asString]. "filename not name because a module and package might share a name"
	^ genericZip: mirrorCollections sortBlock: sortBlock
)
zippedMirrorsWith: other = (

	| commonAncestor |
	commonAncestor:: commonAncestorWith: other.
	^ zipMirrors: {mirrors. commonAncestor mirrors. other mirrors}.
)'private'
genericZip: partitions sortBlock: sortBlock = (

	"Taken from my parsing code"
	| streams result partitionsHavingSmallest |
	result:: OrderedCollection new.
	partitionsHavingSmallest:: OrderedCollection new.
	streams:: partitions collect: [:each |
		(each asSortedCollection: sortBlock) readStream].
	[streams allSatisfy: [:each | each atEnd]] whileFalse: [ | smallest zipped  |
		partitionsHavingSmallest reset.
		smallest:: nil.
		streams doWithIndex: [:stream :i | | c |
			stream atEnd ifFalse: [
				c:: stream peek.
				(smallest isNil or: [sortBlock value: c value: smallest]) ifTrue: [
					(smallest isNil or: [(sortBlock value: smallest value: c) not]) ifTrue: [
						smallest:: c.
						partitionsHavingSmallest reset].
					partitionsHavingSmallest add: i]]].
		zipped:: Array ofSize: partitions size. "Object allocation"
		partitionsHavingSmallest do: [:i | | stream |
			stream:: streams at: i.
			zipped at: i put: stream next].
		result add: zipped].
	^ result
)'testing'
= other = (

	subclassResponsibility
)
isAncestorOf: version = (

	^ self = (self commonAncestorWith: version)
))'accessing'
sourceMirrors = (

	^ importedSourceMirrors
)'subclassResponsibility'
LocalRepository = (

	subclassResponsibility
)
RemoteRepository = (

	subclassResponsibility
))
class Logger = (|
	logMonitor = Monitor new.
	logCounter ::= 0.
|)
('as yet unclassified'
error: msg = (
	Error signal: msg
)
halt: message = (

	log: 'HALT: ', message.
	halt
)
info: message = (

	log: 'INFO: ', message.
)
log: message = (

	"logMonitor critical: [
		logCounter:: logCounter + 1.
		Transcript cr; show: '[', logCounter asString, ' | ', Time now asString, ']', message.]."
)
log: message around: block = (

	| result |
	log: '[BEGIN]', message.
	result:: block value.
	log: '[END]', message.
	^ result
)
warn: message = (

	log: 'WARNING: ', message
))'accessing'
sourceMirrors = (

	^ importedSourceMirrors
)'actions'
forkAndRemember: block = (

	[
		| process |
		process:: Processor activeProcess.
		processes add: process.
		block ensure: [processes remove: process]] fork
)
shutdown = (

	"Might currently be called multiple times"
	"Don't shut down the mirror loader for now, as we're reinstantiating VCS without doing so for the SourceMirrors"
))