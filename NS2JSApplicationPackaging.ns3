Newspeak3
'NS2JS'
class NS2JSApplicationPackaging packageUsing: ns = (
"Produces and packages Javascript programs as either files/directories or as a single flat stream.

To use create an instance of ApplicationPackager, then create an instance of the desired writer with it and call #write.

The ApplicationPackager determines the classes that must be translates and produces the actual Javascript code. The ApplicationPackager provides the hierarchical information needed to build a directory hierarchy as follows. The ApplicationPackager's write methods expect a namespace that must be provided by the JavascriptWriter. The packager can write code to a namespace using #stream: and can request access to a nested namespace using #/. The ApplicationPackager must generate Javascript code in the order that it is later on to be loaded.

The writer can use the hierarchical information to create a directory hierarchy of Javascript files. The writer can just as well ignore the hierarchical information alltogether.

Copyright 2012 SAP AG.
Copyright 2012 Google Inc.

Licensed under the Apache License, Version 2.0 (the ''License''); you may not use this file except in compliance with the License.  You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0"|
	CP = ns NS2CombinatorialParsing CombinatorialParsing.
	BCP = ns NS2CombinatorialParsing BlocklessCombinatorialParsing.
	BlocklessCombinatorialParsing = BCP mixin |> CP.
	Grammar = ns Newspeak3Grammar.
	ASTs = ns Newspeak3AST.
	Parsing = ns Newspeak3Parsing.
	Generation = ns JavascriptGeneration.
	Mirrors = ns NewspeakMirrors. "Why the Squeak mirrors?"
	Compilation = ns Newspeak2JavascriptCompilation.
		
	VMMirror = ns VMMirror.
	PlatformForJS = ns PlatformForJS.	
|)
(
class ApplicationPackager usingPlatform: p = (| 
	private parserLib = BlocklessCombinatorialParsing usingLib: p.
	private grammar = Grammar parserLib: parserLib.
	private asts = ASTs usingLib: p.
	private parsing = Parsing usingLib: p ast: asts grammar: grammar.
	private generation = Generation usingPlatform: p.
	private mirrors = Mirrors usingPlatform: p vmMirror: VMMirror new.
	private compilation = Compilation
		usingPlatform: p
		newspeakParser: parsing
		javascriptGeneration: generation
		mirrorLib: mirrors.
		
	private Compiler = compilation Compiler2.
	
	private OrderedCollection = p collections OrderedCollection.
	|)
(
class OrigApplicationPackager application: appTopLevelClass platform: platformTopLevelClass ideNamespace: ns = (
"Produces a Javascript program which contains a packaged representation of the specified top level class and the code to instantiate and run the class. The generated Javascript code is written into a writer's namespace, which can make use of the hierarchical information to genereate files/directories."|
	appClass = appTopLevelClass.
	platformClass = platformTopLevelClass.
	ideNamespace = ns.
	compiler = Compiler new.
	importsRecorder ::= ImportsRecorder new.
	
	platformClassPackager = ClassPackager mainClass: platformClass.
	applicationClassPackager = ClassPackager mainClass: appClass.
	
	variableStoringMainResult ::= appClass name, 'MainResult'.
|)
(
class ClassPackager mainClass: klass = (
"Describe the class in this comment."|
	klass = klass.
	
|)
('as yet unclassified'
ideNamespaceMockVarName = (
	^klass name, 'IdeNamespaceMock'
)
outputApplicationToNamespace: namespace = (
	
	writeApplicationImportToNamespace: namespace.
	writeApplicationClassToNamespace: namespace.
	(namespace /('run_', klass name, '.js')) stream: [:s |
		writeIdeNamespaceMockTo: s.
		writeApplicationLaunchCodeTo: s].
)
outputPlatformToNamespace: namespace = (

	writeApplicationImportToNamespace: namespace.
	writeApplicationClassToNamespace: namespace.
	(namespace / 'platform.js') stream: [:s |
		writeIdeNamespaceMockTo: s.
		writePlatformInstantiationCodeTo: s].
)
serializeClass: aClass <Class> ^ <String> = (
	| source |	
	source:: (String new: 1000) writeStream.
	aClass mixin printTopClassOn: source.
	^ source contents.
)
writeApplicationClassToNamespace: namespace = (
	writeClass: klass toNamespace: namespace
)
writeApplicationImportToNamespace: namespace = (
	importsRecorder:: ImportsRecorder new.
	klass packageUsing: importsRecorder.
	importsRecorder importedTopLevelClasses do:
		[:each <Symbol> |
			writeClass: (ideNamespace at: each) toNamespace: namespace]
)
writeApplicationLaunchCodeTo: aStream = (
"The main class should be a standard application class, launched using the #main:args: message. Produces a Javascript statement that instantiates the application. Assumes that a platform has already been written out."
	aStream nextPutAll: variableStoringMainResult, ' = ', klass name, '["#packageUsing:"](', ideNamespaceMockVarName, ')["#main:args:"](platform, commandLineArguments);'; cr; cr
)
writeClass: aClass toNamespace: namespace = (
	| source rep |
	
	rep:: compiler compileClassSource: (serializeClass: aClass) readStream within: nil.
	
	compiler outputClass: rep toNamespace: namespace.
	
	(namespace / ('create_', aClass name, '.js')) stream: [:stream |
		stream
			nextPutAll: 'var ';
			nextPutAll: rep first name;
			nextPutAll: ' = '.
		compiler outputCreationOfClass: rep to: stream.
		stream nextPutAll: ';'; cr]
)
writeIdeNamespaceMockTo: aStream = (
	aStream nextPutAll: 'var ', ideNamespaceMockVarName, ' = {'; cr.
	importsRecorder importedTopLevelClasses
		do: [:each <Symbol> | aStream tab; nextPutAll: '"#', each, '": function () { return ', each, '; },'; cr].
	importsRecorder intermediaryNames
		do: [:each <Symbol> | aStream tab; nextPutAll: '"#', each, '": function () { return this; },'; cr].
"		separatedBy: [aStream nextPutAll: ','; cr]."
	aStream nextPutAll: '};'; cr; cr. 
)
writePlatformInstantiationCodeTo: aStream = (
"Should only be used when the main class is a platform class. Declares a variable named 'platform' initialized to contain an instance of the platform class. Because a platform class does not need a platform and does not take application arguments, an instance is initialized by sending the #initialize message rather than the standard #main:args:."
	aStream nextPutAll: 'var platform = ', klass name, '["#packageUsing:"](', ideNamespaceMockVarName, ')["#initialize"]();'; cr; cr
)) : ()
class ImportsRecorder = (
"A message catching proxy which is passed to a top level application class in order to determine the imports it expects."|
	imports = OrderedCollection new.
|)
(
class ImportPhraseReceiver firstMessage: message <Message> = (|
	messages = OrderedCollection with: message.
|)
('as yet unclassified'
addImportedTopLevelClassTo: collection = (
	collection add: messages last selector
)
addIntermediaryNamesTo: collection = (
	collection addAll: ((messages copyFrom: 1 to: messages size - 1) collect: [:each | each selector])
)
doesNotUnderstand: aMessage = (
	messages add: aMessage.
	^self
)
instVarAt: index = (
"Shudder."
	^index = 5
		ifTrue: [nil]
		ifFalse: [super instVarAt: index]
)
instVarNamed: varName = (
	^varName = 'enclosingObject`nil'
		ifTrue: [nil]
		ifFalse: [super instVarNamed: varName]
)
mixin = (
	^MixinApplicationReceiver leftHandSide: self.
)
printOn: aStream = (
	super printOn: aStream.
	aStream nextPutAll: ' ('.
	messages
		do: [:each | each selector printOn: aStream]
		separatedBy: [aStream space].
	aStream nextPutAll: ')'
)) : ()
class MixinApplicationReceiver leftHandSide: lhs <ImportPhraseReceiver> = (|
	mixinSide = lhs.
	classSide
|)
(
class FakeMixinApplicationResult = (
"An instance is retured from an intercepted send of apply:withName: so that the language implementation machinery has something to have its way with, thinking it is a real class."|
	slot1
	slot2
	slot3
	slot4
	slot5
	slot6
|)
('as yet unclassified'
instVarNamed: varName put: varValue = (
	^varName = 'enclosingObject`nil'
		ifTrue: [varValue]
		ifFalse: [super instVarNamed: varName put: varValue]
)) : ()'as yet unclassified'
addImportedTopLevelClassTo: collection = (
)
addIntermediaryNamesTo: collection = (
)
apply: rhs <ImportPhraseReceiver> withName: name = (
	imports add: self.
	classSide:: rhs.
	^FakeMixinApplicationResult new
)
definingClass = (
	^nil
)
printOn: aStream = (
	super printOn: aStream.
	aStream nextPutAll: ' ('.
	mixinSide printOn: aStream.
	aStream nextPutAll: ' |> '.
	classSide printOn: aStream.
)
|> rhs = (
	^self apply: rhs withName: nil
)) : ()'as yet unclassified'
doesNotUnderstand: aMessage = (
	| phraseReceiver |
	phraseReceiver:: ImportPhraseReceiver firstMessage: aMessage.
	imports add: phraseReceiver.
	^phraseReceiver
)
importedTopLevelClasses = (
	| names |
	names:: OrderedCollection new: imports size.
	imports do: [:each | each addImportedTopLevelClassTo: names].
	^names
)
intermediaryNames = (
	| names |
	names:: Set new: imports size.
	imports do: [:each | each addIntermediaryNamesTo: names].
	^names
)) : ()'actions'
writeToWriter: writer = (

	| namespace |
	namespace:: writer root.
	writeInfrastructureToNamespace: namespace.
	writeClassesToNamespace: namespace.
)'private'
writeClassesToNamespace: namespace = (

	platformClassPackager
		outputPlatformToNamespace: namespace.
	applicationClassPackager
		outputApplicationToNamespace: namespace.
)
writeInfrastructureToNamespace: namespace = (

	(namespace / 'infrastructure.js') stream: [:stream |
		compiler outputInfrastructureCodeTo: stream].
)) : ()'accessing'
public compileAppDefn: appDefn usingNamespace: ns to: output = (
	compileAppDefn: appDefn withRuntimeDefn: PlatformForJS usingNamespace: ns to: output
)
public compileAppDefn: appDefn withRuntimeDefn: runtimeDefn usingNamespace: ns to: output = (
	|
	packager = OrigApplicationPackager application: appDefn platform: runtimeDefn ideNamespace: ns.
	
	writer = SingleStreamWriter onStream: output.
	|
	
	packager writeToWriter: writer.
)) : ()
class DirectoryWriter filePath: path = ("Writes out files in a directory hierarchy and generates loading scripts"|
	private generatedFiles = OrderedCollection new.
	private rootPath = path.
	private root = Directory onFilePath: path.
|)
(
class Directory onFilePath: path = (|
	private filePath = path.
|)
('accessing'
/ name = (

	^ Directory onFilePath: filePath / name
)'actions'
stream: block  = (

	generatedFiles add: filePath.
	onPath: filePath stream: block
)) : ()'private'
ensureDirectoryExists: path = (

	path exists ifFalse: [
		ensureDirectoryExists: path containingDirectory.
		path createDirectoryIfFail: [:e | assert: false message: e]].
)
onPath: filePath stream: block  = (

	| stream |
	ensureDirectoryExists: filePath containingDirectory.
	stream:: filePath charOutputStream.
	[block value: stream] ensure: [
		stream close]
)) : ()
class ParallelWriter onWriters: w = (
"Allows writing to multiple writers in parallel."|
	private writers = w.
	public root = ParallelNamespace onNamespaces: (writers collect: [:each | each root]).
|)
(
class ParallelNamespace onNamespaces: ns = (|
	private namespaces = ns.
|)
('accessing'
/ sub = (

	^ ParallelNamespace onNamespaces: (namespaces collect: [:each | each / sub])
)'actions'
stream: block = (

	| contents result |
	contents:: String streamContents: [:stream |
		result:: block value: stream].
	namespaces do: [:each |
		each stream: [:stream |
			stream nextPutAll: contents]].
	^ result
)) : ()) : ()
class SingleStreamWriter onStream: writeStream = (
"Outputs everything onto a single stream"|
	private writeStream = writeStream.
|)
('accessing'
/ subDirectory = (

	^ self
)
root = (

	^ self
)'actions'
stream: block = (

	block value: writeStream
)) : ()'as yet unclassified'
main: p args: a = (
	^ApplicationPackager usingPlatform: p
)) : ()